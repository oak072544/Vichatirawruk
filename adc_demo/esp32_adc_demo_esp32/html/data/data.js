var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"esp32_adc_demo","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated with Waijung 2 ESP32 Target Blockset,\r\n * for Simulink model 'esp32_adc_demo'.\r\n *\r\n * Model version                  : 8.0\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Mon Aug 29 16:38:05 2022\r\n *\r\n * Target selection: esp32.tlc\r\n * Embedded hardware selection: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"esp32_adc_demo.h\"            /* Model's header file */\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n *===============================================================\r\n * Simulink simulation information\r\n *===============================================================\r\n * Simulink model name: esp32_adc_demo\r\n * Note that:\r\n * Waijung 2 ESP32 target forces \"Higher priority value indicates\r\n * higher task priority\" under Simulink model configuration.\r\n * This is opposite to the default Simulink configuration where\r\n * lower priority value indicates higher priority.\r\n * Base priority level for all synchronous (periodic) and asynchronous tasks: 0\r\n * (This is set from Waijung 2 ESP32 target setup blockset under FreeRTOS tab -> Base task priority parameter.)\r\n * Synchronous (periodic) task information:\r\n * Number of synchronous periodic tasks: 1\r\n * Highest priority level needed for periodic tasks: 0\r\n * Highest priority level limit for the system: 16\r\n * Task 0 (Function name: vTaskFunctionBaseRate), base rate: 0.2 seconds, priority: 0\r\n * Default NULL definition: (NULL)\r\n *\r\n *===============================================================\r\n * Waijung 2 Info\r\n *===============================================================\r\n * Waijung 2 version: 20.11b\r\n * Waijung 2 target: ESP32\r\n * Target OS: FreeRTOS\r\n * Project path: C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32_build_system\r\n * Toolchain: ESP-IDF\r\n * ESP-IDF path: C:\\msys32\\home\\skris\\esp\\esp-idf\r\n *===============================================================\r\n */\r\n\r\n/* ANSI C headers */\r\n#include <float.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\n/* Waijung 2 headers */\r\n#include \"waijung2_hwdrvlib.h\"\r\n\r\n/* Default xTaskCreate stack size */\r\n#ifndef DEFAULT_STACK_SIZE\r\n#define DEFAULT_STACK_SIZE             2048\r\n#endif\r\n\r\nvoid vTaskFunctionBaseRate(void *pvParameters)\r\n{\r\n  const TickType_t vPeriodicTaskPreiod = 200/portTICK_PERIOD_MS;\r\n  TickType_t xLastWakeTime;\r\n  xLastWakeTime = xTaskGetTickCount();\r\n\r\n  /* For Debuging the single task base rate, Ignore */\r\n  while (1) {\r\n    /* Setting the base sample rate: */\r\n    vTaskDelayUntil(&xLastWakeTime, vPeriodicTaskPreiod);\r\n\r\n    /* Release the Semaphores for all the base rate functions in the following function: */\r\n    esp32_adc_demo_step();\r\n\r\n    /* Get model outputs here */\r\n  }\r\n}\r\n\r\n/*\r\n * Spawn esp32_adc_demo_main as an independent FreeRTOS task\r\n * from your application code.\r\n */\r\nvoid app_main(void)\r\n{\r\n  /* Initialize model */\r\n  esp32_adc_demo_initialize();\r\n\r\n  /*\r\n   * base_priority variable is used for assigning periodic task priority.\r\n   * Note that, for periodic tasks, Priority property in Simulink blocks\r\n   * has no effects on task execution order. Fastest rate blocks (smaller\r\n   * block's sample time) always have higher priority.\r\n   */\r\n  UBaseType_t base_priority = 0;       /* Base priority */\r\n  xTaskCreate(vTaskFunctionBaseRate, \"vTaskFunctionBaseRate\", DEFAULT_STACK_SIZE,\r\n              NULL, base_priority + 0, NULL);\r\n}\r\n\r\n/* [EOF] */\r\n"},{"name":"esp32_adc_demo.c","type":"source","group":"model","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: esp32_adc_demo.c\r\n *\r\n * Code generated with Waijung 2 ESP32 Target Blockset,\r\n * for Simulink model 'esp32_adc_demo'.\r\n *\r\n * Model version                  : 8.0\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Mon Aug 29 16:38:05 2022\r\n *\r\n * Target selection: esp32.tlc\r\n * Embedded hardware selection: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"esp32_adc_demo.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_esp32_adc_demo_T esp32_adc_demo_B;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_esp32_adc_demo_T esp32_adc_demo_M_;\r\nRT_MODEL_esp32_adc_demo_T *const esp32_adc_demo_M = &esp32_adc_demo_M_;\r\n\r\n/* Model step function */\r\nvoid esp32_adc_demo_step(void)\r\n{\r\n  /* S-Function (esp32_adc): '<Root>/ADC' */\r\n\r\n  /* Updating the ADC pins  */\r\n  adc1_config_width(ADC_WIDTH_BIT_12);//Set the ADC module 1 resolution as 12Bit\r\n  adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_11);// Initializing ADC Channel as GPIO36\r\n  esp32_adc_demo_B.ADC = adc1_get_raw(ADC1_CHANNEL_0);\r\n\r\n  /* RelationalOperator: '<S1>/Compare' incorporates:\r\n   *  Constant: '<S1>/Constant'\r\n   */\r\n  esp32_adc_demo_B.Compare = (esp32_adc_demo_B.ADC >= 500);\r\n\r\n  /* S-Function (esp32_digital_output3): '<Root>/Digital Out' */\r\n\r\n  /* Updating the pins of DigitalOut */\r\n  gpio_set_level(2,(uint32_t) esp32_adc_demo_B.Compare);/* GPIO2 */\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function' */\r\n  esp32_adc_demo_B.y = (esp32_adc_demo_B.ADC >= 500);\r\n\r\n  /* S-Function (esp32_digital_output3): '<Root>/Digital Out1' */\r\n\r\n  /* Updating the pins of DigitalOut1 */\r\n  gpio_set_level(12,(uint32_t) esp32_adc_demo_B.y);/* GPIO12 */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid esp32_adc_demo_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatus(esp32_adc_demo_M, (NULL));\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &esp32_adc_demo_B), 0,\r\n                sizeof(B_esp32_adc_demo_T));\r\n\r\n  /* Start for S-Function (esp32_adc): '<Root>/ADC' */\r\n\r\n  //================================================================= ADC pins: 'ADC' Initialization\r\n\r\n  /* Start for S-Function (esp32_digital_output3): '<Root>/Digital Out' */\r\n\r\n  //================================================================= GPIO Out pins: 'DigitalOut' Initialization\r\n  //GPIO_initialize_DigitalOut();\r\n\r\n  /* Start for S-Function (esp32_digital_output3): '<Root>/Digital Out1' */\r\n\r\n  //================================================================= GPIO Out pins: 'DigitalOut1' Initialization\r\n  //GPIO_initialize_DigitalOut1();\r\n\r\n  /* Enable for S-Function (esp32_digital_output3): '<Root>/Digital Out' */\r\n  /* Level2 S-Function Block: '<Root>/Digital Out' (esp32_digital_output3) */\r\n  GPIO_initialize_DigitalOut();\r\n\r\n  /* Enable for S-Function (esp32_digital_output3): '<Root>/Digital Out1' */\r\n  /* Level2 S-Function Block: '<Root>/Digital Out1' (esp32_digital_output3) */\r\n  GPIO_initialize_DigitalOut1();\r\n}\r\n\r\n/* Model terminate function */\r\nvoid esp32_adc_demo_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/* [EOF] */\r\n"},{"name":"esp32_adc_demo.h","type":"header","group":"model","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: esp32_adc_demo.h\r\n *\r\n * Code generated with Waijung 2 ESP32 Target Blockset,\r\n * for Simulink model 'esp32_adc_demo'.\r\n *\r\n * Model version                  : 8.0\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Mon Aug 29 16:38:05 2022\r\n *\r\n * Target selection: esp32.tlc\r\n * Embedded hardware selection: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_esp32_adc_demo_h_\r\n#define RTW_HEADER_esp32_adc_demo_h_\r\n#ifndef esp32_adc_demo_COMMON_INCLUDES_\r\n#define esp32_adc_demo_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* esp32_adc_demo_COMMON_INCLUDES_ */\r\n\r\n#include \"waijung2_hwdrvlib.h\"\r\n#include \"esp32_adc_demo_types.h\"\r\n#include <stddef.h>\r\n#include <string.h>\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  int16_T ADC;                         /* '<Root>/ADC' */\r\n  boolean_T Compare;                   /* '<S1>/Compare' */\r\n  boolean_T y;                         /* '<Root>/MATLAB Function' */\r\n} B_esp32_adc_demo_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_esp32_adc_demo_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_esp32_adc_demo_T esp32_adc_demo_B;\r\n\r\n/* Model entry point functions */\r\nextern void esp32_adc_demo_initialize(void);\r\nextern void esp32_adc_demo_step(void);\r\nextern void esp32_adc_demo_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_esp32_adc_demo_T *const esp32_adc_demo_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'esp32_adc_demo'\r\n * '<S1>'   : 'esp32_adc_demo/Compare To Constant'\r\n * '<S2>'   : 'esp32_adc_demo/MATLAB Function'\r\n */\r\n#endif                                 /* RTW_HEADER_esp32_adc_demo_h_ */\r\n\r\n/* [EOF] */\r\n"},{"name":"esp32_adc_demo_private.h","type":"header","group":"model","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: esp32_adc_demo_private.h\r\n *\r\n * Code generated with Waijung 2 ESP32 Target Blockset,\r\n * for Simulink model 'esp32_adc_demo'.\r\n *\r\n * Model version                  : 8.0\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Mon Aug 29 16:38:05 2022\r\n *\r\n * Target selection: esp32.tlc\r\n * Embedded hardware selection: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_esp32_adc_demo_private_h_\r\n#define RTW_HEADER_esp32_adc_demo_private_h_\r\n#include \"rtwtypes.h\"\r\n#endif                                /* RTW_HEADER_esp32_adc_demo_private_h_ */\r\n\r\n/* [EOF] */\r\n"},{"name":"esp32_adc_demo_types.h","type":"header","group":"model","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: esp32_adc_demo_types.h\r\n *\r\n * Code generated with Waijung 2 ESP32 Target Blockset,\r\n * for Simulink model 'esp32_adc_demo'.\r\n *\r\n * Model version                  : 8.0\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Mon Aug 29 16:38:05 2022\r\n *\r\n * Target selection: esp32.tlc\r\n * Embedded hardware selection: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_esp32_adc_demo_types_h_\r\n#define RTW_HEADER_esp32_adc_demo_types_h_\r\n\r\n/* Model Code Variants */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_esp32_adc_demo_T RT_MODEL_esp32_adc_demo_T;\r\n\r\n#endif                                 /* RTW_HEADER_esp32_adc_demo_types_h_ */\r\n\r\n/* [EOF] */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated with Waijung 2 ESP32 Target Blockset,\r\n * for Simulink model 'esp32_adc_demo'.\r\n *\r\n * Model version                  : 8.0\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Mon Aug 29 16:38:05 2022\r\n *\r\n * Target selection: esp32.tlc\r\n * Embedded hardware selection: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: Unspecified\r\n *   Signed integer division rounds to: Undefined\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/* [EOF] */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated with Waijung 2 ESP32 Target Blockset,\r\n * for Simulink model 'esp32_adc_demo'.\r\n *\r\n * Model version                  : 8.0\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Mon Aug 29 16:38:05 2022\r\n *\r\n * Target selection: esp32.tlc\r\n * Embedded hardware selection: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"esp32_adc_demo.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/* [EOF] */\r\n"},{"name":"bio_sig.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2002 The MathWorks, Inc.\n *\n * File: bio_sig.h     \n *\n * Abstract:\n *\ttypedef for BlockIOSignals, included by *rt_main.c and MODEL.bio\n */\n\n#ifndef _BIO_SIG_H_\n# define _BIO_SIG_H_\n\ntypedef struct BlockIOSignals_tag {\n  char_T   *blockName;    /* Block's full path name (RTW mangled version)     */\n  char_T   *signalName;   /* Signal label (unmangled, or NULL if not present) */\n  uint_T   portNumber;    /* Block output port number (starting at 0)         */\n  uint_T   signalWidth;   /* Signal's width                                   */\n  void     *signalAddr;   /* Signal's Address in the block I/O vector         */\n  char_T   *dtName;       /* The C-language data type name                    */\n  uint_T   dtSize;        /* The size in # of bytes for the data type         */\n} BlockIOSignals;\n\n#endif\n"},{"name":"blas.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1984-2021 The MathWorks, Inc.\n * All Rights Reserved.\n */\n\n/*\n *  Header File include/refblas.h\n *  Auto generated by f2h.pl, do not modify by hand\n */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef refblas_h\n#define refblas_h\n\n#include <stddef.h>\n\n#if defined(_WIN32) || defined(__hpux)\n#define FORTRAN_WRAPPER(x) x\n#else\n#define FORTRAN_WRAPPER(x) x ## _\n#endif\n\n#ifndef COMPLEX_TYPES\n#define COMPLEX_TYPES\n  typedef struct{float r,i;} complex;\n  typedef struct{double r,i;} doublecomplex;\n#endif\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\n\n/* Source: caxpy.f */\n#define caxpy FORTRAN_WRAPPER(caxpy)\nextern void caxpy(\n    const ptrdiff_t *n,\n    const float  *ca,\n    const float  *cx,\n    const ptrdiff_t *incx,\n    float  *cy,\n    const ptrdiff_t *incy\n);\n\n/* Source: ccopy.f */\n#define ccopy FORTRAN_WRAPPER(ccopy)\nextern void ccopy(\n    const ptrdiff_t *n,\n    const float  *cx,\n    const ptrdiff_t *incx,\n    float  *cy,\n    const ptrdiff_t *incy\n);\n\n/* Source: cdotc.f */\n#define cdotc FORTRAN_WRAPPER(cdotc)\nextern void cdotc(\n    complex* retval,\n    const ptrdiff_t *n,\n    const float  *cx,\n    const ptrdiff_t *incx,\n    const float  *cy,\n    const ptrdiff_t *incy\n);\n\n/* Source: cdotu.f */\n#define cdotu FORTRAN_WRAPPER(cdotu)\nextern void cdotu(\n    complex* retval,\n    const ptrdiff_t *n,\n    const float  *cx,\n    const ptrdiff_t *incx,\n    const float  *cy,\n    const ptrdiff_t *incy\n);\n\n/* Source: cgbmv.f */\n#define cgbmv FORTRAN_WRAPPER(cgbmv)\nextern void cgbmv(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: cgemm.f */\n#define cgemm FORTRAN_WRAPPER(cgemm)\nextern void cgemm(\n    const char   *transa,\n    const char   *transb,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: cgemv.f */\n#define cgemv FORTRAN_WRAPPER(cgemv)\nextern void cgemv(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: cgerc.f */\n#define cgerc FORTRAN_WRAPPER(cgerc)\nextern void cgerc(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *y,\n    const ptrdiff_t *incy,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: cgeru.f */\n#define cgeru FORTRAN_WRAPPER(cgeru)\nextern void cgeru(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *y,\n    const ptrdiff_t *incy,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: chbmv.f */\n#define chbmv FORTRAN_WRAPPER(chbmv)\nextern void chbmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: chemm.f */\n#define chemm FORTRAN_WRAPPER(chemm)\nextern void chemm(\n    const char   *side,\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: chemv.f */\n#define chemv FORTRAN_WRAPPER(chemv)\nextern void chemv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: cher.f */\n#define cher FORTRAN_WRAPPER(cher)\nextern void cher(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: cher2.f */\n#define cher2 FORTRAN_WRAPPER(cher2)\nextern void cher2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *y,\n    const ptrdiff_t *incy,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: cher2k.f */\n#define cher2k FORTRAN_WRAPPER(cher2k)\nextern void cher2k(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: cherk.f */\n#define cherk FORTRAN_WRAPPER(cherk)\nextern void cherk(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: chpmv.f */\n#define chpmv FORTRAN_WRAPPER(chpmv)\nextern void chpmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *ap,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: chpr.f */\n#define chpr FORTRAN_WRAPPER(chpr)\nextern void chpr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    float  *ap\n);\n\n/* Source: chpr2.f */\n#define chpr2 FORTRAN_WRAPPER(chpr2)\nextern void chpr2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *y,\n    const ptrdiff_t *incy,\n    float  *ap\n);\n\n/* Source: crotg.f */\n#define crotg FORTRAN_WRAPPER(crotg)\nextern void crotg(\n    float  *ca,\n    const float  *cb,\n    float  *c,\n    float  *s\n);\n\n/* Source: cscal.f */\n#define cscal FORTRAN_WRAPPER(cscal)\nextern void cscal(\n    const ptrdiff_t *n,\n    const float  *ca,\n    float  *cx,\n    const ptrdiff_t *incx\n);\n\n/* Source: csrot.f */\n#define csrot FORTRAN_WRAPPER(csrot)\nextern void csrot(\n    const ptrdiff_t *n,\n    float  *cx,\n    const ptrdiff_t *incx,\n    float  *cy,\n    const ptrdiff_t *incy,\n    const float  *c,\n    const float  *s\n);\n\n/* Source: csscal.f */\n#define csscal FORTRAN_WRAPPER(csscal)\nextern void csscal(\n    const ptrdiff_t *n,\n    const float  *sa,\n    float  *cx,\n    const ptrdiff_t *incx\n);\n\n/* Source: cswap.f */\n#define cswap FORTRAN_WRAPPER(cswap)\nextern void cswap(\n    const ptrdiff_t *n,\n    float  *cx,\n    const ptrdiff_t *incx,\n    float  *cy,\n    const ptrdiff_t *incy\n);\n\n/* Source: csymm.f */\n#define csymm FORTRAN_WRAPPER(csymm)\nextern void csymm(\n    const char   *side,\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: csyr2k.f */\n#define csyr2k FORTRAN_WRAPPER(csyr2k)\nextern void csyr2k(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: csyrk.f */\n#define csyrk FORTRAN_WRAPPER(csyrk)\nextern void csyrk(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: ctbmv.f */\n#define ctbmv FORTRAN_WRAPPER(ctbmv)\nextern void ctbmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ctbsv.f */\n#define ctbsv FORTRAN_WRAPPER(ctbsv)\nextern void ctbsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ctpmv.f */\n#define ctpmv FORTRAN_WRAPPER(ctpmv)\nextern void ctpmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ctpsv.f */\n#define ctpsv FORTRAN_WRAPPER(ctpsv)\nextern void ctpsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ctrmm.f */\n#define ctrmm FORTRAN_WRAPPER(ctrmm)\nextern void ctrmm(\n    const char   *side,\n    const char   *uplo,\n    const char   *transa,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: ctrmv.f */\n#define ctrmv FORTRAN_WRAPPER(ctrmv)\nextern void ctrmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ctrsm.f */\n#define ctrsm FORTRAN_WRAPPER(ctrsm)\nextern void ctrsm(\n    const char   *side,\n    const char   *uplo,\n    const char   *transa,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: ctrsv.f */\n#define ctrsv FORTRAN_WRAPPER(ctrsv)\nextern void ctrsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: dasum.f */\n#define dasum FORTRAN_WRAPPER(dasum)\nextern double dasum(\n    const ptrdiff_t *n,\n    const double *dx,\n    const ptrdiff_t *incx\n);\n\n/* Source: daxpy.f */\n#define daxpy FORTRAN_WRAPPER(daxpy)\nextern void daxpy(\n    const ptrdiff_t *n,\n    const double *da,\n    const double *dx,\n    const ptrdiff_t *incx,\n    double *dy,\n    const ptrdiff_t *incy\n);\n\n/* Source: dcabs1.f */\n#define dcabs1 FORTRAN_WRAPPER(dcabs1)\nextern double dcabs1(\n    const double *z\n);\n\n/* Source: dcopy.f */\n#define dcopy FORTRAN_WRAPPER(dcopy)\nextern void dcopy(\n    const ptrdiff_t *n,\n    const double *dx,\n    const ptrdiff_t *incx,\n    double *dy,\n    const ptrdiff_t *incy\n);\n\n/* Source: ddot.f */\n#define ddot FORTRAN_WRAPPER(ddot)\nextern double ddot(\n    const ptrdiff_t *n,\n    const double *dx,\n    const ptrdiff_t *incx,\n    const double *dy,\n    const ptrdiff_t *incy\n);\n\n/* Source: dgbmv.f */\n#define dgbmv FORTRAN_WRAPPER(dgbmv)\nextern void dgbmv(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: dgemm.f */\n#define dgemm FORTRAN_WRAPPER(dgemm)\nextern void dgemm(\n    const char   *transa,\n    const char   *transb,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: dgemv.f */\n#define dgemv FORTRAN_WRAPPER(dgemv)\nextern void dgemv(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: dger.f */\n#define dger FORTRAN_WRAPPER(dger)\nextern void dger(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *y,\n    const ptrdiff_t *incy,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: dnrm2.f */\n#define dnrm2 FORTRAN_WRAPPER(dnrm2)\nextern double dnrm2(\n    const ptrdiff_t *n,\n    const double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: drot.f */\n#define drot FORTRAN_WRAPPER(drot)\nextern void drot(\n    const ptrdiff_t *n,\n    double *dx,\n    const ptrdiff_t *incx,\n    double *dy,\n    const ptrdiff_t *incy,\n    const double *c,\n    const double *s\n);\n\n/* Source: drotg.f */\n#define drotg FORTRAN_WRAPPER(drotg)\nextern void drotg(\n    double *da,\n    double *db,\n    double *c,\n    double *s\n);\n\n/* Source: drotm.f */\n#define drotm FORTRAN_WRAPPER(drotm)\nextern void drotm(\n    const ptrdiff_t *n,\n    double *dx,\n    const ptrdiff_t *incx,\n    double *dy,\n    const ptrdiff_t *incy,\n    const double *dparam\n);\n\n/* Source: drotmg.f */\n#define drotmg FORTRAN_WRAPPER(drotmg)\nextern void drotmg(\n    double *dd1,\n    double *dd2,\n    double *dx1,\n    const double *dy1,\n    double *dparam\n);\n\n/* Source: dsbmv.f */\n#define dsbmv FORTRAN_WRAPPER(dsbmv)\nextern void dsbmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: dscal.f */\n#define dscal FORTRAN_WRAPPER(dscal)\nextern void dscal(\n    const ptrdiff_t *n,\n    const double *da,\n    double *dx,\n    const ptrdiff_t *incx\n);\n\n/* Source: dsdot.f */\n#define dsdot FORTRAN_WRAPPER(dsdot)\nextern double dsdot(\n    const ptrdiff_t *n,\n    const float  *sx,\n    const ptrdiff_t *incx,\n    const float  *sy,\n    const ptrdiff_t *incy\n);\n\n/* Source: dspmv.f */\n#define dspmv FORTRAN_WRAPPER(dspmv)\nextern void dspmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *ap,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: dspr.f */\n#define dspr FORTRAN_WRAPPER(dspr)\nextern void dspr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    double *ap\n);\n\n/* Source: dspr2.f */\n#define dspr2 FORTRAN_WRAPPER(dspr2)\nextern void dspr2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *y,\n    const ptrdiff_t *incy,\n    double *ap\n);\n\n/* Source: dswap.f */\n#define dswap FORTRAN_WRAPPER(dswap)\nextern void dswap(\n    const ptrdiff_t *n,\n    double *dx,\n    const ptrdiff_t *incx,\n    double *dy,\n    const ptrdiff_t *incy\n);\n\n/* Source: dsymm.f */\n#define dsymm FORTRAN_WRAPPER(dsymm)\nextern void dsymm(\n    const char   *side,\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: dsymv.f */\n#define dsymv FORTRAN_WRAPPER(dsymv)\nextern void dsymv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: dsyr.f */\n#define dsyr FORTRAN_WRAPPER(dsyr)\nextern void dsyr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: dsyr2.f */\n#define dsyr2 FORTRAN_WRAPPER(dsyr2)\nextern void dsyr2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *y,\n    const ptrdiff_t *incy,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: dsyr2k.f */\n#define dsyr2k FORTRAN_WRAPPER(dsyr2k)\nextern void dsyr2k(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: dsyrk.f */\n#define dsyrk FORTRAN_WRAPPER(dsyrk)\nextern void dsyrk(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: dtbmv.f */\n#define dtbmv FORTRAN_WRAPPER(dtbmv)\nextern void dtbmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: dtbsv.f */\n#define dtbsv FORTRAN_WRAPPER(dtbsv)\nextern void dtbsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: dtpmv.f */\n#define dtpmv FORTRAN_WRAPPER(dtpmv)\nextern void dtpmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: dtpsv.f */\n#define dtpsv FORTRAN_WRAPPER(dtpsv)\nextern void dtpsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: dtrmm.f */\n#define dtrmm FORTRAN_WRAPPER(dtrmm)\nextern void dtrmm(\n    const char   *side,\n    const char   *uplo,\n    const char   *transa,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: dtrmv.f */\n#define dtrmv FORTRAN_WRAPPER(dtrmv)\nextern void dtrmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: dtrsm.f */\n#define dtrsm FORTRAN_WRAPPER(dtrsm)\nextern void dtrsm(\n    const char   *side,\n    const char   *uplo,\n    const char   *transa,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: dtrsv.f */\n#define dtrsv FORTRAN_WRAPPER(dtrsv)\nextern void dtrsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: dzasum.f */\n#define dzasum FORTRAN_WRAPPER(dzasum)\nextern double dzasum(\n    const ptrdiff_t *n,\n    const double *zx,\n    const ptrdiff_t *incx\n);\n\n/* Source: dznrm2.f */\n#define dznrm2 FORTRAN_WRAPPER(dznrm2)\nextern double dznrm2(\n    const ptrdiff_t *n,\n    const double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: icamax.f */\n#define icamax FORTRAN_WRAPPER(icamax)\nextern ptrdiff_t icamax(\n    const ptrdiff_t *n,\n    const float  *cx,\n    const ptrdiff_t *incx\n);\n\n/* Source: idamax.f */\n#define idamax FORTRAN_WRAPPER(idamax)\nextern ptrdiff_t idamax(\n    const ptrdiff_t *n,\n    const double *dx,\n    const ptrdiff_t *incx\n);\n\n/* Source: isamax.f */\n#define isamax FORTRAN_WRAPPER(isamax)\nextern ptrdiff_t isamax(\n    const ptrdiff_t *n,\n    const float  *sx,\n    const ptrdiff_t *incx\n);\n\n/* Source: izamax.f */\n#define izamax FORTRAN_WRAPPER(izamax)\nextern ptrdiff_t izamax(\n    const ptrdiff_t *n,\n    const double *zx,\n    const ptrdiff_t *incx\n);\n\n/* Source: lsame.f */\n#define lsame FORTRAN_WRAPPER(lsame)\nextern ptrdiff_t lsame(\n    const char   *ca,\n    const char   *cb\n);\n\n/* Source: sasum.f */\n#define sasum FORTRAN_WRAPPER(sasum)\nextern float sasum(\n    const ptrdiff_t *n,\n    const float  *sx,\n    const ptrdiff_t *incx\n);\n\n/* Source: saxpy.f */\n#define saxpy FORTRAN_WRAPPER(saxpy)\nextern void saxpy(\n    const ptrdiff_t *n,\n    const float  *sa,\n    const float  *sx,\n    const ptrdiff_t *incx,\n    float  *sy,\n    const ptrdiff_t *incy\n);\n\n/* Source: scasum.f */\n#define scasum FORTRAN_WRAPPER(scasum)\nextern float scasum(\n    const ptrdiff_t *n,\n    const float  *cx,\n    const ptrdiff_t *incx\n);\n\n/* Source: scnrm2.f */\n#define scnrm2 FORTRAN_WRAPPER(scnrm2)\nextern float scnrm2(\n    const ptrdiff_t *n,\n    const float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: scopy.f */\n#define scopy FORTRAN_WRAPPER(scopy)\nextern void scopy(\n    const ptrdiff_t *n,\n    const float  *sx,\n    const ptrdiff_t *incx,\n    float  *sy,\n    const ptrdiff_t *incy\n);\n\n/* Source: sdot.f */\n#define sdot FORTRAN_WRAPPER(sdot)\nextern float sdot(\n    const ptrdiff_t *n,\n    const float  *sx,\n    const ptrdiff_t *incx,\n    const float  *sy,\n    const ptrdiff_t *incy\n);\n\n/* Source: sdsdot.f */\n#define sdsdot FORTRAN_WRAPPER(sdsdot)\nextern float sdsdot(\n    const ptrdiff_t *n,\n    const float  *sb,\n    const float  *sx,\n    const ptrdiff_t *incx,\n    const float  *sy,\n    const ptrdiff_t *incy\n);\n\n/* Source: sgbmv.f */\n#define sgbmv FORTRAN_WRAPPER(sgbmv)\nextern void sgbmv(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: sgemm.f */\n#define sgemm FORTRAN_WRAPPER(sgemm)\nextern void sgemm(\n    const char   *transa,\n    const char   *transb,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: sgemv.f */\n#define sgemv FORTRAN_WRAPPER(sgemv)\nextern void sgemv(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: sger.f */\n#define sger FORTRAN_WRAPPER(sger)\nextern void sger(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *y,\n    const ptrdiff_t *incy,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: snrm2.f */\n#define snrm2 FORTRAN_WRAPPER(snrm2)\nextern float snrm2(\n    const ptrdiff_t *n,\n    const float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: srot.f */\n#define srot FORTRAN_WRAPPER(srot)\nextern void srot(\n    const ptrdiff_t *n,\n    float  *sx,\n    const ptrdiff_t *incx,\n    float  *sy,\n    const ptrdiff_t *incy,\n    const float  *c,\n    const float  *s\n);\n\n/* Source: srotg.f */\n#define srotg FORTRAN_WRAPPER(srotg)\nextern void srotg(\n    float  *sa,\n    float  *sb,\n    float  *c,\n    float  *s\n);\n\n/* Source: srotm.f */\n#define srotm FORTRAN_WRAPPER(srotm)\nextern void srotm(\n    const ptrdiff_t *n,\n    float  *sx,\n    const ptrdiff_t *incx,\n    float  *sy,\n    const ptrdiff_t *incy,\n    const float  *sparam\n);\n\n/* Source: srotmg.f */\n#define srotmg FORTRAN_WRAPPER(srotmg)\nextern void srotmg(\n    float  *sd1,\n    float  *sd2,\n    float  *sx1,\n    const float  *sy1,\n    float  *sparam\n);\n\n/* Source: ssbmv.f */\n#define ssbmv FORTRAN_WRAPPER(ssbmv)\nextern void ssbmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: sscal.f */\n#define sscal FORTRAN_WRAPPER(sscal)\nextern void sscal(\n    const ptrdiff_t *n,\n    const float  *sa,\n    float  *sx,\n    const ptrdiff_t *incx\n);\n\n/* Source: sspmv.f */\n#define sspmv FORTRAN_WRAPPER(sspmv)\nextern void sspmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *ap,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: sspr.f */\n#define sspr FORTRAN_WRAPPER(sspr)\nextern void sspr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    float  *ap\n);\n\n/* Source: sspr2.f */\n#define sspr2 FORTRAN_WRAPPER(sspr2)\nextern void sspr2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *y,\n    const ptrdiff_t *incy,\n    float  *ap\n);\n\n/* Source: sswap.f */\n#define sswap FORTRAN_WRAPPER(sswap)\nextern void sswap(\n    const ptrdiff_t *n,\n    float  *sx,\n    const ptrdiff_t *incx,\n    float  *sy,\n    const ptrdiff_t *incy\n);\n\n/* Source: ssymm.f */\n#define ssymm FORTRAN_WRAPPER(ssymm)\nextern void ssymm(\n    const char   *side,\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: ssymv.f */\n#define ssymv FORTRAN_WRAPPER(ssymv)\nextern void ssymv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: ssyr.f */\n#define ssyr FORTRAN_WRAPPER(ssyr)\nextern void ssyr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: ssyr2.f */\n#define ssyr2 FORTRAN_WRAPPER(ssyr2)\nextern void ssyr2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *y,\n    const ptrdiff_t *incy,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: ssyr2k.f */\n#define ssyr2k FORTRAN_WRAPPER(ssyr2k)\nextern void ssyr2k(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: ssyrk.f */\n#define ssyrk FORTRAN_WRAPPER(ssyrk)\nextern void ssyrk(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *beta,\n    float  *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: stbmv.f */\n#define stbmv FORTRAN_WRAPPER(stbmv)\nextern void stbmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: stbsv.f */\n#define stbsv FORTRAN_WRAPPER(stbsv)\nextern void stbsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: stpmv.f */\n#define stpmv FORTRAN_WRAPPER(stpmv)\nextern void stpmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: stpsv.f */\n#define stpsv FORTRAN_WRAPPER(stpsv)\nextern void stpsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: strmm.f */\n#define strmm FORTRAN_WRAPPER(strmm)\nextern void strmm(\n    const char   *side,\n    const char   *uplo,\n    const char   *transa,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: strmv.f */\n#define strmv FORTRAN_WRAPPER(strmv)\nextern void strmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: strsm.f */\n#define strsm FORTRAN_WRAPPER(strsm)\nextern void strsm(\n    const char   *side,\n    const char   *uplo,\n    const char   *transa,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: strsv.f */\n#define strsv FORTRAN_WRAPPER(strsv)\nextern void strsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: xerbla.f */\n#define xerbla FORTRAN_WRAPPER(xerbla)\nextern void xerbla(\n    const char   *srname,\n    const ptrdiff_t *info,\n    const ptrdiff_t srname_len\n);\n\n/* Source: xerbla_array.f */\n#define xerbla_array FORTRAN_WRAPPER(xerbla_array)\nextern void xerbla_array(\n    const char   *srname_array,\n    const ptrdiff_t *srname_len,\n    const ptrdiff_t *info\n);\n\n/* Source: zaxpy.f */\n#define zaxpy FORTRAN_WRAPPER(zaxpy)\nextern void zaxpy(\n    const ptrdiff_t *n,\n    const double *za,\n    const double *zx,\n    const ptrdiff_t *incx,\n    double *zy,\n    const ptrdiff_t *incy\n);\n\n/* Source: zcopy.f */\n#define zcopy FORTRAN_WRAPPER(zcopy)\nextern void zcopy(\n    const ptrdiff_t *n,\n    const double *zx,\n    const ptrdiff_t *incx,\n    double *zy,\n    const ptrdiff_t *incy\n);\n\n/* Source: zdotc.f */\n#define zdotc FORTRAN_WRAPPER(zdotc)\nextern void zdotc(\n    doublecomplex* retval,\n    const ptrdiff_t *n,\n    const double *zx,\n    const ptrdiff_t *incx,\n    const double *zy,\n    const ptrdiff_t *incy\n);\n\n/* Source: zdotu.f */\n#define zdotu FORTRAN_WRAPPER(zdotu)\nextern void zdotu(\n    doublecomplex* retval,\n    const ptrdiff_t *n,\n    const double *zx,\n    const ptrdiff_t *incx,\n    const double *zy,\n    const ptrdiff_t *incy\n);\n\n/* Source: zdrot.f */\n#define zdrot FORTRAN_WRAPPER(zdrot)\nextern void zdrot(\n    const ptrdiff_t *n,\n    double *cx,\n    const ptrdiff_t *incx,\n    double *cy,\n    const ptrdiff_t *incy,\n    const double *c,\n    const double *s\n);\n\n/* Source: zdscal.f */\n#define zdscal FORTRAN_WRAPPER(zdscal)\nextern void zdscal(\n    const ptrdiff_t *n,\n    const double *da,\n    double *zx,\n    const ptrdiff_t *incx\n);\n\n/* Source: zgbmv.f */\n#define zgbmv FORTRAN_WRAPPER(zgbmv)\nextern void zgbmv(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: zgemm.f */\n#define zgemm FORTRAN_WRAPPER(zgemm)\nextern void zgemm(\n    const char   *transa,\n    const char   *transb,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: zgemv.f */\n#define zgemv FORTRAN_WRAPPER(zgemv)\nextern void zgemv(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: zgerc.f */\n#define zgerc FORTRAN_WRAPPER(zgerc)\nextern void zgerc(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *y,\n    const ptrdiff_t *incy,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: zgeru.f */\n#define zgeru FORTRAN_WRAPPER(zgeru)\nextern void zgeru(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *y,\n    const ptrdiff_t *incy,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: zhbmv.f */\n#define zhbmv FORTRAN_WRAPPER(zhbmv)\nextern void zhbmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: zhemm.f */\n#define zhemm FORTRAN_WRAPPER(zhemm)\nextern void zhemm(\n    const char   *side,\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: zhemv.f */\n#define zhemv FORTRAN_WRAPPER(zhemv)\nextern void zhemv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: zher.f */\n#define zher FORTRAN_WRAPPER(zher)\nextern void zher(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: zher2.f */\n#define zher2 FORTRAN_WRAPPER(zher2)\nextern void zher2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *y,\n    const ptrdiff_t *incy,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: zher2k.f */\n#define zher2k FORTRAN_WRAPPER(zher2k)\nextern void zher2k(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: zherk.f */\n#define zherk FORTRAN_WRAPPER(zherk)\nextern void zherk(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: zhpmv.f */\n#define zhpmv FORTRAN_WRAPPER(zhpmv)\nextern void zhpmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *ap,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: zhpr.f */\n#define zhpr FORTRAN_WRAPPER(zhpr)\nextern void zhpr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    double *ap\n);\n\n/* Source: zhpr2.f */\n#define zhpr2 FORTRAN_WRAPPER(zhpr2)\nextern void zhpr2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *y,\n    const ptrdiff_t *incy,\n    double *ap\n);\n\n/* Source: zrotg.f */\n#define zrotg FORTRAN_WRAPPER(zrotg)\nextern void zrotg(\n    double *ca,\n    const double *cb,\n    double *c,\n    double *s\n);\n\n/* Source: zscal.f */\n#define zscal FORTRAN_WRAPPER(zscal)\nextern void zscal(\n    const ptrdiff_t *n,\n    const double *za,\n    double *zx,\n    const ptrdiff_t *incx\n);\n\n/* Source: zswap.f */\n#define zswap FORTRAN_WRAPPER(zswap)\nextern void zswap(\n    const ptrdiff_t *n,\n    double *zx,\n    const ptrdiff_t *incx,\n    double *zy,\n    const ptrdiff_t *incy\n);\n\n/* Source: zsymm.f */\n#define zsymm FORTRAN_WRAPPER(zsymm)\nextern void zsymm(\n    const char   *side,\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: zsyr2k.f */\n#define zsyr2k FORTRAN_WRAPPER(zsyr2k)\nextern void zsyr2k(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: zsyrk.f */\n#define zsyrk FORTRAN_WRAPPER(zsyrk)\nextern void zsyrk(\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *beta,\n    double *c,\n    const ptrdiff_t *ldc\n);\n\n/* Source: ztbmv.f */\n#define ztbmv FORTRAN_WRAPPER(ztbmv)\nextern void ztbmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ztbsv.f */\n#define ztbsv FORTRAN_WRAPPER(ztbsv)\nextern void ztbsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ztpmv.f */\n#define ztpmv FORTRAN_WRAPPER(ztpmv)\nextern void ztpmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ztpsv.f */\n#define ztpsv FORTRAN_WRAPPER(ztpsv)\nextern void ztpsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ztrmm.f */\n#define ztrmm FORTRAN_WRAPPER(ztrmm)\nextern void ztrmm(\n    const char   *side,\n    const char   *uplo,\n    const char   *transa,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: ztrmv.f */\n#define ztrmv FORTRAN_WRAPPER(ztrmv)\nextern void ztrmv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: ztrsm.f */\n#define ztrsm FORTRAN_WRAPPER(ztrsm)\nextern void ztrsm(\n    const char   *side,\n    const char   *uplo,\n    const char   *transa,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: ztrsv.f */\n#define ztrsv FORTRAN_WRAPPER(ztrsv)\nextern void ztrsv(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n#ifdef __cplusplus\n    }   /* extern \"C\" */\n#endif\n\n#endif /* refblas_h */\n"},{"name":"blascompat32.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * CONFIDENTIAL AND CONTAINING PROPRIETARY TRADE SECRETS\n * Copyright 1984-2012 The MathWorks, Inc.\n * The source code contained in this listing contains proprietary and\n * confidential trade secrets of The MathWorks, Inc.   The use, modification,\n * or development of derivative work based on the code or ideas obtained\n * from the code is prohibited without the express written permission of The\n * MathWorks, Inc.  The disclosure of this code to any party not authorized\n * by The MathWorks, Inc. is strictly forbidden.\n * CONFIDENTIAL AND CONTAINING PROPRIETARY TRADE SECRETS\n */\n\n/*\n *  32-bit API wrapper for libmwblas\n *  WARNING: This module is a temporary module specifically designed to \n *           bridge the incompatiblity between Embedded MATLAB (which lacks\n *           a 64-bit integer type) and 64-bit BLAS only.\n *           Do not link to this module otherwise.\n *           Link to libmwblas instead.\n */   \n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef blascompat32_h\n#define blascompat32_h\n\n#ifndef EXTERN_C\n#ifdef __cplusplus\n  #define EXTERN_C extern \"C\"\n#else\n  #define EXTERN_C extern\n#endif\n#endif\n\n#ifndef LIBMWBLASCOMPAT32_API\n  #define LIBMWBLASCOMPAT32_API\n#endif\n\n#include <tmwtypes.h>\n\n#if defined(_WIN32) \n#define FORTRAN_WRAPPER(x) x\n#else\n#define FORTRAN_WRAPPER(x) x ## _\n#endif\n\n#ifndef COMPLEX_TYPES\n#define COMPLEX_TYPES\n  typedef struct{float r,i;} complex;\n  typedef struct{double r,i;} doublecomplex;\n#endif\n  \nEXTERN_C LIBMWBLASCOMPAT32_API \n#define isamax32 FORTRAN_WRAPPER(isamax32)\nint isamax32(const int *n32, const float  *sx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API \n#define idamax32 FORTRAN_WRAPPER(idamax32)\nint idamax32(const int *n32, const double *dx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API \n#define icamax32 FORTRAN_WRAPPER(icamax32)\nint icamax32(const int *n32, const creal32_T *cx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API \n#define izamax32 FORTRAN_WRAPPER(izamax32)\nint izamax32(const int *n32, const creal_T *zx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API \n#define sasum32 FORTRAN_WRAPPER(sasum32)\nfloat sasum32(const int *n32, const float  *sx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API \n#define dasum32 FORTRAN_WRAPPER(dasum32)\ndouble dasum32(const int *n32, const double *dx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define saxpy32 FORTRAN_WRAPPER(saxpy32)\nvoid saxpy32(const int *n32, const float *sa, const float  *sx,\n             const int *incx32, float *sy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define daxpy32 FORTRAN_WRAPPER(daxpy32)\nvoid daxpy32(const int *n32, const double *da, const double *dx,\n             const int *incx32, double *dy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define caxpy32 FORTRAN_WRAPPER(caxpy32)\nvoid caxpy32(const int *n32, const creal32_T *ca, const creal32_T *cx,\n             const int *incx32, creal32_T *cy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zaxpy32 FORTRAN_WRAPPER(zaxpy32)\nvoid zaxpy32(const int *n32, const creal_T *za, const creal_T *zx,\n             const int *incx32, creal_T *zy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define scopy32 FORTRAN_WRAPPER(scopy32)\nvoid scopy32(const int *n32, const float *sx, const int *incx32, \n             float *sy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dcopy32 FORTRAN_WRAPPER(dcopy32)\nvoid dcopy32(const int *n32, const double *dx, const int *incx32, \n             double *dy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define ccopy32 FORTRAN_WRAPPER(ccopy32)\nvoid ccopy32(const int *n32, const creal32_T *cx, const int *incx32, \n             creal32_T *cy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zcopy32 FORTRAN_WRAPPER(zcopy32)\nvoid zcopy32(const int *n32, creal_T *zx, const int *incx32, \n             creal_T *zy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define cdotc32 FORTRAN_WRAPPER(cdotc32)\ncomplex cdotc32(const int *n32, const creal32_T *cx, const int *incx32,\n              const creal32_T *cy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zdotc32 FORTRAN_WRAPPER(zdotc32)\ndoublecomplex zdotc32(const int *n32, const creal_T *zx, const int *incx32,\n               const creal_T *zy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define sdot32 FORTRAN_WRAPPER(sdot32)\nfloat sdot32(const int *n32, const float *sx, const int *incx32, \n             const float  *sy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define ddot32 FORTRAN_WRAPPER(ddot32)\ndouble ddot32(const int *n32, const double *dx, const int *incx32, \n              const double *dy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define cdotu32 FORTRAN_WRAPPER(cdotu32)\ncomplex cdotu32(const int *n32, const creal32_T *cx, const int *incx32, \n              const creal32_T *cy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zdotu32 FORTRAN_WRAPPER(zdotu32)\ndoublecomplex zdotu32(const int *n32, const creal_T *zx, const int *incx32, \n               const creal_T *zy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define sgemm32 FORTRAN_WRAPPER(sgemm32)\nvoid sgemm32(char *transa, char *transb, const int *m32, const int *n32,\n             const int *k32, const float *alpha, const float *a, const int *lda32,\n             const float *b, const int *ldb32, const float *beta, float *c,\n             const int *ldc32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dgemm32 FORTRAN_WRAPPER(dgemm32)\nvoid dgemm32(char *transa, char *transb, const int *m32, const int *n32,\n             const int *k32, const double *alpha, const double *a, const int *lda32,\n             const double *b, const int *ldb32, const double *beta, double  *c,\n             const int *ldc32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define cgemm32 FORTRAN_WRAPPER(cgemm32)\nvoid cgemm32(char *transa, char *transb, const int *m32, const int *n32,\n             const int *k32, const creal32_T *alpha, const creal32_T *a, const int *lda32,\n             const creal32_T *b, const int *ldb32, const creal32_T *beta, creal32_T *c,\n             const int *ldc32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zgemm32 FORTRAN_WRAPPER(zgemm32)\nvoid zgemm32(char *transa, char *transb, const int *m32, const int *n32,\n             const int *k32, const creal_T *alpha, const creal_T *a, const int *lda32,\n             const creal_T *b, const int *ldb32, const creal_T *beta, creal_T *c,\n             const int *ldc32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define sgemv32 FORTRAN_WRAPPER(sgemv32)\nvoid sgemv32(char *trans, const int *m32, const int *n32, const float *alpha,\n             const float *a, const int *lda32, const float *x, const int *incx32, \n             const float *beta, float *y, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dgemv32 FORTRAN_WRAPPER(dgemv32)\nvoid dgemv32(char *trans, const int *m32, const int *n32, const double *alpha,\n             const double *a, const int *lda32, const double *x, const int *incx32, \n             const double *beta, double *y, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define cgemv32 FORTRAN_WRAPPER(cgemv32)\nvoid cgemv32(char *trans, const int *m32, const int *n32, const creal32_T *alpha,\n             const creal32_T *a, const int *lda32, const creal32_T *x, const int *incx32, \n             const creal32_T *beta, creal32_T *y, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zgemv32 FORTRAN_WRAPPER(zgemv32)\nvoid zgemv32(char *trans, const int *m32, const int *n32, const creal_T *alpha,\n             const creal_T *a, const int *lda32, const creal_T *x, const int *incx32, \n             const creal_T *beta, creal_T *y, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define cgerc32 FORTRAN_WRAPPER(cgerc32)\nvoid cgerc32(const int *m32, const int *n32, const creal32_T *alpha, const creal32_T *x,\n             const int *incx32, const creal32_T *y, const int *incy32,\n             creal32_T *a, const int *lda32);     \n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zgerc32 FORTRAN_WRAPPER(zgerc32)\nvoid zgerc32(const int *m32, const int *n32, const creal_T *alpha, const creal_T *x,\n             const int *incx32, creal_T *y, const int *incy32,\n             creal_T *a, const int *lda32);\n     \nEXTERN_C LIBMWBLASCOMPAT32_API\n#define sger32 FORTRAN_WRAPPER(sger32)\nvoid sger32(const int *m32, const int *n32, const float *alpha, const float  *x,\n            const int *incx32, const float *y, const int *incy32, \n            float *a, const int *lda32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dger32 FORTRAN_WRAPPER(dger32)\nvoid dger32(const int *m32, const int *n32, const double *alpha, const double *x,\n            const int *incx32, const double *y, const int *incy32,\n            double *a, const int *lda32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define cgeru32 FORTRAN_WRAPPER(cgeru32)\nvoid cgeru32(const int *m32, const int *n32, const creal32_T *alpha, const creal32_T *x,\n             const int *incx32, const creal32_T *y, const int *incy32,\n             creal32_T *a, const int *lda32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zgeru32 FORTRAN_WRAPPER(zgeru32)\nvoid zgeru32(const int *m32, const int *n32, const creal_T *alpha, const creal_T *x,\n             const int *incx32, creal_T *y, const int *incy32,\n             creal_T *a, const int *lda32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define snrm232 FORTRAN_WRAPPER(snrm232)\nfloat snrm232(const int *n32, const float *x, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dnrm232 FORTRAN_WRAPPER(dnrm232)\ndouble dnrm232(const int *n32, const double *x, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define scnrm232 FORTRAN_WRAPPER(scnrm232)\nfloat scnrm232(const int *n32, const creal32_T *x, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dznrm232 FORTRAN_WRAPPER(dznrm232)\ndouble dznrm232(const int *n32, const creal_T *x, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define srotg32 FORTRAN_WRAPPER(srotg32)\nvoid srotg32(float  *sa, float  *sb, float  *c, float  *s);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define drotg32 FORTRAN_WRAPPER(drotg32)\nvoid drotg32(double *da, double *db, double *c, double *s);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define crotg32 FORTRAN_WRAPPER(crotg32)\nvoid crotg32(creal32_T *ca, creal32_T *cb, creal32_T *c, creal32_T *s);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zrotg32 FORTRAN_WRAPPER(zrotg32)\nvoid zrotg32(creal_T *ca, creal_T *cb, creal_T *c, creal_T *s);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define srot32 FORTRAN_WRAPPER(srot32)\nvoid srot32(const int *n32, float  *sx, const int *incx32, float  *sy, \n            const int *incy32, const float *c, const float *s);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define drot32 FORTRAN_WRAPPER(drot32)\nvoid drot32(const int *n32, double *dx, const int *incx32, double *dy,\n            const int *incy32, const double *c, const double *s);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define csrot32 FORTRAN_WRAPPER(csrot32)\nvoid csrot32(const int *n32, creal32_T *cx, const int *incx32, creal32_T *cy, \n             const int *incy32, const float *c, const creal32_T *s);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zdrot32 FORTRAN_WRAPPER(zdrot32)\nvoid zdrot32(const int *n32, creal_T *cx, const int *incx32, creal_T *cy, \n             const int *incy32, const double *c, const creal_T *s);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define sscal32 FORTRAN_WRAPPER(sscal32)\nvoid sscal32(const int *n32, const float *sa, float  *sx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dscal32 FORTRAN_WRAPPER(dscal32)\nvoid dscal32(const int *n32, const double *da, double *dx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define cscal32 FORTRAN_WRAPPER(cscal32)\nvoid cscal32(const int *n32, const creal32_T *ca, creal32_T *cx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zscal32 FORTRAN_WRAPPER(zscal32)\nvoid zscal32(const int *n32, const creal_T *za, creal_T *zx, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define sswap32 FORTRAN_WRAPPER(sswap32)\nvoid sswap32(const int *n32, float  *sx, const int *incx32, float  *sy, \n             const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dswap32 FORTRAN_WRAPPER(dswap32)\nvoid dswap32(const int *n32, double *dx, const int *incx32, double *dy,\n             const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define cswap32 FORTRAN_WRAPPER(cswap32)\nvoid cswap32(const int *n32, creal32_T *cx, const int *incx32, \n             creal32_T *cy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define zswap32 FORTRAN_WRAPPER(zswap32)\nvoid zswap32(const int *n32, creal_T *zx, const int *incx32, \n             creal_T *zy, const int *incy32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define strsm32 FORTRAN_WRAPPER(strsm32)\nvoid strsm32(char   *side, char   *uplo, char   *transa, \n             char *diag, const int *m32, const int *n32,\n             const float *alpha, const float *a, const int *lda32, \n             float  *b, const int *ldb32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dtrsm32 FORTRAN_WRAPPER(dtrsm32)\nvoid dtrsm32(char   *side, char   *uplo, char   *transa, \n             char *diag, const int *m32, const int *n32, \n             const double *alpha, const double *a, const int *lda32, \n             double *b, const int *ldb32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define ctrsm32 FORTRAN_WRAPPER(ctrsm32)\nvoid ctrsm32(char   *side, char   *uplo, char   *transa, \n             char *diag, const int *m32, const int *n32, \n             const creal32_T *alpha, const creal32_T *a, const int *lda32, \n             creal32_T *b, const int *ldb32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define ztrsm32 FORTRAN_WRAPPER(ztrsm32)\nvoid ztrsm32(char   *side, char   *uplo, char   *transa,\n             char *diag, const int *m32, const int *n32,\n             const creal_T *alpha, const creal_T *a, const int *lda32, \n             creal_T *b, const int *ldb32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define strsv32 FORTRAN_WRAPPER(strsv32)\nvoid strsv32(char   *uplo, char   *trans, char   *diag,\n                const int *n32, const float *a, const int *lda32,\n                float *x, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define dtrsv32 FORTRAN_WRAPPER(dtrsv32)\nvoid dtrsv32(char   *uplo, char   *trans, char   *diag,\n                const int *n32, const double *a, const int *lda32, \n                double *x, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define ctrsv32 FORTRAN_WRAPPER(ctrsv32)\nvoid ctrsv32(char   *uplo, char   *trans, char   *diag, \n                const int *n32, const creal32_T *a, const int *lda32, \n                creal32_T *x, const int *incx32);\n\nEXTERN_C LIBMWBLASCOMPAT32_API\n#define ztrsv32 FORTRAN_WRAPPER(ztrsv32)\nvoid ztrsv32(char   *uplo, char   *trans, char   *diag,\n                const int *n32, const creal_T *a, const int *lda32, \n                creal_T *x, const int *incx32);\n\n#endif /* blascompat32_h */\n"},{"name":"cg_matrx.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2002 The MathWorks, Inc.\n *\n * File    : cg_matrx.h       \n * Abstract:\n *\tProvided for backwards compatibility. See rt_matrx.h for details.\n */\n\n#include \"rt_matrx.h\"\n\n/* [EOF] cg_matrx.h */\n"},{"name":"cg_sfun.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* cg_sfun.h \n *  \n * Entry point for user-written S-Functions when compiled for\n * use with the Simulink C-Code Generator.  This file should\n * be conditionally included at the bottom of any user-written\n * S-Function so as to enable the static functions within it\n * to be registered at startup.  Also, the macro S_FUNCTION_NAME\n * should be declared within the S-Function to specify the\n * entry point name--that is the name by which the S-Function\n * is to be known to the outside world.\n *\n * Copyright 1994-2005 The MathWorks, Inc.\n */\n\n#ifdef __cplusplus\nextern \"C\"\n#endif\n\nvoid S_FUNCTION_NAME(SimStruct *S)\n{\n#if S_FUNCTION_LEVEL == 1\n  /* level 1 */\n  ssSetmdlInitializeSizes(S, mdlInitializeSizes);\n  ssSetmdlInitializeSampleTimes(S, mdlInitializeSampleTimes); \n  ssSetmdlInitializeConditionsLevel1(S, mdlInitializeConditions);\n  ssSetmdlOutputsLevel1(S, mdlOutputs); \n  ssSetmdlUpdateLevel1(S, mdlUpdate); \n  ssSetmdlDerivativesLevel1(S, mdlDerivatives);\n  ssSetmdlTerminate(S, mdlTerminate);\n#else\n  /* user level 2 */\n\n  ssSetmdlInitializeSizes(S, mdlInitializeSizes);\n  ssSetmdlInitializeSampleTimes(S, mdlInitializeSampleTimes); \n\n# if defined(MDL_INITIALIZE_CONDITIONS)\n    ssSetmdlInitializeConditions(S, mdlInitializeConditions);\n# endif\n# if defined(MDL_START)\n    ssSetmdlStart(S, mdlStart);\n# endif\n\n# if defined(MDL_SETUP_RUNTIME_RESOURCES)\n    ssSetmdlSetupRuntimeResources(S, mdlSetupRuntimeResources);\n# endif\n\n# if defined(RTW_GENERATED_ENABLE)\n    ssSetRTWGeneratedEnable(S, mdlEnable);\n# endif\n\n# if defined(RTW_GENERATED_DISABLE)\n    ssSetRTWGeneratedDisable(S, mdlDisable);\n# endif\n\n# if defined(MDL_ENABLE)\n    ssSetmdlEnable(S, mdlEnable);\n# endif\n\n# if defined(MDL_DISABLE)\n    ssSetmdlDisable(S, mdlDisable);\n# endif\n\n  ssSetmdlOutputs(S, mdlOutputs); \n# if defined(MDL_GET_TIME_OF_NEXT_VAR_HIT)\n    ssSetmdlGetTimeOfNextVarHit(S, mdlGetTimeOfNextVarHit); \n# endif\n# if defined(MDL_UPDATE)\n    ssSetmdlUpdate(S, mdlUpdate); \n# endif\n# if defined(MDL_DERIVATIVES)\n    ssSetmdlDerivatives(S, mdlDerivatives);\n# endif\n\n# if defined(MDL_PROJECTION)\n    ssSetmdlProjection(S, mdlProjection);\n# endif\n\n# if defined(MDL_FORCINGFUNCTION)\n    ssSetmdlForcingFunction(S, mdlForcingFunction);\n# endif\n\n# if defined(MDL_MASSMATRIX)\n    ssSetmdlMassMatrix(S, mdlMassMatrix);\n# endif\n\n# if defined(MDL_RTWCG)\n    ssSetmdlRTWCG(S, mdlRTWCG);\n# endif\n\n# if defined(MDL_ZERO_CROSSINGS) && (defined(MATLAB_MEX_FILE) || defined(NRT))\n    ssSetmdlZeroCrossings(S, mdlZeroCrossings);\n# endif\n\n# if defined(MDL_CLEANUP_RUNTIME_RESOURCES)\n    ssSetmdlCleanupRuntimeResources(S, mdlCleanupRuntimeResources);\n# endif\n\n  ssSetmdlTerminate(S, mdlTerminate);\n#endif\n}\n"},{"name":"cgxeooprt.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/*\n * PUBLISHED header for C cgxeooprt, the OOP runtime library for CGXE C file\n *\n * Copyright 2020 The MathWorks, Inc.\n *\n */\n\n#ifndef cgxeooprt_h\n#define cgxeooprt_h\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n/*\n * Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n\n#endif\n\n#ifndef LIBCGXEOOPRT_API\n#define LIBCGXEOOPRT_API\n#endif\n\n#if defined(BUILDING_LIBMWCGXEOOPRT) || defined(DLL_IMPORT_SYM)\n/* internal use */\n# include \"simstruct/simstruc.h\"\n#else\n/* external use */\n# include \"simstruc.h\"\n#endif\n\n/*\n * MATLAB INTERNAL USE ONLY :: Call Out-Of-Process Runtime Function\n */\nEXTERN_C LIBCGXEOOPRT_API void cgxertCallSLCCOutOfProcessFcn(SimStruct* S,\n                                                             int sysIdx,\n                                                             int blkIdx,\n                                                             const char* ccChecksum,\n                                                             const char* fcnName,\n                                                             int32_T argNum,\n                                                             int32_T* scopeIds,\n                                                             int32_T* dims,\n                                                             int32_T* elemSizes,\n                                                             void** dataPtrs);\n\n\n\n#endif /* cgxeooprt_h */\n"},{"name":"cgxert.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/*\n * PUBLISHED header for C cgxert, the runtime library for CGXE C file\n *\n * Copyright 2014-2019 The MathWorks, Inc.\n *\n */\n\n#ifndef cgxert_h\n#define cgxert_h\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n/*\n * Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n\n#endif\n\n#ifndef LIBCGXERT_API\n#define LIBCGXERT_API\n#endif\n\n#if defined(BUILDING_LIBMWCGXERT) || defined(DLL_IMPORT_SYM)\n/* internal use */\n# include \"simstruct/simstruc.h\"\n#else\n/* external use */\n# include \"simstruc.h\"\n#endif\n\n#include <setjmp.h>\n#include <stdarg.h>\n\ntypedef void *CgxertCTX;\n\ntypedef struct covrtInstance covrtInstance;\n\ntypedef struct emlrtBCInfo emlrtBCInfo;\n\ntypedef void (*tbb_task_func)(void *);\n\ntypedef enum\n{\n    CGXERT_DIAG_BLOCK_PATH = 0,\n    CGXERT_DIAG_STRING,\n    CGXERT_DIAG_STRING_FROM_DOUBLE,\n    CGXERT_DIAG_NUMERIC,\n    CGXERT_DIAG_NUMERIC_FROM_DOUBLE\n} cgxertDiagnosticsInputType;\n\n/*\n *  MATLAB INTERNAL USE ONLY :: macro wrappers\n */\nEXTERN_C LIBCGXERT_API const void*         cgxertGetInputPortSignal(CgxertCTX ctx, int32_T/*Sint32*/index);\nEXTERN_C LIBCGXERT_API const void* const * cgxertGetInputPortSignalPtrs(CgxertCTX ctx, int32_T ip);\nEXTERN_C LIBCGXERT_API void*  cgxertGetOutputPortSignal(CgxertCTX ctx, int32_T index);\nEXTERN_C LIBCGXERT_API void*  cgxertGetDWork(CgxertCTX ctx, int32_T index);\nEXTERN_C LIBCGXERT_API void*  cgxertGetRunTimeParamInfoData(CgxertCTX ctx, int32_T index);\nEXTERN_C LIBCGXERT_API void   cgxertSetSimStateCompliance(CgxertCTX ctx, int32_T simStateCompliance);\nEXTERN_C LIBCGXERT_API void   cgxertSetStopRequested(CgxertCTX ctx, bool stop);\nEXTERN_C LIBCGXERT_API void   cgxertSetErrStat(CgxertCTX ctx, char* errMsg);\nEXTERN_C LIBCGXERT_API void   cgxertSetSolverNeedsReset(CgxertCTX ctx);\nEXTERN_C LIBCGXERT_API double cgxertGetT(CgxertCTX ctx);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get varsize I/O port dimensions array address\n */\nEXTERN_C LIBCGXERT_API int* cgxertGetCurrentInputPortDimensions(CgxertCTX ctx, int32_T portNumber);\nEXTERN_C LIBCGXERT_API int* cgxertGetCurrentOutputPortDimensions(CgxertCTX ctx, int32_T portNumber);\nEXTERN_C LIBCGXERT_API void cgxertSetCurrentOutputPortDimensions(CgxertCTX ctx, int32_T pIdx, int32_T dIdx, int32_T val);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Sim through codegen subsystem utilities\n */\nEXTERN_C LIBCGXERT_API void    cgxertCheckCurrentInputPortDimensions(CgxertCTX ctx, const char* sysObjName, const char* methodName);\nEXTERN_C LIBCGXERT_API void    cgxertCallAccelRunBlock(CgxertCTX ctx, int32_T sysIdx, int32_T blkIdx, int32_T method);\nEXTERN_C LIBCGXERT_API int32_T cgxertGetSubsysIdx(CgxertCTX ctx);\nEXTERN_C LIBCGXERT_API void*   cgxertPrepareEmlrtTLS(CgxertCTX ctx, void *aEmlrtCtx, int32_T sysIdx, int32_T blkIdx);\n\nEXTERN_C LIBCGXERT_API void    SimulinkFunctionInvokeAPI(CgxertCTX ctx, const char* scopedFcnName, int_T numArgs, void* execArgs[]);\n\nEXTERN_C LIBCGXERT_API void    slmsgReceiveData(CgxertCTX ctx, int portIdx, void* received_data, int32_T* status);\nEXTERN_C LIBCGXERT_API void    slmsgSendData(CgxertCTX ctx, int portIdx, const void* data_to_send, int32_T* status);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Runtime info access utilities\n */\nEXTERN_C LIBCGXERT_API void*          cgxertGetRuntimeInstance(CgxertCTX ctx);\nEXTERN_C LIBCGXERT_API void           cgxertSetRuntimeInstance(CgxertCTX ctx, void* instance);\nEXTERN_C LIBCGXERT_API void*          cgxertGetEMLRTCtx(CgxertCTX ctx);\nEXTERN_C LIBCGXERT_API SimStruct*     cgxertGetSimStruct(CgxertCTX ctx);\nEXTERN_C LIBCGXERT_API covrtInstance* cgxertGetCovrtInstance(CgxertCTX ctx, int key);\nEXTERN_C LIBCGXERT_API uint32_T       cgxertGetCovId(CgxertCTX ctx, int key);\nEXTERN_C LIBCGXERT_API void           cgxertSetNumTicksToNextHitForControllableRate(CgxertCTX ctx, double numTicksToNextHit);\nEXTERN_C LIBCGXERT_API bool           cgxertGetErrorStatus(CgxertCTX ctx);\n\n/*\n * MATLAB INTERNAL USE ONLY :: macro wrappers for Data Store Memory functions\n */\nEXTERN_C LIBCGXERT_API void ReadFromDataStoreElement_wrapper(CgxertCTX ctx, int dsmIndex, char* dsmName, int elementIndex);\nEXTERN_C LIBCGXERT_API void WriteToDataStoreElement_wrapper(CgxertCTX ctx, int dsmIndex, char* dsmName, int elementIndex);\nEXTERN_C LIBCGXERT_API void ReadFromDataStore_wrapper(CgxertCTX ctx, int dsmIndex, char* dsmName);\nEXTERN_C LIBCGXERT_API void WriteToDataStore_wrapper(CgxertCTX ctx, int dsmIndex, char* dsmName);\n\nEXTERN_C LIBCGXERT_API void UpdateDataStoreLog_wrapper(CgxertCTX ctx, void* dsmId);\nEXTERN_C LIBCGXERT_API bool cgxertGetDSMBlockDiagnosticsEnabled_wrapper(CgxertCTX ctx, int dsmIdx, const char* dsmName);\nEXTERN_C LIBCGXERT_API void GetDataStoreNameAddrIdx_wrapper(CgxertCTX ctx, const char *name, void **dsmAddress);\nEXTERN_C LIBCGXERT_API void MemRegionCreateDescriptor_wrapper(CgxertCTX ctx, int numSubMemRegions, SFcnMemRegionInfo** memRegionDescriptor);\nEXTERN_C LIBCGXERT_API void MemRegionSetFlatSubElement_wrapper(CgxertCTX ctx, SFcnMemRegionInfo* memRegionDescriptor, int subRegionIdx, int busElementIdx, int numFlatIdx, int *flatIdxs);\nEXTERN_C LIBCGXERT_API void AccessDataStoreRegion_wrapper(CgxertCTX ctx, int dsmIdx, void *dataAddr,  SFcnMemRegionInfo* dsmRegionDescriptor, bool isReadOnly);\nEXTERN_C LIBCGXERT_API void MemRegionDestroyDescriptor_wrapper(CgxertCTX ctx, SFcnMemRegionInfo** memRegionDescriptor);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check for Ctrl+C interrupt from the command prompt\n */\nEXTERN_C LIBCGXERT_API unsigned int cgxertListenForCtrlC(CgxertCTX ctx);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Call Simulink Function server\n */\nEXTERN_C LIBCGXERT_API void cgxertCallSLFcn(SimStruct *S,\n                                            const char* fcnName,\n                                            const char* fullPath,\n                                            int blkId,\n                                            int numInputs,\n                                            void* inArgs,\n                                            void* inSizes,\n                                            int numOutputs,\n                                            void* outArgs,\n                                            int* outSizes);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Report Out-Of-Process Runtime Error\n */\nEXTERN_C LIBCGXERT_API void cgxertReportOOPRuntimeError(SimStruct* S,\n                                                        int sysIdx,\n                                                        int blkIdx,\n                                                        void* errMsg,\n                                                        bool isAllowDebug);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Handle runtime diagnostic report request\n */\nEXTERN_C LIBCGXERT_API void cgxertReportError(CgxertCTX ctx, int sysIdx, int blkIdx,\n                                              const char* const aMsgID,\n                                              const int aArgCount, ...);\n\nEXTERN_C LIBCGXERT_API void cgxertReportWarning(CgxertCTX ctx, int sysIdx, int blkIdx,\n                                                const char* const aMsgID,\n                                                const int aArgCount, ...);\n\nEXTERN_C LIBCGXERT_API void cgxertCheckNullptr(CgxertCTX ctx, int sysIdx, int blkIdx,void * aInfoVoid, void* aPtr);\t\t\t\t\t\t\t\t\t\n\nEXTERN_C LIBCGXERT_API int32_T cgxertBoundsCheck(CgxertCTX ctx,\n    int sysIdx,\n    int blkIdx,\n    void* aInfoVoid,\n    int32_T aIndexValue,\n    int32_T aLoBound,\n    int32_T aHiBound);\n\n    /*\n * MATLAB INTERNAL USE ONLY :: gcb utilities\n */\nEXTERN_C LIBCGXERT_API void cgxertSetGcb(CgxertCTX ctx, int sysIdx, int blkIdx);\nEXTERN_C LIBCGXERT_API void cgxertRestoreGcb(CgxertCTX ctx, int sysIdx, int blkIdx);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Multi-threading helpers\n */\nEXTERN_C LIBCGXERT_API void  cgxertSemCreate(CgxertCTX ctx, void **semPtr);\nEXTERN_C LIBCGXERT_API void  cgxertSemPost(CgxertCTX ctx, void *semPtr);\nEXTERN_C LIBCGXERT_API void  cgxertSemWait(CgxertCTX ctx, void *semPtr);\nEXTERN_C LIBCGXERT_API void  cgxertSemDestroy(CgxertCTX ctx, void *semPtr);\n\nEXTERN_C LIBCGXERT_API void  cgxertEnterParallelRegion(CgxertCTX ctx);\nEXTERN_C LIBCGXERT_API void  cgxertExitParallelRegion(CgxertCTX ctx);\nEXTERN_C LIBCGXERT_API void* cgxertAllocTLS(SimStruct *S, int32_T threadId);\nEXTERN_C LIBCGXERT_API void  cgxertSetTLSJmpBufEnv(CgxertCTX ctx, jmp_buf *aJBEnv);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Profiling instrumentation functions.\n */\nEXTERN_C LIBCGXERT_API void* cgxertCreateSectionProfiles(size_t sectionCount);\nEXTERN_C LIBCGXERT_API void  cgxertStartProfiling(void* opaqueSectionProfiles, size_t sectionNumber);\nEXTERN_C LIBCGXERT_API void  cgxertStopProfiling(void* opaqueSectionProfiles, size_t sectionNumber);\nEXTERN_C LIBCGXERT_API void  cgxertExportSectionProfiles(void* opaqueSectionProfiles, CgxertCTX ctx);\nEXTERN_C LIBCGXERT_API void  cgxertExportToEngineSectionProfiles(void* opaqueSectionProfiles, uint32_T *sectionBlkIds, CgxertCTX ctx);\nEXTERN_C LIBCGXERT_API void  cgxertDestroySectionProfiles(void* opaqueSectionProfiles);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Multithread with TBB wrappers\n */\n\nEXTERN_C LIBCGXERT_API void cgxertCreateTaskGroup(void **group, int nThreadFcns);\nEXTERN_C LIBCGXERT_API void cgxertInsertTask(void * group, tbb_task_func f, void* param);\nEXTERN_C LIBCGXERT_API void cgxertWaitTaskGroup(void * group);\nEXTERN_C LIBCGXERT_API void cgxertDestroyTaskGroup(void ** group);\n\n// Debugger\nEXTERN_C LIBCGXERT_API void* cgxertListenerInitializeUsingSimStruct(SimStruct* S);\nEXTERN_C LIBCGXERT_API void* cgxertListenerInitializeUsingBlockPath(char* blkPath);\n\nEXTERN_C LIBCGXERT_API void cgxertListenerInitializeRuntimeVars(void* rt,\n    int* aIsDebuggerActivePtr,\n    bool isJitCompliantDebuggerOn,\n    uint32_T* lineNumberPtr);\nEXTERN_C LIBCGXERT_API void cgxertListenerInitializeRuntimeFcnVarsUniversal(void* rt,\n    unsigned int* numFcnVars,\n    char* dataNames[],\n    void* dataPtrs[],\n    char* marshallingOutFcnNames[],\n    char* marshallingInFcnNames[],\n    void* marshallingOutFcns[],\n    void* marshallingInFcns[],\n    unsigned int statuses[]);\n\nEXTERN_C LIBCGXERT_API void cgxertListenerReportStartingSection(void* rt,\n    char* aScriptName,\n    char* className,\n    char* methodName);\n\n\nEXTERN_C LIBCGXERT_API void cgxertListenerReportEndingSection(void* rt,\n    char* aScriptName,\n    char* className,\n    char* methodName);\n\nEXTERN_C LIBCGXERT_API void cgxertListenerPushScopeForSingleVarUniversal(void* rt,\n    char* aVarName,\n    void* aDataPtr,\n    char* aMarshallingOutFunctionName,\n    char* aMarshallingInFunctionName,\n    void* aMarshallingOutFunction,\n    void* aMarshallingInFunction, \n    unsigned int aStatus);\n\nEXTERN_C LIBCGXERT_API void cgxertListenerReportLineNumber(void* rt,\n    int aLineNumber);\n\n\nEXTERN_C LIBCGXERT_API bool cgxertDebugCheckFixedPointLicense(void);\n#endif /* cgxert_h */\n"},{"name":"covrt.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * PUBLISHED header for covrt, the runtime library for Code Coverage\n *\n * Copyright 1984-2021 The MathWorks, Inc.\n *\n */\n\n#ifndef covrt_h\n#define covrt_h\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n/*\n * Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n\n#endif\n\n#ifndef LIBCOVRT_API\n#define LIBCOVRT_API\n#endif\n\n#include <setjmp.h>\n#include <stdio.h>\n#include \"matrix.h\"\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Instance specific runtime data.\n */\ntypedef struct covrtInstanceData covrtInstanceData;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Instance type\n */\ntypedef struct covrtInstance\n{\n    covrtInstanceData* data;\n} covrtInstance;\n\n\n/* one instance per mex */\nextern covrtInstance gCoverageLoggingInstance;\n\n\ntypedef struct CovrtStateflowData CovrtStateflowData;\n\ntypedef struct CovrtStateflowInstance\n{\n    CovrtStateflowData*  data;\n    double instanceHandle;\n    bool isCoverageOn;\n    bool isAccelCreated;\n} CovrtStateflowInstance;\n\n\ntypedef int CovrtBlockId;\n#define COVRT_INVALID_BLOCK_ID -1\n\n/*\n * MATLAB INTERNAL USE ONLY :: Enable/Disable Coverage Logging during mex execution\n */\nEXTERN_C LIBCOVRT_API void covrtEnableCoverageLogging(bool enable);\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Enabled/Disable use of cv.mex\n */\nEXTERN_C LIBCOVRT_API void covrtUseCV(bool useCV);\n\n/*\n * MATLAB INTERNAL USE ONLY :: reset flag\n */\nEXTERN_C LIBCOVRT_API void covrtResetUpdateFlag();\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Allocate instance data\n */\nEXTERN_C LIBCOVRT_API void covrtAllocateInstanceData(covrtInstance* instance);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Free instance data\n */\nEXTERN_C LIBCOVRT_API void covrtFreeInstanceData(covrtInstance* instance);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Free instance data\n */\nEXTERN_C LIBCOVRT_API mxArray* covrtSerializeInstanceData(covrtInstance* instance);\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Coverage engine script initalization callback\n */\nEXTERN_C LIBCOVRT_API void covrtScriptStart(covrtInstance* instance,\n                                            unsigned int cvId);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize Script\n */\nEXTERN_C LIBCOVRT_API void covrtScriptInit(covrtInstance* instance,\n                                           const char* path,\n                                           unsigned int cvId,\n                                           unsigned int fcnCnt,\n                                           unsigned int basicBlockCnt,\n                                           unsigned int ifCnt,\n                                           unsigned int testobjectiveCnt,\n                                           unsigned int saturationCnt,\n                                           unsigned int switchCnt,\n                                           unsigned int forCnt,\n                                           unsigned int whileCnt,\n                                           unsigned int condCnt,\n                                           unsigned int mcdcCnt);\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize Function\n */\nEXTERN_C LIBCOVRT_API void covrtFcnInit(covrtInstance* instance,\n                                        unsigned int cvId,\n                                        unsigned int fcnIdx,\n                                        const char *name,\n                                        int charStart,\n                                        int charExprEnd,\n                                        int charEnd);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize Basic Block\n */\nEXTERN_C LIBCOVRT_API void covrtBasicBlockInit(covrtInstance* instance,\n                                               unsigned int cvId,\n                                               unsigned int fcnIdx,\n                                               int charStart,\n                                               int charExprEnd,\n                                               int charEnd);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize If\n */\nEXTERN_C LIBCOVRT_API void covrtIfInit(covrtInstance* instance,\n                                       unsigned int cvId,\n                                       unsigned int ifIdx,\n                                       int charStart,\n                                       int charExprEnd,\n                                       int charElseStart,\n                                       int charEnd);\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize Mcdc\n */\nEXTERN_C LIBCOVRT_API void covrtMcdcInit(covrtInstance* instance,\n                                         unsigned int cvId,\n                                         unsigned int mcdcIdx,\n                                         int charStart,\n                                         int charEnd,\n                                         int condCnt,\n                                         int firstCondIdx,\n                                         const int* condStart,\n                                         const int* condEnd,\n                                         int postFixLength,\n                                         const int* postFixExprs);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize Switch\n */\nEXTERN_C LIBCOVRT_API void covrtSwitchInit(covrtInstance* instance,\n                                           unsigned int cvId,\n                                           unsigned int switchIdx,\n                                           int charStart,\n                                           int charExprEnd,\n                                           int charEnd,\n                                           unsigned int caseCnt,\n                                           const int *caseStart,\n                                           const int *caseExprEnd);\n\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize For\n */\nEXTERN_C LIBCOVRT_API void covrtForInit(covrtInstance* instance,\n                                        unsigned int cvId,\n                                        unsigned int forIdx,\n                                        int charStart,\n                                        int charExprEnd,\n                                        int charEnd);\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize While\n */\nEXTERN_C LIBCOVRT_API void covrtWhileInit(covrtInstance* instance,\n                                          unsigned int cvId,\n                                          unsigned int whileIdx,\n                                          int charStart,\n                                          int charExprEnd,\n                                          int charEnd);\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize MCDC\n */\nEXTERN_C LIBCOVRT_API void covrtMCDCInit(covrtInstance* instance,\n                                         unsigned int cvId,\n                                         unsigned int mcdcIdx,\n                                         int charStart,\n                                         int charEnd,\n                                         unsigned int condCnt,\n                                         unsigned int firstCondIdx,\n                                         const int *condStart,\n                                         const int *condEnd,\n                                         unsigned int pfxLength,\n                                         const int *pfixExpr);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Log Function\n */\nEXTERN_C LIBCOVRT_API void covrtLogFcn(covrtInstance* instance,\n                                       uint32_T covId,\n                                       uint32_T fcnId);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Log Basic Block\n */\nEXTERN_C LIBCOVRT_API void covrtLogBasicBlock(covrtInstance* instance,\n                                              uint32_T covId,\n                                              uint32_T basicBlockId);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Log If\n */\nEXTERN_C LIBCOVRT_API int32_T covrtLogIf(covrtInstance* instance,\n                                         uint32_T covId,\n                                         uint32_T fcnId,\n                                         int32_T ifId,\n                                         int32_T condition);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Log Cond\n */\nEXTERN_C LIBCOVRT_API int32_T covrtLogCond(covrtInstance* instance,\n                                           uint32_T covId,\n                                           uint32_T fcnId,\n                                           int32_T condId,\n                                           int32_T condition);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Log If\n */\nEXTERN_C LIBCOVRT_API void covrtLogFor(covrtInstance* instance,\n                                       uint32_T covId,\n                                       uint32_T fcnId,\n                                       int32_T forId,\n                                       int32_T entryOrExit);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Log While\n */\nEXTERN_C LIBCOVRT_API int32_T covrtLogWhile(covrtInstance* instance,\n                                            uint32_T covId,\n                                            uint32_T fcnId,\n                                            int32_T whileId,\n                                            int32_T condition);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Log Switch\n */\nEXTERN_C LIBCOVRT_API void covrtLogSwitch(covrtInstance* instance,\n                                          uint32_T covId,\n                                          uint32_T fcnId,\n                                          int32_T switchId,\n                                          int32_T caseId);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Log If\n */\nEXTERN_C LIBCOVRT_API int32_T covrtLogMcdc(covrtInstance* instance,\n                                           uint32_T covId,\n                                           uint32_T fcnId,\n                                           int32_T mcdcId,\n                                           int32_T condition);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Log decision in block\n */\nEXTERN_C LIBCOVRT_API int32_T covrtLogBlockDec(covrtInstance* instance,\n                                               uint32_T covId,\n                                               int32_T decId,\n                                               int32_T eleIdx,\n                                               int32_T decVal);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Simulink block coverage\n */\n\nEXTERN_C LIBCOVRT_API void covrtSimulinkSessionInit(void* sessionInterface);\nEXTERN_C LIBCOVRT_API void covrtSimulinkSessionCleanup();\nEXTERN_C LIBCOVRT_API void covrtSimulinkSetTopModelInterface(void* cvTopModelInterface);\nEXTERN_C LIBCOVRT_API void covrtSimulinkRegisterBlock(double blockHandle);\nEXTERN_C LIBCOVRT_API bool covrtIsBlockRegistered(double blockHandle);\n\nEXTERN_C LIBCOVRT_API void covrtMarkSkipInitCovRecording(const char* model);\nEXTERN_C LIBCOVRT_API void covrtMarkModelInitialized(const char* model);\nEXTERN_C LIBCOVRT_API bool covrtIsModelInitialized(const char* model);\nEXTERN_C LIBCOVRT_API void covrtMarkModelStarted(const char* model);\nEXTERN_C LIBCOVRT_API bool covrtIsModelStarted(const char* model);\nEXTERN_C LIBCOVRT_API void covrtMarkModelTerminated(const char* model);\nEXTERN_C LIBCOVRT_API bool covrtIsModelTerminated(const char* model);\n\nEXTERN_C LIBCOVRT_API void covrtSimulinkBlockCovInit(const char* model, int blockSysIdx, int blockIdx, const char* blockSID, bool updateAtStart);\nEXTERN_C LIBCOVRT_API void covrtSimulinkBlockCovRecord(const char* model, int blockSysIdx, int blockIdx);\n\nEXTERN_C LIBCOVRT_API void covrtModelInit(const char* modelName);\nEXTERN_C LIBCOVRT_API void covrtModelStart(const char* modelName);\nEXTERN_C LIBCOVRT_API void covrtModelFastRestart(const char* modelName);\nEXTERN_C LIBCOVRT_API void covrtModelTerm(const char* modelName);\nEXTERN_C LIBCOVRT_API void covrtModelTermAll();\n\n/*\n * MATLAB INTERNAL USE ONLY :: Stateflow coverage instance\n */\n\nEXTERN_C LIBCOVRT_API\nCovrtStateflowInstance* covrtAllocateStateflowInstance(\n    CovrtStateflowInstance* instance,\n    const char* chartPath);\n\nEXTERN_C LIBCOVRT_API \nCovrtStateflowInstance* covrtDeleteStateflowInstance(CovrtStateflowInstance* instance);\n\nEXTERN_C LIBCOVRT_API\nvoid covrtCreateStateflowInstanceData(CovrtStateflowInstance* instance,\n                                      unsigned int stateCount,\n                                      unsigned int eventCount,\n                                      unsigned int transCount,\n                                      unsigned int dataCount);\n\nEXTERN_C LIBCOVRT_API\nvoid covrtSetInstanceCvIds(\n    double instanceHandle,\n    unsigned int cvChartId,\n    double* cvStateIds,\n    size_t stateCnt,\n    double* cvTransIds,\n    size_t transCnt);\n\nEXTERN_C LIBCOVRT_API void covrtSetEmlScriptCvIds(double instanceHandle,\n                                                  double* numToCvIdMap,\n                                                  size_t size);\n\nEXTERN_C LIBCOVRT_API\nvoid covrtDeleteStateflowInstanceData(CovrtStateflowInstance* instance);\n\n\nEXTERN_C LIBCOVRT_API void covrtRelationalopInitFcn(\n    CovrtStateflowInstance* instance,\n    unsigned int transitionNumber,\n    unsigned int relopCnt,\n    const int* txtStartIdx,\n    const int* txtEndIdx,\n    const int* relationalEps,\n    const int* relationalOp);\n\nEXTERN_C LIBCOVRT_API void covrtSaturationInitFcn(\n    CovrtStateflowInstance* instance,\n    unsigned int objectType,\n    unsigned int transitionNumber,\n    unsigned int satCnt,\n    const unsigned int* txtStartIdx,\n    const unsigned int* txtEndIdx);\n\nEXTERN_C LIBCOVRT_API void covrtTestobjectiveInitFcn(CovrtStateflowInstance* instance,\n                                                     unsigned int objectType,\n                                                     unsigned int objectNumber,\n                                                     unsigned int testobjectiveCnt,\n                                                     const unsigned int* txtStartIdx,\n                                                     const unsigned int* txtEndIdx);\n\n\nEXTERN_C LIBCOVRT_API void covrtTransInitFcn(CovrtStateflowInstance* instance,\n                                             unsigned int transitionNumber,\n                                             int predicateCnt,\n                                             const unsigned int* txtStartIdx,\n                                             const unsigned int* txtEndIdx,\n                                             unsigned int postFixPredicateTreeCount,\n                                             const int* postFixPredicateTree);\n\nEXTERN_C LIBCOVRT_API void covrtStateInitFcn(CovrtStateflowInstance* instance,\n                                             unsigned int stateNumber,\n                                             unsigned int numChild,\n                                             bool hasDuringSwitch,\n                                             bool hasExitSwitch,\n                                             bool hasHistSwitch,\n                                             unsigned int onDecCnt,\n                                             const unsigned int* decStartInd,\n                                             const unsigned int* decEndInd);\n\nEXTERN_C LIBCOVRT_API void covrtChartInitFcn(CovrtStateflowInstance* instance,\n                                             unsigned int numChild,\n                                             bool hasDuringSwitch,\n                                             bool hasExitSwitch,\n                                             bool hasHistSwitch);\n\nEXTERN_C LIBCOVRT_API void covrtAssignmentInitFcn(CovrtStateflowInstance* instance,\n                                                  unsigned int objectType,\n                                                  unsigned int objectNumber,\n                                                  unsigned int numAssignments,\n                                                  const int* assignmentKeys,\n                                                  const unsigned int* assignTxtStartIdx,\n                                                  const unsigned int* assignTxtEndIdx,\n                                                  unsigned int numTotalConditions,\n                                                  const int* conditionKeys,\n                                                  const unsigned int* condTxtStartIdx,\n                                                  const unsigned int* condTxtEndIdx,\n                                                  unsigned int postFixPredicateTreeConcatCount,\n                                                  const int* postFixPredicateTreeConcat,\n                                                  const unsigned int* condTextIdxOffsets,\n                                                  const unsigned int* pptIdxOffsets);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtTestobjectiveUpdateFcn(CovrtStateflowInstance* instance,\n                                                               unsigned int objectType,\n                                                               unsigned int objectNumber,\n                                                               unsigned int objectIndex,\n                                                               int retValue);\n\nEXTERN_C LIBCOVRT_API bool covrtAssignmentUpdateFcn(CovrtStateflowInstance* instance,\n                                                            unsigned int objectType,\n                                                            unsigned int objectNumber,\n                                                            unsigned int objectIndex,\n                                                            unsigned int retValue);\n\n\nEXTERN_C LIBCOVRT_API unsigned int covrtRelationalopUpdateFcn(CovrtStateflowInstance* instance,\n                                                              unsigned int objectType,\n                                                              unsigned int objectNumber,\n                                                              unsigned int objectIndex,\n                                                              double lhsVal,\n                                                              double rhsVal,\n                                                              int relationalopEps,\n                                                              unsigned int op,\n                                                              int retValue);\n\nEXTERN_C LIBCOVRT_API bool covrtSaturationUpdateFcn(CovrtStateflowInstance* instance,\n                                                            unsigned int objectType,\n                                                            unsigned int objectNumber,\n                                                            unsigned int satIdx,\n                                                            unsigned int isNeg,\n                                                            int val);\n\nEXTERN_C LIBCOVRT_API void covrtSaturationUpdateAccumFcn(CovrtStateflowInstance* instance,\n                                                         unsigned int objectType,\n                                                         unsigned int objectNumber,\n                                                         unsigned int satIdx,\n                                                         unsigned int accumMode);\n\nEXTERN_C LIBCOVRT_API bool covrtDecUpdateFcn(CovrtStateflowInstance* instance,\n                                                     unsigned int objectType,\n                                                     unsigned int objectNumber,\n                                                     unsigned int objectIndex,\n                                                     unsigned int retValue);\n\nEXTERN_C LIBCOVRT_API bool covrtTransitionDecUpdateFcn(CovrtStateflowInstance* instance,\n                                                            unsigned int objectType,\n                                                            unsigned int objectNumber,\n                                                            unsigned int objectIndex,\n                                                            bool retValue);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtBasicBlockUpdateFcn(CovrtStateflowInstance* instance,\n                                                            unsigned int objectType,\n                                                            unsigned int objectNumber,\n                                                            unsigned int objectIndex);\n\nEXTERN_C LIBCOVRT_API bool covrtCondUpdateFcn(CovrtStateflowInstance* instance,\n                                                      unsigned int objectType,\n                                                      unsigned int objectNumber,\n                                                      unsigned int objectIndex,\n                                                      bool retValue);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtSigUpdateFcn(CovrtStateflowInstance* instance,\n                                                     unsigned int dataNumber,\n                                                     double equivValue);\n/*\n * MATLAB INTERNAL USE ONLY :: EML coverage instance\n */\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlInitFcn(CovrtStateflowInstance* instance,\n                                                   const char* path,\n                                                   unsigned int objectType,\n                                                   unsigned int objectNumber,\n                                                   unsigned int fcnCnt,\n                                                   unsigned int basicBlockCnt,\n                                                   unsigned int ifCnt,\n                                                   unsigned int testobjectiveCnt,\n                                                   unsigned int saturationCnt,\n                                                   unsigned int switchCnt,\n                                                   unsigned int forCnt,\n                                                   unsigned int whileCnt,\n                                                   unsigned int condCnt,\n                                                   unsigned int mcdcCnt);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlFcnInitFcn(CovrtStateflowInstance* instance,\n                                                      unsigned int objectType,\n                                                      unsigned int objectNumber,\n                                                      unsigned int fcnIdx,\n                                                      const char *name,\n                                                      int charStart,\n                                                      int charExprEnd,\n                                                      int charEnd);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlTestobjectiveInitFcn(CovrtStateflowInstance* instance,\n                                                                unsigned int objectType,\n                                                                unsigned int objectNumber,\n                                                                unsigned int objIdx,\n                                                                const char *name,\n                                                                int charStart,\n                                                                int charExprEnd,\n                                                                int charEnd);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlSaturationInitFcn(CovrtStateflowInstance* instance,\n                                                             unsigned int objectType,\n                                                             unsigned int objectNumber,\n                                                             unsigned int objIdx,\n                                                             int charStart,\n                                                             int charExprEnd,\n                                                             int charEnd);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlIfInitFcn(CovrtStateflowInstance* instance,\n                                                     unsigned int objectType,\n                                                     unsigned int objectNumber,\n                                                     unsigned int ifIdx,\n                                                     int charStart,\n                                                     int charExprEnd,\n                                                     int charElseStart,\n                                                     int charEnd,\n                                                     bool isPositiveOnly);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlSwitchInitFcn(CovrtStateflowInstance* instance,\n                                                         unsigned int objectType,\n                                                         unsigned int objectNumber,\n                                                         unsigned int switchIdx,\n                                                         int charStart,\n                                                         int charExprEnd,\n                                                         int charEnd,\n                                                         unsigned int caseCnt,\n                                                         const int *caseStart,\n                                                         const int *caseExprEnd);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlForInitFcn(CovrtStateflowInstance* instance,\n                                                      unsigned int objectType,\n                                                      unsigned int objectNumber,\n                                                      unsigned int forIdx,\n                                                      int charStart,\n                                                      int charExprEnd,\n                                                      int charEnd);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlWhileInitFcn(CovrtStateflowInstance* instance,\n                                                        unsigned int objectType,\n                                                        unsigned int objectNumber,\n                                                        unsigned int whileIdx,\n                                                        int charStart,\n                                                        int charExprEnd,\n                                                        int charEnd);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlMCDCInitFcn(CovrtStateflowInstance* instance,\n                                                       unsigned int objectType,\n                                                       unsigned int objectNumber,\n                                                       unsigned int mcdcIdx,\n                                                       int charStart,\n                                                       int charEnd,\n                                                       unsigned int condCnt,\n                                                       unsigned int firstCondIdx,\n                                                       const int *condStart,\n                                                       const int *condEnd,\n                                                       unsigned int pfxLength,\n                                                       const int *pfixExpr,\n                                                       bool isPositiveOnly);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlRelationalInitFcn(CovrtStateflowInstance* instance,\n                                                             unsigned int objectType,\n                                                             unsigned int objectNumber,\n                                                             unsigned int objIdx,\n                                                             int charStart,\n                                                             int charEnd,\n                                                             int relationalEps,\n                                                             unsigned int relationalOp);\n/*\n * MATLAB INTERNAL USE ONLY :: EML coverage eval functions\n */\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlFcnEval(CovrtStateflowInstance* instance,\n                                                   unsigned int objectType,\n                                                   unsigned int objectNumber,\n                                                   unsigned int objectIndex);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlTestobjectiveEval(CovrtStateflowInstance* instance,\n                                                             unsigned int objectType,\n                                                             unsigned int objectNumber,\n                                                             unsigned int objectIndex,\n                                                             unsigned int retValue);\n\n\nEXTERN_C LIBCOVRT_API bool covrtEmlIfEval(CovrtStateflowInstance* instance,\n                                                  unsigned int objectType,\n                                                  unsigned int objectNumber,\n                                                  unsigned int objectIndex,\n                                                  unsigned int retValue);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlForEval(CovrtStateflowInstance* instance,\n                                                   unsigned int objectType,\n                                                   unsigned int objectNumber,\n                                                   unsigned int objectIndex,\n                                                   unsigned int retValue);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlWhileEval(CovrtStateflowInstance* instance,\n                                                     unsigned int objectType,\n                                                     unsigned int objectNumber,\n                                                     unsigned int objectIndex,\n                                                     unsigned int retValue);\n\nEXTERN_C LIBCOVRT_API unsigned int covrtEmlSwitchEval(CovrtStateflowInstance* instance,\n                                                      unsigned int objectType,\n                                                      unsigned int objectNumber,\n                                                      unsigned int objectIndex,\n                                                      unsigned int retValue);\n\nEXTERN_C LIBCOVRT_API bool covrtEmlCondEval(CovrtStateflowInstance* instance,\n                                                    unsigned int objectType,\n                                                    unsigned int objectNumber,\n                                                    unsigned int objectIndex,\n                                                    unsigned int retValue);\n\nEXTERN_C LIBCOVRT_API bool covrtEmlMcdcEval(CovrtStateflowInstance* instance,\n                                                    unsigned int objectType,\n                                                    unsigned int objectNumber,\n                                                    unsigned int objectIndex,\n                                                    unsigned int retValue);\n\n\n#endif /* covrt_h */\n"},{"name":"cvstCG_ComputeMetric.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012 The MathWorks, Inc. */\n\n#ifndef _COMPUTEMETRIC_\n#define _COMPUTEMETRIC_\n\n#ifndef LIBMWCOMPUTEMETRIC_API\n#    define LIBMWCOMPUTEMETRIC_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* SSD */\nEXTERN_C LIBMWCOMPUTEMETRIC_API void ComputeMetric_ssd_double(real_T *f1, real_T *f2, real_T * scores,\n\t\t\t    uint32_T numFeatures1, uint32_T numFeatures2, uint32_T featureLength);\nEXTERN_C LIBMWCOMPUTEMETRIC_API void ComputeMetric_ssd_single(real32_T *f1, real32_T *f2, real32_T * scores,\n\t\t\t    uint32_T numFeatures1, uint32_T numFeatures2, uint32_T featureLength);\n/* SAD */\nEXTERN_C LIBMWCOMPUTEMETRIC_API void ComputeMetric_sad_double(real_T *f1, real_T *f2, real_T * scores,\n\t\t\t    uint32_T numFeatures1, uint32_T numFeatures2, uint32_T featureLength);\nEXTERN_C LIBMWCOMPUTEMETRIC_API void ComputeMetric_sad_single(real32_T *f1, real32_T *f2, real32_T * scores,\n\t\t\t    uint32_T numFeatures1, uint32_T numFeatures2, uint32_T featureLength);\n/* HAMMING */\nEXTERN_C LIBMWCOMPUTEMETRIC_API void ComputeMetric_hamming_single(uint8_T *f1, uint8_T *f2, real32_T * scores,\n\t\t\t    uint32_T numFeatures1, uint32_T numFeatures2, uint32_T featureLength);\n\n#endif\n"},{"name":"cvstCG_acfObjectDetector.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*******************************************************************************\n * Piotr's Computer Vision Matlab Toolbox      Version 3.24\n * Copyright 2014 Piotr Dollar & Ron Appel.  [pdollar-at-gmail.com]\n * Licensed under the Simplified BSD License [see external/bsd.txt]\n *******************************************************************************/\n\n#ifndef ACFOBJECTDETECTOR_\n#define ACFOBJECTDETECTOR_\n\n#ifndef LIBMWACFOBJECTDETECTOR_API\n#    define LIBMWACFOBJECTDETECTOR_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\" /* mwSize is defined here */\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid rgb2luv(const float *rgb, float *luv, const float *yTable,\n\tconst size_t nPixelsPerChannel, const size_t nYTable);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid convTri(float *I, float *O, int h, int w, int d, int r, int s, float*T, int h0, int h1);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid convTri1(float *I, float *O, int h, int w, int d, float p, int s, float *T);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid gradient(const float *I, float *gMag, float *gDir, size_t h, size_t w, size_t d, float *M, float *Gx, float *Gy);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid gradientSSE(const float *I, float *gMag, float *gDir, size_t h, size_t w, size_t d, size_t hsse, float *M,\n\tfloat *Gx, float *Gy);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid noInterpolation(float *gradHist, float *gMag, float *gDir, int cellSize,\n\tint h, int w, int numberOfRowCells, int numberOfColumnCells,\n\tint numberOfCellsPerBin, int numBins, int useSignedOrientation, int *iO, float *iM);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid orientationInterpolation(float *gradHist, float *gMag, float *gDir, int cellSize,\n\tint h, int w, int numberOfRowCells, int numberOfColumnCells, int numberOfCellsPerBin,\n\tint numBins, int useSignedOrientation, int *iO, float *iM, int *iO2, float *iM2);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid spatialInterpolation(float *gradHist, float *gMag, float *gDir, int cellSize,\n\tint h, int w, int numberOfRowCells, int numberOfColumnCells, int numberOfCellsPerBin,\n\tint numBins, int useSignedOrientation, int *iO, float *iM);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid spatialOrientationInterpolation(float *gradHist, float *gMag, float *gDir, int cellSize,\n\tint h, int w, int numberOfRowCells, int numberOfColumnCells, int numberOfCellsPerBin,\n\tint numBins, int useSignedOrientation, int *iO, float *iM, int* iO2, float *iM2);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nint32_T  getNumberOfBoundingBoxes(float *chns, float *thrs, float *hs, uint32_T *fids, uint32_T *child,\n\tconst int shrink, const int modelHt, const int modelWd, const int stride, const float cascThr,\n\tconst int height, const int width, const int nChns, const int nTreeNodes, const int nTrees,\n\tconst int height1, const int width1, const int treeDepth, void** rs_w, void** cs_w, void** hs1_w, unsigned char* flag);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid copyBoundingBox(void* rs_w, void* cs_w, void* hs1_w, double* bbs, const int stride, const int modelHt,\n\tconst int modelWd, int m);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid resample_float(float *A, float *B, int ha, int hb, int wa, int wb, int d, float r);\n\nEXTERN_C LIBMWACFOBJECTDETECTOR_API\nvoid resample_double(double *A, double *B, int ha, int hb, int wa, int wb, int d, float r);\n\n\n#endif\n"},{"name":"cvstCG_disparitySGM.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* This file defines the codegen input parameter structure and entry point\n * function. */\n/* Copyright 2018-2019 The MathWorks, Inc. */\n\n#ifndef _DISPARITYSGM_C_API_\n#define _DISPARITYSGM_C_API_\n\n#ifndef LIBMWDISPARITYSGM_API\n#    define LIBMWDISPARITYSGM_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\" /* mwSize is defined here */\n#else\n#include \"rtwtypes.h\"\n#endif\n\n#ifndef typedef_cvstDisparitySGMStruct_T\n#define typedef_cvstDisparitySGMStruct_T\n\ntypedef struct {\n    int MinDisparity;\n    int NumberOfDisparities;\n    int UniquenessThreshold;\n    int Directions;\n    int Penalty1;\n    int Penalty2;\n} cvstDisparitySGMStruct_T;\n\n\n#endif /*typedef_cvstDisparitySGMStruct_T: used by matlab coder*/\n\nEXTERN_C LIBMWDISPARITYSGM_API void disparitySGMCompute(\n        uint8_T* inImg1, uint8_T* inImg2, uint32_T *left_CT,\n        uint32_T *right_CT, int16_T *MC_img, int16_T *minLr0Buf, int16_T *minLr1Buf, int16_T *Lr0Buf,\n        int16_T *Lr1Buf, int16_T *_Lr0Buf, int16_T *Lr4Buf, int16_T *dirCost_sum, int nRows, int nCols,\n        float* dis, cvstDisparitySGMStruct_T *params);\n\n#endif\n"},{"name":"cvstCG_foregroundDetector.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015 The MathWorks, Inc. */\n\n#ifndef _FOREGROUNDDETECTOR_\n#define _FOREGROUNDDETECTOR_\n\n#ifndef LIBMWFOREGROUNDDETECTOR_API\n#    define LIBMWFOREGROUNDDETECTOR_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n    #include \"tmwtypes.h\" /* mwSize is defined here */\n#else\n   #include \"rtwtypes.h\"\n#endif\n\n\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API \nvoid foregroundDetector_construct_double_double(void **ptr2ptrObj);\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API \nvoid foregroundDetector_construct_uint8_float(void **ptr2ptrObj);\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_construct_float_float(void **ptr2ptrObj);\n\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_step_double_double(void *ptrClass, \n                                           const double * inImage, \n                                           boolean_T *mask, \n                                           double learningRate);\n \nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_step_uint8_float(void *ptrClass, \n                                         const uint8_T * inImage, \n                                         boolean_T *mask, \n                                         float learningRate);\n \nEXTERN_C LIBMWFOREGROUNDDETECTOR_API \nvoid foregroundDetector_step_float_float(void *ptrClass, \n                                         const float * inImage, \n                                         boolean_T *mask, \n                                         float learningRate);\n\n\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_step_rowMaj_double_double(void *ptrClass, \n                                           const double * inImage, \n                                           boolean_T *mask, \n                                           double learningRate);\n \nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_step_rowMaj_uint8_float(void *ptrClass, \n                                         const uint8_T * inImage, \n                                         boolean_T *mask, \n                                         float learningRate);\n \nEXTERN_C LIBMWFOREGROUNDDETECTOR_API \nvoid foregroundDetector_step_rowMaj_float_float(void *ptrClass, \n                                         const float * inImage, \n                                         boolean_T *mask, \n                                         float learningRate);\n\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_initialize_double_double(\n    void *ptrClass,\n    int32_T nDims,\t\n    int32_T *dims,\n    int32_T numGaussians, \n    double initialVariance,\n    double initialWeight, \n    double varianceThreshold,\n    double minBGRatio);\n\t\t\t\t\t\t\t\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_initialize_uint8_float(\n    void *ptrClass,\n    int32_T numberOfDims,\t\n    int32_T *dims,\n    int32_T numGaussians, \n    float initialVariance,\n    float initialWeight, \n    float varianceThreshold,\n    float minBGRatio);\n\t\t\t\t\t\t\t\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_initialize_float_float(\n    void *ptrClass,\n    int32_T numberOfDims,\t\n    int32_T *dims,\n    int32_T numGaussians, \n    float initialVariance,\n    float initialWeight, \n    float varianceThreshold,\n    float minBGRatio);\t\t\t\t\t\t\t\n\n\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_reset_double_double(void *ptrClass);\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_reset_uint8_float(void *ptrClass);\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API \nvoid foregroundDetector_reset_float_float(void *ptrClass);\n\n\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API \nvoid foregroundDetector_release_double_double(void *ptrClass);\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API \nvoid foregroundDetector_release_uint8_float(void *ptrClass);\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_release_float_float(void *ptrClass);\n\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_deleteObj_float_float(void *ptrClass);\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API \nvoid foregroundDetector_deleteObj_uint8_float(void *ptrClass);\nEXTERN_C LIBMWFOREGROUNDDETECTOR_API\nvoid foregroundDetector_deleteObj_double_double(void *ptrClass);\n\n#endif\n\n\n"},{"name":"cvstCG_kdtree.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2019 The MathWorks, Inc. */\n#ifndef _KDTREE_\n#define _KDTREE_\n\n#ifndef LIBMWKDTREE_API\n#define LIBMWKDTREE_API\n#endif\n\n#ifndef EXTERN_C\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\" /* mwSize is defined here */\n#else\n#include \"rtwtypes.h\"\n#endif\n\n\nEXTERN_C LIBMWKDTREE_API void kdtreeConstruct_single(void** ptr2ptrObj);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeConstruct_double(void** ptr2ptrObj);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeConstructRM_single(void** ptr2ptrObj);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeConstructRM_double(void** ptr2ptrObj);\n\nEXTERN_C LIBMWKDTREE_API boolean_T kdtreeNeedsReindex_single(void* ptrObj, void* pData);\n\nEXTERN_C LIBMWKDTREE_API boolean_T kdtreeNeedsReindex_double(void* ptrObj, void* pData);\n\nEXTERN_C LIBMWKDTREE_API boolean_T kdtreeNeedsReindexRM_single(void* ptrObj, void* pData);\n\nEXTERN_C LIBMWKDTREE_API boolean_T kdtreeNeedsReindexRM_double(void* ptrObj, void* pData);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeIndex_single(void* ptrObj,\n                                                 void* pData,\n                                                 uint32_T dataSize,\n                                                 uint32_T dims,\n                                                 double numTrees,\n                                                 double bucketSize,\n                                                 double seed);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeIndex_double(void* ptrObj,\n                                                 void* pData,\n                                                 uint32_T dataSize,\n                                                 uint32_T dims,\n                                                 double numTrees,\n                                                 double bucketSize,\n                                                 double seed);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeIndexRM_single(void* ptrObj,\n                                                   void* pData,\n                                                   uint32_T dataSize,\n                                                   uint32_T dims,\n                                                   double numTrees,\n                                                   double bucketSize,\n                                                   double seed);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeIndexRM_double(void* ptrObj,\n                                                   void* pData,\n                                                   uint32_T dataSize,\n                                                   uint32_T dims,\n                                                   double numTrees,\n                                                   double bucketSize,\n                                                   double seed);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeBoxSearch_single(void* ptrObj,\n                                                        void* roi,\n                                                        void** resultIndices);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeBoxSearch_double(void* ptrObj,\n                                                        void* roi,\n                                                        void** resultIndices);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeBoxSearchRM_single(void* ptrObj,\n                                                          void* roi,\n                                                          void** resultIndices);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeBoxSearchRM_double(void* ptrObj,\n                                                          void* roi,\n                                                          void** resultIndices);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeBoxSearchSetOutputs(void* ptrIndices, uint32_T* location);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeKNNSearch_single(void* ptrObj,\n                                                        void* queryData,\n                                                        uint32_T numQueries,\n                                                        uint32_T numQueryDims,\n                                                        uint32_T knn,\n                                                        double paramChecks,\n                                                        float paramEps,\n                                                        void* indices,\n                                                        void* dists,\n                                                        void* valid,\n                                                        int32_T grainSize,\n                                                        uint32_T tbbQueryThreshold);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeKNNSearch_double(void* ptrObj,\n                                                        void* queryData,\n                                                        uint32_T numQueries,\n                                                        uint32_T numQueryDims,\n                                                        uint32_T knn,\n                                                        double paramChecks,\n                                                        double paramEps,\n                                                        void* indices,\n                                                        void* dists,\n                                                        void* valid,\n                                                        int32_T grainSize,\n                                                        uint32_T tbbQueryThreshold);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeKNNSearchRM_single(void* ptrObj,\n                                                          void* queryData,\n                                                          uint32_T numQueries,\n                                                          uint32_T numQueryDims,\n                                                          uint32_T knn,\n                                                          double paramChecks,\n                                                          float paramEps,\n                                                          void* indices,\n                                                          void* dists,\n                                                          void* valid,\n                                                          int32_T grainSize,\n                                                          uint32_T tbbQueryThreshold);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeKNNSearchRM_double(void* ptrObj,\n                                                          void* queryData,\n                                                          uint32_T numQueries,\n                                                          uint32_T numQueryDims,\n                                                          uint32_T knn,\n                                                          double paramChecks,\n                                                          double paramEps,\n                                                          void* indices,\n                                                          void* dists,\n                                                          void* valid,\n                                                          int32_T grainSize,\n                                                          uint32_T tbbQueryThresholds);\n\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeRadiusSearch_single(void* ptrObj,\n                                                           void* queryData,\n                                                           uint32_T numQueries,\n                                                           uint32_T numQueryDims,\n                                                           float radius,\n                                                           double paramChecks,\n                                                           float paramEps,\n                                                           void** resultIndices,\n                                                           void** resultDists,\n                                                           uint32_T* valid,\n                                                           int32_T grainSize,\n                                                           uint32_T tbbQueryThresholds);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeRadiusSearch_double(void* ptrObj,\n                                                           void* queryData,\n                                                           uint32_T numQueries,\n                                                           uint32_T numQueryDims,\n                                                           double radius,\n                                                           double paramChecks,\n                                                           double paramEps,\n                                                           void** resultIndices,\n                                                           void** resultDists,\n                                                           uint32_T* valid,\n                                                           int32_T grainSize,\n                                                           uint32_T tbbQueryThresholds);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeRadiusSearchRM_single(void* ptrObj,\n                                                             void* queryData,\n                                                             uint32_T numQueries,\n                                                             uint32_T numQueryDims,\n                                                             float radius,\n                                                             double paramChecks,\n                                                             float paramEps,\n                                                             void** resultIndices,\n                                                             void** resultDists,\n                                                             uint32_T* valid,\n                                                             int32_T grainSize,\n                                                             uint32_T tbbQueryThresholds);\n\nEXTERN_C LIBMWKDTREE_API int32_T kdtreeRadiusSearchRM_double(void* ptrObj,\n                                                             void* queryData,\n                                                             uint32_T numQueries,\n                                                             uint32_T numQueryDims,\n                                                             double radius,\n                                                             double paramChecks,\n                                                             double paramEps,\n                                                             void** resultIndices,\n                                                             void** resultDists,\n                                                             uint32_T* valid,\n                                                             int32_T grainSize,\n                                                             uint32_T tbbQueryThresholds);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeRadiusSearchSetOutputs_single(void* ptrIndicesIn,\n                                                                  void* ptrDistsIn,\n                                                                  uint32_T* ptrIndicesOut,\n                                                                  float* ptrDistsOut);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeRadiusSearchSetOutputs_double(void* ptrIndicesIn,\n                                                                  void* ptrDistsIn,\n                                                                  uint32_T* ptrIndicesOut,\n                                                                  double* ptrDistsOut);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeDeleteObj_single(void* ptrObj);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeDeleteObj_double(void* ptrObj);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeDeleteObjRM_single(void* ptrObj);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeDeleteObjRM_double(void* ptrObj);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeGetLocationDataPointer_single(void* locationData,\n                                                                  uint32_T dataSize,\n                                                                  uint32_T dims,\n                                                                  void** ptr2locationDataPtr);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeGetLocationDataPointer_double(void* locationData,\n                                                                  uint32_T dataSize,\n                                                                  uint32_T dims,\n                                                                  void** ptr2locationDataPtr);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeDeleteLocationDataPointer_single(void* locationPtr);\n\nEXTERN_C LIBMWKDTREE_API void kdtreeDeleteLocationDataPointer_double(void* locationPtr);\n\n#endif\n"},{"name":"cvstCG_ocrutils.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _OCRUTILS_\n#define _OCRUTILS_\n\n#ifndef OCRUTILS_API\n#    define OCRUTILS_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C OCRUTILS_API\nint32_T tesseractRecognizeTextUint8(void **, const uint8_T * I, char ** utf8Text,\n                                    const int32_T width, const int32_T height,\n                                    const char * textLayout, const char * charSet,\n                                    const char * tessdata, const char * lang,\n                                    const boolean_T resetParams);\n\nEXTERN_C OCRUTILS_API\nint32_T tesseractRecognizeTextLogical(void **, const boolean_T * I, char ** utf8Text,\n                                      const int32_T width, const int32_T height,\n                                      const char * textLayout, const char * charSet,\n                                      const char * tessdata, const char * lang,\n                                      const boolean_T resetParams);\n\nEXTERN_C OCRUTILS_API\nvoid cleanupTesseract(void *);\n\nEXTERN_C OCRUTILS_API\nvoid copyTextAndCleanup(char * src, uint8_T * dest, const size_t length);\n\nEXTERN_C OCRUTILS_API\nint32_T getTextFromMetadata(void * ocrMetadata, char ** utf8Text);\n\nEXTERN_C OCRUTILS_API\nvoid cleanupMetadata(void *);\n\nEXTERN_C OCRUTILS_API\nvoid collectMetadata(void * tessAPI, void ** ocrMetadata,\n                     int32_T * numChars, int32_T * numWords, int32_T * numTextLines,\n                     int32_T * numParagraphs, int32_T * numBlocks);\n\nEXTERN_C OCRUTILS_API\nvoid copyMetadata(void * ocrMetadata,\n                  double * charBBox,\n                  int32_T * charWordIndex,\n                  float * charConfidence,\n                  double * wordBBox,\n                  int32_T * wordTextLineIndex,\n                  float * wordConfidence,\n                  int32_T * wordCharacterIndex,\n                  double * textlineBBox,\n                  int32_T * textlineParagraphIndex,\n                  float * textlineConfidence,\n                  int32_T * textlineCharacterIndex,\n                  double * paragraphBBox,\n                  int32_T * paragraphBlockIndex,\n                  float * paragraphConfidence,\n                  int32_T * paragraphCharacterIndex,\n                  double * blockBBox,\n                  int32_T * blockPageIndex,\n                  float * blockConfidence,\n                  int32_T * blockCharacterIndex);\n#endif  \n\n\n"},{"name":"cvstCG_optimizePoses.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"#ifndef OPTIMIZEPOSES_\n#define OPTIMIZEPOSES_\n\n#ifndef LIBMWOPTIMIZEPOSES_API\n#define LIBMWOPTIMIZEPOSES_API\n#endif\n\n#ifndef EXTERN_C\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\" /* mwSize is defined here */\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWOPTIMIZEPOSES_API void tform2quatpose(void* mtform, double* mpose);\nEXTERN_C LIBMWOPTIMIZEPOSES_API void quatpose2tform(const double* mtform, double* mpose);\nEXTERN_C LIBMWOPTIMIZEPOSES_API void initializeVectors(const int numNodes,\n                                                       const int poseDim,\n                                                       void* mNodes,\n                                                       void** nodesVec);\nEXTERN_C LIBMWOPTIMIZEPOSES_API void poseOptimizer(const double blockSolverType,\n                                                   const double maxIter,\n                                                   const double funcTol,\n                                                   const double verboseFlag,\n                                                   const double maxTime,\n                                                   void* mNodes,\n                                                   void* mEdges,\n                                                   void* mInfoMats,\n                                                   double* mOptimNodes,\n                                                   double* structValues);\n#endif\n"},{"name":"cvstCG_readAprilTag.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"#ifndef _APRILTAGCORE_\n#define _APRILTAGCORE_\n\n#ifndef LIBMWREADAPRILTAG_API\n#    define LIBMWREADAPRILTAG_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\" /* mwSize is defined here */\n#else\n#include \"rtwtypes.h\"\n#endif\n\n#include <stdint.h>\n\nEXTERN_C LIBMWREADAPRILTAG_API \n        void initialiseOutput(void* id, void* locations, \n        void* familyLengths, void* familyNames, void* detectionObj,\n        int detectionSize); \n\nEXTERN_C LIBMWREADAPRILTAG_API \n        void initialisePoses(void* rotMatrices, void* transVectors,\n        void* detectionObj, void* posesObj, int posesSize);\n\nEXTERN_C LIBMWREADAPRILTAG_API \n        int getAprilTagIdPoseDetections(void* imageData, void* inputTag, \n        boolean_T estimatePose, const float quadDecimate, const int32_t width, const int32_t height,\n        void** detectionObj, int* familyLengths, const int numberTags, const int* tagLengths,\n        double* focalLen, double* principalPoint, double tagSize, void** posesObj, int* detectionSize);\n#endif"},{"name":"cvstCG_readBarcode.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2021 The MathWorks, Inc. */\n#ifndef _BARCODECORE_\n#define _BARCODECORE_\n\n#ifndef LIBMWREADBARCODE_API\n#    define LIBMWREADBARCODE_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\" /* mwSize is defined here */\n#else\n#include \"rtwtypes.h\"\n#endif\n\n#include <stdint.h>\n\nEXTERN_C LIBMWREADBARCODE_API  \n    void multiFormatDetectDecode(void* mImgData, const int32_t width, \n                             const int32_t height, void* mFormatData, \n                             const int nFormats,  const int* formatLengths, \n                             const bool robustRowScan, \n                             const bool robustPatternScan, void** resultObj, \n                             int* locSize, int* msgLen, int* formatLen);\n\nEXTERN_C LIBMWREADBARCODE_API  \n    void initializeOutput(void* msg, void* loc, void* format, void* resultObj);\n\n#endif"},{"name":"cvstCG_searchOrganizedPointCloud.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018 The MathWorks, Inc. */\n\n#ifndef _SEARCHORGANIZEDPOINTCLOUD_\n#define _SEARCHORGANIZEDPOINTCLOUD_\n\n#ifndef LIBMWSEARCHORGANIZEDPOINTCLOUD_API\n#    define LIBMWSEARCHORGANIZEDPOINTCLOUD_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n\n// knn search for different classes (single/double)\nEXTERN_C LIBMWSEARCHORGANIZEDPOINTCLOUD_API\n        uint32_T searchOrganizedPointCloud_knnsearch_single(float* location,\n        uint32_T height,\n        uint32_T width,\n        float *point,\n        double kValue,\n        float *pointProjection,\n        float *KRKRT,\n        void** resultIndices,\n        void** resultDistances);\nEXTERN_C LIBMWSEARCHORGANIZEDPOINTCLOUD_API\n        uint32_T searchOrganizedPointCloud_knnsearch_double(double* location,\n        uint32_T height,\n        uint32_T width,\n        double *point,\n        double kValue,\n        double *pointProjection,\n        double *KRKRT,\n        void** resultIndices,\n        void** resultDistances);\n// radius search for different classes (single/double)\nEXTERN_C LIBMWSEARCHORGANIZEDPOINTCLOUD_API\n        uint32_T searchOrganizedPointCloud_radiussearch_single(float* location,\n        uint32_T height,\n        uint32_T width,\n        float *point,\n        double kValue,\n        float *pointProjection,\n        float *KRKRT,\n        void** resultIndices,\n        void** resultDistances);\nEXTERN_C LIBMWSEARCHORGANIZEDPOINTCLOUD_API\n        uint32_T searchOrganizedPointCloud_radiussearch_double(double* location,\n        uint32_T height,\n        uint32_T width,\n        double *point,\n        double kValue,\n        double *pointProjection,\n        double *KRKRT,\n        void** resultIndices,\n        void** resultDistances);\n// Assign outputs for different classes (single/double)\nEXTERN_C LIBMWSEARCHORGANIZEDPOINTCLOUD_API\n        void searchOrganizedPointCloudAssignOutputs_single(void* ptrIndices,\n        void* ptrDists,\n        uint32_T* indicesPtr,\n        float* distancePtr);\nEXTERN_C LIBMWSEARCHORGANIZEDPOINTCLOUD_API\n        void searchOrganizedPointCloudAssignOutputs_double(void* ptrIndices,\n        void* ptrDists,\n        uint32_T* indicesPtr,\n        double* distancePtr);\n\n\n#endif\n"},{"name":"cvstCG_voxelGridFilter.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2021 The MathWorks, Inc. */\n\n#ifndef _VOXELGRIDFILTER_\n#define _VOXELGRIDFILTER_\n\n#ifndef LIBMWVOXELGRIDFILTER_API\n#define LIBMWVOXELGRIDFILTER_API\n#endif\n\n#ifndef EXTERN_C\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* VoxelGridFilter */\nEXTERN_C LIBMWVOXELGRIDFILTER_API uint32_T populateIndexVector_single(const float* pData,\n                                                                      const uint32_T numPoints,\n                                                                      const double voxelSize,\n                                                                      const float* pRange,\n                                                                      void** ptr2ptrIndexVector,\n                                                                      double minVoxelPoints);\n\nEXTERN_C LIBMWVOXELGRIDFILTER_API uint32_T populateIndexVector_double(const double* pData,\n                                                                      const uint32_T numPoints,\n                                                                      const double voxelSize,\n                                                                      const double* pRange,\n                                                                      void** ptr2ptrIndexVector,\n                                                                      double minVoxelPoints);\n\nEXTERN_C LIBMWVOXELGRIDFILTER_API void voxelGridAlgImpl_single(const float* pData,\n                                                               const uint32_T numPoints,\n                                                               const unsigned char* pColor,\n                                                               const float* pNormal,\n                                                               const float* pIntensity,\n                                                               const float* pRangeData,\n                                                               const float* pRange,\n                                                               float* pFilteredData,\n                                                               unsigned char* pFilteredColorData,\n                                                               float* pFilteredNormalData,\n                                                               float* pFilteredIntensityData,\n                                                               float* pFilteredRangeData,\n                                                               float* pCovData,\n                                                               uint32_T* pCountData,\n                                                               void* ptrIndexVector,\n                                                               const uint32_T total,\n                                                               const boolean_T needColor,\n                                                               const boolean_T needNormal,\n                                                               const boolean_T needIntensity,\n                                                               const boolean_T needRangeData,\n                                                               const boolean_T needCovariance,\n                                                               const boolean_T needCount);\n\nEXTERN_C LIBMWVOXELGRIDFILTER_API void voxelGridAlgImpl_double(const double* pData,\n                                                               const uint32_T numPoints,\n                                                               const unsigned char* pColor,\n                                                               const double* pNormal,\n                                                               const double* pIntensity,\n                                                               const double* pRangeData,\n                                                               const double* pRange,\n                                                               double* pFilteredData,\n                                                               unsigned char* pFilteredColorData,\n                                                               double* pFilteredNormalData,\n                                                               double* pFilteredIntensityData,\n                                                               double* pFilteredRangeData,\n                                                               double* pCovData,\n                                                               uint32_T* pCountData,\n                                                               void* ptrIndexVector,\n                                                               const uint32_T total,\n                                                               const boolean_T needColor,\n                                                               const boolean_T needNormal,\n                                                               const boolean_T needIntensity,\n                                                               const boolean_T needRangeData,\n                                                               const boolean_T needCovariance,\n                                                               const boolean_T needCount);\n\nEXTERN_C LIBMWVOXELGRIDFILTER_API void voxelGridAlgImpl_single_uint8Intensity(\n    const float* pData,\n    const uint32_T numPoints,\n    const unsigned char* pColor,\n    const float* pNormal,\n    const unsigned char* pIntensity,\n    const float* pRangeData,\n    const float* pRange,\n    float* pFilteredData,\n    unsigned char* pFilteredColorData,\n    float* pFilteredNormalData,\n    unsigned char* pFilteredIntensityData,\n    float* pFilteredRangeData,\n    float* pCovData,\n    uint32_T* pCountData,\n    void* ptrIndexVector,\n    const uint32_T total,\n    const boolean_T needColor,\n    const boolean_T needNormal,\n    const boolean_T needIntensity,\n    const boolean_T needRangeData,\n    const boolean_T needCovariance,\n    const boolean_T needCount);\n\nEXTERN_C LIBMWVOXELGRIDFILTER_API void voxelGridAlgImpl_single_uint16Intensity(\n    const float* pData,\n    const uint32_T numPoints,\n    const unsigned char* pColor,\n    const float* pNormal,\n    const uint16_T* pIntensity,\n    const float* pRangeData,\n    const float* pRange,\n    float* pFilteredData,\n    unsigned char* pFilteredColorData,\n    float* pFilteredNormalData,\n    uint16_T* pFilteredIntensityData,\n    float* pFilteredRangeData,\n    float* pCovData,\n    uint32_T* pCountData,\n    void* ptrIndexVector,\n    const uint32_T total,\n    const boolean_T needColor,\n    const boolean_T needNormal,\n    const boolean_T needIntensity,\n    const boolean_T needRangeData,\n    const boolean_T needCovariance,\n    const boolean_T needCount);\n\nEXTERN_C LIBMWVOXELGRIDFILTER_API void voxelGridAlgImpl_double_uint8Intensity(\n    const double* pData,\n    const uint32_T numPoints,\n    const unsigned char* pColor,\n    const double* pNormal,\n    const unsigned char* pIntensity,\n    const double* pRangeData,\n    const double* pRange,\n    double* pFilteredData,\n    unsigned char* pFilteredColorData,\n    double* pFilteredNormalData,\n    unsigned char* pFilteredIntensityData,\n    double* pFilteredRangeData,\n    double* pCovData,\n    uint32_T* pCountData,\n    void* ptrIndexVector,\n    const uint32_T total,\n    const boolean_T needColor,\n    const boolean_T needNormal,\n    const boolean_T needIntensity,\n    const boolean_T needRangeData,\n    const boolean_T needCovariance,\n    const boolean_T needCount);\n\nEXTERN_C LIBMWVOXELGRIDFILTER_API void voxelGridAlgImpl_double_uint16Intensity(\n    const double* pData,\n    const uint32_T numPoints,\n    const unsigned char* pColor,\n    const double* pNormal,\n    const uint16_T* pIntensity,\n    const double* pRangeData,\n    const double* pRange,\n    double* pFilteredData,\n    unsigned char* pFilteredColorData,\n    double* pFilteredNormalData,\n    uint16_T* pFilteredIntensityData,\n    double* pFilteredRangeData,\n    double* pCovData,\n    uint32_T* pCountData,\n    void* ptrIndexVector,\n    const uint32_T total,\n    const boolean_T needColor,\n    const boolean_T needNormal,\n    const boolean_T needIntensity,\n    const boolean_T needRangeData,\n    const boolean_T needCovariance,\n    const boolean_T needCount);\n\n#endif\n"},{"name":"dt_info.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2002 The MathWorks, Inc.\n *\n *\n * Abstract:\n *   typedef for data type transitions vectors.  Included by MODEL.dt\n */\n\n#ifndef _DTINFO_H_\n#define _DTINFO_H_\n\n/* Data type transition */\ntypedef struct DataTypeTransition_tag {\n  char_T *baseAddr; /* starting address of the transition  */\n  int_T  dataType;\n  int_T  isComplex; /* elements of this region are complex */\n  int_T  nEls;\n} DataTypeTransition;\n\n/* Data type transition table */\ntypedef struct DataTypeTransitionTable_tag {\n  uint_T             numTransitions;     /* number of transitions in table  */\n  DataTypeTransition *transitions;       /* base address of transition table*/\n} DataTypeTransitionTable;\n\ntypedef struct DataTypeInfo_T\n{\n    const char* name;\n    int_T dataTypeId;\n    uint_T size;\n} DataTypeInfo;\n\n\n/*\n * The model's data type transition info structure is attached\n * to the SimStruct:\n *\n * DataTypeTransInfo *dtInfo = ssGetModelMappingInfo(S);\n *\n * Additional information is accessed via:\n * \n * uint_T NumDataTypes     = dtGetNumDataTypes(dtInfo);\n * uint_T DataTypeSizes[]  = dtGetDataTypeSizes(dtInfo);\n * char_T *DataTypeNames[] = dtGetDataTypeNames(dtInfo);\n *\n * DataTypeTransTable *B     = dtGetBIODataTypeTrans(dtInfo);\n * DataTypeTransTable *P     = dtGetParamDataTypeTrans(dtInfo);\n * DataTypeTransTable *DWork = dtGetDWorkDataTypeTrans(dtInfo);\n * DataTypeTransTable *Xd    = dtGetDiscStatesDataTypeTrans(dtInfo);\n * DataTypeTransTable *U     = dtGetExternalInputsDataTypeTrans(dtInfo);\n * DataTypeTransTable *Y     = dtGetExternalOutputsDataTypeTrans(dtInfo);\n *\n * And, using the block outputs as an example\n * \n * uint_T              NumBIOTransitions  = dtGetNumTransitions(B);\n * DataTypeTransition  *BIOTransitions    = dtGetTransitions(B);\n * char_T              *address           = dtTransGetAddress(B, idx);\n * int_T               dataType           = dtTransGetDataType(B, idx);\n * int_T               isComplex          = dtTransGetComplexFlag(B, idx);\n *\n * where, idx is the index into the block outputs transition table.\n * For example, dtTransGetComplexFlag(B, 5) indicates whether the fifth\n * transition represents a complex region of the block outputs structure\n * structure and dtTransGetAddress(B, 5) is the absolute base address of\n * the region.\n */\n \ntypedef struct DataTypeTransInfo_tag {\n  uint_T         numDataTypes;    /* number of data types in model    */\n  uint_T         *dataTypeSizes;  /* data types (bytes) of data types */\n  char_T  const **dataTypeNames;  /* names of data types              */\n\n  DataTypeTransitionTable *BTransTable;     /* block outputs */\n  DataTypeTransitionTable *PTransTable;     /* parameters */\n  DataTypeTransitionTable *DWorkTransTable; /* data type work vector */\n  DataTypeTransitionTable *XdTransTable;    /* discrete states */\n  DataTypeTransitionTable *UTransTable;     /* model inputs */\n  DataTypeTransitionTable *YTransTable;     /* model outputs */\n  DataTypeInfo *dataTypeInfoTable;\n} DataTypeTransInfo;\n\n#define dtGetNumDataTypes(dtInfo)   ((uint_T)((dtInfo)->numDataTypes))\n#define dtGetDataTypeSizes(dtInfo)  ((dtInfo)->dataTypeSizes)\n#define dtGetDataTypeNames(dtInfo)  ((dtInfo)->dataTypeNames)\n\n#define dtGetBIODataTypeTrans(dtInfo)             ((dtInfo)->BTransTable)\n#define dtGetParamDataTypeTrans(dtInfo)           ((dtInfo)->PTransTable)\n#define dtGetDWorkDataTypeTrans(dtInfo)           ((dtInfo)->DWorkTransTable)\n#define dtGetDiscStatesDataTypeTrans(dtInfo)      ((dtInfo)->XdTransTable)\n#define dtGetExternalInputsDataTypeTrans(dtInfo)  ((dtInfo)->UTransTable)\n#define dtGetExternalOutputsDataTypeTrans(dtInfo) ((dtInfo)->YTransTable)\n\n#define dtGetNumTransitions(dtTable) \\\n    ((dtTable)->numTransitions)\n\n#define dtGetTransitions(dtTable) \\\n    ((dtTable)->transitions)\n\n#define dtTransGetAddress(dtTable, idx) \\\n    ((dtTable)->transitions[(idx)].baseAddr)\n\n#define dtTransGetDataType(dtTable, idx) \\\n    ((dtTable)->transitions[(idx)].dataType)\n\n#define dtTransNEls(dtTable, idx) \\\n    ((dtTable)->transitions[(idx)].nEls)\n\n#define dtTransGetComplexFlag(dtTable, idx) \\\n    ((dtTable)->transitions[(idx)].isComplex)\n\n#endif /* _DTINFO_ */\n"},{"name":"emlrt.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * PUBLISHED header for emlrt, the runtime library for MATLAB Coder\n *\n * Copyright 1984-2022 The MathWorks, Inc.\n *\n */\n#ifndef emlrt_h\n#define emlrt_h\n\n#if defined(_MSC_VER) || defined(__GNUC__)\n#pragma once\n#endif\n\n/*\n * Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n#endif\n\n#ifndef LIBEMLRT_API\n#define LIBEMLRT_API\n#endif\n\n#if defined(BUILDING_LIBEMLRT)\n#include \"emlrt_extern_include_begin.hpp\"\n#endif\n#include \"matrix.h\"\n#if defined(BUILDING_LIBEMLRT)\n#include \"emlrt_extern_include_end.hpp\"\n#endif\n\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n/* Incomplete typedef for mxGPUArray */\n#ifndef MX_GPUARRAY_DEFINED\n#ifdef __cplusplus\nclass mxGPUArray;\n#else\ntypedef struct mxGPUArray_tag mxGPUArray;\n#endif\n/*lint -esym(1923,MX_GPUARRAY_DEFINED) // MACRO input cannot be converted to const variable in C*/\n#define MX_GPUARRAY_DEFINED 1.0\n#endif\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Version\n */\n#define EMLRT_VERSION_R2022A 0x2022A\n#define EMLRT_VERSION_INFO EMLRT_VERSION_R2022A\n\n/*\n * MATLAB INTERNAL USE ONLY :: Thread local context type\n */\ntypedef void* emlrtCTX;\ntypedef const void* emlrtConstCTX;\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX error function\n */\ntypedef void (*EmlrtErrorFunction)(const char* aIdentifier,\n                                   const CHAR16_T* aMessage,\n                                   emlrtCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Prototypes of OpenMP lock functions.\n */\ntypedef void (*EmlrtLockeeFunction)(emlrtConstCTX aTLS, void* aData);\ntypedef void (*EmlrtLockerFunction)(EmlrtLockeeFunction aLockee, emlrtConstCTX aTLS, void* aData);\n#define emlrtCallLockeeFunction(emlrtLockeeFcnPtr, emlrtLockeeArg0, emlrtLockeeArg1) \\\n    emlrtLockeeFcnPtr(emlrtLockeeArg0, emlrtLockeeArg1)\n\n/*\n * MATLAB INTERNAL USE ONLY :: Runtime message identifier\n */\ntypedef struct emlrtMsgIdentifier {\n    const char* fIdentifier;\n    const struct emlrtMsgIdentifier* fParent;\n    boolean_T bParentIsCell;\n} emlrtMsgIdentifier;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Runtime stack info\n */\ntypedef struct emlrtRSInfo {\n    int32_T lineNo;\n    const char* fcnName;\n    const char* pathName;\n} emlrtRSInfo;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Runtime call stack\n */\ntypedef struct emlrtStack {\n    emlrtRSInfo* site;\n    emlrtCTX tls;\n    const struct emlrtStack* prev;\n} emlrtStack;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Runtime call stack\n */\ntypedef struct emlrtCallStack {\n    uint32_T fRTStackPointer;\n    uint32_T* fRTStackSize;\n} emlrtCallStack;\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Context\n */\ntypedef struct emlrtContext {\n    boolean_T bFirstTime;\n    boolean_T bInitialized;\n    uint32_T fVersionInfo;\n    EmlrtErrorFunction fErrorFunction;\n    const char* fFunctionName;\n    struct emlrtCallStack* fRTCallStack;\n    boolean_T bDebugMode;\n    uint32_T fSigWrd[4];\n    void* fSigMem;\n} emlrtContext;\n\n/*\n * MATLAB INTERNAL USE ONLY :: External Mode Simulation\n */\ntypedef struct emlrtExternalSim {\n    void* fESim;\n    uint8_T* fIOBuffer;\n    uint8_T* fIOBufHead;\n    size_t fIOBufSize;\n} emlrtExternalSim;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Array bounds check parameters\n */\ntypedef struct emlrtBCInfo {\n    int32_T iFirst;\n    int32_T iLast;\n    int32_T lineNo;\n    int32_T colNo;\n    const char* aName;\n    const char* fName;\n    const char* pName;\n    int32_T checkKind;\n} emlrtBCInfo;\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Design range check parameters\n */\ntypedef struct emlrtDRCInfo {\n    int32_T lineNo;\n    int32_T colNo;\n    const char* fName;\n    const char* pName;\n} emlrtDRCInfo;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Equality check parameters\n */\ntypedef struct emlrtECInfo {\n    int32_T nDims;\n    int32_T lineNo;\n    int32_T colNo;\n    const char* fName;\n    const char* pName;\n} emlrtECInfo;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Array bounds check parameters\n */\ntypedef struct {\n    int32_T lineNo;\n    int32_T colNo;\n    const char* fName;\n    const char* pName;\n} emlrtRTEInfo;\n\ntypedef emlrtRTEInfo emlrtMCInfo;\n\n/* MATLAB INTERNAL USE ONLY :: Reference to global runtime context */\nextern emlrtContext emlrtContextGlobal;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Dispatch to mexPrintf\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtMexVprintf(const char* aFmt, va_list aVargs);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Dispatch to mexPrintf\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtMexPrintf(emlrtConstCTX aTLS, const char* aFmt, ...);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Dispatch to snprintf\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtMexSnprintf(char* retString, size_t n, const char* aFmt, ...);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Query first-time sentinel\n */\nEXTERN_C LIBEMLRT_API boolean_T emlrtFirstTimeR2012b(emlrtCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create an mxArray alias\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtAlias(const mxArray* in);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a persistent mxArray alias\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtAliasP(const mxArray* in);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Return a vector of mxArray to MATLAB\n */\nEXTERN_C LIBEMLRT_API void emlrtReturnArrays(const int32_T aNlhs,\n                                             mxArray* aLHS[],\n                                             const mxArray* const aRHS[]);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Protect mxArray from being overwritten if necessary\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtProtectR2012b(const mxArray* pa,\n                                                        int32_T,\n                                                        boolean_T,\n                                                        int32_T reservedNumEl);\n\n/*\n * MATLAB INTERNAL USE ONLY :: License check\n */\nEXTERN_C LIBEMLRT_API void emlrtLicenseCheckR2012b(emlrtCTX aTLS,\n                                                   const char* aFeatureKey,\n                                                   const int32_T b);\n/*\n * MATLAB INTERNAL USE ONLY :: License check\n */\nEXTERN_C LIBEMLRT_API void emlrtLicenseCheckR2022a(emlrtCTX aTLS,\n                                                   const char* aMsgId,\n                                                   const char* aFeatureKey,\n                                                   const int32_T b);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Verify default fimath\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckDefaultFimathR2008b(const mxArray** ctFimath);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Clear mxArray allocation count\n */\nEXTERN_C LIBEMLRT_API void emlrtClearAllocCountR2012b(emlrtCTX aTLS,\n                                                      boolean_T bM,\n                                                      uint32_T iL,\n                                                      const char* ctDTO);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Load a specified library\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtLoadLibrary(const char* aFullname);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Load a specified MATLAB library\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtLoadMATLABLibrary(const char* aFullName);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Assign to an mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtAssign(const mxArray** lhs, const mxArray* rhs);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Assign to a persistent mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtAssignP(const mxArray** lhs, const mxArray* rhs);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Array bounds check\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtBoundsCheckR2012b(int32_T indexValue,\n                                                     emlrtBCInfo* aInfo,\n                                                     emlrtCTX aTLS);\n\n#ifdef INT_TYPE_64_IS_SUPPORTED\n/*\n * MATLAB INTERNAL USE ONLY :: Array bounds check for int64\n */\nEXTERN_C LIBEMLRT_API int64_T emlrtBoundsCheckInt64(const int64_T indexValue,\n                                                    const emlrtBCInfo* const aInfo,\n                                                    const emlrtCTX aTLS);\n#endif\n\n/*\n * MATLAB INTERNAL USE ONLY :: Dynamic array bounds check\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtDynamicBoundsCheckR2012b(int32_T indexValue,\n                                                            int32_T loBound,\n                                                            int32_T hiBound,\n                                                            emlrtBCInfo* aInfo,\n                                                            emlrtConstCTX aTLS);\n\n#ifdef INT_TYPE_64_IS_SUPPORTED\n/*\n * MATLAB INTERNAL USE ONLY :: Dynamic array bounds check for int64\n */\nEXTERN_C LIBEMLRT_API int64_T emlrtDynamicBoundsCheckInt64(const int64_T indexValue,\n                                                           const int32_T loBound,\n                                                           const int32_T hiBound,\n                                                           const emlrtBCInfo* const aInfo,\n                                                           const emlrtConstCTX aTLS);\n#endif\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check that the target value is within the design range.\n */\nEXTERN_C LIBEMLRT_API real_T emlrtDesignRangeCheck(real_T targetValue,\n                                                   real_T rangeMin,\n                                                   real_T rangeMax,\n                                                   emlrtDRCInfo* aInfo,\n                                                   emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Perform integer multiplication, raise runtime error\n *                             if the operation overflows.\n */\nEXTERN_C LIBEMLRT_API size_t emlrtSizeMulR2012b(size_t s1,\n                                                size_t s2,\n                                                const emlrtRTEInfo* aInfo,\n                                                emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create an mxArray string from a C string\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateStringR2022a(emlrtConstCTX aTLS, const char* in);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create an mxArray string from a single char\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateString1R2022a(emlrtConstCTX aTLS, char c);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a struct matrix mxArray\n */\nEXTERN_C LIBEMLRT_API mxArray* emlrtCreateStructMatrix(int32_T m,\n                                                       int32_T n,\n                                                       int32_T nfields,\n                                                       const char** field_names);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a class instance mxArray\n */\nEXTERN_C LIBEMLRT_API mxArray* emlrtCreateClassInstance2022a(emlrtConstCTX, const char* className);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a struct matrix mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateStructArray(int32_T ndim,\n                                                            const int32_T* pdim,\n                                                            int32_T nfields,\n                                                            const char** field_names);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create an enum\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateEnumR2012b(emlrtConstCTX aTLS,\n                                                           const char* name,\n                                                           const mxArray* data);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Add a field to a struct matrix mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateField(const mxArray* mxStruct, const char* fldName);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check an input sparse matrix\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckSparse(emlrtConstCTX aTLS,\n                                            const emlrtMsgIdentifier* aMsgId,\n                                            const mxArray* s,\n                                            const void* pDims,\n                                            const boolean_T* aDynamic,\n                                            int32_T aClassId,\n                                            int32_T aComplexity);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Polymorphic mex utility functions\n */\n\nEXTERN_C LIBEMLRT_API const char* emlrtGetClassName(const mxArray* pa);\n\nEXTERN_C LIBEMLRT_API boolean_T emlrtCompareString(const char* actual, const char* expected);\n\nEXTERN_C LIBEMLRT_API boolean_T emlrtIsComplex(const mxArray* pa);\n\nEXTERN_C LIBEMLRT_API boolean_T emlrtIsHeterogeneous(const mxArray* pa);\n\nEXTERN_C LIBEMLRT_API int emlrtNumCellElements(const mxArray* pa);\n\nEXTERN_C LIBEMLRT_API mxArray* emlrtGetCellElement(const mxArray* pa, int index);\n\nEXTERN_C LIBEMLRT_API int emlrtGetNumStructFields(const mxArray* pa);\n\nEXTERN_C LIBEMLRT_API const char* emlrtGetStructFieldName(const mxArray* pa, int index);\n\nEXTERN_C LIBEMLRT_API mxArray* emlrtGetStructField(const mxArray* pa, const char* fieldName);\n\nEXTERN_C LIBEMLRT_API boolean_T emlrtIsCompatibleSize(const mxArray* pa,\n                                                      const uint32_T* aSizeVec,\n                                                      const boolean_T* aVardimVec,\n                                                      const uint32_T sizeLength);\n\nEXTERN_C LIBEMLRT_API boolean_T emlrtIsSparse(const mxArray* pa);\nEXTERN_C LIBEMLRT_API uint32_T emlrtGetSizeLength(const mxArray* pa);\nEXTERN_C LIBEMLRT_API mxArray* emlrtGetClassProperty(const mxArray* pa, const char* propertyName);\n\nEXTERN_C LIBEMLRT_API boolean_T emlrtCompareFiType(const mxArray* aFi,\n                                                   const mxArray* fiMathMx,\n                                                   const mxArray* ntMx);\nEXTERN_C LIBEMLRT_API boolean_T emlrtIsComplexFi(const mxArray* aFi);\nEXTERN_C LIBEMLRT_API boolean_T emlrtCompareConstant(const mxArray* aConst,\n                                                     const uint32_T* aCheckSum);\n/*\n * MATLAB INTERNAL USE ONLY :: Check an input sparse matrix\n */\n\nEXTERN_C LIBEMLRT_API mxArray* emlrtCreateSparse(const void* d,\n                                                 const int32_T* colidx,\n                                                 const int32_T* rowidx,\n                                                 int32_T m,\n                                                 int32_T n,\n                                                 int32_T maxnz,\n                                                 int32_T aClassId,\n                                                 int32_T aComplexity);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Add a field to a struct matrix mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtAddField(const mxArray* mxStruct,\n                                                   const mxArray* mxField,\n                                                   const char* fldName,\n                                                   int32_T index);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Set the value from propValues of all properties in propNames of a\n * class instance mxArray.\n */\nEXTERN_C LIBEMLRT_API void emlrtSetAllProperties(emlrtConstCTX,\n                                                 const mxArray**,\n                                                 int32_T index,\n                                                 int32_T numberOfProperties,\n                                                 const char** propertyNames,\n                                                 const char** classNames,\n                                                 const mxArray** propertyValues);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get the value mxArray of all properties of a class instance mxArray.\n */\nEXTERN_C LIBEMLRT_API void emlrtGetAllProperties(emlrtConstCTX,\n                                                 const mxArray*,\n                                                 int32_T index,\n                                                 int32_T numberOfProperties,\n                                                 const char** propertyNames,\n                                                 const char** classNames,\n                                                 const mxArray** propertyValues);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get the redirect target MCOS instance mxArray of a redirect source\n * MCOS instance mxArray.\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtConvertInstanceToRedirectTarget(emlrtConstCTX aTLS,\n                                                                          const mxArray* mxCls,\n                                                                          int aIndex,\n                                                                          const char* className);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get the redirect source MCOS instance mxArray of a redirect target\n * MCOS instance mxArray.\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtConvertInstanceToRedirectSource(emlrtConstCTX aTLS,\n                                                                          const mxArray* mxCls,\n                                                                          int aIndex,\n                                                                          const char* className);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get a field from a struct matrix mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtGetFieldR2017b(emlrtConstCTX aTLS,\n                                                         const mxArray* mxStruct,\n                                                         int32_T aIndex,\n                                                         int32_T fldNumber,\n                                                         const char* fldName);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Set field value in structure array, given index and field name\n */\nEXTERN_C LIBEMLRT_API void emlrtSetField(mxArray* mxStruct,\n                                         int32_T aIndex,\n                                         const char* fldName,\n                                         mxArray* mxValue);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Set field value in structure array, given index and field index\n */\nEXTERN_C LIBEMLRT_API void emlrtSetFieldR2017b(const mxArray* mxStruct,\n                                               int32_T aIndex,\n                                               const char* fldName,\n                                               const mxArray* mxValue,\n                                               int32_T fldIdx);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a cell array\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateCellArrayR2014a(int32_T ndim, const int32_T* pdim);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a cell matrix mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateCellMatrix(int32_T m, int32_T n);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Set a cell element\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtSetCell(const mxArray* mxCellArray,\n                                                  int32_T aIndex,\n                                                  const mxArray* mxCell);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get a cell element\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtGetCell(emlrtConstCTX aTLS,\n                                                  const emlrtMsgIdentifier* aMsgId,\n                                                  const mxArray* mxCell,\n                                                  int32_T aIndex);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check if empty\n */\nEXTERN_C LIBEMLRT_API boolean_T emlrtIsEmpty(const mxArray* mxCell);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a numeric matrix mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateNumericMatrix(int32_T m,\n                                                              int32_T n,\n                                                              int32_T classID,\n                                                              int32_T nComplexFlag);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a numeric matrix mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateNumericArray(int32_T ndim,\n                                                             const void* pdim,\n                                                             int32_T classID,\n                                                             int32_T nComplexFlag);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a scaled numeric matrix mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateScaledNumericArrayR2008b(int32_T ndim,\n                                                                         const void* pdim,\n                                                                         int32_T classID,\n                                                                         int32_T nComplexFlag,\n                                                                         int32_T aScale);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a double scalar mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateDoubleScalar(real_T in);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a logical matrix mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateLogicalArray(int32_T ndim, const int32_T* dims);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a 2-D logical matrix mxArray\n */\nEXTERN_C LIBEMLRT_API mxArray* emlrtCreateLogicalMatrix(int32_T aN, int32_T aM);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a logical scalar mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateLogicalScalar(boolean_T in);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a character array mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateCharArray(int32_T ndim, const int32_T* dims);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a FI mxArray from a value mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateFIR2013b(emlrtConstCTX aTLS,\n                                                         const mxArray* fimath,\n                                                         const mxArray* ntype,\n                                                         const char* fitype,\n                                                         const mxArray* fival,\n                                                         const boolean_T fmIsLocal,\n                                                         const boolean_T aForceComplex);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Set the dimensions of an mxArray.\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtSetDimensions(mxArray* aMx, const int32_T* dims, int32_T ndims);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get the intarray from a FI mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtImportFiIntArrayR2008b(const mxArray* aFiMx);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get the enum int32_T from an MCOS enumeration mxArray.\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtGetEnumElementR2009a(const mxArray* aEnum, int32_T aIndex);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get the enum int32_T from an MCOS enumeration mxArray.\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtGetEnumUnderlyingArrayR2009a(const mxArray* aEnum);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Convert MATLAB mxArray data format to C data format\n */\nEXTERN_C LIBEMLRT_API void emlrtMatlabDataToCFormat(const mxArray* inputMx,\n                                                    const mxArray* cformatMx);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Convert C data format to MATLAB data format\n */\nEXTERN_C LIBEMLRT_API void emlrtMatlabDataFromCFormat(const mxArray* outputMx,\n                                                      const mxArray* cformatMx);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Try to coerce mxArray to provided class; return same mxArray if not\n * possible.\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCoerceToClassR2014b(const mxArray* inputMx,\n                                                              const char* className);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Destroy an mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtDestroyArray(const mxArray** pa);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Destroy an mxArray R2017a\n */\nEXTERN_C LIBEMLRT_API void emlrtDestroyArrayR2017a(mxArray* pa);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Destroy a vector of mxArrays\n */\nEXTERN_C LIBEMLRT_API void emlrtDestroyArrays(int32_T narrays, const mxArray** parrays);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Free the imaginary part of a matrix if all the imaginary elements are\n * zero\n */\nEXTERN_C LIBEMLRT_API void emlrtFreeImagIfZero(const mxArray* pa);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Display an mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtDisplayR2012b(const mxArray* pa,\n                                              const char* name,\n                                              emlrtMCInfo* aLoc,\n                                              emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Double check parameters\n */\ntypedef struct {\n    int32_T lineNo;\n    int32_T colNo;\n    const char* fName;\n    const char* pName;\n    int32_T checkKind; /* see src/cg_ir/base/Node.hpp::CG_Node_CheckEnum */\n} emlrtDCInfo;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check that d can be safely cast to int.\n */\nEXTERN_C LIBEMLRT_API real_T emlrtIntegerCheckR2012b(real_T d,\n                                                     emlrtDCInfo* aInfo,\n                                                     emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check that d is not NaN.\n */\nEXTERN_C LIBEMLRT_API real_T emlrtNotNanCheckR2012b(real_T d,\n                                                    emlrtDCInfo* aInfo,\n                                                    emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check that d >= 0.\n */\nEXTERN_C LIBEMLRT_API real_T emlrtNonNegativeCheckR2012b(real_T d,\n                                                         emlrtDCInfo* aInfo,\n                                                         emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check that the loop has an integer number of iterations.\n */\nEXTERN_C LIBEMLRT_API void emlrtForLoopVectorCheckR2012b(real_T start,\n                                                         real_T step,\n                                                         real_T end,\n                                                         mxClassID classID,\n                                                         int32_T n,\n                                                         emlrtRTEInfo* aInfo,\n                                                         emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check that the loop range is valid for code generation.\n */\nEXTERN_C LIBEMLRT_API void emlrtForLoopVectorCheckR2021a(real_T start,\n                                                         real_T step,\n                                                         real_T end,\n                                                         mxClassID classID,\n                                                         int32_T n,\n                                                         emlrtRTEInfo* aInfo,\n                                                         emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: fetch a global variable\n */\nEXTERN_C LIBEMLRT_API void emlrtPutGlobalVariable(const char* name, const mxArray* parray);\n\n/*\n * MATLAB INTERNAL USE ONLY :: fetch a global variable\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtGetGlobalVariable(const char* name);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Call out to MATLAB to report error from MLFB/Stateflow\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtSFCallMATLABReportError(emlrtConstCTX aTLS,\n                                                                  emlrtMCInfo* aLoc,\n                                                                  int32_T nrhs,\n                                                                  const mxArray** prhs);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Extract the C stack from emlrtConstCtx\n */\nEXTERN_C LIBEMLRT_API mxArray* emlrtExtractStack(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Call out to MATLAB\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCallMATLABR2012b(emlrtConstCTX aTLS,\n                                                           int32_T nlhs,\n                                                           const mxArray** plhs,\n                                                           int32_T nrhs,\n                                                           const mxArray** prhs,\n                                                           const char* cmd,\n                                                           boolean_T tmp,\n                                                           emlrtMCInfo* aLoc);\n\n/*\n * MATLAB INTERNAL USE ONLY :: malloc for MEX\n */\nEXTERN_C LIBEMLRT_API void* emlrtMallocMex(size_t aSize);\n\n/*\n * MATLAB INTERNAL USE ONLY :: calloc for MEX\n */\nEXTERN_C LIBEMLRT_API void* emlrtCallocMex(size_t aNum, size_t aSize);\n\n/*\n * MATLAB INTERNAL USE ONLY :: free for MEX\n */\nEXTERN_C LIBEMLRT_API void emlrtFreeMex(void* aPtr);\n\n/*\n * MATLAB INTERNAL USE ONLY :: malloc for EmxArrays\n */\nEXTERN_C LIBEMLRT_API void* emlrtMallocEmxArray(size_t aSize);\n\n/*\n * MATLAB INTERNAL USE ONLY :: free for EmxArrays\n */\nEXTERN_C LIBEMLRT_API void emlrtFreeEmxArray(void* aPtr);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Enter a new function within a MEX call.\n */\nEXTERN_C LIBEMLRT_API void emlrtHeapReferenceStackEnterFcnR2012b(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Enter a new function within a MEX call.\n */\nEXTERN_C LIBEMLRT_API void emlrtHeapReferenceStackEnterFcn(void);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Leave a scope within a MEX call.\n */\nEXTERN_C LIBEMLRT_API void emlrtHeapReferenceStackLeaveScope(emlrtConstCTX aTLS,\n                                                             int32_T aAllocCount);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Leave a function within a MEX call.\n */\nEXTERN_C LIBEMLRT_API void emlrtHeapReferenceStackLeaveFcnR2012b(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Leave a function within a MEX call.\n */\nEXTERN_C LIBEMLRT_API void emlrtHeapReferenceStackLeaveFcn(void);\n\n\nEXTERN_C LIBEMLRT_API void emlrtPushHeapReferenceStackR2021a(emlrtConstCTX aTLS,\n                                                             bool aNeedStack,\n                                                             void* aHeapReference,\n                                                             void* aFreeFcn,\n                                                             void* aSimStruct,\n                                                             void* aJITInstance,\n                                                             void* aStackData);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Push emxArray onto heap reference stack.\n */\nEXTERN_C LIBEMLRT_API void emlrtPushHeapReferenceStackEmxArray(emlrtConstCTX aTLS,\n                                                               bool aNeedStack,\n                                                               void* aHeapReference,\n                                                               void* aFreeFcn,\n                                                               void* aSimStruct,\n                                                               void* aJITInstance,\n                                                               void* aStackData);\n\nEXTERN_C LIBEMLRT_API void emlrtRemoveHeapReference(emlrtConstCTX aTLS, void* aHeapReference);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Push a new entry to the heap reference stack.\n */\nEXTERN_C LIBEMLRT_API void emlrtSetGlobalSyncFcn(emlrtConstCTX aTLS, void* aSyncFcn);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Push a new entry to the heap reference stack.\n */\nEXTERN_C LIBEMLRT_API void emlrtSetGlobalSyncFcnWithSD(emlrtConstCTX aTLS,\n                                                       void* aStackData,\n                                                       void* aSyncFcn);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Push a new entry to the heap reference stack.\n */\nEXTERN_C LIBEMLRT_API void emlrtSetJITGlobalSyncFcn(emlrtConstCTX aTLS,\n                                                    void* aJITInstance,\n                                                    void* aSyncFcn);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Push a new entry to the heap reference stack.\n */\nEXTERN_C LIBEMLRT_API void emlrtSetJITGlobalSyncFcnWithSD(emlrtConstCTX aTLS,\n                                                          void* aJITInstance,\n                                                          void* aStackData,\n                                                          void* aSyncFcn);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize a character mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtInitCharArrayR2013a(emlrtConstCTX aTLS,\n                                                    int32_T n,\n                                                    const mxArray* a,\n                                                    const char* s);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize a logical mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtInitLogicalArray(int32_T n, const mxArray* a, const boolean_T* b);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize an integral array from a multiword type\n */\nEXTERN_C LIBEMLRT_API void emlrtInitIntegerArrayFromMultiword(const mxArray* aOut,\n                                                              const void* aInData);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Export a numeric mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtExportNumericArrayR2013b(emlrtConstCTX aTLS,\n                                                         const mxArray* aOut,\n                                                         const void* aInData,\n                                                         int32_T aElementSize);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Auto-generated mexFunction\n */\ntypedef void (*emlrtMexFunction)(int, mxArray*[], int, const mxArray*[]);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Auto-generated entry-point\n */\ntypedef struct emlrtEntryPoint {\n    const char* fName;\n    emlrtMexFunction fMethod;\n} emlrtEntryPoint;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Lookup an entry point\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtGetEntryPointIndexR2016a(emlrtConstCTX aTLS,\n                                                            int32_T nrhs,\n                                                            const mxArray* prhs[],\n                                                            const char* aEntryPointNames[],\n                                                            int32_T aNumEntryPoints);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Decode wide character strings in mxArray struct array.\n * The struct array consists of name resolution entries which may contain file paths.\n * If the file path is using UTF-8, then the string is plain 7-bit ASCII but encoded.\n * We need to decode those if necessary. The resulting mxArray strings (for file paths)\n * will be proper UTF-16 strings.\n */\nEXTERN_C LIBEMLRT_API void emlrtNameCapturePostProcessR2013b(const mxArray** mxInfo);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Decode string array into mxArray object containing\n * name resolution data.\n */\nEXTERN_C LIBEMLRT_API void emlrtNameCaptureMxArrayR2016a(const char* mxInfoEncoded[],\n                                                         uint32_T uncompressedSize,\n                                                         const mxArray** mxInfo);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Parallel runtime error exception\n */\n#ifdef __cplusplus\nclass EmlrtParallelRunTimeError {\n  public:\n    EmlrtParallelRunTimeError();\n    EmlrtParallelRunTimeError(const EmlrtParallelRunTimeError& e);\n    ~EmlrtParallelRunTimeError();\n};\n#endif\n\n/*\n * MATLAB INTERNAL USE ONLY :: Report if we are in a parallel region\n */\nEXTERN_C LIBEMLRT_API boolean_T emlrtIsInParallelRegion(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Enter a parallel region.\n */\nEXTERN_C LIBEMLRT_API void emlrtEnterParallelRegion(emlrtConstCTX aTLS,\n                                                    boolean_T aInParallelRegion);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Exit a parallel region.\n */\nEXTERN_C LIBEMLRT_API void emlrtExitParallelRegion(emlrtConstCTX aTLS, boolean_T aInParallelRegion);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check if we're running on the MATLAB thread.\n */\nEXTERN_C LIBEMLRT_API boolean_T emlrtIsMATLABThread(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Record the occurrence of a parallel warning.\n */\nEXTERN_C LIBEMLRT_API boolean_T emlrtSetWarningFlag(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Report a parallel runtime error\n */\nEXTERN_C LIBEMLRT_API void emlrtReportParallelRunTimeError(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Ensure active thread is MATLAB\n */\nEXTERN_C LIBEMLRT_API void emlrtAssertMATLABThread(emlrtConstCTX aTLS, emlrtMCInfo* aLoc);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Push the current jmp_buf environment\n */\nEXTERN_C LIBEMLRT_API void emlrtPushJmpBuf(emlrtConstCTX aTLS, jmp_buf* volatile* aJBEnviron);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Pop the current jmp_buf environment\n */\nEXTERN_C LIBEMLRT_API void emlrtPopJmpBuf(emlrtConstCTX aTLS, jmp_buf* volatile* aJBEnviron);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Set the current jmp_buf environment\n */\nEXTERN_C LIBEMLRT_API void emlrtSetJmpBuf(emlrtConstCTX aTLS, jmp_buf* aJBEnviron);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get the current jmp_buf environment\n */\nEXTERN_C LIBEMLRT_API jmp_buf* emlrtGetJmpBuf(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a shallow copy of an mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrtCreateReference(const mxArray* pa);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Division by zero error\n */\nEXTERN_C LIBEMLRT_API void emlrtDivisionByZeroErrorR2012b(const emlrtRTEInfo* aInfo,\n                                                          emlrtConstCTX aTLS);\n\nEXTERN_C LIBEMLRT_API void emlrtDivisionByZeroWarningOrError2018b(const emlrtRTEInfo* aInfo,\n                                                                  emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Integer overflow error\n */\nEXTERN_C LIBEMLRT_API void emlrtIntegerOverflowErrorR2012b(const emlrtRTEInfo* aInfo,\n                                                           emlrtConstCTX aTLS);\n\nEXTERN_C LIBEMLRT_API void emlrtIntegerOverflowWarningOrError2018b(const emlrtRTEInfo* aInfo,\n                                                                   emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Raise C heap allocation failure\n */\nEXTERN_C LIBEMLRT_API void emlrtHeapAllocationErrorR2012b(const emlrtRTEInfo* aInfo,\n                                                          emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Error with given message ID and args.\n */\nEXTERN_C LIBEMLRT_API void emlrtErrorWithMessageIdR2018a(emlrtConstCTX aTLS,\n                                                         const emlrtRTEInfo* aInfo,\n                                                         const char* aMsgID,\n                                                         const char* aReportID,\n                                                         int aArgCount,\n                                                         ...);\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Error with given message ID and args.\n */\nEXTERN_C LIBEMLRT_API void emlrtErrorWithMessageIdR2012b(emlrtConstCTX aTLS,\n                                                         const emlrtRTEInfo* aInfo,\n                                                         const char* aMsgID,\n                                                         int32_T aArgCount,\n                                                         ...);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Error with given message ID and args.\n */\nEXTERN_C LIBEMLRT_API void emlrtErrMsgIdAndTxt(emlrtCTX aTLS,\n                                               const char* aMsgID,\n                                               int32_T aArgCount,\n                                               ...);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Error with given message ID and explicit message text.\n */\nEXTERN_C LIBEMLRT_API void emlrtErrMsgIdAndExplicitTxt(emlrtConstCTX aTLS,\n                                                       const emlrtRTEInfo* aInfo,\n                                                       const char* aMsgID,\n                                                       int32_T aStrlen,\n                                                       const char* aMsgTxt);\n\ntypedef struct {\n    const char* MexFileName;\n    const char* TimeStamp;\n    const char* buildDir;\n    int32_T numFcns;\n    int32_T numHistogramBins;\n} emlrtLocationLoggingFileInfoType;\n\ntypedef struct {\n    const char* FunctionName;\n    int32_T FunctionID;\n    int32_T numInstrPoints;\n} emlrtLocationLoggingFunctionInfoType;\n\ntypedef struct {\n    real_T NumberOfZeros;\n    real_T NumberOfPositiveValues;\n    real_T NumberOfNegativeValues;\n    real_T TotalNumberOfValues;\n    real_T SimSum;\n    real_T HistogramOfPositiveValues[256];\n    real_T HistogramOfNegativeValues[256];\n} emlrtLocationLoggingHistogramType;\n\ntypedef struct {\n    real_T SimMin;\n    real_T SimMax;\n    int32_T OverflowWraps;\n    int32_T Saturations;\n    boolean_T IsAlwaysInteger;\n    emlrtLocationLoggingHistogramType* HistogramTable;\n} emlrtLocationLoggingDataType;\n\ntypedef struct {\n    int32_T MxInfoID;\n    int32_T TextStart;\n    int32_T TextLength;\n    int16_T Reason;\n    boolean_T MoreLocations;\n} emlrtLocationLoggingLocationType;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get LocationLogging Info\n */\nEXTERN_C LIBEMLRT_API mxArray* emlrtLocationLoggingPullLog(const char* const MexFileName,\n                                                           boolean_T pullCompReportFromMexFunction);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Save LocationLogging Info\n */\nEXTERN_C LIBEMLRT_API void emlrtLocationLoggingPushLog(\n    const emlrtLocationLoggingFileInfoType* const fileInfo,\n    const emlrtLocationLoggingFunctionInfoType* const functionInfoTable,\n    const emlrtLocationLoggingDataType* const dataTables,\n    const emlrtLocationLoggingLocationType* const locationTables,\n    const uint8_T* serializedReport,\n    size_t sizeofSerializedReport,\n    const int32_T* numFieldsTables,\n    const char** fieldNamesTables);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Save LocationLogging Info\n */\nEXTERN_C LIBEMLRT_API void emlrtLocationLoggingPushLogR2017a(\n    const emlrtLocationLoggingFileInfoType* const fileInfo,\n    const emlrtLocationLoggingFunctionInfoType* const functionInfoTable,\n    const emlrtLocationLoggingDataType* const dataTables,\n    const emlrtLocationLoggingLocationType* const locationTables,\n    const int32_T* numFieldsTables,\n    const char** fieldNamesTables,\n    const char* serializedReport[],\n    size_t sizeofSerializedReport);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Clear LocationLogging Info\n */\nEXTERN_C LIBEMLRT_API boolean_T emlrtLocationLoggingClearLog(const char* const MexFileName);\n\n/*\n * MATLAB INTERNAL USE ONLY :: List entries in LocationLogging Info\n */\nEXTERN_C LIBEMLRT_API mxArray* emlrtLocationLoggingListLogs(void);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Add instrumentation results to FPT Repository\n */\nEXTERN_C LIBEMLRT_API void addResultsToFPTRepository(const char* const blkSID);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Initialize a runtime stack\n */\nEXTERN_C LIBEMLRT_API void emlrtEnterRtStackR2012b(emlrtCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Terminate a runtime stack\n */\nEXTERN_C LIBEMLRT_API void emlrtLeaveRtStackR2012b(emlrtCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Push to runtime stack\n */\nEXTERN_C LIBEMLRT_API void emlrtPushRtStackR2012b(const struct emlrtRSInfo* aRSInfo, emlrtCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Pop from runtime stack\n */\nEXTERN_C LIBEMLRT_API void emlrtPopRtStackR2012b(const struct emlrtRSInfo* aRSInfo, emlrtCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get the address of the Ctrl-C flag.\n */\nEXTERN_C LIBEMLRT_API const volatile char* emlrtGetBreakCheckFlagAddressR2012b(void);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check for Ctrl+C (break)\n */\nEXTERN_C LIBEMLRT_API void emlrtBreakCheckR2012b(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Issues interrupt signal to MATLAB as if by Ctrl+C\n */\nEXTERN_C LIBEMLRT_API void emlrtInterruptMATLAB(void);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Equality check for 1-D sizes\n */\nEXTERN_C LIBEMLRT_API void emlrtSizeEqCheck1DR2012b(int32_T dim1,\n                                                    int32_T dim2,\n                                                    emlrtECInfo* aInfo,\n                                                    emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Equality check error for size vectors\n */\nEXTERN_C LIBEMLRT_API void emlrtSizeEqCheckNDErrorR2021b(const int32_T* dims1,\n                                                         const int32_T* dims2,\n                                                         emlrtECInfo* aInfo,\n                                                         emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Equality check for size vectors\n */\nEXTERN_C LIBEMLRT_API void emlrtSizeEqCheckNDR2012b(const int32_T* dims1,\n                                                    const int32_T* dims2,\n                                                    emlrtECInfo* aInfo,\n                                                    emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: equality check\n */\nEXTERN_C LIBEMLRT_API void emlrtDimSizeEqCheckR2012b(int32_T dim1,\n                                                     int32_T dim2,\n                                                     emlrtECInfo* aInfo,\n                                                     emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: greater than or equal to check\n */\nEXTERN_C LIBEMLRT_API void emlrtDimSizeGeqCheckR2012b(int32_T dim1,\n                                                      int32_T dim2,\n                                                      emlrtECInfo* aInfo,\n                                                      emlrtConstCTX aTLS);\n/*\n * MATLAB INTERNAL USE ONLY :: equality or singleton check\n */\nEXTERN_C LIBEMLRT_API void emlrtDimSizeImpxCheckR2021b(int32_T dim1,\n                                                       int32_T dim2,\n                                                       emlrtECInfo* aInfo,\n                                                       emlrtConstCTX aTLS);\n/*\n * MATLAB INTERNAL USE ONLY :: Check size compatibility for A(I1,..IN) = B assignment in MATLAB.\n */\nEXTERN_C LIBEMLRT_API void emlrtSubAssignSizeCheckR2012b(const int32_T* dims1,\n                                                         int32_T nDims1,\n                                                         const int32_T* dims2,\n                                                         int32_T nDims2,\n                                                         emlrtECInfo* aInfo,\n                                                         emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check size compatibility for A(I) = B assignment in MATLAB.\n */\nEXTERN_C LIBEMLRT_API void emlrtSubAssignSizeCheck1dR2017a(int32_T dim1,\n                                                           int32_T dim2,\n                                                           emlrtECInfo* aInfo,\n                                                           emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Allocate thread-local storage.\n */\nEXTERN_C LIBEMLRT_API void* emlrtAllocTLS(emlrtConstCTX aMaster, int32_T aTeamTID);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Allocate thread local storage for a parallel region.\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtAllocRegionTLSs(emlrtCTX aTLS,\n                                                   boolean_T aInParallelRegion,\n                                                   int32_T aMaxThreads,\n                                                   int32_T aNumThreads);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Allocate the root thread-local storage.\n */\nEXTERN_C LIBEMLRT_API void emlrtUpdateCTX(emlrtConstCTX emlrtCtx, struct emlrtContext* aContext);\n\n\n/*\n * MATLAB INTERNAL USE ONLY :: Allocate the root thread-local storage.\n */\nEXTERN_C LIBEMLRT_API void emlrtCreateRootTLSR2022a(\n    emlrtCTX* aRootTLS,\n    struct emlrtContext* aContext,\n    EmlrtLockerFunction aLockerFunction,\n    int32_T aNumProcs,\n    void* aExceptionBridge,\n    const char* aCharacterEncoding,\n    boolean_T aCharacterEncodingSizeConsistencyEnabled);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Deallocate the root thread-local storage.\n */\nEXTERN_C LIBEMLRT_API void emlrtDestroyRootTLS(emlrtCTX* aRootTLS);\n\nEXTERN_C LIBEMLRT_API void emlrtSetIsInDestructor(emlrtCTX aTLS, bool aValue);\n\nEXTERN_C LIBEMLRT_API void emlrtShouldCleanupOnError(emlrtCTX aTLS, bool aValue);\n\nEXTERN_C LIBEMLRT_API void emlrtCleanupOnException(emlrtCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Set Jit Simulation Mode.\n */\nEXTERN_C LIBEMLRT_API void emlrtSetSimThruJIT(emlrtCTX aTLS, boolean_T aSimThruJIT);\n\nEXTERN_C LIBEMLRT_API char* emlrtExtractMessageId2015b(emlrtConstCTX aTLS,\n                                                       const struct emlrtMsgIdentifier* aMsgId);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the class of an mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckClass(const char* msgName,\n                                           const mxArray* pa,\n                                           const char* className);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the class of an mxArray pa to be exactly aClassName, otherwise\n * error out using aMsgId and aTLS.\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckMcosClass2017a(emlrtConstCTX aTLS,\n                                                    const emlrtMsgIdentifier* aMsgId,\n                                                    const mxArray* pa,\n                                                    const char* aClassName);\n/*\n * MATLAB INTERNAL USE ONLY :: Check the contents of two mxArrays to be equal.\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckCtMxArray2018b(emlrtConstCTX aTLS,\n                                                    const emlrtMsgIdentifier* aMsgId,\n                                                    const mxArray* rtArray,\n                                                    const mxArray* ctArray);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the size, class and complexness of an mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckBuiltInR2012b(emlrtConstCTX aTLS,\n                                                   const struct emlrtMsgIdentifier* aMsgId,\n                                                   const mxArray* pa,\n                                                   const char* className,\n                                                   boolean_T complex,\n                                                   uint32_T nDims,\n                                                   const void* pDims);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the size, class and complexness of a variable-size mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckVsBuiltInR2012b(emlrtConstCTX aTLS,\n                                                     const struct emlrtMsgIdentifier* aMsgId,\n                                                     const mxArray* pa,\n                                                     const char* className,\n                                                     boolean_T complex,\n                                                     uint32_T nDims,\n                                                     const void* pDims,\n                                                     const boolean_T* aDynamic,\n                                                     int32_T* aOutSizes);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the type of a FI mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckFiR2012b(emlrtConstCTX aTLS,\n                                              const struct emlrtMsgIdentifier* aMsgId,\n                                              const mxArray* aFi,\n                                              boolean_T aComplex,\n                                              uint32_T aNDims,\n                                              const void* aVDims,\n                                              const mxArray* aFimath,\n                                              const mxArray* aNumericType);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the type of a variable-size FI mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckVsFiR2012b(emlrtConstCTX aTLS,\n                                                const struct emlrtMsgIdentifier* aMsgId,\n                                                const mxArray* aFi,\n                                                boolean_T aComplex,\n                                                uint32_T aNDims,\n                                                const void* aVDims,\n                                                const boolean_T* aDynamic,\n                                                const mxArray* aFimath,\n                                                const mxArray* aNumericType);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the type of a static-size struct mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckStructR2012b(emlrtConstCTX aTLS,\n                                                  const emlrtMsgIdentifier* aMsgId,\n                                                  const mxArray* s,\n                                                  int32_T nFields,\n                                                  const char** fldNames,\n                                                  uint32_T nDims,\n                                                  const void* pDims);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the type of a variable-size struct mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckVsStructR2012b(emlrtConstCTX aTLS,\n                                                    const struct emlrtMsgIdentifier* aMsgId,\n                                                    const mxArray* s,\n                                                    int32_T nFields,\n                                                    const char** fldNames,\n                                                    uint32_T nDims,\n                                                    const void* pDims,\n                                                    const boolean_T* aDynamic,\n                                                    int32_T* aOutSizes);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the checksum of an mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckArrayChecksumR2018b(emlrtConstCTX,\n                                                         mxArray const*,\n                                                         boolean_T globalVar,\n                                                         int const*,\n                                                         const char**,\n                                                         uint32_T const*);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the type of a static-size struct mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckEnumR2012b(emlrtConstCTX aTLS,\n                                                const char* enumName,\n                                                int32_T nEnumElements,\n                                                const char** enumNames,\n                                                const int32_T* enumValues);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Import a character array.\n */\nEXTERN_C LIBEMLRT_API void emlrtImportCharArrayR2015b(emlrtConstCTX aTLS,\n                                                      const mxArray* aSrc,\n                                                      char_T* aDst,\n                                                      int32_T aNumel);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Import a character.\n */\nEXTERN_C LIBEMLRT_API void emlrtImportCharR2015b(emlrtConstCTX aTLS,\n                                                 const mxArray* aSrc,\n                                                 char_T* aDst);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Import an mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtImportArrayR2015b(emlrtConstCTX aTLS,\n                                                  const mxArray* aIn,\n                                                  void* aOutData,\n                                                  int32_T aElementSize,\n                                                  boolean_T aComplex);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Import an mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtImportArrayR2015b_SameComplex(emlrtConstCTX aTLS,\n                                                              const mxArray* aIn,\n                                                              void* aOutData,\n                                                              int32_T aElementSize);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Import a FI mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtImportVsFiArrayR2011b(const mxArray* aFiMx,\n                                                      const mxArray* aIntMx,\n                                                      void* aOutData,\n                                                      int32_T aElementSize,\n                                                      boolean_T aComplex,\n                                                      uint32_T nDimsMax,\n                                                      int32_T* aOutSizes);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Set the actual sizes of a dynamic FI array\n */\nEXTERN_C LIBEMLRT_API void emlrtSetVsFiSizes(const mxArray* aFi,\n                                             uint32_T nDimsExpected,\n                                             int32_T* aOutSizes);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get double uniform random values in (0,1)\n */\nEXTERN_C LIBEMLRT_API void emlrtRandu(real_T* const aRanduBuffer, const int32_T aNumel);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get double normal random values\n */\nEXTERN_C LIBEMLRT_API void emlrtRandn(real_T* const aRandnBuffer, const int32_T aNumel);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the type of a static-sized cell mxArray\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckCell(emlrtConstCTX aTLS,\n                                          const emlrtMsgIdentifier* aMsgId,\n                                          const mxArray* s,\n                                          uint32_T nDims,\n                                          const void* pDims,\n                                          const boolean_T* aDynamic);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check the type of a variable-sized cell mxArray\n * and assign the size of the mxArray to aOutSizes\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckVsCell(emlrtConstCTX aTLS,\n                                            const struct emlrtMsgIdentifier* aMsgId,\n                                            const mxArray* s,\n                                            uint32_T nDims,\n                                            const void* pDims,\n                                            const boolean_T* aDynamic,\n                                            int32_T* aOutSizes);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check a cell mxArray with unassigned base type\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckCellWithUnassignedBase(emlrtConstCTX aTLS,\n                                                            const struct emlrtMsgIdentifier* aMsgId,\n                                                            const mxArray* pa);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get the library path of a function pointer\n */\nEXTERN_C LIBEMLRT_API const char* emlrtGetLibraryPath(const void* pFcn);\n\n/*\n * MATLAB INTERNAL USE ONLY :: emlrt strlen function\n */\nEXTERN_C LIBEMLRT_API size_t emlrtStrlen(const char*);\n\n/*\n * MATLAB INTERNAL USE ONLY :: FFTW MEX Wrapper\n */\nEXTERN_C LIBEMLRT_API void* emlrtFFTWMalloc(size_t aSize);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTWFree(void* data);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Double 1D complex to complex FFT, this function assumes in and out to\n * be interleaved complex.\n */\nEXTERN_C LIBEMLRT_API void emlrtFFTW_1D_C2C(const real_T* in,\n                                            real_T* out,\n                                            int32_T stride,\n                                            int32_T fftLen,\n                                            int32_T ldx,\n                                            int32_T numFFT,\n                                            int32_T direction);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTW_1D_R2C(const real_T* in,\n                                            real_T* out,\n                                            int32_T stride,\n                                            int32_T fftLen,\n                                            int32_T ldx,\n                                            int32_T numFFT,\n                                            int32_T direction);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTW_1D_C2R(const real_T* in,\n                                            real_T* out,\n                                            int32_T stride,\n                                            int32_T fftLen,\n                                            int32_T ldx,\n                                            int32_T numFFT,\n                                            int32_T direction);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Float 1D complex to complex FFT, this function assumes in and out to\n * be interleaved complex.\n */\nEXTERN_C LIBEMLRT_API void emlrtFFTWF_1D_C2C(const real32_T* in,\n                                             real32_T* out,\n                                             int32_T stride,\n                                             int32_T fftLen,\n                                             int32_T ldx,\n                                             int32_T numFFT,\n                                             int32_T direction);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTWF_1D_R2C(const real32_T* in,\n                                             real32_T* out,\n                                             int32_T stride,\n                                             int32_T fftLen,\n                                             int32_T ldx,\n                                             int32_T numFFT,\n                                             int32_T direction);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTWF_1D_C2R(const real32_T* in,\n                                             real32_T* out,\n                                             int32_T stride,\n                                             int32_T fftLen,\n                                             int32_T ldx,\n                                             int32_T numFFT,\n                                             int32_T direction);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Setter and getter for FFTW plan method.\n */\nEXTERN_C LIBEMLRT_API const char* emlrtFFTWGetPlanMethod(void);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTWSetPlanMethod(const char* method);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Double FFTW plan import/export/delete.\n */\nEXTERN_C LIBEMLRT_API char* emlrtFFTWExportDoublePlan(void);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTWImportDoublePlan(const char* aPlanStr);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTWForgetDoublePlan(void);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Double FFTW plan import/export/delete.\n */\nEXTERN_C LIBEMLRT_API char* emlrtFFTWExportSinglePlan(void);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTWImportSinglePlan(const char* aPlanStr);\n\nEXTERN_C LIBEMLRT_API void emlrtFFTWForgetSinglePlan(void);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Force FFTW to run with single thread or not.\n */\nEXTERN_C LIBEMLRT_API void emlrtFFTWSetNumThreads(int32_T numThreads);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Check LXE profiler status\n */\nEXTERN_C LIBEMLRT_API void emlrtCheckProfilerStatus();\n\n#ifndef __cplusplus\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Profiling Function Entry\n */\nEXTERN_C LIBEMLRT_API void emlrtMEXProfilingFunctionEntry(const char* fcnUniqKey,\n                                                          boolean_T isMexOutdated);\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Profiling Function Exit\n */\nEXTERN_C LIBEMLRT_API void emlrtMEXProfilingFunctionExit(boolean_T isMexOutdated);\n\n#else\n// Need a sentinel class to make sure call stack is correct during stack unwinding\nstruct LIBEMLRT_API emlrtProfilerSentinel {\n    emlrtProfilerSentinel();\n    ~emlrtProfilerSentinel();\n\n    bool Initialized;\n    bool AlreadyExit;\n\n  private:\n    emlrtProfilerSentinel& operator=(const emlrtProfilerSentinel&);\n    emlrtProfilerSentinel(const emlrtProfilerSentinel&);\n};\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Profiling Function Entry\n */\nLIBEMLRT_API void emlrtMEXProfilingFunctionEntryCPP(const char* fcnUniqKey,\n                                                    boolean_T isMexOutdated,\n                                                    emlrtProfilerSentinel* aSentinel);\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Profiling Function Exit\n */\nLIBEMLRT_API void emlrtMEXProfilingFunctionExitCPP(emlrtProfilerSentinel* aSentinel);\n\n#endif\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Profiling Unregister Function\n */\nEXTERN_C LIBEMLRT_API void emlrtProfilerUnregisterMEXFcn(const char* fcnUniqKey,\n                                                         boolean_T isMexOutdated);\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Profiling Register Function\n */\nEXTERN_C LIBEMLRT_API void emlrtProfilerRegisterMEXFcn(const char* completeName,\n                                                       const char* aPath,\n                                                       const char* aFcnName,\n                                                       int32_T numLineNos,\n                                                       const int32_T* lineNos,\n                                                       boolean_T isMexOutdated);\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Profiling Profile Statement\n */\nEXTERN_C LIBEMLRT_API void emlrtMEXProfilingStatement(uint32_T aPoint, boolean_T isMexOutdated);\n\n/*\n * MATLAB INTERNAL USE ONLY :: MEX Profiling Check MEX File Outdated Function\n */\nEXTERN_C LIBEMLRT_API boolean_T emlrtProfilerCheckMEXOutdated(void);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Report a detected CUDA runtime error\n */\nEXTERN_C LIBEMLRT_API void emlrtCUDAError(uint32_T errcode,\n                                          const char* ename,\n                                          const char* emsg,\n                                          const emlrtRTEInfo* aInfo,\n                                          emlrtConstCTX aTLS);\n/*\n * MATLAB INTERNAL USE ONLY :: Report a detected CUDA runtime error as a warning\n * useful for capturing errors within destructors and throwing those as warnings, so that\n * MATLAB does not crash for MEX builds\n */\nEXTERN_C LIBEMLRT_API void emlrtCUDAWarning(uint32_T errcode,\n                                            const char* ename,\n                                            const char* emsg,\n                                            const emlrtRTEInfo* aInfo);\n/*\n * MATLAB INTERNAL USE ONLY :: Report a detected CUDA runtime error (light API)\n */\nEXTERN_C LIBEMLRT_API void emlrtThinCUDAError(uint32_T errcode,\n                                              const char* ename,\n                                              const char* emsg,\n                                              const char* paramname,\n                                              emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Wrapper of several mxArray Apis\n */\nEXTERN_C LIBEMLRT_API void* emlrtMxCalloc(size_t numEl, size_t elSize);\n\nEXTERN_C LIBEMLRT_API void emlrtMxFree(void* in);\n\nEXTERN_C LIBEMLRT_API mxArray* emlrtMxCreateString(const char* aStr);\n\nEXTERN_C LIBEMLRT_API mxArray* emlrtMxCreateDoubleScalar(double v);\n\nEXTERN_C LIBEMLRT_API void* emlrtMxGetData(const mxArray* aMxArray);\n\nEXTERN_C LIBEMLRT_API void emlrtMxSetData(mxArray* aMxArray, void* data);\n\nEXTERN_C LIBEMLRT_API real_T* emlrtMxGetPr(const mxArray* aMxArray);\n\nEXTERN_C LIBEMLRT_API boolean_T* emlrtMxGetLogicals(const mxArray* aMxArray);\n\nEXTERN_C LIBEMLRT_API void* emlrtMxGetImagData(const mxArray* aMxArray);\n\nEXTERN_C LIBEMLRT_API double* emlrtMxGetPi(const mxArray* aMxArray);\n\nEXTERN_C LIBEMLRT_API const mxArray* emlrtMexGetVariablePtr(const char* workspace,\n                                                            const char* varname);\n/*\n * MATLAB INTERNAL USE ONLY :: Initilize mxArray from multiword fixed point\n */\nEXTERN_C LIBEMLRT_API void emlrtInitMultiwordFXP(const mxArray* mxArray,\n                                                 const void* inData,\n                                                 int32_T scaleFactor);\n\n/*\n *  MATLAB INTERNAL USE ONLY :: Get environment variable\n */\nEXTERN_C LIBEMLRT_API char* emlrtGetEnv(const char* name);\n\n\n/*\n *  MATLAB INTERNAL USE ONLY :: Get environment variable\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtGetEnvR2022a(const char* aEncoding,\n                                                int32_T aSizeConsistencyEnabled,\n                                                const char* aName,\n                                                char* aValue);\n\n/*\n *  MATLAB INTERNAL USE ONLY :: Set environment variable\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtSetEnvR2022a(const char* aEncoding,\n                                                int32_T aSizeConsistencyEnabled,\n                                                const char* aName,\n                                                const char* aValue);\n\n/*\n *  MATLAB INTERNAL USE ONLY :: Character encoding conversion\n */\nEXTERN_C LIBEMLRT_API int32_T emlrtEncoding2Encoding(const char* aSrcEncoding,\n                                                     const char* aDstEncoding,\n                                                     int32_T aSizeConsistencyEnabled,\n                                                     int32_T aInputBufferLength,\n                                                     const char* aInputBuffer,\n                                                     char* aOutputBuffer);\n\n\nEXTERN_C LIBEMLRT_API void emlrtCaptureInputs(const mxArray** data,\n                                              int32_T numInputs,\n                                              void* aFcnPtr);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Create a numeric matrix mxGPUArray\n */\nEXTERN_C LIBEMLRT_API mxGPUArray* emlrtGPUCreateNumericArray(const char* className,\n                                                             boolean_T nComplexFlag,\n                                                             int32_T ndim,\n                                                             const void* pdim);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get read only GPU device pointer from mxGpuArray\n */\nEXTERN_C LIBEMLRT_API const void* emlrtGPUGetDataReadOnly(const mxGPUArray* inArray);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get GPU device pointer from mxGpuArray\n */\nEXTERN_C LIBEMLRT_API void* emlrtGPUGetData(mxGPUArray* inArray);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get class name from class id\n */\nEXTERN_C LIBEMLRT_API const char* emlrtClassIDToClassName(mxClassID classID);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Marshall input mxArray and return mxGPUArray\n */\nEXTERN_C LIBEMLRT_API const mxGPUArray* emlrt_marshallInGPU(emlrtConstCTX aTLS,\n                                                            const mxArray* inArray,\n                                                            const char* id,\n                                                            const char* className,\n                                                            boolean_T nComplexFlag,\n                                                            int32_T ndim,\n                                                            const void* pdim,\n                                                            boolean_T marshallByRef);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Marshall input mxArray and return mxGPUArray\n */\nEXTERN_C LIBEMLRT_API const mxGPUArray* emlrt_marshallInGPUVardim(emlrtConstCTX aTLS,\n                                                                  const mxArray* inArray,\n                                                                  const char* id,\n                                                                  const char* className,\n                                                                  boolean_T nComplexFlag,\n                                                                  int32_T ndim,\n                                                                  const void* pdim,\n                                                                  boolean_T marshallByRef,\n                                                                  const boolean_T* aDynamic,\n                                                                  int32_T* aOutSizes);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Marshall output mxGPUArray and return mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrt_marshallOutGPU(const mxGPUArray* inArray);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Marshall output mxGPUArray and return mxArray\n */\nEXTERN_C LIBEMLRT_API const mxArray* emlrt_marshallOutGPUVardim(mxGPUArray* const inArray,\n                                                                const int32_T aNDims,\n                                                                const int32_T* aOutSizes);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Destroy GPUArray\n */\nEXTERN_C LIBEMLRT_API void emlrtDestroyGPUArray(const mxGPUArray* inArray);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Deep copy of input to protect it when modified\n */\nEXTERN_C LIBEMLRT_API mxArray* emlrtProtectGPUArray(const mxArray* inArray);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Deep copy of mxGPUArray\n */\nEXTERN_C LIBEMLRT_API mxGPUArray* emlrtGPUCopyGPUArray(const mxGPUArray* inArray);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Load gpu library\n */\nEXTERN_C LIBEMLRT_API void emlrtInitGPU(emlrtConstCTX aTLS);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Exit Time Cleanup\n */\nEXTERN_C LIBEMLRT_API void emlrtExitTimeCleanup(struct emlrtContext*);\n\ntypedef struct emlrtTimespec {\n    double tv_sec;\n    double tv_nsec;\n} emlrtTimespec;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get time using monotonic clock\n */\nEXTERN_C LIBEMLRT_API int emlrtClockGettimeMonotonic(emlrtTimespec*);\n\ntypedef struct emlrtStructTm {\n    double tm_nsec;\n    double tm_sec;\n    double tm_min;\n    double tm_hour;\n    double tm_mday;\n    double tm_mon;\n    double tm_year;\n    boolean_T tm_isdst;\n} emlrtStructTm;\n\n/*\n * MATLAB INTERNAL USE ONLY :: Get wallclock time\n */\nEXTERN_C LIBEMLRT_API void emlrtWallclock(emlrtStructTm* aStructTm);\n\n#if defined(_WIN32) || defined(WIN32)\n/*\n * MATLAB INTERNAL USE ONLY :: Wrapper for nanosleep\n */\nEXTERN_C LIBEMLRT_API int emlrtSleepWin64(uint32_T aMilliSeconds);\n#else\n/*\n * MATLAB INTERNAL USE ONLY :: Wrapper for nanosleep\n */\nEXTERN_C LIBEMLRT_API int emlrtNanosleep(const emlrtTimespec*);\n#endif /* defined(_WIN32) || defined(WIN32) */\n\n/*\n * MATLAB INTERNAL USE ONLY :: Sleep for some duration\n */\nEXTERN_C LIBEMLRT_API int emlrtSleep(const emlrtTimespec* aEMLRTTimespec);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Pause for user input like pause()\n */\nEXTERN_C LIBEMLRT_API void emlrtPauseForInput(void);\n\nEXTERN_C LIBEMLRT_API mxArray* emlrtMxCPUtoGPU(const mxArray* pa);\n\nEXTERN_C LIBEMLRT_API mxArray* emlrtMxGPUtoCPU(const mxArray* pa);\n\n/*\n * MATLAB INTERNAL USE ONLY :: Profiling instrumentation APIs\n */\nEXTERN_C LIBEMLRT_API void emlrtProfilingEnterFunction(const char* function,\n                                                       uint32_T nBlocks,\n                                                       uint32_T staticSize,\n                                                       const char* filename,\n                                                       uint32_T line);\n\n#ifdef INT_TYPE_64_IS_SUPPORTED\nEXTERN_C LIBEMLRT_API void emlrtProfilingNode(uint64_T aSequenceId,\n                                              uint64_T aNodeId,\n                                              uint64_T aTypeSequenceId,\n                                              const char* aSid);\n\nEXTERN_C LIBEMLRT_API void emlrtProfilingNamedNode(uint64_T aSequenceId,\n                                                   uint64_T aNodeId,\n                                                   uint64_T aTypeSequenceId,\n                                                   const char* aSid,\n                                                   const char* aName);\n\nEXTERN_C LIBEMLRT_API void emlrtProfilingType(uint64_T aTypeSequenceId,\n                                              uint64_T aTypeClassId,\n                                              uint64_T aTypeInstanceId,\n                                              uint64_T aTypeSize,\n                                              const char* aName);\n\nEXTERN_C LIBEMLRT_API void emlrtProfilingDMTypeDimension(uint64_T aTypeSequenceId,\n                                                         uint64_T aNodeId,\n                                                         uint32_T aDimension,\n                                                         uint64_T aElementCount);\n\n#endif\n\nEXTERN_C LIBEMLRT_API void emlrtProfilingExitFunction(void);\n\nEXTERN_C LIBEMLRT_API void emlrtProfilingStart(void);\nEXTERN_C LIBEMLRT_API void emlrtProfilingSave(void);\nEXTERN_C LIBEMLRT_API void emlrtProfilingFinish(void);\nEXTERN_C LIBEMLRT_API void emlrtProfilingClear(void);\n\n/*\n * MATLAB INTERNAL USE ONLY :: mxClassID for half mxArray.\n */\n\n#ifndef mxHALF_CLASS\n#define mxHALF_CLASS ((mxClassID)(-2357))\n#endif\n\n#endif /* emlrt_h */\n"},{"name":"engine.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1984-2017 The MathWorks, Inc.\n */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef PUBLISHED_EXTERN_API_HPP\n#define PUBLISHED_EXTERN_API_HPP\n\n#if defined(BUILDING_LIBENG)\n #define LIBMWENGINE_PUBLISHED_API DLL_EXPORT_SYM\n#else\n #define LIBMWENGINE_PUBLISHED_API\n#endif\n\n#ifndef EXTERN_C\n #ifdef __cplusplus\n  #define EXTERN_C extern \"C\"\n #else\n  #define EXTERN_C extern\n #endif\n#endif\n\n#ifndef LIBMWENGINE_PUBLISHED_API_EXTERN_C\n #define LIBMWENGINE_PUBLISHED_API_EXTERN_C EXTERN_C LIBMWENGINE_PUBLISHED_API\n#endif\n\n\n#include \"matrix.h\"\n\ntypedef struct engine Engine;\n\n/* Execute matlab statement */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C int engEvalString(Engine *ep,\n  const char *string);\n\n/* Start matlab process for single use.\n   Not currently supported on UNIX. */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C Engine *engOpenSingleUse(\n  const char *startcmd, void *reserved, int *retstatus);\n\n/* SetVisible, do nothing since this function is only for NT  */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C int engSetVisible(Engine *ep, bool newVal);\n\n/* GetVisible, do nothing since this function is only for NT */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C int engGetVisible(Engine *ep, bool* bVal);\n\n/* Start matlab process */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C Engine *engOpen(const char *startcmd);\n\n/* Start matlab process */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C Engine *fengOpen(const char *startcmd);\n\n/* Close down matlab server */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C int engClose(Engine *ep);\n\n/* Get a variable with the specified name from MATLAB's workspace */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C mxArray *engGetVariable(\n  Engine *ep, const char *name);\n\n/* Put a variable into MATLAB's workspace with the specified name */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C int engPutVariable(Engine *ep,\n  const char *var_name, const mxArray *ap);\n\n/* register a buffer to hold matlab text output */\nLIBMWENGINE_PUBLISHED_API_EXTERN_C int engOutputBuffer(Engine *ep,\n  char *buffer, int buflen);\n\n#endif /* PUBLISHED_EXTERN_API_HPP */\n"},{"name":"ext_share.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/* File: ext_share.h\n * Absract:\n *\tExternal mode shared data structures used by the external communication\n *\tmex link, the generated code, and Simulink.\n *\n * Copyright 1994-2020 The MathWorks, Inc.\n *\n */\n\n#ifndef EXTSHARE\n#define EXTSHARE\n\ntypedef enum {\n    /*================================\n     * Packets/actions to target.\n     *==============================*/\n\n    /* connection actions */\n    EXT_CONNECT,\n    EXT_DISCONNECT_REQUEST,\n    EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD,\n    EXT_DISCONNECT_CONFIRMED,\n\n    /* parameter upload/download actions */\n    EXT_SETPARAM,\n    EXT_GETPARAMS,\n\n    /* data upload actions */\n    EXT_SELECT_SIGNALS,\n    EXT_SELECT_TRIGGER,\n    EXT_ARM_TRIGGER,\n    EXT_CANCEL_LOGGING,\n\n    /* model control actions */\n    EXT_MODEL_START,\n    EXT_MODEL_STOP,\n    EXT_MODEL_PAUSE,\n    EXT_MODEL_STEP,\n    EXT_MODEL_CONTINUE,\n\n    /* data request actions */\n    EXT_GET_TIME,\n\n    /*================================\n     * Packets/actions from target.\n     *==============================*/\n\n    /* responses */\n    EXT_CONNECT_RESPONSE, /* must not be 0! */\n    EXT_DISCONNECT_REQUEST_RESPONSE,\n    EXT_SETPARAM_RESPONSE,\n    EXT_GETPARAMS_RESPONSE,\n    EXT_MODEL_SHUTDOWN,\n    EXT_GET_TIME_RESPONSE,\n    EXT_MODEL_START_RESPONSE,\n    EXT_MODEL_PAUSE_RESPONSE,\n    EXT_MODEL_STEP_RESPONSE,\n    EXT_MODEL_CONTINUE_RESPONSE,\n    EXT_UPLOAD_LOGGING_DATA,\n    EXT_SELECT_SIGNALS_RESPONSE,\n    EXT_SELECT_TRIGGER_RESPONSE,\n    EXT_ARM_TRIGGER_RESPONSE,\n    EXT_CANCEL_LOGGING_RESPONSE,\n\n    /*\n     * This packet is sent from the target to signal the end of a data\n     * collection event (e.g., each time that the duration is reached).\n     * This packet only applies to normal mode (see\n     * EXT_TERMINATE_LOG_SESSION)\n     */\n    EXT_TERMINATE_LOG_EVENT,\n\n    /*\n     * This packet is sent from the target at the end of each data logging\n     * session.  This occurs either at the end of a oneshot or at the end\n     * of normal mode (i.e., the last in a series of oneshots).\n     */\n    EXT_TERMINATE_LOG_SESSION,\n\n    /*\n     * This packet header is used only in DAEMON_MODE.\n     * This is sent from the target to the host after receiving a chunk of\n     * data. The host pauses sending data until it receives this\n     * acknowledgement packet.\n     */\n    EXT_DAEMON_ACK,\n\n    EXTENDED = 255 /* reserved for extending beyond 254 ID's */\n} ExtModeAction;\n\n\ntypedef enum { STATUS_OK, NOT_ENOUGH_MEMORY } ResponseStatus;\n\ntypedef enum { LittleEndian, BigEndian } MachByteOrder;\n\n#ifndef TARGETSIMSTATUS_DEFINED\n#define TARGETSIMSTATUS_DEFINED\ntypedef enum {\n    TARGET_STATUS_NOT_CONNECTED,\n    TARGET_STATUS_WAITING_TO_START,\n    TARGET_STATUS_STARTING, /* in the process of starting - host waiting\n                               for confirmation */\n\n    TARGET_STATUS_RUNNING,\n    TARGET_STATUS_PAUSED\n} TargetSimStatus;\n#endif\n\n/*\n * The packet header consists of 2 32 bit unsigned ints [type, size].  size\n * is the number of bytes coming after the header.  It is always expressed\n * in target bytes.\n */\ntypedef struct PktHeader_tag {\n    uint32_T type; /* packet type */\n    uint32_T size; /* number of bytes to follow */\n} PktHeader;\n#define NUM_HDR_ELS (2)\n\n#ifndef FALSE\nenum { FALSE, TRUE };\n#endif\n\n#define NO_ERR (0)\n\n#define EXT_NO_ERROR ((boolean_T)(0))\n#define EXT_ERROR ((boolean_T)(1))\n\n#define UNKNOWN_BYTES_NEEDED (-1)\n\n#ifndef __cplusplus /* see g2161154 */\n#define PRIVATE static\n#define PUBLIC\n#endif /* __cpluscplus */\n\n#endif /* __EXTSHARE__ */\n"},{"name":"ext_svr.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2008 The MathWorks, Inc.\n *\n * File: ext_svr.h     \n *\n * Abstract:\n *\tFunction prototypes for provided TCP socket based external mode\n *      implementation.\n */\n\n#ifndef __EXT_SVR__\n#define __EXT_SVR__\n\n#include \"ext_share.h\"\n\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\nextern boolean_T SendPktToHost(const ExtModeAction action,\n                               const int           size,\n                               const char          *data);\n\nextern boolean_T rt_ExtModeInit(void);\n\nextern void      rt_PktServerWork(RTWExtModeInfo *ei,\n                                  int_T          numSampTimes,\n                                  boolean_T      *stopReq);\n\nextern void      rt_UploadServerWork(int_T numSampTimes);\n\nextern boolean_T rt_ExtModeShutdown(int_T numSampTimes);\n\nextern void      rt_UploadCheckTrigger(int_T numSampTimes);\n\nextern void      rt_UploadCheckEndTrigger(void);\n\nextern void      rt_UploadBufAddTimePoint(int_T tid,\n                                          real_T taskTime);\n\n#ifndef VXWORKS\nextern void      rt_ExtModeSleep(long sec,   /* number of seconds to wait      */\n                                 long usec); /* number of micro seconds to wait*/\n#else\nextern void      rt_UploadServer(int_T numSampTimes);\n\nextern void      rt_PktServer(RTWExtModeInfo *ei,\n                              int_T          numSampTimes,\n                              boolean_T      *stopReq);\n\nextern void      rt_SetPortInExtUD(const int_T port);\n#endif\n\nextern const char_T *ExtParseArgsAndInitUD(const int_T  argc,\n                                           const char_T *argv[]);\nextern boolean_T  ExtWaitForStartPkt(void);\n\n#ifdef __cplusplus\n\n}\n#endif\n\n#endif /* __EXT_SVR__ */\n\n/* [EOF] ext_svr.h */\n"},{"name":"ext_svr_transport.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2002 The MathWorks, Inc.\n *\n * File: ext_svr_transport.h     \n *\n * Abstract:\n *  PUBLIC interface for ext_svr_transport.c.\n */\n\n/********************* DO NOT CHANGE BELOW THIS LINE **************************\n *                                                                            *\n * The function prototypes below define the interface between the target-     *\n * side external mode and ext_svr_transport.  They should not need to be      *\n * changed.  Only the implementation of these functions in ext_svr_transport.c*\n * should need to be modified.                                                *\n *                                                                            *\n ******************************************************************************/\n\n/*\n * Export the user data as an 'opaque' or 'incomplete' data type.  ext_svr\n * may reference it (i.e., pass pointers to it, but it can not dereference\n * the pointer).\n */\ntypedef struct ExtUserData_tag ExtUserData;\n\n\n/*\n * Define the transport interface.\n */\n\nextern boolean_T ExtInit(ExtUserData *UD);\n\nextern boolean_T ExtOpenConnection(\n    ExtUserData *UD,\n    boolean_T   *outConnectionMade);\n\nextern void ExtCloseConnection(ExtUserData *UD);\n\nextern void ExtShutDown(ExtUserData *UD);\n\nextern const char_T *ExtProcessArgs(\n    ExtUserData   *UD,\n    const int_T   argc,\n    const char_T  *argv[]);\n\nextern boolean_T ExtWaitForStartPktFromHost(ExtUserData *UD);\n\nextern ExtUserData *ExtUserDataCreate(void);\n\nextern void ExtUserDataDestroy(ExtUserData *userData);\n\n#ifdef VXWORKS\nextern void ExtUserDataSetPort(ExtUserData *UD, const int_T port);\n#endif\n\nextern boolean_T ExtGetHostPkt(\n    const ExtUserData *UD,\n    const int         nBytesToGet,\n    int               *nBytesGot,\n    char              *dst);\n\nextern boolean_T ExtSetHostPkt(\n    const ExtUserData *UD,\n    const int         nBytesToSet,\n    const char        *src,\n    int               *nBytesSet);\n\nextern void ExtModeSleep(\n    const ExtUserData *UD,\n    const long        sec,  \n    const long        usec);\n\nextern void ExtForceDisconnect(ExtUserData *UD);\n\n"},{"name":"ext_test.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2002 The MathWorks, Inc.\n *\n * File: ext_test.h     \n *\n * Abstract:\n *   \n */\n\n#ifndef __EXT_TEST_OBJECT__\n#define __EXT_TEST_OBJECT__\n\n#ifdef TMW_EXTMODE_TESTING\nextern void rtExtModeTestingInit(void);\nextern void rtExtModeTestingKillIfOrphaned(boolean_T pktReceived);\nextern void rtExtModeTestingRemoveBatMarker(void);\n#else\n#define rtExtModeTestingInit()                      /* do nothing */\n#define rtExtModeTestingKillIfOrphaned(pktReceived) /* do nothing */\n#define rtExtModeTestingRemoveBatMarker()           /* do nothing */\n#endif\n\n#endif /* __EXT_TEST_OBJECT__ */\n"},{"name":"ext_types.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2004 The MathWorks, Inc.\n *\n * File: ext_types.h     \n *\n * Abstract:\n */\n\n#ifndef __EXT_TYPES__\n#define __EXT_TYPES__\n\n/* Additional types required for Simulink External Mode */\n#ifndef fcn_call_T\n# define fcn_call_T real_T\n#endif\n#ifndef action_T\n# define action_T real_T\n#endif\n\n/****************************************\n * Dynamic vs. Static memory allocation *\n ****************************************/\n#if defined(EXTMODE_STATIC) && !defined(XCP_MEM_DAQ_RESERVED_POOLS_NUMBER)\n#  include \"mem_mgr.h\"\n#  include <stdlib.h>\n#  define malloc ExtModeMalloc\n#  define calloc ExtModeCalloc\n#  define free   ExtModeFree\n#endif\n\n/****************************************\n * Integer only code                    *\n ****************************************/\n#ifdef EXT_MODE\n#  if INTEGER_CODE == 1\n#    undef  real_T\n#    define real_T int32_T\n\n#    undef  real32_T\n#    define real32_T int32_T\n\n#    undef  double\n#    define double int32_T\n\n#    undef  time_T\n#    define time_T int32_T\n\n#    undef rtmGetTFinal\n#    define rtmGetTFinal(E) (((E)->extModeInfo->tFinalTicks))\n\n#  endif /* INTEGER_CODE == 1 */\n#endif /* #ifdef EXTMODE */\n\n\n#endif /* __EXT_TYPES__ */\n\n/* [EOF] ext_types.h */\n"},{"name":"ext_work.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2012 The MathWorks, Inc.\n *\n * File: ext_work.h     \n *\n * Abstract:\n *   \n */\n\n#ifndef __EXT_WORK_OBJECT__\n#define __EXT_WORK_OBJECT__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef EXT_MODE\n#include \"ext_types.h\"\n\n#if defined(VXWORKS)\n    /*VxWorks headers*/\n    #include <vxWorks.h>\n    #include <taskLib.h>\n    #include <sysLib.h>\n    #include <semLib.h>\n    #include <rebootLib.h>\n    #include <logLib.h>\n\n    extern void rtExtModeTornadoStartup(RTWExtModeInfo *ei,\n                                        int_T          numSampTimes,\n                                        boolean_T      *stopReqPtr,\n                                        int_T          priority,\n                                        int32_T        stack_size,\n                                        SEM_ID         startStopSem);\n\n    extern void rtExtModeTornadoCleanup(int_T numSampTimes);\n\n    extern void rtExtModeTornadoSetPortInExtUD(const int_T port);\n\n#elif defined(C6000_EXT_MODE)\n    /* C6000 headers*/\n    #include <std.h>\n    #include <stddef.h>\n    #include <sem.h>\n\n    extern void rtExtModeC6000Startup( RTWExtModeInfo *ei,\n                                       int_T          numSampTimes,\n                                       boolean_T      *stopReqPtr);\n\n    extern void rtExtModeC6000Cleanup(int_T numSampTimes);\n#else\n    extern void rtExtModePauseIfNeeded(RTWExtModeInfo *ei,\n                                       int_T          numSampTimes,\n                                       boolean_T      *stopReqPtr);\n\n    extern void rtExtModeWaitForStartPkt(RTWExtModeInfo *ei,\n                                         int_T          numSampTimes,\n                                         boolean_T      *stopReqPtr);\n    void rtExtModeInitUD(void);\n#endif /* #if defined(VXWORKS) */\n\nextern void rtExtModeOneStep(RTWExtModeInfo *ei,\n                             int_T          numSampTimes,\n                             boolean_T      *stopReqPtr);\n\nextern void rtExtModeCheckEndTrigger(void);\n\nextern void rtExtModeUploadCheckTrigger(int_T numSampTimes);\n\nextern void rtExtModeUpload(int_T tid,\n                            real_T taskTime);\n\nextern void rtExtModeCheckInit(int_T numSampTimes);\n\nextern void rtExtModeShutdown(int_T numSampTimes);\n\nextern void rtExtModeParseArgs(int_T        argc, \n                               const char_T *argv[],\n                               real_T       *rtmFinal);\n\nextern void rtERTExtModeSetTFinal(real_T *rtmTFinal);\nextern void rtSetTFinalForExtMode(real_T *rtmTFinal);\n\nextern void rtParseArgsForExtMode(int_T        argc, \n                                  const char_T *argv[]);\n\nextern void rtERTExtModeStartMsg(void);\n\n#else /* #ifdef EXTMODE */\n\n#if defined(VXWORKS)\n    #define rtExtModeTornadoStartup(ei,                          \\\n                                    numSampTimes,                \\\n                                    stopReqPtr,                  \\\n                                    priority,                    \\\n                                    stack_size,                  \\\n                                    startStopSem) /* do nothing */\n    #define rtExtModeTornadoCleanup(numSampTimes); /* do nothing */\n    #define rtExtModeTornadoSetPortInExtUD(port); /* do nothing */\n#elif defined(C6000_EXT_MODE)  \n    #define rtExtModePauseIfNeeded(ei,st,sr) /* do nothing */\n    #define rtExtModeWaitForStartPkt(ei,st,sr) /* do nothing */\n#else\n    #define rtExtModePauseIfNeeded(ei,st,sr) /* do nothing */\n    #define rtExtModeWaitForStartPkt(ei,st,sr) /* do nothing */\n#endif /* #ifdef VXWORKS */\n\n#define rtExtModeOneStep(ei,st,sr) /* do nothing */\n#define rtExtModeCheckEndTrigger() /* do nothing */\n#define rtExtModeUploadCheckTrigger(numSampTimes) /* do nothing */\n#define rtExtModeUpload(t,ttime) /* do nothing */\n#define rtExtModeCheckInit(numSampTimes) /* do nothing */\n#define rtExtModeShutdown(numSampTimes) /* do nothing */\n#define rtExtModeParseArgs(argc, argv, tf); /* do nothing */\n#define rtERTExtModeSetTFinal(tf); /* do nothing */\n#define rtSetTFinalForExtMode(tf); /* do nothing */\n#define rtParseArgsForExtMode(argc, argv); (void)(argc); \\\n                                           (void)(argv);\n#define rtERTExtModeStartMsg(); /* do nothing */\n\n#endif  /* #ifdef EXTMODE */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __EXT_WORK_OBJECT__ */\n"},{"name":"fintrf.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"\n#ifndef MXHBB__RELEASE_VERSION_DETECTOR__\n#define MXHBB__RELEASE_VERSION_DETECTOR__\n\n#define MW_FIRST_API_VERSION 700\n#define R2017b 700\n#define R2018a 800\n#define R2018b 800\n#define R2019a 800\n#define R2019b 800\n#define R201aa 800\n#define R201ab 800\n#define R201ba 800\n#define R201bb 800\n#define R201ca 800\n#define R201cb 800\n#define R201da 800\n#define R201db 800\n#define R201ea 800\n#define R201eb 800\n#define R201fa 800\n#define R201fb 800\n#define R2020a 800\n#define R2020b 800\n#define R2021a 800\n#define R2021b 800\n#define MW_LATEST_API_VERSION 800\n\n\n#define MW_REL2VER(A) A \n\n#if defined(MX_COMPAT_32) || defined(MEX_DOUBLE_HANDLE)\n\n#if defined(MATLAB_MEXCMD_RELEASE) || defined(MATLAB_MEXSRC_RELEASE)\n\n/* Errors! Legacy knobs cannot be used with release-based hard knobs */\n\n#if defined(MX_COMPAT_32) && defined(MATLAB_MEXCMD_RELEASE)\n#error \"MEX command option -R20XXx is incompatible with MX_COMPAT_32\"\n#endif\n\n#if defined(MEX_DOUBLE_HANDLE) && defined(MATLAB_MEXCMD_RELEASE)\n#error \"MEX command option -R20XXx is incompatible with MEX_DOUBLE_HANDLE\"\n#endif\n\n#if defined(MX_COMPAT_32) && defined(MATLAB_MEXSRC_RELEASE)\n#error \"Source code macro MATLAB_MEXSRC_RELEASE is incompatible with MX_COMPAT_32\"\n#endif\n\n#if defined(MEX_DOUBLE_HANDLE) && defined(MATLAB_MEXSRC_RELEASE)\n#error \"Source code macro MATLAB_MEXSRC_RELEASE is incompatible with MEX_DOUBLE_HANDLE\"\n#endif\n\n#else\n\n/* Legacy knobs are defined  */\n\n#define MATLAB_TARGET_API_VERSION MW_FIRST_API_VERSION\n\n#endif\n\n#else /* defined(MX_COMPAT_32) || defined(MEX_DOUBLE_HANDLE) */\n\n/* No Legacy knobs. Check release-based tag */\n\n#if defined(MATLAB_MEXCMD_RELEASE)\n#define MW_MEXCMD_VERSION MW_REL2VER(MATLAB_MEXCMD_RELEASE)\n#if MW_MEXCMD_VERSION < MW_FIRST_API_VERSION\n#error invalid MATLAB_MEXCMD_RELEASE definition\n#endif\n#endif\n\n#if defined(MATLAB_MEXSRC_RELEASE)\n#define MW_MEXSRC_VERSION MW_REL2VER(MATLAB_MEXSRC_RELEASE)\n#if MW_MEXSRC_VERSION < MW_FIRST_API_VERSION\n#error invalid MATLAB_MEXSRC_RELEASE definition\n#endif\n#endif\n      \n#if defined(MATLAB_DEFAULT_RELEASE)\n#define MW_DEFAULT_VERSION MW_REL2VER(MATLAB_DEFAULT_RELEASE)\n#if MW_DEFAULT_VERSION < MW_FIRST_API_VERSION\n#error invalid MATLAB_DEFAULT_RELEASE definition\n#endif\n#endif\n\n#if defined(MATLAB_MEXCMD_RELEASE) && defined(MATLAB_MEXSRC_RELEASE)\n#if MW_MEXCMD_VERSION != MW_MEXSRC_VERSION\n#error \"MEX command option -R20XXx is incompatible with MATLAB_MEXSRC_RELEASE\"\n#endif\n#endif\n\n#if defined(MATLAB_MEXCMD_RELEASE) || defined(MATLAB_MEXSRC_RELEASE)\n\n/* Check whether MEXCMD and MEXSRC release tags are compatible */\n\n#if defined(MATLAB_MEXCMD_RELEASE)\n#define MATLAB_TARGET_API_VERSION MW_MEXCMD_VERSION\n#else\n#define MATLAB_TARGET_API_VERSION MW_MEXSRC_VERSION\n#endif\n\n#else /* defined(MATLAB_MEXCMD_RELEASE) || defined(MATLAB_MEXSRC_RELEASE) */\n\n#if defined(MATLAB_DEFAULT_RELEASE)\n#define MATLAB_TARGET_API_VERSION MW_DEFAULT_VERSION\n#else\n\n/* None of the input macros are defined. Use LATEST */\n#define MATLAB_TARGET_API_VERSION MW_LATEST_API_VERSION\n\n#endif /* defined(MATLAB_DEFAULT_RELEASE) */\n\n#endif /* defined(MATLAB_MEXCMD_RELEASE) || defined(MATLAB_MEXSRC_RELEASE) */\n\n#endif /* defined(MX_COMPAT_32) || defined(MEX_DOUBLE_HANDLE) */\n\n#if defined(TARGET_API_VERSION)\n#if MATLAB_TARGET_API_VERSION != TARGET_API_VERSION\n#error MATLAB_TARGET_API_VERSION != TARGET_API_VERSION\n#endif\n#else\n#define TARGET_API_VERSION MATLAB_TARGET_API_VERSION\n#endif\n\n#endif /* MXHBB__RELEASE_VERSION_DETECTOR__ */\n#if defined(WITH_COMMENTS)\n/*\n * fintrf.h\t- MATLAB/FORTRAN interface header file. This file\n *\t\t  contains the declaration of the pointer type needed\n *\t\t  by the MATLAB/FORTRAN interface.\n *\n * Copyright 1984-2018 The MathWorks, Inc.\n * All Rights Reserved.\n */\n#endif\n#if defined(__LP64__) || defined(_M_AMD64) || defined(__amd64)\n# define mwpointer integer*8\n# define mwPointer integer*8\n# define MWPOINTER INTEGER*8\n#else\n# define mwpointer integer*4\n# define mwPointer integer*4\n# define MWPOINTER INTEGER*4\n#endif\n\n#if defined(MX_COMPAT_32)\n# define mwsize  integer*4\n# define mwSize  integer*4\n# define MWSIZE  INTEGER*4\n# define mwindex integer*4\n# define mwIndex integer*4\n# define MWINDEX INTEGER*4\n# define mwsignedindex integer*4\n# define mwSignedIndex integer*4\n# define MWSIGNEDINDEX INTEGER*4\n#else\n# define mwsize  mwpointer\n# define mwSize  mwpointer\n# define MWSIZE  MWPOINTER\n# define mwindex mwpointer\n# define mwIndex mwpointer\n# define MWINDEX MWPOINTER\n# define mwsignedindex mwpointer\n# define mwSignedIndex mwpointer\n# define MWSIGNEDINDEX MWPOINTER\n#endif\n\n#if defined(TARGET_API_VERSION)\n#if !(TARGET_API_VERSION == 700 || TARGET_API_VERSION == 800)\n#error invalid TARGET_VERSION_API definition\n#elif defined(MEX_DOUBLE_HANDLE) && TARGET_API_VERSION != 700\n#error It is illegal to use MEX_DOUBLE_HANDLE with linear versioning\n#elif defined(MX_COMPAT_32) && TARGET_API_VERSION != 700\n#error It is illegal to use MX_COMPAT_32 with linear versioning\n#endif\n#endif\n\n#if TARGET_API_VERSION == 800\n\n#if defined(WITH_COMMENTS)\n/*\n * Interleaved Complex (IC) mxArray APIs\n */\n#endif\n\n#define mxGetPi mxGetPiIsDeprecated\n#define MXGETPI MXGETPIISDEPRECATED\n#define mxgetpi mxgetpiisdeprecated\n#define mxSetPi mxSetPiIsDeprecated\n#define MXSETPI MXSETPIISDEPRECATED\n#define mxsetpi mxsetpiisdeprecated\n#define mxGetImageData mxGetImagDataIsDeprecated\n#define MXGETIMAGEDATA MXGETIMAGDATAISDEPRECATED\n#define mxgetimagedata mxgetimagdataisdeprecated\n#define mxSetImageData mxSetImagDataIsDeprecated\n#define MXSETIMAGEDATA MXSETIMAGDATAISDEPRECATED\n#define mxsetimagedata mxsetimagdataisdeprecated\n#define mxCreateFull mxCreateFullDeprecated\n#define MXCREATEFULL MXCREATEFULLDEPRECATED\n#define mxcreatefull mxcreatefulldeprecated\n\n#define mxFree mxFree800\n#define MXFREE MXFREE800\n#define mxfree mxfree800\n#define mxDestroyArray mxDestroyArray800\n#define MXDESTROYARRAY MXDESTROYARRAY800\n#define mxdestroyarray mxdestroyarray800\n#define mxCreateString mxCreateString800\n#define MXCREATESTRING MXCREATESTRING800\n#define mxcreatestring mxcreatestring800\n#define mxCreateDoubleScalar mxCreateDoubleScalar800\n#define MXCREATEDOUBLESCALAR MXCREATEDOUBLESCALAR800\n#define mxcreatedoublescalar mxcreatedoublescalar800\n#define mxIsDouble mxIsDouble800\n#define MXISDOUBLE MXISDOUBLE800\n#define mxisdouble mxisdouble800\n#define mxIsSingle mxIsSingle800\n#define MXISSINGLE MXISSINGLE800\n#define mxissingle mxissingle800\n#define mxIsNumeric mxIsNumeric800\n#define MXISNUMERIC MXISNUMERIC800\n#define mxisnumeric mxisnumeric800\n#define mxIsInt64 mxIsInt64800\n#define MXISINT64 MXISINT64800\n#define mxisint64 mxisint64800\n#define mxIsUint64 mxIsUint64800\n#define MXISUINT64 MXISUINT64800\n#define mxisuint64 mxisuint64800\n#define mxIsInt32 mxIsInt32800\n#define MXISINT32 MXISINT32800\n#define mxisint32 mxisint32800\n#define mxIsUint32 mxIsUint32800\n#define MXISUINT32 MXISUINT32800\n#define mxisuint32 mxisuint32800\n#define mxIsInt16 mxIsInt16800\n#define MXISINT16 MXISINT16800\n#define mxisint16 mxisint16800\n#define mxIsUint16 mxIsUint16800\n#define MXISUINT16 MXISUINT16800\n#define mxisuint16 mxisuint16800\n#define mxIsInt8 mxIsInt8800\n#define MXISINT8 MXISINT8800\n#define mxisint8 mxisint8800\n#define mxIsUint8 mxIsUint8800\n#define MXISUINT8 MXISUINT8800\n#define mxisuint8 mxisuint8800\n#define mxIsChar mxIsChar800\n#define MXISCHAR MXISCHAR800\n#define mxischar mxischar800\n#define mxIsLogical mxIsLogical800\n#define MXISLOGICAL MXISLOGICAL800\n#define mxislogical mxislogical800\n#define mxIsSparse mxIsSparse800\n#define MXISSPARSE MXISSPARSE800\n#define mxissparse mxissparse800\n#define mxIsStruct mxIsStruct800\n#define MXISSTRUCT MXISSTRUCT800\n#define mxisstruct mxisstruct800\n#define mxIsCell mxIsCell800\n#define MXISCELL MXISCELL800\n#define mxiscell mxiscell800\n#define mxIsClass mxIsClass800\n#define MXISCLASS MXISCLASS800\n#define mxisclass mxisclass800\n#define mxisfinite mxisfinite800\n#define MXISFINITE MXISFINITE800\n#define mxisfinite mxisfinite800\n#define mxIsInf mxIsInf800\n#define MXISINF MXISINF800\n#define mxisinf mxisinf800\n#define mxIsNaN mxIsNaN800\n#define MXISNAN MXISNAN800\n#define mxisnan mxisnan800\n#define mxIsEmpty mxIsEmpty800\n#define MXISEMPTY MXISEMPTY800\n#define mxisempty mxisempty800\n#define mxIsFromGlobalWS mxIsFromGlobalWS800\n#define MXISFROMGLOBALWS MXISFROMGLOBALWS800\n#define mxisfromglobalws mxisfromglobalws800\n#define mxGetNaN mxGetNaN800\n#define MXGETNAN MXGETNAN800\n#define mxgetnan mxgetnan800\n#define mxGetClassId mxGetClassId800\n#define MXGETCLASSID MXGETCLASSID800\n#define mxgetclassid mxgetclassid800\n#define mxGetClassName mxGetClassName800\n#define MXGETCLASSNAME MXGETCLASSNAME800\n#define mxgetclassname mxgetclassname800\n#define mxGetNumberOfFields mxGetNumberOfFields800\n#define MXGETNUMBEROFFIELDS MXGETNUMBEROFFIELDS800\n#define mxgetnumberoffields mxgetnumberoffields800\n#define mxGetFieldNameByNumber mxGetFieldNameByNumber800\n#define MXGETFIELDNAMEBYNUMBER MXGETFIELDNAMEBYNUMBER800\n#define mxgetfieldnamebynumber mxgetfieldnamebynumber800\n#define mxGetFieldNumber mxGetFieldNumber800\n#define MXGETFIELDNUMBER MXGETFIELDNUMBER800\n#define mxgetfieldnumber mxgetfieldnumber800\n#define mxAddField mxAddField800\n#define MXADDFIELD MXADDFIELD800\n#define mxaddfield mxaddfield800\n#define mxRemoveField mxRemoveField800\n#define MXREMOVEFIELD MXREMOVEFIELD800\n#define mxremovefield mxremovefield800\n#define mxClassIDFromClassName mxClassIDFromClassName800\n#define MXCLASSIDFROMCLASSNAME MXCLASSIDFROMCLASSNAME800\n#define mxclassidfromclassname mxclassidfromclassname800\n#define mxGetN mxgetn800\n#define MXGETN MXGETN800\n#define mxgetn mxgetn800\n#define mxCreateCellArray mxCreateCellArray800\n#define MXCREATECELLARRAY MXCREATECELLARRAY800\n#define mxcreatecellarray mxcreatecellarray800\n#define mxCreateCellMatrix mxCreateCellMatrix800\n#define MXCREATECELLMATRIX MXCREATECELLMATRIX800\n#define mxcreatecellmatrix mxcreatecellmatrix800\n#define mxCreateCharArray mxCreateCharArray800\n#define MXCREATECHARARRAY MXCREATECHARARRAY800\n#define mxcreatechararray mxcreatechararray800\n#define mxCreateDoubleMatrix mxCreateDoubleMatrix800\n#define MXCREATEDOUBLEMATRIX MXCREATEDOUBLEMATRIX800\n#define mxcreatedoublematrix mxcreatedoublematrix800\n#define mxCreateNumericArray mxCreateNumericArray800\n#define MXCREATENUMERICARRAY MXCREATENUMERICARRAY800\n#define mxcreatenumericarray mxcreatenumericarray800\n#define mxCreateNumericMatrix mxCreateNumericMatrix800\n#define MXCREATENUMERICMATRIX MXCREATENUMERICMATRIX800\n#define mxcreatenumericmatrix mxcreatenumericmatrix800\n#define mxCalcSingleSubscript mxCalcSingleSubscript800\n#define MXCALCSINGLESUBSCRIPT MXCALCSINGLESUBSCRIPT800\n#define mxcalcsinglesubscript mxcalcsinglesubscript800\n#define mxCreateCharMatrixFromStrings mxCreateCharMatrixFromStrings800\n#define MXCREATECHARMATRIXFROMSTRINGS MXCREATECHARMATRIXFROMSTRINGS800\n#define mxcreatecharmatrixfromstrings mxcreatecharmatrixfromstrings800\n#define mxCreateSparse mxCreateSparse800\n#define MXCREATESPARSE MXCREATESPARSE800\n#define mxcreatesparse mxcreatesparse800\n#define mxCreateStructArray mxCreateStructArray800\n#define MXCREATESTRUCTARRAY MXCREATESTRUCTARRAY800\n#define mxcreatestructarray mxcreatestructarray800\n#define mxCreateStructMatrix mxCreateStructMatrix800\n#define MXCREATESTRUCTMATRIX MXCREATESTRUCTMATRIX800\n#define mxcreatestructmatrix mxcreatestructmatrix800\n#define mxGetCell mxGetCell800\n#define MXGETCELL MXGETCELL800\n#define mxgetcell mxgetcell800\n#define mxGetDimensions mxGetDimensions800\n#define MXGETDIMENSIONS MXGETDIMENSIONS800\n#define mxgetdimensions mxgetdimensions800\n#define mxGetField mxGetField800\n#define MXGETFIELD MXGETFIELD800\n#define mxgetfield mxgetfield800\n#define mxGetFieldByNumber mxGetFieldByNumber800\n#define MXGETFIELDBYNUMBER MXGETFIELDBYNUMBER800\n#define mxgetfieldbynumber mxgetfieldbynumber800\n#define mxGetProperty mxGetProperty800\n#define MXGETPROPERTY MXGETPROPERTY800\n#define mxgetproperty mxgetproperty800\n#define mxGetIr mxGetIr800\n#define MXGETIR MXGETIR800\n#define mxgetir mxgetir800\n#define mxGetJc mxGetJc800\n#define MXGETJC MXGETJC800\n#define mxgetjc mxgetjc800\n#define mxGetNumberOfDimensions mxGetNumberOfDimensions800\n#define MXGETNUMBEROFDIMENSIONS MXGETNUMBEROFDIMENSIONS800\n#define mxgetnumberofdimensions mxgetnumberofdimensions800\n#define mxGetNzmax mxGetNzmax800\n#define MXGETNZMAX MXGETNZMAX800\n#define mxgetnzmax mxgetnzmax800\n#define mxGetString mxGetString800\n#define MXGETSTRING MXGETSTRING800\n#define mxgetstring mxgetstring800\n#define mxSetCell mxSetCell800\n#define MXSETCELL MXSETCELL800\n#define mxsetcell mxsetcell800\n#define mxSetField mxSetField800\n#define MXSETFIELD MXSETFIELD800\n#define mxsetfield mxsetfield800\n#define mxSetFieldByNumber mxSetFieldByNumber800\n#define MXSETFIELDBYNUMBER MXSETFIELDBYNUMBER800\n#define mxsetfieldbynumber mxsetfieldbynumber800\n#define mxSetProperty mxSetProperty800\n#define MXSETPROPERTY MXSETPROPERTY800\n#define mxsetproperty mxsetproperty800\n#define mxSetIr mxSetIr800\n#define MXSETIR MXSETIR800\n#define mxsetir mxsetir800\n#define mxSetJc mxSetJc800\n#define MXSETJC MXSETJC800\n#define mxsetjc mxsetjc800\n#define mxGetM mxgetm800\n#define MXGETM MXGETM800\n#define mxgetm mxgetm800\n#define mxGetNumberOfElements mxGetNumberOfElements800\n#define MXGETNUMBEROFELEMENTS MXGETNUMBEROFELEMENTS800\n#define mxgetnumberofelements mxgetnumberofelements800\n#define mxMalloc mxMalloc800\n#define MXMALLOC MXMALLOC800\n#define mxmalloc mxmalloc800\n#define mxCalloc mxCalloc800\n#define MXCALLOC MXCALLOC800\n#define mxcalloc mxcalloc800\n#define mxRealloc mxRealloc800\n#define MXREALLOC MXREALLOC800\n#define mxrealloc mxrealloc800\n#define mxCreateCharMatrixFromStrs mxCreateCharMatrixFromStrs800\n#define MXCREATECHARMATRIXFROMSTRS MXCREATECHARMATRIXFROMSTRS800\n#define mxcreatecharmatrixfromstrs mxcreatecharmatrixfromstrs800\n#define mxCopyReal4ToPtr mxCopyReal4ToPtr800\n#define MXCOPYREAL4TOPTR MXCOPYREAL4TOPTR800\n#define mxcopyreal4toptr mxcopyreal4toptr800\n#define mxCopyPtrToReal4 mxCopyPtrToReal4800\n#define MXCOPYPTRTOREAL4 MXCOPYPTRTOREAL4800\n#define mxcopyptrtoreal4 mxcopyptrtoreal4800\n#define mxCopyReal8ToPtr mxCopyReal8ToPtr800\n#define MXCOPYREAL8TOPTR MXCOPYREAL8TOPTR800\n#define mxcopyreal8toptr mxcopyreal8toptr800\n#define mxCopyPtrToReal8 mxCopyPtrToReal8800\n#define MXCOPYPTRTOREAL8 MXCOPYPTRTOREAL8800\n#define mxcopyptrtoreal8 mxcopyptrtoreal8800\n#define mxCopyCharacterToPtr mxCopyCharacterToPtr800\n#define MXCOPYCHARACTERTOPTR MXCOPYCHARACTERTOPTR800\n#define mxcopycharactertoptr mxcopycharactertoptr800\n#define mxCopyPtrToCharacter mxCopyPtrToCharacter800\n#define MXCOPYPTRTOCHARACTER MXCOPYPTRTOCHARACTER800\n#define mxcopyptrtocharacter mxcopyptrtocharacter800\n#define mxCopyInteger1ToPtr mxCopyInteger1ToPtr800\n#define MXCOPYINTEGER1TOPTR MXCOPYINTEGER1TOPTR800\n#define mxcopyinteger1toptr mxcopyinteger1toptr800\n#define mxCopyPtrToInteger1 mxCopyPtrToInteger1800\n#define MXCOPYPTRTOINTEGER1 MXCOPYPTRTOINTEGER1800\n#define mxcopyptrtointeger1 mxcopyptrtointeger1800\n#define mxCopyInteger2ToPtr mxCopyInteger2ToPtr800\n#define MXCOPYINTEGER2TOPTR MXCOPYINTEGER2TOPTR800\n#define mxcopyinteger2toptr mxcopyinteger2toptr800\n#define mxCopyPtrToInteger2 mxCopyPtrToInteger2800\n#define MXCOPYPTRTOINTEGER2 MXCOPYPTRTOINTEGER2800\n#define mxcopyptrtointeger2 mxcopyptrtointeger2800\n#define mxCopyInteger4ToPtr mxCopyInteger4ToPtr800\n#define MXCOPYINTEGER4TOPTR MXCOPYINTEGER4TOPTR800\n#define mxcopyinteger4toptr mxcopyinteger4toptr800\n#define mxCopyPtrToInteger4 mxCopyPtrToInteger4800\n#define MXCOPYPTRTOINTEGER4 MXCOPYPTRTOINTEGER4800\n#define mxcopyptrtointeger4 mxcopyptrtointeger4800\n#define mxCopyInteger8ToPtr mxCopyInteger8ToPtr800\n#define MXCOPYINTEGER8TOPTR MXCOPYINTEGER8TOPTR800\n#define mxcopyinteger8toptr mxcopyinteger8toptr800\n#define mxCopyPtrToInteger8 mxCopyPtrToInteger8800\n#define MXCOPYPTRTOINTEGER8 MXCOPYPTRTOINTEGER8800\n#define mxcopyptrtointeger8 mxcopyptrtointeger8800\n#define mxCopyPtrToPtrArray mxCopyPtrToPtrArray800\n#define MXCOPYPTRTOPTRARRAY MXCOPYPTRTOPTRARRAY800\n#define mxcopyptrtoptrarray mxcopyptrtoptrarray800\n#define mxCopyMWIndexToPtr mxCopyMWIndexToPtr800\n#define MXCOPYMWINDEXTOPTR MXCOPYMWINDEXTOPTR800\n#define mxcopymwindextoptr mxcopymwindextoptr800\n#define mxCopyPtrToMWIndex mxCopyPtrToMWIndex800\n#define MXCOPYPTRTOMWINDEX MXCOPYPTRTOMWINDEX800\n#define mxcopyptrtomwindex mxcopyptrtomwindex800\n#define mxCopyPtrToComplex16 mxCopyPtrToComplex16800\n#define MXCOPYPTRTOCOMPLEX16 MXCOPYPTRTOCOMPLEX16800\n#define mxcopyptrtocomplex16 mxcopyptrtocomplex16800\n#define mxCopyComplex16ToPtr mxCopyComplex16ToPtr800\n#define MXCOPYCOMPLEX16TOPTR MXCOPYCOMPLEX16TOPTR800\n#define mxcopycomplex16toptr mxcopycomplex16toptr800\n#define mxCopyPtrToComplex8 mxCopyPtrToComplex8800\n#define MXCOPYPTRTOCOMPLEX8 MXCOPYPTRTOCOMPLEX8800\n#define mxcopyptrtocomplex8 mxcopyptrtocomplex8800\n#define mxCopyComplex8ToPtr mxCopyComplex8ToPtr800\n#define MXCOPYCOMPLEX8TOPTR MXCOPYCOMPLEX8TOPTR800\n#define mxcopycomplex8toptr mxcopycomplex8toptr800\n#define mxGetElementSize mxGetElementSize800\n#define MXGETELEMENTSIZE MXGETELEMENTSIZE800\n#define mxgetelementsize mxgetelementsize800\n#define mxSetM mxSetM800\n#define MXSETM MXSETM800\n#define mxsetm mxsetm800\n#define mxSetN mxSetN800\n#define MXSETN MXSETN800\n#define mxsetn mxsetn800\n#define mxSetDimensions mxSetDimensions800\n#define MXSETDIMENSIONS MXSETDIMENSIONS800\n#define mxsetdimensions mxsetdimensions800\n#define mxSetNzmax mxSetNzmax800\n#define MXSETNZMAX MXSETNZMAX800\n#define mxsetnzmax mxsetnzmax800\n#define mxGetPr mxGetPr800\n#define MXGETPR MXGETPR800\n#define mxgetpr mxgetpr800\n#define mxSetPr mxSetPr800\n#define MXSETPR MXSETPR800\n#define mxsetpr mxsetpr800\n#define mxGetData mxGetData800\n#define MXGETDATA MXGETDATA800\n#define mxgetdata mxgetdata800\n#define mxSetData mxSetData800\n#define MXSETDATA MXSETDATA800\n#define mxsetdata mxsetdata800\n#define mxGetScalar mxGetScalar800\n#define MXGETSCALAR MXGETSCALAR800\n#define mxgetscalar mxgetscalar800\n#define mxDuplicateArray mxDuplicateArray800\n#define MXDUPLICATEARRAY MXDUPLICATEARRAY800\n#define mxduplicatearray mxduplicatearray800\n#define mxIsComplex mxIsComplex800\n#define MXISCOMPLEX MXISCOMPLEX800\n#define mxiscomplex mxiscomplex800\n#define mxMakeArrayReal mxMakeArrayReal800\n#define MXMAKEARRAYREAL MXMAKEARRAYREAL800\n#define mxmakearrayreal mxmakearrayreal800\n#define mxMakeArrayComplex mxMakeArrayComplex800\n#define MXMAKEARRAYCOMPLEX MXMAKEARRAYCOMPLEX800\n#define mxmakearraycomplex mxmakearraycomplex800\n#define mxGetDoubles mxGetDoubles800\n#define MXGETDOUBLES MXGETDOUBLES800\n#define mxgetdoubles mxgetdoubles800\n#define mxSetDoubles mxSetDoubles800\n#define MXSETDOUBLES MXSETDOUBLES800\n#define mxsetdoubles mxsetdoubles800\n#define mxGetComplexDoubles mxGetComplexDoubles800\n#define MXGETCOMPLEXDOUBLES MXGETCOMPLEXDOUBLES800\n#define mxgetcomplexdoubles mxgetcomplexdoubles800\n#define mxSetComplexDoubles mxSetComplexDoubles800\n#define MXSETCOMPLEXDOUBLES MXSETCOMPLEXDOUBLES800\n#define mxsetcomplexdoubles mxsetcomplexdoubles800\n#define mxGetSingles mxGetSingles800\n#define MXGETSINGLES MXGETSINGLES800\n#define mxgetsingles mxgetsingles800\n#define mxSetSingles mxSetSingles800\n#define MXSETSINGLES MXSETSINGLES800\n#define mxsetsingles mxsetsingles800\n#define mxGetComplexSingles mxGetComplexSingles800\n#define MXGETCOMPLEXSINGLES MXGETCOMPLEXSINGLES800\n#define mxgetcomplexsingles mxgetcomplexsingles800\n#define mxSetComplexSingles mxSetComplexSingles800\n#define MXSETCOMPLEXSINGLES MXSETCOMPLEXSINGLES800\n#define mxsetcomplexsingles mxsetcomplexsingles800\n#define mxGetInt8s mxGetInt8s800\n#define MXGETINT8S MXGETINT8S800\n#define mxgetint8s mxgetint8s800\n#define mxSetInt8s mxSetInt8s800\n#define MXSETINT8S MXSETINT8S800\n#define mxsetint8s mxsetint8s800\n#define mxGetUint8s mxGetUint8s800\n#define MXGETUINT8S MXGETUINT8S800\n#define mxgetuint8s mxgetuint8s800\n#define mxSetUint8s mxSetUint8s800\n#define MXSETUINT8S MXSETUINT8S800\n#define mxsetuint8s mxsetuint8s800\n#define mxGetInt16s mxGetInt16s800\n#define MXGETINT16S MXGETINT16S800\n#define mxgetint16s mxgetint16s800\n#define mxSetInt16s mxSetInt16s800\n#define MXSETINT16S MXSETINT16S800\n#define mxsetint16s mxsetint16s800\n#define mxGetUint16s mxGetUint16s800\n#define MXGETUINT16S MXGETUINT16S800\n#define mxgetuint16s mxgetuint16s800\n#define mxSetUint16s mxSetUint16s800\n#define MXSETUINT16S MXSETUINT16S800\n#define mxsetuint16s mxsetuint16s800\n#define mxGetInt32s mxGetInt32s800\n#define MXGETINT32S MXGETINT32S800\n#define mxgetint32s mxgetint32s800\n#define mxSetInt32s mxSetInt32s800\n#define MXSETINT32S MXSETINT32S800\n#define mxsetint32s mxsetint32s800\n#define mxGetUint32s mxGetUint32s800\n#define MXGETUINT32S MXGETUINT32S800\n#define mxgetuint32s mxgetuint32s800\n#define mxSetUint32s mxSetUint32s800\n#define MXSETUINT32S MXSETUINT32S800\n#define mxsetuint32s mxsetuint32s800\n#define mxGetInt64s mxGetInt64s800\n#define MXGETINT64S MXGETINT64S800\n#define mxgetint64s mxgetint64s800\n#define mxSetInt64s mxSetInt64s800\n#define MXSETINT64S MXSETINT64S800\n#define mxsetint64s mxsetint64s800\n#define mxGetUint64s mxGetUint64s800\n#define MXGETUINT64S MXGETUINT64S800\n#define mxgetuint64s mxgetuint64s800\n#define mxSetUint64s mxSetUint64s800\n#define MXSETUINT64S MXSETUINT64S800\n#define mxsetuint64s mxsetuint64s800\n\n#if defined(WITH_COMMENTS)\n/*\n * MEX module APIs\n */\n#endif\n#define mexPrintf mexPrintf800\n#define mexprintf mexprintf800\n#define MEXPRINTF MEXPRINTF800\n#define mexErrMsgIdAndTxt mexErrMsgIdAndTxt800\n#define mexerrmsgidandtxt mexerrmsgidandtxt800\n#define MEXERRMSGIDANDTXT MEXERRMSGIDANDTXT800\n#define mexWarnMsgIdAndTxt mexWarnMsgIdAndTxt800\n#define mexwarnmsgidandtxt mexwarnmsgidandtxt800\n#define MEXWARNMSGIDANDTXT MEXWARNMSGIDANDTXT800\n#define mexErrMsgTxt mexErrMsgTxt800\n#define mexerrmsgtxt mexerrmsgtxt800\n#define MEXERRMSGTXT MEXERRMSGTXT800\n#define mexWarnMsgTxt mexWarnMsgTxt800\n#define mexwarnmsgtxt mexwarnmsgtxt800\n#define MEXWARNMSGTXT MEXWARNMSGTXT800\n#define mexIsLocked mexIsLocked800\n#define mexislocked mexislocked800\n#define MEXISLOCKED MEXISLOCKED800\n#define mexLock mexLock800\n#define mexlock mexlock800\n#define MEXLOCK MEXLOCK800\n#define mexUnlock mexUnlock800\n#define mexunlock mexunlock800\n#define MEXUNLOCK MEXUNLOCK800\n#define mexMakeArrayPersistent mexMakeArrayPersistent800\n#define mexmakearraypersistent mexmakearraypersistent800\n#define MEXMAKEARRAYPERSISTENT MEXMAKEARRAYPERSISTENT800\n#define mexMakeMemoryPersistent mexMakeMemoryPersistent800\n#define mexmakememorypersistent mexmakememorypersistent800\n#define MEXMAKEMEMORYPERSISTENT MEXMAKEMEMORYPERSISTENT800\n#define mexIsGlobal mexIsGlobal800\n#define mexisglobal mexisglobal800\n#define MEXISGLOBAL MEXISGLOBAL800\n#define mexFunctionName mexFunctionName800\n#define mexfunctionname mexfunctionname800\n#define MEXFUNCTIONNAME MEXFUNCTIONNAME800\n#define mexAtExit mexAtExit800\n#define mexatexit mexatexit800\n#define MEXATEXIT MEXATEXIT800\n\n#define mexCallMATLAB mexCallMATLAB800\n#define mexcallmatlab mexcallmatlab800\n#define MEXCALLMATLAB MEXCALLMATLAB800\n#define mexCallMATLABWithTrap mexCallMATLABWithTrap800\n#define mexcallmatlabwithtrap mexcallmatlabwithtrap800\n#define MEXCALLMATLABWITHTRAP MEXCALLMATLABWITHTRAP800\n\n#define mexEvalString mexEvalString800\n#define mexevalstring mexevalstring800\n#define MEXEVALSTRING MEXEVALSTRING800\n#define mexEvalStringWithTrap mexEvalStringWithTrap800\n#define mexevalstringwithtrap mexevalstringwithtrap800\n#define MEXEVALSTRINGWITHTRAP MEXEVALSTRINGWITHTRAP800\n#define mexGetVariable mexGetVariable800\n#define mexgetvariable mexgetvariable800\n#define MEXGETVARIABLE MEXGETVARIABLE800\n#define mexGetVariablePtr mexGetVariablePtr800\n#define mexgetvariableptr mexgetvariableptr800\n#define MEXGETVARIABLEPTR MEXGETVARIABLEPTR800\n#define mexPutVariable mexPutVariable800\n#define mexputvariable mexputvariable800\n#define MEXPUTVARIABLE MEXPUTVARIABLE800\n\n#define mexGet mexGetIsDeprecated\n#define mexget mexgetisdeprecated\n#define MEXGET MEXGETISDEPRECATED\n#define mexSet mexSetIsDeprecated\n#define mexset mexsetisdeprecated\n#define MEXSET MEXSETISDEPRECATED\n#define mexSetTrapFlag mexSetTrapFlagIsDeprecated\n#define mexsettrapflag mexsettrapflagisdeprecated\n#define MEXSETTRAPFLAG MEXSETTRAPFLAGISDEPRECATED\n\n#if defined(WITH_COMMENTS)\n/*\n * MAT module APIs\n */\n#endif\n#define matOpen matOpen800\n#define matopen matopen800\n#define MATOPEN MATOPEN800\n#define matClose matClose800\n#define matclose matclose800\n#define MATCLOSE MATCLOSE800\n#define matGetVariable matGetVariable800\n#define matGetVariable matGetVariable800\n#define MATGETVARIABLE MATGETVARIABLE800\n#define matGetNextVariable matGetNextVariable800\n#define matGetNextVariable matGetNextVariable800\n#define MATGETNEXTVARIABLE MATGETNEXTVARIABLE800\n#define matGetVariableInfo matGetVariableInfo800\n#define matGetVariableInfo matGetVariableInfo800\n#define MATGETVARIABLEINFO MATGETVARIABLEINFO800\n#define matGetDir matGetDir800\n#define matGetDir matGetDir800\n#define MATGETDIR MATGETDIR800\n#define matGetErrno matGetErrno800\n#define matGetErrno matGetErrno800\n#define MATGETERRNO MATGETERRNO800\n#define matPutVariable matPutVariable800\n#define matPutVariable matPutVariable800\n#define MATPUTVARIABLE MATPUTVARIABLE800\n#define matPutVariableAsGlobal matPutVariableAsGlobal800\n#define matPutVariableAsGlobal matPutVariableAsGlobal800\n#define MATPUTVARIABLEASGLOBAL MATPUTVARIABLEASGLOBAL800\n\n#elif defined(MX_COMPAT_32)\n\n#if defined(WITH_COMMENTS)\n/*\n * Compatibility layer for MEX files using the 32-bit mxArray APIs\n */\n#endif\n\n#define mxCalcSingleSubscript mxCalcSingleSubscript700\n#define mxCreateCellArray mxCreateCellArray700\n#define mxCreateCellMatrix mxCreateCellMatrix700\n#define mxCreateCharArray mxCreateCharArray700\n#define mxCreateCharMatrixFromStrings mxCreateCharMatrixFromStrs700\n#define mxCreateDoubleMatrix mxCreateDoubleMatrix700\n#define mxCreateNumericArray mxCreateNumericArray700\n#define mxCreateNumericMatrix mxCreateNumericMatrix700\n#define mxCreateSparse mxCreateSparse700\n#define mxCreateStructArray mxCreateStructArray700\n#define mxCreateStructMatrix mxCreateStructMatrix700\n#define mxGetCell mxGetCell700\n#define mxGetDimensions mxGetDimensions700\n#define mxGetField mxGetField700\n#define mxGetFieldByNumber mxGetFieldByNumber700\n#define mxGetProperty mxGetProperty700\n#define mxGetIr mxGetIr700\n#define mxGetJc mxGetJc700\n#define mxGetNumberOfDimensions mxGetNumberOfDimensions700\n#define mxGetNzmax mxGetNzmax700\n#define mxGetString mxGetString700\n#define mxSetCell mxSetCell700\n#define mxSetDimensions mxSetDimensions700\n#define mxSetField mxSetField700\n#define mxSetFieldByNumber mxSetFieldByNumber700\n#define mxSetProperty mxSetProperty700\n#define mxSetIr mxSetIr700\n#define mxSetJc mxSetJc700\n#define mxSetM mxSetM700\n#define mxSetN mxSetN700\n#define mxSetNzmax mxSetNzmax700\n#define mxGetM mxGetM700\n#define mxGetN mxGetN700\n#define mxGetNumberOfElements mxGetNumberOfElements700\n#define mxGetElementSize mxGetElementSize700\n#define mxMalloc mxMalloc700\n#define mxCalloc mxCalloc700\n#define mxRealloc mxRealloc700\n#define mxCopyReal4ToPtr mxCopyReal4ToPtr700\n#define mxCopyPtrToReal4 mxCopyPtrToReal4700\n#define mxCopyReal8ToPtr mxCopyReal8ToPtr700\n#define mxCopyPtrToReal8 mxCopyPtrToReal8700\n#define mxCopyCharacterToPtr mxCopyCharacterToPtr700\n#define mxCopyPtrToCharacter mxCopyPtrToCharacter700\n#define mxCopyInteger1ToPtr mxCopyInteger1ToPtr700\n#define mxCopyPtrToInteger1 mxCopyPtrToInteger1700\n#define mxCopyInteger2ToPtr mxCopyInteger2ToPtr700\n#define mxCopyPtrToInteger2 mxCopyPtrToInteger2700\n#define mxCopyInteger4ToPtr mxCopyInteger4ToPtr700\n#define mxCopyPtrToInteger4 mxCopyPtrToInteger4700\n#define mxCopyInteger8ToPtr mxCopyInteger8ToPtr700\n#define mxCopyPtrToInteger8 mxCopyPtrToInteger8700\n#define mxCopyPtrToPtrArray mxCopyPtrToPtrArray700\n#define mxCopyComplex16ToPtr mxCopyComplex16ToPtr700\n#define mxCopyPtrToComplex16 mxCopyPtrToComplex16700\n#define mxCopyComplex8ToPtr mxCopyComplex8ToPtr700\n#define mxCopyPtrToComplex8 mxCopyPtrToComplex8700\n#define mxCopyMWIndexToPtr mxCopyMWIndexToPtr700\n#define mxCopyPtrToMWIndex mxCopyPtrToMWIndex700\n#define mxCreateCharMatrixFromStrs mxCreateCharMatrixFromStrs700\n#define MXCALCSINGLESUBSCRIPT MXCALCSINGLESUBSCRIPT700\n#define MXCREATECELLARRAY MXCREATECELLARRAY700\n#define MXCREATECELLMATRIX MXCREATECELLMATRIX700\n#define MXCREATECHARARRAY MXCREATECHARARRAY700\n#define MXCREATECHARMATRIXFROMSTRINGS MXCREATECHARMATRIXFROMSTRS700\n#define MXCREATEDOUBLEMATRIX MXCREATEDOUBLEMATRIX700\n#define MXCREATENUMERICARRAY MXCREATENUMERICARRAY700\n#define MXCREATENUMERICMATRIX MXCREATENUMERICMATRIX700\n#define MXCREATESPARSE MXCREATESPARSE700\n#define MXCREATESTRUCTARRAY MXCREATESTRUCTARRAY700\n#define MXCREATESTRUCTMATRIX MXCREATESTRUCTMATRIX700\n#define MXGETCELL MXGETCELL700\n#define MXGETDIMENSIONS MXGETDIMENSIONS700\n#define MXGETFIELD MXGETFIELD700\n#define MXGETFIELDBYNUMBER MXGETFIELDBYNUMBER700\n#define MXGETPROPERTY MXGETPROPERTY700\n#define MXGETIR MXGETIR700\n#define MXGETJC MXGETJC700\n#define MXGETNUMBEROFDIMENSIONS MXGETNUMBEROFDIMENSIONS700\n#define MXGETNZMAX MXGETNZMAX700\n#define MXGETSTRING MXGETSTRING700\n#define MXSETCELL MXSETCELL700\n#define MXSETDIMENSIONS MXSETDIMENSIONS700\n#define MXSETFIELD MXSETFIELD700\n#define MXSETFIELDBYNUMBER MXSETFIELDBYNUMBER700\n#define MXSETPROPERTY MXSETPROPERTY700\n#define MXSETIR MXSETIR700\n#define MXSETJC MXSETJC700\n#define MXSETM MXSETM700\n#define MXSETN MXSETN700\n#define MXSETNZMAX MXSETNZMAX700\n#define MXGETM MXGETM700\n#define MXGETN MXGETN700\n#define MXGETNUMBEROFELEMENTS MXGETNUMBEROFELEMENTS700\n#define MXGETELEMENTSIZE MXGETELEMENTSIZE700\n#define MXMALLOC MXMALLOC700\n#define MXCALLOC MXCALLOC700\n#define MXREALLOC MXREALLOC700\n#define MXCOPYREAL4TOPTR MXCOPYREAL4TOPTR700\n#define MXCOPYPTRTOREAL4 MXCOPYPTRTOREAL4700\n#define MXCOPYREAL8TOPTR MXCOPYREAL8TOPTR700\n#define MXCOPYPTRTOREAL8 MXCOPYPTRTOREAL8700\n#define MXCOPYCHARACTERTOPTR MXCOPYCHARACTERTOPTR700\n#define MXCOPYPTRTOCHARACTER MXCOPYPTRTOCHARACTER700\n#define MXCOPYINTEGER1TOPTR MXCOPYINTEGER1TOPTR700\n#define MXCOPYPTRTOINTEGER1 MXCOPYPTRTOINTEGER1700\n#define MXCOPYINTEGER2TOPTR MXCOPYINTEGER2TOPTR700\n#define MXCOPYPTRTOINTEGER2 MXCOPYPTRTOINTEGER2700\n#define MXCOPYINTEGER4TOPTR MXCOPYINTEGER4TOPTR700\n#define MXCOPYPTRTOINTEGER4 MXCOPYPTRTOINTEGER4700\n#define MXCOPYINTEGER8TOPTR MXCOPYINTEGER8TOPTR700\n#define MXCOPYPTRTOINTEGER8 MXCOPYPTRTOINTEGER8700\n#define MXCOPYPTRTOPTRARRAY MXCOPYPTRTOPTRARRAY700\n#define MXCOPYCOMPLEX16TOPTR MXCOPYCOMPLEX16TOPTR700\n#define MXCOPYPTRTOCOMPLEX16 MXCOPYPTRTOCOMPLEX16700\n#define MXCOPYCOMPLEX8TOPTR MXCOPYCOMPLEX8TOPTR700\n#define MXCOPYPTRTOCOMPLEX8 MXCOPYPTRTOCOMPLEX8700\n#define MXCOPYMWINDEXTOPTR MXCOPYMWINDEXTOPTR700\n#define MXCOPYPTRTOMWINDEX MXCOPYPTRTOMWINDEX700\n#define MXCREATECHARMATRIXFROMSTRS MXCREATECHARMATRIXFROMSTRS700\n#define mxcalcsinglesubscript mxcalcsinglesubscript700\n#define mxcreatecellarray mxcreatecellarray700\n#define mxcreatecellmatrix mxcreatecellmatrix700\n#define mxcreatechararray mxcreatechararray700\n#define mxcreatecharmatrixfromstrings mxcreatecharmatrixfromstrs700\n#define mxcreatedoublematrix mxcreatedoublematrix700\n#define mxcreatenumericarray mxcreatenumericarray700\n#define mxcreatenumericmatrix mxcreatenumericmatrix700\n#define mxcreatesparse mxcreatesparse700\n#define mxcreatestructarray mxcreatestructarray700\n#define mxcreatestructmatrix mxcreatestructmatrix700\n#define mxgetcell mxgetcell700\n#define mxgetdimensions mxgetdimensions700\n#define mxgetfield mxgetfield700\n#define mxgetfieldbynumber mxgetfieldbynumber700\n#define mxgetproperty mxgetproperty700\n#define mxgetir mxgetir700\n#define mxgetjc mxgetjc700\n#define mxgetnumberofdimensions mxgetnumberofdimensions700\n#define mxgetnzmax mxgetnzmax700\n#define mxgetstring mxgetstring700\n#define mxsetcell mxsetcell700\n#define mxsetdimensions mxsetdimensions700\n#define mxsetfield mxsetfield700\n#define mxsetfieldbynumber mxsetfieldbynumber700\n#define mxsetproperty mxsetproperty700\n#define mxsetir mxsetir700\n#define mxsetjc mxsetjc700\n#define mxsetm mxsetm700\n#define mxsetn mxsetn700\n#define mxsetnzmax mxsetnzmax700\n#define mxgetm mxgetm700\n#define mxgetn mxgetn700\n#define mxgetnumberofelements mxgetnumberofelements700\n#define mxgetelementsize mxgetelementsize700\n#define mxmalloc mxmalloc700\n#define mxcalloc mxcalloc700\n#define mxrealloc mxrealloc700\n#define mxcopyreal4toptr mxcopyreal4toptr700\n#define mxcopyptrtoreal4 mxcopyptrtoreal4700\n#define mxcopyreal8toptr mxcopyreal8toptr700\n#define mxcopyptrtoreal8 mxcopyptrtoreal8700\n#define mxcopycharactertoptr mxcopycharactertoptr700\n#define mxcopyptrtocharacter mxcopyptrtocharacter700\n#define mxcopyinteger1toptr mxcopyinteger1toptr700\n#define mxcopyptrtointeger1 mxcopyptrtointeger1700\n#define mxcopyinteger2toptr mxcopyinteger2toptr700\n#define mxcopyptrtointeger2 mxcopyptrtointeger2700\n#define mxcopyinteger4toptr mxcopyinteger4toptr700\n#define mxcopyptrtointeger4 mxcopyptrtointeger4700\n#define mxcopyinteger8toptr mxcopyinteger8toptr700\n#define mxcopyptrtointeger8 mxcopyptrtointeger8700\n#define mxcopyptrtoptrarray mxcopyptrtoptrarray700\n#define mxcopycomplex16toptr mxcopycomplex16toptr700\n#define mxcopyptrtocomplex16 mxcopyptrtocomplex16700\n#define mxcopycomplex8toptr mxcopycomplex8toptr700\n#define mxcopyptrtocomplex8 mxcopyptrtocomplex8700\n#define mxcopymwindextoptr mxcopymwindextoptr700\n#define mxcopyptrtomwindex mxcopyptrtomwindex700\n#define mxcreatecharmatrixfromstrs mxcreatecharmatrixfromstrs700\n\n#else\n\n#ifndef __linux\n#define mxCalcSingleSubscript mxCalcSingleSubscript730\n#define mxCreateCellArray mxCreateCellArray730\n#define mxCreateCellMatrix mxCreateCellMatrix730\n#define mxCreateCharArray mxCreateCharArray730\n#define mxCreateCharMatrixFromStrings mxCreateCharMatrixFromStrs730\n#define mxCreateDoubleMatrix mxCreateDoubleMatrix730\n#define mxCreateNumericArray mxCreateNumericArray730\n#define mxCreateNumericMatrix mxCreateNumericMatrix730\n#define mxCreateSparse mxCreateSparse730\n#define mxCreateStructArray mxCreateStructArray730\n#define mxCreateStructMatrix mxCreateStructMatrix730\n#define mxGetCell mxGetCell730\n#define mxGetDimensions mxGetDimensions730\n#define mxGetField mxGetField730\n#define mxGetFieldByNumber mxGetFieldByNumber730\n#define mxGetProperty mxGetProperty730\n#define mxGetIr mxGetIr730\n#define mxGetJc mxGetJc730\n#define mxGetNumberOfDimensions mxGetNumberOfDimensions730\n#define mxGetNzmax mxGetNzmax730\n#define mxGetString mxGetString730\n#define mxSetCell mxSetCell730\n#define mxSetDimensions mxSetDimensions730\n#define mxSetField mxSetField730\n#define mxSetFieldByNumber mxSetFieldByNumber730\n#define mxSetProperty mxSetProperty730\n#define mxSetIr mxSetIr730\n#define mxSetJc mxSetJc730\n#define mxSetM mxSetM730\n#define mxSetN mxSetN730\n#define mxSetNzmax mxSetNzmax730\n#define mxGetM mxGetM730\n#define mxGetN mxGetN730\n#define mxGetNumberOfElements mxGetNumberOfElements730\n#define mxGetElementSize mxGetElementSize730\n#define mxMalloc mxMalloc730\n#define mxCalloc mxCalloc730\n#define mxRealloc mxRealloc730\n#define mxCopyReal4ToPtr mxCopyReal4ToPtr730\n#define mxCopyPtrToReal4 mxCopyPtrToReal4730\n#define mxCopyReal8ToPtr mxCopyReal8ToPtr730\n#define mxCopyPtrToReal8 mxCopyPtrToReal8730\n#define mxCopyCharacterToPtr mxCopyCharacterToPtr730\n#define mxCopyPtrToCharacter mxCopyPtrToCharacter730\n#define mxCopyInteger1ToPtr mxCopyInteger1ToPtr730\n#define mxCopyPtrToInteger1 mxCopyPtrToInteger1730\n#define mxCopyInteger2ToPtr mxCopyInteger2ToPtr730\n#define mxCopyPtrToInteger2 mxCopyPtrToInteger2730\n#define mxCopyInteger4ToPtr mxCopyInteger4ToPtr730\n#define mxCopyPtrToInteger4 mxCopyPtrToInteger4730\n#define mxCopyInteger8ToPtr mxCopyInteger8ToPtr730\n#define mxCopyPtrToInteger8 mxCopyPtrToInteger8730\n#define mxCopyPtrToPtrArray mxCopyPtrToPtrArray730\n#define mxCopyComplex16ToPtr mxCopyComplex16ToPtr730\n#define mxCopyPtrToComplex16 mxCopyPtrToComplex16730\n#define mxCopyComplex8ToPtr mxCopyComplex8ToPtr730\n#define mxCopyPtrToComplex8 mxCopyPtrToComplex8730\n#define mxCopyMWIndexToPtr mxCopyMWIndexToPtr730\n#define mxCopyPtrToMWIndex mxCopyPtrToMWIndex730\n#define mxCreateCharMatrixFromStrs mxCreateCharMatrixFromStrs730\n#define MXCALCSINGLESUBSCRIPT MXCALCSINGLESUBSCRIPT730\n#define MXCREATECELLARRAY MXCREATECELLARRAY730\n#define MXCREATECELLMATRIX MXCREATECELLMATRIX730\n#define MXCREATECHARARRAY MXCREATECHARARRAY730\n#define MXCREATECHARMATRIXFROMSTRINGS MXCREATECHARMATRIXFROMSTRS730\n#define MXCREATEDOUBLEMATRIX MXCREATEDOUBLEMATRIX730\n#define MXCREATENUMERICARRAY MXCREATENUMERICARRAY730\n#define MXCREATENUMERICMATRIX MXCREATENUMERICMATRIX730\n#define MXCREATESPARSE MXCREATESPARSE730\n#define MXCREATESTRUCTARRAY MXCREATESTRUCTARRAY730\n#define MXCREATESTRUCTMATRIX MXCREATESTRUCTMATRIX730\n#define MXGETCELL MXGETCELL730\n#define MXGETDIMENSIONS MXGETDIMENSIONS730\n#define MXGETFIELD MXGETFIELD730\n#define MXGETFIELDBYNUMBER MXGETFIELDBYNUMBER730\n#define MXGETPROPERTY MXGETPROPERTY730\n#define MXGETIR MXGETIR730\n#define MXGETJC MXGETJC730\n#define MXGETNUMBEROFDIMENSIONS MXGETNUMBEROFDIMENSIONS730\n#define MXGETNZMAX MXGETNZMAX730\n#define MXGETSTRING MXGETSTRING730\n#define MXSETCELL MXSETCELL730\n#define MXSETDIMENSIONS MXSETDIMENSIONS730\n#define MXSETFIELD MXSETFIELD730\n#define MXSETFIELDBYNUMBER MXSETFIELDBYNUMBER730\n#define MXSETPROPERTY MXSETPROPERTY730\n#define MXSETIR MXSETIR730\n#define MXSETJC MXSETJC730\n#define MXSETM MXSETM730\n#define MXSETN MXSETN730\n#define MXSETNZMAX MXSETNZMAX730\n#define MXGETM MXGETM730\n#define MXGETN MXGETN730\n#define MXGETNUMBEROFELEMENTS MXGETNUMBEROFELEMENTS730\n#define MXGETELEMENTSIZE MXGETELEMENTSIZE730\n#define MXMALLOC MXMALLOC730\n#define MXCALLOC MXCALLOC730\n#define MXREALLOC MXREALLOC730\n#define MXCOPYREAL4TOPTR MXCOPYREAL4TOPTR730\n#define MXCOPYPTRTOREAL4 MXCOPYPTRTOREAL4730\n#define MXCOPYREAL8TOPTR MXCOPYREAL8TOPTR730\n#define MXCOPYPTRTOREAL8 MXCOPYPTRTOREAL8730\n#define MXCOPYCHARACTERTOPTR MXCOPYCHARACTERTOPTR730\n#define MXCOPYPTRTOCHARACTER MXCOPYPTRTOCHARACTER730\n#define MXCOPYINTEGER1TOPTR MXCOPYINTEGER1TOPTR730\n#define MXCOPYPTRTOINTEGER1 MXCOPYPTRTOINTEGER1730\n#define MXCOPYINTEGER2TOPTR MXCOPYINTEGER2TOPTR730\n#define MXCOPYPTRTOINTEGER2 MXCOPYPTRTOINTEGER2730\n#define MXCOPYINTEGER4TOPTR MXCOPYINTEGER4TOPTR730\n#define MXCOPYPTRTOINTEGER4 MXCOPYPTRTOINTEGER4730\n#define MXCOPYINTEGER8TOPTR MXCOPYINTEGER8TOPTR730\n#define MXCOPYPTRTOINTEGER8 MXCOPYPTRTOINTEGER8730\n#define MXCOPYPTRTOPTRARRAY MXCOPYPTRTOPTRARRAY730\n#define MXCOPYCOMPLEX16TOPTR MXCOPYCOMPLEX16TOPTR730\n#define MXCOPYPTRTOCOMPLEX16 MXCOPYPTRTOCOMPLEX16730\n#define MXCOPYCOMPLEX8TOPTR MXCOPYCOMPLEX8TOPTR730\n#define MXCOPYPTRTOCOMPLEX8 MXCOPYPTRTOCOMPLEX8730\n#define MXCOPYMWINDEXTOPTR MXCOPYMWINDEXTOPTR730\n#define MXCOPYPTRTOMWINDEX MXCOPYPTRTOMWINDEX730\n#define MXCREATECHARMATRIXFROMSTRS MXCREATECHARMATRIXFROMSTRS730\n#define mxcalcsinglesubscript mxcalcsinglesubscript730\n#define mxcreatecellarray mxcreatecellarray730\n#define mxcreatecellmatrix mxcreatecellmatrix730\n#define mxcreatechararray mxcreatechararray730\n#define mxcreatecharmatrixfromstrings mxcreatecharmatrixfromstrs730\n#define mxcreatedoublematrix mxcreatedoublematrix730\n#define mxcreatenumericarray mxcreatenumericarray730\n#define mxcreatenumericmatrix mxcreatenumericmatrix730\n#define mxcreatesparse mxcreatesparse730\n#define mxcreatestructarray mxcreatestructarray730\n#define mxcreatestructmatrix mxcreatestructmatrix730\n#define mxgetcell mxgetcell730\n#define mxgetdimensions mxgetdimensions730\n#define mxgetfield mxgetfield730\n#define mxgetfieldbynumber mxgetfieldbynumber730\n#define mxgetproperty mxgetproperty730\n#define mxgetir mxgetir730\n#define mxgetjc mxgetjc730\n#define mxgetnumberofdimensions mxgetnumberofdimensions730\n#define mxgetnzmax mxgetnzmax730\n#define mxgetstring mxgetstring730\n#define mxsetcell mxsetcell730\n#define mxsetdimensions mxsetdimensions730\n#define mxsetfield mxsetfield730\n#define mxsetfieldbynumber mxsetfieldbynumber730\n#define mxsetproperty mxsetproperty730\n#define mxsetir mxsetir730\n#define mxsetjc mxsetjc730\n#define mxsetm mxsetm730\n#define mxsetn mxsetn730\n#define mxsetnzmax mxsetnzmax730\n#define mxgetm mxgetm730\n#define mxgetn mxgetn730\n#define mxgetnumberofelements mxgetnumberofelements730\n#define mxgetelementsize mxgetelementsize730\n#define mxmalloc mxmalloc730\n#define mxcalloc mxcalloc730\n#define mxrealloc mxrealloc730\n#define mxcopyreal4toptr mxcopyreal4toptr730\n#define mxcopyptrtoreal4 mxcopyptrtoreal4730\n#define mxcopyreal8toptr mxcopyreal8toptr730\n#define mxcopyptrtoreal8 mxcopyptrtoreal8730\n#define mxcopycharactertoptr mxcopycharactertoptr730\n#define mxcopyptrtocharacter mxcopyptrtocharacter730\n#define mxcopyinteger1toptr mxcopyinteger1toptr730\n#define mxcopyptrtointeger1 mxcopyptrtointeger1730\n#define mxcopyinteger2toptr mxcopyinteger2toptr730\n#define mxcopyptrtointeger2 mxcopyptrtointeger2730\n#define mxcopyinteger4toptr mxcopyinteger4toptr730\n#define mxcopyptrtointeger4 mxcopyptrtointeger4730\n#define mxcopyinteger8toptr mxcopyinteger8toptr730\n#define mxcopyptrtointeger8 mxcopyptrtointeger8730\n#define mxcopyptrtoptrarray mxcopyptrtoptrarray730\n#define mxcopycomplex16toptr mxcopycomplex16toptr730\n#define mxcopyptrtocomplex16 mxcopyptrtocomplex16730\n#define mxcopycomplex8toptr mxcopycomplex8toptr730\n#define mxcopyptrtocomplex8 mxcopyptrtocomplex8730\n#define mxcopymwindextoptr mxcopymwindextoptr730\n#define mxcopyptrtomwindex mxcopyptrtomwindex730\n#define mxcreatecharmatrixfromstrs mxcreatecharmatrixfromstrs730\n#endif\n\n#define mexGet mexGetIsDeprecated\n#define mexget mexgetisdeprecated\n#define MEXGET MEXGETISDEPRECATED\n#define mexSet mexSetIsDeprecated\n#define mexset mexsetisdeprecated\n#define MEXSET MEXSETISDEPRECATED\n#define mexSetTrapFlag mexSetTrapFlagIsDeprecated\n#define mexsettrapflag mexsettrapflagisdeprecated\n#define MEXSETTRAPFLAG MEXSETTRAPFLAGISDEPRECATED\n\n#endif\n/* Current MATRIX published API version */\n#define MX_CURRENT_API_VER 0x08000000\n#define FORT_MX_CURRENT_API_VER z'08000000'\n\n/* Backward compatible MATRIX published API versions */\n#define MX_LAST_32BIT_VER 0x07000000\n#define MX_LAST_SEPARATE_COMPLEX_VER 0x07300000\n#define FORT_MX_LAST_32BIT_VER z'07000000'\n#define FORT_MX_LAST_SEPARATE_COMPLEX_VER z'07300000'\n\n/* Required MEX-file MATRIX published API version */\n#if TARGET_API_VERSION == 700\n#if defined(MX_COMPAT_32)\n#define MX_TARGET_API_VER MX_LAST_32BIT_VER\n#define FORT_MX_TARGET_API_VER FORT_MX_LAST_32BIT_VER\n#else\n#define MX_TARGET_API_VER MX_LAST_SEPARATE_COMPLEX_VER\n#define FORT_MX_TARGET_API_VER FORT_MX_LAST_SEPARATE_COMPLEX_VER\n#endif\n#else\n#define MX_TARGET_API_VER MX_CURRENT_API_VER\n#define FORT_MX_TARGET_API_VER FORT_MX_CURRENT_API_VER\n#endif\n\n/*\n * The following macros enable conditional compilation based on the\n * target published API. The macros can be used in a single source file\n * that is intended to be built against multiple matrix API versions.\n *\n * MX_HAS_64BIT_ARRAY_DIMS evaluates to a non-zero value if array\n * dimensions are 64 bits wide.\n *\n * MX_HAS_INTERLEAVED_COMPLEX evaluates to a non-zero value if complex\n * array data is interleaved.\n *\n */\n\n#ifdef __GFORTRAN__\n#define MX_HAS_64BIT_ARRAY_DIMS MX_TARGET_API_VER > MX_LAST_32BIT_VER\n#define MX_HAS_INTERLEAVED_COMPLEX MX_TARGET_API_VER > MX_LAST_SEPARATE_COMPLEX_VER\n#else\n#define MX_HAS_64BIT_ARRAY_DIMS FORT_MX_TARGET_API_VER > FORT_MX_LAST_32BIT_VER\n#define MX_HAS_INTERLEAVED_COMPLEX FORT_MX_TARGET_API_VER > FORT_MX_LAST_SEPARATE_COMPLEX_VER\n#endif\n\n"},{"name":"fixedpoint.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#include \"fixpoint_spec.h\"\n/* Copyright 1994-2010 The MathWorks, Inc.\n */\n\n#ifdef SUPPORTS_PRAGMA_ONCE\n#pragma once\n#endif\n\n#ifndef fix_published_intro_h\n#define fix_published_intro_h\n\n/* Abstract:\n *\n * The primary motivation of this header file is to allow customers to\n * write C language S-functions that support fixed-point data types.  However,\n * the API in this header extends beyond fixed-point and includes support for\n * standard floating point and integer data types.  \n *\n * This header contains definitions and prototypes for use in creating \n * Simulink S-functions that can process a wide variety of data types.\n * These data types include the Simulink builtin data types,\n *     double        single\n *     uint8         int8\n *     uint16        int16\n *     uint32        int32\n * all the MathWorks defined fixed-point data types such as\n *     sfix16_En15\n *     ufix32_En16\n *     ufix128\n *     sfix37_S3_B5\n * and the versions of data types obtained when Data Type Override is set\n * to Scaled Doubles such as\n *     flts16\n *     flts16_En15\n *     fltu32_S3_B5\n *\n * This header file contains functions and definitions that allow S-functions\n * to determine which of these data types an input port or output port is\n * using.  The S-function can also specify which of these data types should\n * be used for an input, output, DWork state, or Runtime Parameter.  The\n * information required to properly read to and write from different variables\n * of each data type is given.\n */\n\n/* Note on License Design:\n *\n * The following comments are simply an attempt to clarify the License Design \n * so that authors can write better S-functions.\n * As of \n *      Release 13\n *      Simulink 5.0\n *      Fixed-Point Blockset 4.0\n * all the blocks from Fixed-Point Blockset were merged into Simulink.  All\n * the blocks are installed even if a user does not have a Fixed-Point License.\n * Simulink customers can use all the blocks with any builtin data types that a\n * block supports.  If all the blocks in a model are only using builtin data\n * types and the Min-Max-Overflow Logging Mode is set to Force Off, then a \n * Fixed-Point License is NOT required.  If any block in a model is \"actively\" \n * using a non-builtin fixed-point data type or is actively logging Min-Max and/or\n * Overflow information, then a Fixed-Point License will be required for the \n * remainder of that Matlab session.  \n *   Even if blocks in a model are configured to have fixed-point signals and/or\n * configured to log Min-Max-Overflow information, then simply loading, viewing, \n * editing, or saving a model should not trigger active use.  Actions such as \n * Update Diagram, Simulation, and Code Generation from such a model are active \n * use and would cause a Fixed-Point License to be checked out.\n *   S-functions written using the API in this header file should be able to\n * follow this license design.  For example, suppose an S-function is written\n * so that it can handle any builtin or fixed-point data type.  Suppose in a\n * particular model, this S-function is processing just builtin data types such \n * as double, single, uint8, or int32.  That use case would not trigger a \n * Fixed-Point License to be checked out.  Suppose in a different model,\n * the S-function was processing non-builtin fixed-point data types.  That use,\n * like any other use of fixed-point data types, would cause a Fixed-Point \n * License to be checked out.\n *   The key pitfall S-function authors must guard against is registering\n * a fixed-point data type when a model is simply being loaded or viewed.  In\n * Simulink jargon, loading or opening a model or sub-system is a \n * \"Sizes Call Only.\"  The Simulink S-function API provides a way to detect a\n * \"Sizes Call Only\", so by careful programming, an S-function author can avoid \n * Fixed-Point License problems when a user is simply loading or viewing a model.\n */\n\n/* Simulink supports fixed-point data types with any number of bits from\n *    1 to FXP_MAX_BITS for unsigned numbers and \n *    2 to FXP_MAX_BITS for signed numbers.\n * The API in this header file treats pure integers just like\n * any other fixed-point numbers.  Pure integers just happen \n * to have trivial scaling.  The 6 standard Simulink integer\n * types uint8, int8, uint16, int16, uint32, and int32 are not \n * exceptions.  They are treated like fixed-point numbers \n * that happened to have trivial scaling and happened to have\n * 8, 16, or 32 bits.  The same API applies.\n *   Simulink builtin integers are special only in that they do\n * not trigger the need for a Fixed-Point License. \n *\n * The number of bits used to represent a signal in simulation\n * may be more than the number specified.  In this case, the\n * signals will be emulated inside various sized containers \n * according to the following rules.  For 32 or fewer bits, the\n * rules are simple.  For 32 or fewer bits, the container is a\n * scalar integer type directly understood by the compiler.  The\n * case of using a scalar integer type is classified as single-word.\n * The three cases with 32 or fewer bits are shown by a table.\n *\n *   Specified Bits       Container Bits   Container typedef\n *    1 to  8              8               int8_T  or uint8_T\n *    9 to 16             16               int16_T or uint16_T\n *   17 to 32             32               int32_T or uint32_T\n *\n * For 33 or more bits, the rules are more complicated and can\n * depend on the model, the Matlab Host, the current target\n * for code generation, and the version of Simulink Fixed Point\n * being used.  Signals with 33 or more bits will either be stored \n * using a single-word \n * container with more than 32 bits or will be stored using a \n * multi-word representation.\n *\n * All multi-word representations will follow a general form.\n * \n * typedef struct {\n *     SOME_UNSIGNED_CHUNK_TYPE chunks[ NUM_CHUNKS_FOR_M_BITS ];\n * } (u)intM_T\n *\n * The chunk at index zero will hold the least significant bits, and\n * the highest index will hold the most significant bits.\n *\n * Whether single-word or multi-word is used can depend on \n * the model, the Matlab Host, the current \n * target for code generation, and the version of Simulink Fixed Point.\n * The specific type used for SOME_UNSIGNED_CHUNK_TYPE can also vary depending\n * on the model, the Matlab Host, the current target for code generation,\n * and the version of Simulink Fixed Point.\n * \n * To be portable, sfunctions that are intended to support fixed-point\n * signals with more than 32 bits must react to container variations\n * at runtime.  The most general way to do this is to use the interfaces\n * for getting and setting \"bit-regions\" provided by this header.\n * To support use of code optimized to a specific additional APIs\n * are provided that can query the current properties of a data type.\n * However, sfunction authors need to be aware the properties of a data \n * type can vary depending on\n * the model, the Matlab Host, the current \n * target for code generation, and the version of Simulink Fixed Point.\n * A robustly written sfunction will need to check the properties at runtime\n * at least once after update diagram has started.  The most portable sfunctions\n * will be written so that they can use an optimized case if possible or \n * switch to general bit-region case if necessary.  At the very least,\n * a robust sfunction will need to gracefully set an error if does not\n * have a case that supports the current memory layout.  Keep in mind that\n * supporting every specific case for the current release of Simulink Fixed Point\n * does not guarantee that every specific case in a future release will be \n * covered.  For this reason, it is best to have bit-region case or at\n * the very least gracefully error if needed.\n *\n * For signed numbers, the bit encoding format is always \n * two's complement.\n *\n * When the specified number of bits is less than the size of\n * the container, the desired bits are always stored in the\n * least significant part of the container.  Any \"unused\" bits\n * are in the most significant part of the container.  \n * \n * For both single word case and multiword cases, any unused bits \n * must be set to a sign extension.  If the data type is\n * an unsigned number, then obviously, the number is always\n * nonnegative so the (implicit) sign bit is zero.  For unsigned\n * data types, all unused bits must always be cleared to zero.\n *    If the data type is a signed number, then the sign bit is\n * one for strictly negative numbers and zero otherwise.  If\n * the stored integer is negative, then all unused bits must be\n * set to one.  If the stored integer is positive, then all\n * unused bits must be cleared to zero.\n *\n * Simulink also supports two builtin floating point data types.  \n * These are the standard floating point singles and doubles.\n *\n * Simulink also supports a data type category that is a hybrid \n * between floating-point and fixed-point.  This category is\n * called ScaledDouble.  ScaledDouble cases occur when\n * an individual block is configured to have a fixed-point\n * output, but the system it lives in has its Data Type Override \n * setting for a system is set to Scaled Doubles.  The\n * resulting data type has the scaling the fixed-point\n * specification, but stores its output using floating \n * point doubles.  Storing in a double means that overflow\n * and precision issues are almost always eliminated. Removing the \n * range and precision issues is very useful for benchmarking, testing, \n * and debugging. \n *   ScaledDouble data types contain information\n * signedness and number of bits of what their non-overrided data \n * types would have been.  This is useful for information for other\n * portions of the model that are not being debugged with Data Type \n * Override.\n */\n\n#endif /* fix_published_intro_h */\n/* Copyright 1994-2010 The MathWorks, Inc.\n */\n\n#ifdef SUPPORTS_PRAGMA_ONCE\n#pragma once\n#endif\n\n#ifndef fxplimits_h\n#define fxplimits_h\n\n#define FXP_MAX_BITS 128\n\n#endif /* fxplimits_h */\n/* Copyright 1994-2010 The MathWorks, Inc.\n */\n\n#ifdef SUPPORTS_PRAGMA_ONCE\n#pragma once\n#endif\n\n#ifndef fxpsimulinkscalingintro_h\n#define fxpsimulinkscalingintro_h\n\n/* Simulink Scaling\n *\n * Simulink data types support scaling.  The Fixed-Point User's Guide\n * presents the following general formula.\n * \n *    V = S * Q + B\n *\n * where\n *\n *    V is the Real World Value in the engineering units of choice\n *    Q is the called the Stored Integer Value.  It is the raw value \n *      stored in the digital hardware.  Despite the name Q can use\n *      an integer or a floating point format.\n *    S is the Slope.  For clarity, this is also called the Total-Slope\n *    B is the Bias\n *\n * The Total-Slope is often decomposed into two parts.\n *\n *    S = F * 2^E\n *\n * where\n *\n *   1. <= F < 2.0\n *\n *    F is the Fractional Slope\n *    E is the Fixed Exponent, E is always an integer.\n *\n * If\n *    B == 0.0\n * and\n *    F == 1.0\n * then\n * there is a clean binary point interpretation.\n *\n *    Fraction Length = -1 * Fixed Exponent \n *\n * For example, if \n *    S == 0.125\n *    B == 0.0\n * then\n *    F == 1.0\n *    E == -3\n * so\n *    Fraction Length = 3\n * therefore, this data type has 3 bits to the right of the\n * binary point.\n *\n * The concept of scaling is most useful for fixed-point cases, but\n * it does generalize to all the scalar numeric data types.  For\n * floating point doubles and singles and for pure integers, \n * the scaling is trivial\n *    B == 0\n *    S == 1\n *    F == 1\n *    E == 0\n *    Fraction Length == 0\n * The access methods to get scaling information can be used\n * for all the data types, they just return trivial values\n * when the scaling is trivial.\n */ \n\n#endif /* fxpsimulinkscalingintro_h */\n/* Copyright 2011-2102 The MathWorks, Inc.\n */\n#ifndef SL_TYPES_FXPMODEOVERFLOW_HPP\n#define SL_TYPES_FXPMODEOVERFLOW_HPP\n\n/* The enums specify the overflow handling modes supported by most fixed-point\n * math functions.\n */\ntypedef enum fxpModeOverflow_tag {\n    FXP_OVERFLOW_WRAP = 0, /* must be zero */\n    FXP_OVERFLOW_SATURATE\n\n} fxpModeOverflow;\n\n#endif /* SL_TYPES_FXPMODEOVERFLOW_HPP */\n/* Copyright 2011-2012 The MathWorks, Inc.\n */\n#ifndef SL_TYPES_FXPMODEROUNDING_HPP\n#define SL_TYPES_FXPMODEROUNDING_HPP\n\n/* The enums specify the rounding modes supported by most fixed-point\n * math functions.\n */\ntypedef enum fxpModeRounding_tag {\n    FXP_ROUND_ZERO = 0, /* must be zero */\n    FXP_ROUND_NEAR,\n    FXP_ROUND_CEIL,\n    FXP_ROUND_FLOOR,\n    FXP_ROUND_SIMPLEST,\n    FXP_ROUND_NEAR_ML, /* Round -x.5 to -(x+1) not -x so as to match MATLAB. */\n    FXP_ROUND_CONVERGENT\n} fxpModeRounding;\n\n#define FXP_ROUND_METHOD_COUNT ((FXP_ROUND_CONVERGENT) + 1)\n\n#endif /* SL_TYPES_FXPMODEROUNDING_HPP */\n/* Copyright 1994-2010 The MathWorks, Inc.\n */\n\n#ifdef SUPPORTS_PRAGMA_ONCE\n#pragma once\n#endif\n\n#ifndef fix_published_fxpOverflowLogs_h\n#define fix_published_fxpOverflowLogs_h\n\n/* Overflow logging structure\n *\n * Some fixed-point math functions accept a pointer to this structure.\n * These functions will initialize each of the event counts to zero.  Then\n * the functions will carryout the requested math operations.  Each\n * time an event is detect during the math operation the appropriate \n * count will be incremented.  The increment operations makes sure\n * the count does not overflow to zero; it will saturate to the upper limit.\n *   \n * For example, suppose a fixed-point conversion function is called. Suppose,\n * one overflow occurred during the conversion.  After the function return,\n * the memory pointed to be overflow logging structure pointer would indicate\n * one overflow, zero saturations, and zero divide-by-zeros.\n */\ntypedef struct fxpOverflowLogs_tag\n{\n      int OverflowOccurred;\n      int SaturationOccurred;\n      int DivisionByZeroOccurred;\n\n} fxpOverflowLogs;\n\n#endif /* fix_published_fxpOverflowLogs_h */\n/* Copyright 1994-2019 The MathWorks, Inc.\n * \n * \n */\n\n#ifdef SUPPORTS_PRAGMA_ONCE\n#pragma once\n#endif\n\n#ifndef fix_published_sfun_api_h\n#define fix_published_sfun_api_h\n\n#if(defined(COMPILE_FOR_SEA))\n/* Expose the System object simstruc.h (via simstruc.hpp) */\n#  include \"systemobject_sfun/simstruc.hpp\"\n#else\n# if (defined(BUILDING_LIBFIXEDPOINT) || defined(DLL_IMPORT_SYM))\n  /* internal use: include internal copy of simstruc.h */\n#  include \"simstruct/simstruc.h\"\n# else\n/* Expose the simstruc.h */\n#  include \"simstruc.h\"    \n# endif\n#endif\n\n\n/* Function: ssRegisterDataTypeInteger ===============================\n * \n * This function fully registers any integer data type with Simulink and \n * returns a Data Type Id. Supported types are\n *    Unsigned with wordlength 1 up to 128\n *    Signed   with wordlength 2 up to 128\n * \n * This function is available for any Simulink install, even if \n * Fixed-Point Designer is not installed.\n * If the registered wordlength of the integer is 8, 16, 32, or 64,\n * then a Simulink license is sufficient.\n * For any of the other 124 possible wordlengths,\n * a Fixed-Point Designer license is required.\n *\n *\n * Unlike the standard Simulink function, ssRegisterDataType, additional \n * registration steps do not need to be taken \n * and should not be taken.  The returned Data Type Id can be used to specify\n * the data types of input ports, output ports, RunTimeParameters, and DWork\n * states.  The Data Type Id can also be used with all the standard \n * data type access methods in simstruc.h such as ssGetDataTypeSize. \n *    \n * The input arguments are\n *    isSigned              TRUE if signed, FALSE if unsigned\n *    wordLength            total number of bits including any sign bit\n *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override\n *                          if TRUE obey Data Type Override setting, depending\n *                          on Data Type Override, resulting data type could be\n *                          True Double, True Single, Scaled Double, or the \n *                          requested fixed point type.\n *\n * Cautions:\n *\n * 1) If the registered data type is not one of the builtin data types, then\n * a Fixed-Point License will be checked out.  To prevent, a Fixed-Point\n * License from being checked out when a user simply opens or views a model,\n * calls to registration should be protected with\n *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )\n *       ssRegisterDataType ...\n * \n * 2) In general, there is no fixed relationship between the Data Type Id value \n * and the input arguments.  Simulink hands out data type Ids on a first come,\n * first served basis, so small changes to a model can cause a different data\n * type id value to be returned.  Always use functions to get data type\n * attributes from the data type id; never directly rely on the data type\n * id value.  \n */\nFIXPOINT_EXPORT_EXTERN_C DTypeId ssRegisterDataTypeInteger(\n    SimStruct *S,\n    int isSigned,\n    int wordLength,\n    int obeyDataTypeOverride\n    );\n\n\n\n/* Function: ssRegisterDataTypeFxpBinaryPoint ===============================\n * \n * This function fully registers a fixed-point data type with Simulink and \n * returns a Data Type Id.  Unlike the standard Simulink function, \n * ssRegisterDataType, additional registration steps do not need to be taken \n * and should not be taken.  The returned Data Type Id can be used to specify\n * the data types of input ports, output ports, RunTimeParameters, and DWork\n * states.  The Data Type Id can also be used with all the standard \n * data type access methods in simstruc.h such as ssGetDataTypeSize. \n *    \n * The input arguments are\n *    isSigned              TRUE if signed, FALSE if unsigned\n *    wordLength            total number of bits including any sign bit\n *    fractionLength        number of bit to right of binary point\n *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override\n *                          if TRUE obey Data Type Override setting, depending\n *                          on Data Type Override, resulting data type could be\n *                          True Double, True Single, Scaled Double, or the \n *                          requested fixed point type.\n *\n * Cautions:\n *\n * 1) If the registered data type is not one of the builtin data types, then\n * a Fixed-Point License will be checked out.  To prevent, a Fixed-Point\n * License from being checked out when a user simply opens or views a model,\n * calls to registration should be protected with\n *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )\n *       ssRegisterDataType ...\n * \n * 2) There is no fixed relationship between the Data Type Id value and\n * the input arguments.  Simulink hands out data type Ids on a first come, first\n * served basis, so small changes to a model can cause a different data\n * type id value to be returned.  Always uses functions to get data type\n * attributes from the data type id; never directly rely on the data type\n * id value.  \n */\nFIXPOINT_EXPORT_EXTERN_C DTypeId ssRegisterDataTypeFxpBinaryPoint(\n    SimStruct *S,\n    int isSigned,\n    int wordLength,\n    int fractionLength,\n    int obeyDataTypeOverride\n    );\n    \n    \n    \n/* Function: ssRegisterDataTypeFxpSlopeBias ===============================\n * \n * This function fully registers a fixed-point data type with Simulink and \n * returns a Data Type Id.  Unlike the standard Simulink function, \n * ssRegisterDataType, additional registration steps do not need to be taken \n * and should not be taken.  The returned Data Type Id can be used to specify\n * the data types of input ports, output ports, RunTimeParameters, and DWork\n * states.  The Data Type Id can also be used with all the standard \n * data type access methods in simstruc.h such as ssGetDataTypeSize. \n *    \n * The input arguments are\n *    isSigned              TRUE if signed, FALSE if unsigned\n *    wordLength            total number of bits including any sign bit\n *    totalSlope            total slope\n *    bias                  bias\n *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override\n *                          if TRUE obey Data Type Override setting, depending\n *                          on Data Type Override, resulting data type could be\n *                          True Double, True Single, Scaled Double, or the \n *                          requested fixed point type.\n *\n * Cautions:\n *\n * 1) If the registered data type is not one of the builtin data types, then\n * a Fixed-Point License will be checked out.  To prevent, a Fixed-Point\n * License from being checked out when a user simply opens or views a model,\n * calls to registration should be protected with\n *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )\n *       ssRegisterDataType ...\n * \n * 2) There is no fixed relationship between the Data Type Id value and\n * the input arguments.  Simulink hands out data type Ids on a first come, first\n * served basis, so small changes to a model can cause a different data\n * type id value to be returned.  Always uses functions to get data type\n * attributes from the data type id; never directly rely on the data type\n * id value.  \n */\nFIXPOINT_EXPORT_EXTERN_C DTypeId ssRegisterDataTypeFxpSlopeBias(\n    SimStruct *S,\n    int isSigned,\n    int wordLength,\n    double totalSlope,\n    double bias,\n    int obeyDataTypeOverride\n    );\n\n\n\n/* Function: ssRegisterDataTypeFxpFSlopeFixExpBias =============================\n * \n * This function fully registers a fixed-point data type with Simulink and \n * returns a Data Type Id.  Unlike the standard Simulink function, \n * ssRegisterDataType, additional registration steps do not need to be taken \n * and should not be taken.  The returned Data Type Id can be used to specify\n * the data types of input ports, output ports, RunTimeParameters, and DWork\n * states.  The Data Type Id can also be used with all the standard \n * data type access methods in simstruc.h such as ssGetDataTypeSize. \n *    \n * The input arguments are\n *    isSigned              TRUE if signed, FALSE if unsigned\n *    wordLength            total number of bits including any sign bit\n *    fractionalSlope       fractional slope\n *    fixedExponent         fixed exponent\n *    bias                  bias\n *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override\n *                          if TRUE obey Data Type Override setting, depending\n *                          on Data Type Override, resulting data type could be\n *                          True Double, True Single, Scaled Double, or the \n *                          requested fixed point type.\n *\n * Cautions:\n *\n * 1) If the registered data type is not one of the builtin data types, then\n * a Fixed-Point License will be checked out.  To prevent, a Fixed-Point\n * License from being checked out when a user simply opens or views a model,\n * calls to registration should be protected with\n *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )\n *       ssRegisterDataType ...\n * \n * 2) There is no fixed relationship between the Data Type Id value and\n * the input arguments.  Simulink hands out data type Ids on a first come, first\n * served basis, so small changes to a model can cause a different data\n * type id value to be returned.  Always uses functions to get data type\n * attributes from the data type id; never directly rely on the data type\n * id value.  \n */\nFIXPOINT_EXPORT_EXTERN_C DTypeId ssRegisterDataTypeFxpFSlopeFixExpBias(\n    SimStruct *S,\n    int isSigned,\n    int wordLength,\n    double fractionalSlope,\n    int fixedExponent,\n    double bias,\n    int obeyDataTypeOverride\n    );\n\n\n\n/* Function: ssRegisterDataTypeFxpScaledDouble =============================\n * \n * This function fully registers a fixed-point data type with Simulink and \n * returns a Data Type Id.  Unlike the standard Simulink function, \n * ssRegisterDataType, additional registration steps do not need to be taken \n * and should not be taken.  The returned Data Type Id can be used to specify\n * the data types of input ports, output ports, RunTimeParameters, and DWork\n * states.  The Data Type Id can also be used with all the standard \n * data type access methods in simstruc.h such as ssGetDataTypeSize. \n *    \n * The input arguments are\n *    isSigned              TRUE if signed, FALSE if unsigned\n *    wordLength            total number of bits including any sign bit\n *    fractionalSlope       fractional slope\n *    fixedExponent         fixed exponent\n *    bias                  bias\n *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override\n *                          if TRUE obey Data Type Override setting, depending\n *                          on Data Type Override, resulting data type could be\n *                          True Double, True Single, Scaled Double, or the \n *                          requested fixed point type.\n *\n * Cautions:\n *\n * 1) If the registered data type is not one of the builtin data types, then\n * a Fixed-Point License will be checked out.  To prevent, a Fixed-Point\n * License from being checked out when a user simply opens or views a model,\n * calls to registration should be protected with\n *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )\n *       ssRegisterDataType ...\n * \n * 2) There is no fixed relationship between the Data Type Id value and\n * the input arguments.  Simulink hands out data type Ids on a first come, first\n * served basis, so small changes to a model can cause a different data\n * type id value to be returned.  Always uses functions to get data type\n * attributes from the data type id; never directly rely on the data type\n * id value.\n */\nFIXPOINT_EXPORT_EXTERN_C DTypeId ssRegisterDataTypeFxpScaledDouble(\n    SimStruct *S,\n    int isSigned,\n    int wordLength,\n    double fractionalSlope,\n    int fixedExponent,\n    double bias,\n    int obeyDataTypeOverride\n    );\n\n\n/* Function: ssRegisterDataTypeHalfPrecision =============================\n * \n * This function fully registers a Half precision data type with Simulink and \n * returns a Data Type Id.  Unlike the standard Simulink function, \n * ssRegisterDataType, additional registration steps do not need to be taken \n * and should not be taken.  The returned Data Type Id can be used to specify\n * the data types of input ports, output ports, RunTimeParameters, and DWork\n * states.  The Data Type Id can also be used with all the standard \n * data type access methods in simstruc.h such as ssGetDataTypeSize. \n * \n * The supported half precision (binary16) floating-point format is specified \n * in IEEE 754 standard with following format: \n * . Sign bit: 1 bit      \n * . Exponent width: 5 bits \n * . Significand precision 11 bits (10 explicitly stored)\n * \n *  sign  exponent:5bits    fraction:10bits\n * | b15 | b14... ... b10 | b9 ... ... b0   |\n *    \n * The input arguments are\n *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override\n *                          if TRUE obey Data Type Override setting, depending\n *                          on Data Type Override, resulting data type could be\n *                          True Double, True Single, Scaled Double, or the \n *                          requested fixed point type.\n *\n * Cautions:\n *\n * 1) When registering Half precision data type, a Fixed-point Designer\n * License will be checked out. To prevent a Fixed-Point Designer License\n * from being checked out when a user simply opens or views a model,\n * calls to registration should be protected with\n *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )\n *       ssRegisterDataType ...\n * \n * 2) There is no fixed relationship between the Data Type Id value and\n * the input arguments.  Simulink hands out data type Ids on a first come, first\n * served basis, so small changes to a model can cause a different data\n * type id value to be returned.  It is recommended to always use functions to \n * get data type attributes from the data type id; never directly rely on \n * the data type id value.\n */\nFIXPOINT_EXPORT_EXTERN_C DTypeId ssRegisterDataTypeHalfPrecision(\n    SimStruct *S,\n    int obeyDataTypeOverride\n    );\n\n\n/* Function: ssGetDataTypeIsFxpFltApiCompat ==============================\n * \n * Giving a registered Data Type Id as input, determine if it is \n * supported by the API for user written fixed-point and floating-point\n * s-functions.  Support covers all the standard Simulink numeric types \n * double, single, uint8, ..., int32.  It also includes all the Fixed-Point \n * data types, including ScaledDouble versions.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeIsFxpFltApiCompat(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\ntypedef enum fxpStorageContainerCategory_tag {\n    FXP_STORAGE_UNKNOWN = 0,\n    FXP_STORAGE_DOUBLE,\n    FXP_STORAGE_SINGLE,\n    FXP_STORAGE_UINT8,\n    FXP_STORAGE_INT8,\n    FXP_STORAGE_UINT16,\n    FXP_STORAGE_INT16,\n    FXP_STORAGE_UINT32,\n    FXP_STORAGE_INT32,\n    FXP_STORAGE_CHUNKARRAY,\n    FXP_STORAGE_SCALEDDOUBLE,\n    FXP_STORAGE_OTHER_SINGLE_WORD,\n    FXP_STORAGE_MULTIWORD,\n    FXP_STORAGE_HALFPRECISION\n} fxpStorageContainerCategory;\n\n\n/* Function: ssGetDataTypeStorageContainCat ===============================\n * \n * Giving a registered Data Type Id as input, determine the Storage Container\n * Category used to represent Input Signals, Output Signals, Run Time \n * Parameters, DWorks, etc. during Simulink Simulations.\n *   Descriptions of the Storage Containers and the definitions of\n * the output fxpStorageContainerCategory are given earlier in this header\n * file.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C fxpStorageContainerCategory ssGetDataTypeStorageContainCat(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeStorageContainSize ===============================\n * \n * Giving a registered Data Type Id as input, determine the Storage Container\n * Size used to represent Input Signals, Output Signals, Run Time \n * Parameters, DWorks, etc. during Simulink Simulations.  This is the size\n * that the sizeof() function would return.  This is the appropriate size\n * measurement to pass to functions like memcpy().\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n *\n * This functions gives the same answer as the standard function \n * ssGetDataTypeSize.  This alternate version is only provide to reinforce\n * the distinction between specified word length and container size.  For\n * example, sfix24_En10 is specified to have 24 bits, but it actually is\n * stored in a larger container during Simulink Simulations.  The size of\n * the larger container is returned by this function.  This is the proper\n * value to use for memcpy, malloc, etc.\n */\nFIXPOINT_EXPORT_EXTERN_C size_t ssGetDataTypeStorageContainerSize(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeIsFixedPoint ===============================\n * \n * Giving a registered Data Type Id as input, determine the if the data\n * type is a fixed-point type.  Pure integers including the standard Simulink\n * integer types uint8, int8, uint16, uint32, and int32 are classified\n * as fixed-point types by this function.  Double, Single, Half and \n * ScaledDouble are NOT classified as fixed-point types.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeIsFixedPoint(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeIsFloatingPoint ===============================\n * \n * Giving a registered Data Type Id as input, determine if the data\n * type is a traditional floating-point type.  Double and Single  \n * are traditional floating-point types.  ScaledDouble and Half is NOT classified\n * as traditional floating-point types.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeIsFloatingPoint(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n/* Function: ssGetDataTypeIsDoubleSingleOrHalf ===============================\n * \n * Giving a registered Data Type Id as input, determine if the data\n * type is double, single or half precision type specified by IEEE 754 standard.\n * This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeIsDoubleSingleOrHalf(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n\n/* Function: ssGetDataTypeIsHalfPrecision ===============================\n * \n * Giving a registered Data Type Id as input, determine if the data\n * type is a Half precision type, which is specified in IEEE754 standard.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeIsHalfPrecision(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeFxpWordLength ===============================\n * \n * Giving a registered Data Type Id as input, determine the word length \n * of the data type.  \n *     When the data type is fixed-point (including pure\n * integers), the word length is the total number of bits including \n * any sign bits, any bits in the integer part, and any bits in the \n * fractional bits.  \n *     When the data type is ScaledDouble, the\n * word length is the total bits the original data type would have\n * used if override had not occurred.  For example, flts32_En4 would \n * have been sfix32_En4 if Data Type Override was off.  The word length is\n * therefore 32 bits.\n *     When the data type is true floating-point, this function errors\n * out.  Word length for a floating-point data type can mean different\n * things to different users.  For some, word length should only be the\n * physical mantissa bits excluding the hidden lead one.  For others,\n * the hidden leading one should be included.  For still others, the \n * word length should be all the physical bits including sign bit,\n * exponent bits, and mantissa bits, but not the hidden bit.  Rather\n * than mislead some users, this function errors out.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeFxpWordLength(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeFxpContainWordLen ===============================\n * \n * Giving a registered Data Type Id as input, determine the word length \n * of the storage container.\n *    When the data type is fixed-point (including pure\n * integers), the word length is the total number of bits including \n * any sign bits, any bits in the integer part, and any bits in the \n * fractional bits.  \n *   The information provided by this function is not meaning full\n * when the data type is ScaledDouble or true floating point.  For\n * these data types, this function will error out.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeFxpContainWordLen(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeFxpIsSigned ===============================\n * \n * Giving a registered Data Type Id as input, return true if the data\n * type is signed, and return false if it is unsigned.  \n *    When the data type is fixed-point (including pure\n * integers), the meaning of signed or unsigned is obvious.\n *     When the data type is ScaledDouble, the whether the data type\n * is signed or unsigned is determined by what the original data type would \n * have used if override had not occurred.  For example, flts32_En4 would \n * have been sfix32_En4 if Data Type Override was off.  This uses a signed\n * integer so the return value is true.  Conversely, fltu8_S3 would have\n * used ufix8_S3 which is unsigned, so false would be returned.\n *     When the data type is true floating-point, this function errors\n * out.  Asking whether a floating point number is signed or unsigned causes\n * some confusion, so this is prevented.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeFxpIsSigned(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeIsScalingTrivial =============================\n * \n * Giving a registered Data Type Id as input, determine if the scaling\n * is the trivial case of \n *    Slope   S == 1.0\n *    Bias    B == 0.0\n * This is always true for pure integers like int8 and for the true floating\n * point types double and single.  It will also be true for ScaledDouble\n * of pure integers such as flts8.  For binary point scaling, trivial means\n * the binary point is just to the right of the least significant bit.\n * Equivalently, the fraction length is zero.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeIsScalingTrivial(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeIsScalingPow2 ===========================\n * \n * Giving a registered Data Type Id as input, determine if the scaling\n * is an exact power of two\n *    Fractional Slope   F == 1.0\n *    Bias               B == 0.0\n * If the scaling is trivial, then the answer is true.  For fixed-point\n * cases, the answer is true if there is a clean binary point interpretation\n * of the scaling.\n *    Many fixed-point algorithms are only designed to handle power of\n * two scaling.  For this algorithms, this function can be called in\n * mdlSetInputPortDataType and mdlSetOutputPortDataType to prevent\n * unsupported data types from being accepted.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeIsScalingPow2(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeFractionLength ===============================\n * \n * Giving a registered Data Type Id as input, determine the fraction\n * length for data types that use power of two scaling. \n *    This function should be called only if ssGetDataTypeIsScalingPow2 \n * returns true.  It errors out otherwise.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeFractionLength(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeTotalSlope ===============================\n * \n * Giving a registered Data Type Id as input, determine the scalings \n * total slope.\n *    S = F * 2^E\n * where\n *   1. <= F < 2.0\n *   S is the Total Slope\n *   F is the Fractional Slope\n *   E is the Fixed Exponent, E is always an integer\n *\n *     When the data type is ScaledDouble, the slope is determined by \n * what the original data type would  have used if override had not occurred.  \n * For example, flts32_En4 would have been sfix32_En4 if Data Type Override was \n * off.  The total slope is 0.0625 = 2^-4.   For fltu16_S7p98, the total \n * slope is 7.98\n *     When the data type has trivial scaling, including floating point\n * double and single, the total slope is the trivial value 1.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C double ssGetDataTypeTotalSlope(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeBias ===============================\n * \n * Giving a registered Data Type Id as input, determine the scalings \n * bias.\n *     When the data type is ScaledDouble, the slope is determined by \n * what the original data type would  have used if override had not occurred.  \n * For example, flts32_En4 would have been sfix32_En4 if Data Type Override was \n * off.  The bias is simply 0.   For fltu16_S3_Bn55p32, the total \n * slope is -55.32\n *     When the data type has trivial scaling, including floating point\n * double and single, the bias is the trivial value 0.  Likewise, when \n * the data type has power of two scaling, the bias is always the trivial\n * value 0.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C double ssGetDataTypeBias(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeFracSlope ===============================\n * \n * Giving a registered Data Type Id as input, determine the scalings \n * fractional slope.\n *    S = F * 2^E\n * where\n *   1. <= F < 2.0\n *   S is the Total Slope\n *   F is the Fractional Slope\n *   E is the Fixed Exponent, E is always an integer\n *\n *     When the data type is ScaledDouble, the slope is determined by \n * what the original data type would  have used if override had not occurred.  \n * For example, flts32_En4 would have been sfix32_En4 if Data Type Override was \n * off.  This case has power of two scaling, so the fractional slope is the \n * trivial case 1.   For fltu16_S3, the total slope is 3 which is decomposed\n * into Fixed Exponent +1 and Fractional Slope 1.5 \n *     When the data type has trivial scaling, including floating point\n * double and single, the total slope is the trivial value 1.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C double ssGetDataTypeFracSlope(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeFixedExponent ===============================\n * \n * Giving a registered Data Type Id as input, determine the scalings \n * fixed exponent.\n *    S = F * 2^E\n * where\n *   1. <= F < 2.0\n *   S is the Total Slope\n *   F is the Fractional Slope\n *   E is the Fixed Exponent, E is always an integer\n *\n * When the data type a clean binary point interpretation, the Fixed Exponent is \n * simply the negative of the Fraction Length.\n *     When the data type is ScaledDouble, the fixed exponent is determined by \n * what the original data type would  have used if override had not occurred.  \n * For example, flts32_En4 would have been sfix32_En4 if Data Type Override was \n * off.  This case has power of two scaling with fraction length +4 and\n * Fixed Exponent -4.   For fltu16_S3, the total slope is 3 which is decomposed\n * into Fixed Exponent +1 and Fractional Slope 1.5 \n *     When the data type has trivial scaling, including floating point\n * double and single, the fixed exponent is the trivial value 0.\n *   This function will error out if ssGetDataTypeIsFxpFltApiCompat\n * returns false.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeFixedExponent(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function: ssGetDataTypeIsInteger\n * \n * Giving a registered Data Type Id, determine the if the data\n * type is one of 255 integer types supported by Simulink.\n *     Unsigned with wordlength 1 up to 128\n *     Signed   with wordlength 2 up to 128\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeIsInteger(\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n/* Function: ssGetDataTypeIsSpecifiedInteger\n * \n * Giving a registered Data Type Id, determine\n * if the data type is an integer with the specified\n * signedness and wordlength.\n */\nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeIsSpecifiedInteger(\n    SimStruct *S,\n    DTypeId dataTypeId,\n    int isSigned,\n    int wordLength\n    );\n\n\nFIXPOINT_EXPORT_EXTERN_C void ssFxpConvert(\n    SimStruct *S,\n\n    void       *pVoidDest,\n    size_t      sizeofDest,\n    DTypeId     dataTypeIdDest,\n\n    const void *pVoidSrc,\n    size_t      sizeofSrc,\n    DTypeId     dataTypeIdSrc,\n\n    fxpModeRounding roundMode,\n    fxpModeOverflow overflowMode,\n\n    fxpOverflowLogs *pFxpOverflowLogs\n);\n\n\n\nFIXPOINT_EXPORT_EXTERN_C double ssFxpConvertToRealWorldValue(\n    SimStruct *S,\n    const void *pVoidSrc,\n    size_t      sizeofSrc,\n    DTypeId     dataTypeIdSrc\n);\n\n\n\nFIXPOINT_EXPORT_EXTERN_C void ssFxpConvertFromRealWorldValue(\n    SimStruct *S,\n\n    void       *pVoidDest,\n    size_t      sizeofDest,\n    DTypeId     dataTypeIdDest,\n\n    double      dblRealWorldValue,\n\n    fxpModeRounding roundMode,\n    fxpModeOverflow overflowMode,\n\n    fxpOverflowLogs *pFxpOverflowLogs\n);\n\n \n/* Function ssGetDataTypeNumberOfChunks\n *\n * Giving a dataTypeId as Input, return the number of chunks the container uses.\n *\n */ \nFIXPOINT_EXPORT_EXTERN_C int ssGetDataTypeNumberOfChunks (\n    SimStruct *S,\n    DTypeId dataTypeId\n    );\n\n\n/* Function ssFxpGetU32BitRegion\n *\n * This function accesses a fixed point data and returns the stored integer \n * value for the 32 bit region specified by region index. RegionIndex could \n * be any non-negative values. Emulation bits get padded if the RegionIndex \n * is larger than the data size.\n *\n * The input parameters are\n *       pVoid:   a void point to a memory area.\n *       dataTypeId:  a registered fixed point dataTypeId.\n *       regionIndex: the specified 32 bit region.\n *\n * Caution:\n * This function requires dataTypeId to be a valid fixed point data. Floating \n * point data is not supported.\n */\nFIXPOINT_EXPORT_EXTERN_C uint32_T ssFxpGetU32BitRegion(\n    SimStruct *S,\n\n    const void       *pVoid,\n\n    DTypeId     dataTypeId,\n\n    unsigned int regionIndex\n);\n\n\n/* Function ssFxpSetU32BitRegion\n *\n * This function directly sets the 32 bit region specified by region index for \n * a fixed point data. RegionIndex could be any non-negative values, but only\n * physical bits get written. It will error out if regionValue violates sign \n * extension of the fixed point data.\n *\n * The input parameters are\n *       pVoid:   a void point to a fixed point data.\n *       dataTypeId:  a valid fixed point data type id.\n *       regionValue: the value to be written to the 32 bit region.\n *       regionIndex: the specified 32 bit region.\n *\n * Caution:\n * This function requires dataTypeId to be a valid fixed point data. Floating \n * point data is not supported.\n */\nFIXPOINT_EXPORT_EXTERN_C void ssFxpSetU32BitRegion(\n    SimStruct *S,\n\n    void       *pVoid,\n\n    DTypeId     dataTypeId,\n\n    uint32_T    regionValue,\n\n    unsigned int regionIndex\n);\n\n\n/* Function: ssLogFixptInstrumentation =============================\n *    Record information collected during simulation, such as\n *    output maximum, minimum, and counts of any overflows, saturations, or\n *    divisions by zero that occurred.\n */ \nFIXPOINT_EXPORT_EXTERN_C void ssLogFixptInstrumentation(\n    SimStruct *S,\n    DTypeId dataTypeId,\n    double    minValue,\n    double    maxValue,\n    int countOverflows,\n    int countSaturations,\n    int countDivisionsByZero,\n    char *pStrName\n    );\n\n \n/* These two functions are obsolete and can be ignored.\n * They no longer have any impact on the memory layout for inputs and outputs.\n * The memory layout introduced in R2008a is always used.\n */\nFIXPOINT_EXPORT_EXTERN_C void ssFxpSetU32BitRegionCompliant(  \n    SimStruct *S,  \n    int value\n);\nFIXPOINT_EXPORT_EXTERN_C void ssFxpGetU32BitRegionCompliant(  \n    SimStruct *S,  \n    int *result\n);\n\n\n#endif /* fix_published_sfun_api_h */\n/* Copyright 1994-2019 The MathWorks, Inc.\n */\n\n#ifdef SUPPORTS_PRAGMA_ONCE\n#pragma once\n#endif\n\n#ifndef fix_published_deprecated_h\n#define fix_published_deprecated_h\n\n/* Deprecated items provided only for backwards compatibility */\n\n/* The term Doubles-Override is outdated and misleading.\n * Instead, the terms Data-Type-Override and Scaled-Doubles should be used \n * as appropriate.\n * The follow definition is provided for backwards compatibility\n */\n#define FXP_STORAGE_DOUBLESOVERRIDE FXP_STORAGE_SCALEDDOUBLE\n#define FXP_DT_FIXPT_DBL_OVER FXP_DT_SCALED_DOUBLE\n#define fxpIsDataTypeFixPtDblOver(pFxpDataTypeProp)   fxpIsDataTypeScaledDouble(pFxpDataTypeProp)\n#define fxpIsDataTypeFloatOrDblOver(pFxpDataTypeProp) (fxpIsDataTypeDoubleOrSclDbl(pFxpDataTypeProp) || fxpIsDataTypeSingle(pFxpDataTypeProp))\n\n\n#endif /* fix_published_deprecated_h */\n"},{"name":"fixpoint_spec.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2008-2011 The MathWorks, Inc. */\n\n#ifndef FIXPOINT_SPEC_H\n#define FIXPOINT_SPEC_H\n\n#ifdef SUPPORTS_PRAGMA_ONCE\n#pragma once\n#endif\n\n#ifdef BUILDING_LIBFIXEDPOINT\n\n# define FIXPOINT_EXPORT_CLASS    DLL_EXPORT_SYM\n# define FIXPOINT_EXPORT_FCN      DLL_EXPORT_SYM\n# define FIXPOINT_EXPORT          DLL_EXPORT_SYM\n# define FIXPOINT_EXPORT_EXTERN_C extern \"C\" DLL_EXPORT_SYM\n\n#elif defined(DLL_IMPORT_SYM)\n\n# define FIXPOINT_EXPORT_CLASS    DLL_IMPORT_SYM\n# define FIXPOINT_EXPORT_FCN      DLL_IMPORT_SYM\n# define FIXPOINT_EXPORT          DLL_IMPORT_SYM\n#ifdef __cplusplus\n# define FIXPOINT_EXPORT_EXTERN_C extern \"C\" DLL_IMPORT_SYM\n#else\n# define FIXPOINT_EXPORT_EXTERN_C extern DLL_IMPORT_SYM\n#endif\n\n#else\n\n#ifdef __cplusplus\n#define FIXPOINT_EXPORT_EXTERN_C extern \"C\"\n#else\n#define FIXPOINT_EXPORT_EXTERN_C extern\n#endif\n\n# define FIXPOINT_EXPORT_CLASS  extern\n# define FIXPOINT_EXPORT_FCN    extern\n# define FIXPOINT_EXPORT        extern\n\n#endif\n\n#endif \n\n"},{"name":"i18n_c_api.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2019 The Mathworks, Inc.*/\n\n/* \\file i18n_c_api.h */\n\n/* This file provide C interface for calling i18n level functionalities \n * like i18n initialization and what not */\n\n#ifndef i18n_c_api_h\n#define i18n_c_api_h\n\n#include \"tmwtypes.h\"\n\n#ifdef BUILDING_LIBMWI18N\n  #include \"package.h\"\n  #define LIBMWI18N_C_API extern \"C\" DLL_EXPORT_SYM\n#else\n  #if defined(__cplusplus)\n    #define LIBMWI18N_C_API extern \"C\"\n  #else \n    #define LIBMWI18N_C_API extern\n  #endif\n#endif\n\n/* Initialize i18n services API for apps with C codebase */\n\nLIBMWI18N_C_API void i18n_init(void);\n\n#endif\n"},{"name":"io64.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2002-2006 The MathWorks, Inc. */\n\n/* io64.h\n *\n * Include this header file if you need to perform file I/O\n * on large files greater than 2GB (2^31-1 bytes).\n * The definitions in this header file are designed to facilitate\n * cross-platform 64 bit file I/O.\n *\n * This file must be included before any other include file, at the\n * very top of your source file, even before system include files\n * such as stdio.h, to enable 64 bit file I/O for mex files.\n *\n * After including this file (io64.h), you should use the following\n * functions, structs and types for file I/O to enable file I/O beyond\n * the 2GB (2^31-1 byte) limit:\n *\n * fopen()        - 64 bit capable after including this file, use as always\n *                  with no changes\n *\n * getFilePos()   - use this function instead of ftell(), as ftell() is\n *                  not supported for 64 bit file I/O on most platforms.\n *                  getFilePos() is an alias for the POSIX fgetpos()\n *\n * setFilePos()   - use this function instead of fseek(), as fseek() is\n *                  not supported for 64 bit file I/O on most platforms.\n *                  setFilePos() is an alias for the POSIX fsetpos()\n *\n * fpos_T         - the offset argument for getFilePos() and setFilePos()\n *                  is really a pointer to a signed 64 bit integer,\n *                  int64_T, but it must be cast to (fpos_T*)\n *\n * getFileStat()  - use this function instead of stat() to get the size\n *                  in bytes of a file on disk specified by name\n *\n * getFileFstat() - use this function instead of fstat() to get the size\n *                  in bytes of an opened file specified by a FILE* pointer\n *\n * structStat     - use a pointer to a structStat instead of a pointer to\n *                  struct stat as argument to getFileStat() and\n *                  getFileFstat()\n *\n * No changes are required for the following functions:\n *\n * fprintf(), fscanf(), fread(), fwrite(), fclose().\n */\n\n#ifndef __tmw__io64__h__\n#define __tmw__io64__h__\n\n#define TMW_ENABLE_INT64 (-1)\n\n/* linux, hpux - must be defined before any other include file */\n#if defined(__linux__)\n#\tundef  _LARGEFILE64_SOURCE\n#\tdefine _LARGEFILE64_SOURCE\n#endif\n\n#include <stdio.h>\n#include <sys/stat.h>\n\n#if defined(_WIN32) /* windows */\n#\tdefine getFilePos   fgetpos\n#\tdefine setFilePos   fsetpos\n#\tdefine structStat   struct _stati64\n#\tdefine getFileStat  _stati64\n#\tdefine getFileFstat _fstati64\n#\tdefine fileno       _fileno\n#\tdefine fpos_T       fpos_t\n#elif defined(__APPLE__) /* mac */\n#\tdefine getFilePos   fgetpos\n#\tdefine setFilePos   fsetpos\n#\tdefine structStat   struct stat\n#\tdefine getFileStat  stat\n#\tdefine getFileFstat fstat\n#\tdefine fpos_T       fpos_t\n#elif defined(__linux__) || defined(__sun)\n#\tif defined(__GNUC__) && (__GNUC__ >= 3)\n\t\t/* fopen works for large files as-is */\n#\telse\n#\t\tdefine fopen fopen64\n#\tendif\n#\tdefine getFilePos   fgetpos64\n#\tdefine setFilePos   fsetpos64\n#\tdefine structStat   struct stat64\n#\tdefine getFileStat  stat64\n#\tdefine getFileFstat fstat64\n#\tdefine fpos_T       fpos64_t\n#endif\n\n#endif /* __tmw__io64__h__ */\n"},{"name":"lapack.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1984-2021 The MathWorks, Inc.\n * All Rights Reserved.\n */\n\n/*\n *  Header File include/mllapack.h\n *  Auto generated by f2h.pl, do not modify by hand\n */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef mllapack_h\n#define mllapack_h\n\n#if !defined(MW_HAVE_LAPACK_DECLS) && defined(_LAPACKE_H_) /* %#ok */\n#error \"The files lapack.h and lapacke.h may not be simultaneously included because of conflicting declarations of LAPACK routines. Include at most one of these headers in each source file.\" /* %#ok */\n#else  /* %#ok */\n#include <stddef.h>\n\n#if defined(_WIN32) || defined(__hpux)\n#define FORTRAN_WRAPPER(x) x\n#else\n#define FORTRAN_WRAPPER(x) x ## _\n#endif\n\n#ifndef COMPLEX_TYPES\n#define COMPLEX_TYPES\n  typedef struct{float r,i;} complex;\n  typedef struct{double r,i;} doublecomplex;\n#endif\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\n\n/* Source: dlamch.f */\n#define dlamch FORTRAN_WRAPPER(dlamch)\nextern double dlamch(\n    const char   *cmach\n);\n\n/* Source: dlamch.f */\n#define dlamc3 FORTRAN_WRAPPER(dlamc3)\nextern double dlamc3(\n    const double *a,\n    const double *b\n);\n\n/* Source: slamch.f */\n#define slamch FORTRAN_WRAPPER(slamch)\nextern float slamch(\n    const char   *cmach\n);\n\n/* Source: slamch.f */\n#define slamc3 FORTRAN_WRAPPER(slamc3)\nextern float slamc3(\n    const float  *a,\n    const float  *b\n);\n\n/* Source: cbbcsd.f */\n#define cbbcsd FORTRAN_WRAPPER(cbbcsd)\nextern void cbbcsd(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const char   *jobv2t,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *theta,\n    float  *phi,\n    float  *u1,\n    const ptrdiff_t *ldu1,\n    float  *u2,\n    const ptrdiff_t *ldu2,\n    float  *v1t,\n    const ptrdiff_t *ldv1t,\n    float  *v2t,\n    const ptrdiff_t *ldv2t,\n    float  *b11d,\n    float  *b11e,\n    float  *b12d,\n    float  *b12e,\n    float  *b21d,\n    float  *b21e,\n    float  *b22d,\n    float  *b22e,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *info\n);\n\n/* Source: cbdsqr.f */\n#define cbdsqr FORTRAN_WRAPPER(cbdsqr)\nextern void cbdsqr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncvt,\n    const ptrdiff_t *nru,\n    const ptrdiff_t *ncc,\n    float  *d,\n    float  *e,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgbbrd.f */\n#define cgbbrd FORTRAN_WRAPPER(cgbbrd)\nextern void cgbbrd(\n    const char   *vect,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncc,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *d,\n    float  *e,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *pt,\n    const ptrdiff_t *ldpt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgbcon.f */\n#define cgbcon FORTRAN_WRAPPER(cgbcon)\nextern void cgbcon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgbequ.f */\n#define cgbequ FORTRAN_WRAPPER(cgbequ)\nextern void cgbequ(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *r,\n    float  *c,\n    float  *rowcnd,\n    float  *colcnd,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: cgbequb.f */\n#define cgbequb FORTRAN_WRAPPER(cgbequb)\nextern void cgbequb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *r,\n    float  *c,\n    float  *rowcnd,\n    float  *colcnd,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: cgbrfs.f */\n#define cgbrfs FORTRAN_WRAPPER(cgbrfs)\nextern void cgbrfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *afb,\n    const ptrdiff_t *ldafb,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgbsv.f */\n#define cgbsv FORTRAN_WRAPPER(cgbsv)\nextern void cgbsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cgbsvx.f */\n#define cgbsvx FORTRAN_WRAPPER(cgbsvx)\nextern void cgbsvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *afb,\n    const ptrdiff_t *ldafb,\n    ptrdiff_t *ipiv,\n    char   *equed,\n    float  *r,\n    float  *c,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgbtf2.f */\n#define cgbtf2 FORTRAN_WRAPPER(cgbtf2)\nextern void cgbtf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: cgbtrf.f */\n#define cgbtrf FORTRAN_WRAPPER(cgbtrf)\nextern void cgbtrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: cgbtrs.f */\n#define cgbtrs FORTRAN_WRAPPER(cgbtrs)\nextern void cgbtrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cgebak.f */\n#define cgebak FORTRAN_WRAPPER(cgebak)\nextern void cgebak(\n    const char   *job,\n    const char   *side,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const float  *scale,\n    const ptrdiff_t *m,\n    float  *v,\n    const ptrdiff_t *ldv,\n    ptrdiff_t *info\n);\n\n/* Source: cgebal.f */\n#define cgebal FORTRAN_WRAPPER(cgebal)\nextern void cgebal(\n    const char   *job,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    float  *scale,\n    ptrdiff_t *info\n);\n\n/* Source: cgebd2.f */\n#define cgebd2 FORTRAN_WRAPPER(cgebd2)\nextern void cgebd2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tauq,\n    float  *taup,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgebrd.f */\n#define cgebrd FORTRAN_WRAPPER(cgebrd)\nextern void cgebrd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tauq,\n    float  *taup,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgecon.f */\n#define cgecon FORTRAN_WRAPPER(cgecon)\nextern void cgecon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeequ.f */\n#define cgeequ FORTRAN_WRAPPER(cgeequ)\nextern void cgeequ(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *r,\n    float  *c,\n    float  *rowcnd,\n    float  *colcnd,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: cgeequb.f */\n#define cgeequb FORTRAN_WRAPPER(cgeequb)\nextern void cgeequb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *r,\n    float  *c,\n    float  *rowcnd,\n    float  *colcnd,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: cgees.f */\n#define cgees FORTRAN_WRAPPER(cgees)\nextern void cgees(\n    const char   *jobvs,\n    const char   *sort,\n    ptrdiff_t (*select)(),\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *sdim,\n    float  *w,\n    float  *vs,\n    const ptrdiff_t *ldvs,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeesx.f */\n#define cgeesx FORTRAN_WRAPPER(cgeesx)\nextern void cgeesx(\n    const char   *jobvs,\n    const char   *sort,\n    ptrdiff_t (*select)(),\n    const char   *sense,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *sdim,\n    float  *w,\n    float  *vs,\n    const ptrdiff_t *ldvs,\n    float  *rconde,\n    float  *rcondv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeev.f */\n#define cgeev FORTRAN_WRAPPER(cgeev)\nextern void cgeev(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *w,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeevx.f */\n#define cgeevx FORTRAN_WRAPPER(cgeevx)\nextern void cgeevx(\n    const char   *balanc,\n    const char   *jobvl,\n    const char   *jobvr,\n    const char   *sense,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *w,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    float  *scale,\n    float  *abnrm,\n    float  *rconde,\n    float  *rcondv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgehd2.f */\n#define cgehd2 FORTRAN_WRAPPER(cgehd2)\nextern void cgehd2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgehrd.f */\n#define cgehrd FORTRAN_WRAPPER(cgehrd)\nextern void cgehrd(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgejsv.f */\n#define cgejsv FORTRAN_WRAPPER(cgejsv)\nextern void cgejsv(\n    const char   *joba,\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobr,\n    const char   *jobt,\n    const char   *jobp,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *sva,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *cwork,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgelq.f */\n#define cgelq FORTRAN_WRAPPER(cgelq)\nextern void cgelq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *tsize,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgelq2.f */\n#define cgelq2 FORTRAN_WRAPPER(cgelq2)\nextern void cgelq2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgelqf.f */\n#define cgelqf FORTRAN_WRAPPER(cgelqf)\nextern void cgelqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgelqt.f */\n#define cgelqt FORTRAN_WRAPPER(cgelqt)\nextern void cgelqt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgelqt3.f */\n#define cgelqt3 FORTRAN_WRAPPER(cgelqt3)\nextern void cgelqt3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: cgels.f */\n#define cgels FORTRAN_WRAPPER(cgels)\nextern void cgels(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgelsd.f */\n#define cgelsd FORTRAN_WRAPPER(cgelsd)\nextern void cgelsd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *s,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgelss.f */\n#define cgelss FORTRAN_WRAPPER(cgelss)\nextern void cgelss(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *s,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgelsy.f */\n#define cgelsy FORTRAN_WRAPPER(cgelsy)\nextern void cgelsy(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *jpvt,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgemlq.f */\n#define cgemlq FORTRAN_WRAPPER(cgemlq)\nextern void cgemlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *t,\n    const ptrdiff_t *tsize,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgemlqt.f */\n#define cgemlqt FORTRAN_WRAPPER(cgemlqt)\nextern void cgemlqt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgemqr.f */\n#define cgemqr FORTRAN_WRAPPER(cgemqr)\nextern void cgemqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *t,\n    const ptrdiff_t *tsize,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgemqrt.f */\n#define cgemqrt FORTRAN_WRAPPER(cgemqrt)\nextern void cgemqrt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgeql2.f */\n#define cgeql2 FORTRAN_WRAPPER(cgeql2)\nextern void cgeql2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqlf.f */\n#define cgeqlf FORTRAN_WRAPPER(cgeqlf)\nextern void cgeqlf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqp3.f */\n#define cgeqp3 FORTRAN_WRAPPER(cgeqp3)\nextern void cgeqp3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqr.f */\n#define cgeqr FORTRAN_WRAPPER(cgeqr)\nextern void cgeqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *tsize,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqr2.f */\n#define cgeqr2 FORTRAN_WRAPPER(cgeqr2)\nextern void cgeqr2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqr2p.f */\n#define cgeqr2p FORTRAN_WRAPPER(cgeqr2p)\nextern void cgeqr2p(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqrf.f */\n#define cgeqrf FORTRAN_WRAPPER(cgeqrf)\nextern void cgeqrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqrfp.f */\n#define cgeqrfp FORTRAN_WRAPPER(cgeqrfp)\nextern void cgeqrfp(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqrt.f */\n#define cgeqrt FORTRAN_WRAPPER(cgeqrt)\nextern void cgeqrt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqrt2.f */\n#define cgeqrt2 FORTRAN_WRAPPER(cgeqrt2)\nextern void cgeqrt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqrt3.f */\n#define cgeqrt3 FORTRAN_WRAPPER(cgeqrt3)\nextern void cgeqrt3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: cgerfs.f */\n#define cgerfs FORTRAN_WRAPPER(cgerfs)\nextern void cgerfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgerq2.f */\n#define cgerq2 FORTRAN_WRAPPER(cgerq2)\nextern void cgerq2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgerqf.f */\n#define cgerqf FORTRAN_WRAPPER(cgerqf)\nextern void cgerqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgesc2.f */\n#define cgesc2 FORTRAN_WRAPPER(cgesc2)\nextern void cgesc2(\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *rhs,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *jpiv,\n    float  *scale\n);\n\n/* Source: cgesdd.f */\n#define cgesdd FORTRAN_WRAPPER(cgesdd)\nextern void cgesdd(\n    const char   *jobz,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgesv.f */\n#define cgesv FORTRAN_WRAPPER(cgesv)\nextern void cgesv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cgesvd.f */\n#define cgesvd FORTRAN_WRAPPER(cgesvd)\nextern void cgesvd(\n    const char   *jobu,\n    const char   *jobvt,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgesvdx.f */\n#define cgesvdx FORTRAN_WRAPPER(cgesvdx)\nextern void cgesvdx(\n    const char   *jobu,\n    const char   *jobvt,\n    const char   *range,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *ns,\n    float  *s,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgesvj.f */\n#define cgesvj FORTRAN_WRAPPER(cgesvj)\nextern void cgesvj(\n    const char   *joba,\n    const char   *jobu,\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *sva,\n    const ptrdiff_t *mv,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *cwork,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgesvx.f */\n#define cgesvx FORTRAN_WRAPPER(cgesvx)\nextern void cgesvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    char   *equed,\n    float  *r,\n    float  *c,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgetc2.f */\n#define cgetc2 FORTRAN_WRAPPER(cgetc2)\nextern void cgetc2(\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *jpiv,\n    ptrdiff_t *info\n);\n\n/* Source: cgetf2.f */\n#define cgetf2 FORTRAN_WRAPPER(cgetf2)\nextern void cgetf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: cgetrf.f */\n#define cgetrf FORTRAN_WRAPPER(cgetrf)\nextern void cgetrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: cgetrf2.f */\n#define cgetrf2 FORTRAN_WRAPPER(cgetrf2)\nextern void cgetrf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: cgetri.f */\n#define cgetri FORTRAN_WRAPPER(cgetri)\nextern void cgetri(\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgetrs.f */\n#define cgetrs FORTRAN_WRAPPER(cgetrs)\nextern void cgetrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cgetsls.f */\n#define cgetsls FORTRAN_WRAPPER(cgetsls)\nextern void cgetsls(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggbak.f */\n#define cggbak FORTRAN_WRAPPER(cggbak)\nextern void cggbak(\n    const char   *job,\n    const char   *side,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const float  *lscale,\n    const float  *rscale,\n    const ptrdiff_t *m,\n    float  *v,\n    const ptrdiff_t *ldv,\n    ptrdiff_t *info\n);\n\n/* Source: cggbal.f */\n#define cggbal FORTRAN_WRAPPER(cggbal)\nextern void cggbal(\n    const char   *job,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    float  *lscale,\n    float  *rscale,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgges.f */\n#define cgges FORTRAN_WRAPPER(cgges)\nextern void cgges(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    float  *alpha,\n    float  *beta,\n    float  *vsl,\n    const ptrdiff_t *ldvsl,\n    float  *vsr,\n    const ptrdiff_t *ldvsr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgges3.f */\n#define cgges3 FORTRAN_WRAPPER(cgges3)\nextern void cgges3(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    float  *alpha,\n    float  *beta,\n    float  *vsl,\n    const ptrdiff_t *ldvsl,\n    float  *vsr,\n    const ptrdiff_t *ldvsr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggesx.f */\n#define cggesx FORTRAN_WRAPPER(cggesx)\nextern void cggesx(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const char   *sense,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    float  *alpha,\n    float  *beta,\n    float  *vsl,\n    const ptrdiff_t *ldvsl,\n    float  *vsr,\n    const ptrdiff_t *ldvsr,\n    float  *rconde,\n    float  *rcondv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggev.f */\n#define cggev FORTRAN_WRAPPER(cggev)\nextern void cggev(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggev3.f */\n#define cggev3 FORTRAN_WRAPPER(cggev3)\nextern void cggev3(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggevx.f */\n#define cggevx FORTRAN_WRAPPER(cggevx)\nextern void cggevx(\n    const char   *balanc,\n    const char   *jobvl,\n    const char   *jobvr,\n    const char   *sense,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    float  *lscale,\n    float  *rscale,\n    float  *abnrm,\n    float  *bbnrm,\n    float  *rconde,\n    float  *rcondv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggglm.f */\n#define cggglm FORTRAN_WRAPPER(cggglm)\nextern void cggglm(\n    const ptrdiff_t *n,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *d,\n    float  *x,\n    float  *y,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgghd3.f */\n#define cgghd3 FORTRAN_WRAPPER(cgghd3)\nextern void cgghd3(\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgghrd.f */\n#define cgghrd FORTRAN_WRAPPER(cgghrd)\nextern void cgghrd(\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *info\n);\n\n/* Source: cgglse.f */\n#define cgglse FORTRAN_WRAPPER(cgglse)\nextern void cgglse(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    float  *d,\n    float  *x,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggqrf.f */\n#define cggqrf FORTRAN_WRAPPER(cggqrf)\nextern void cggqrf(\n    const ptrdiff_t *n,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *taua,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *taub,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggrqf.f */\n#define cggrqf FORTRAN_WRAPPER(cggrqf)\nextern void cggrqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *taua,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *taub,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggsvd3.f */\n#define cggsvd3 FORTRAN_WRAPPER(cggsvd3)\nextern void cggsvd3(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggsvp3.f */\n#define cggsvp3 FORTRAN_WRAPPER(cggsvp3)\nextern void cggsvp3(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *tola,\n    const float  *tolb,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *iwork,\n    float  *rwork,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgsvj0.f */\n#define cgsvj0 FORTRAN_WRAPPER(cgsvj0)\nextern void cgsvj0(\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *sva,\n    const ptrdiff_t *mv,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const float  *eps,\n    const float  *sfmin,\n    const float  *tol,\n    const ptrdiff_t *nsweep,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgsvj1.f */\n#define cgsvj1 FORTRAN_WRAPPER(cgsvj1)\nextern void cgsvj1(\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *sva,\n    const ptrdiff_t *mv,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const float  *eps,\n    const float  *sfmin,\n    const float  *tol,\n    const ptrdiff_t *nsweep,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgtcon.f */\n#define cgtcon FORTRAN_WRAPPER(cgtcon)\nextern void cgtcon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *du2,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cgtrfs.f */\n#define cgtrfs FORTRAN_WRAPPER(cgtrfs)\nextern void cgtrfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *dlf,\n    const float  *df,\n    const float  *duf,\n    const float  *du2,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgtsv.f */\n#define cgtsv FORTRAN_WRAPPER(cgtsv)\nextern void cgtsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *dl,\n    float  *d,\n    float  *du,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cgtsvx.f */\n#define cgtsvx FORTRAN_WRAPPER(cgtsvx)\nextern void cgtsvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    float  *dlf,\n    float  *df,\n    float  *duf,\n    float  *du2,\n    ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgttrf.f */\n#define cgttrf FORTRAN_WRAPPER(cgttrf)\nextern void cgttrf(\n    const ptrdiff_t *n,\n    float  *dl,\n    float  *d,\n    float  *du,\n    float  *du2,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: cgttrs.f */\n#define cgttrs FORTRAN_WRAPPER(cgttrs)\nextern void cgttrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *du2,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cgtts2.f */\n#define cgtts2 FORTRAN_WRAPPER(cgtts2)\nextern void cgtts2(\n    const ptrdiff_t *itrans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *du2,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: chb2st_kernels.f */\n#define chb2st_kernels FORTRAN_WRAPPER(chb2st_kernels)\nextern void chb2st_kernels(\n    char   *uplo,\n    ptrdiff_t *wantz,\n    ptrdiff_t *ttype,\n    ptrdiff_t *st,\n    ptrdiff_t *ed,\n    ptrdiff_t *sweep,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *ib,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *v,\n    float  *tau,\n    ptrdiff_t *ldvt,\n    float  *work\n);\n\n/* Source: chbev.f */\n#define chbev FORTRAN_WRAPPER(chbev)\nextern void chbev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chbev_2stage.f */\n#define chbev_2stage FORTRAN_WRAPPER(chbev_2stage)\nextern void chbev_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chbevd.f */\n#define chbevd FORTRAN_WRAPPER(chbevd)\nextern void chbevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: chbevd_2stage.f */\n#define chbevd_2stage FORTRAN_WRAPPER(chbevd_2stage)\nextern void chbevd_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: chbevx.f */\n#define chbevx FORTRAN_WRAPPER(chbevx)\nextern void chbevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: chbevx_2stage.f */\n#define chbevx_2stage FORTRAN_WRAPPER(chbevx_2stage)\nextern void chbevx_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *q,\n    ptrdiff_t *ldq,\n    float  *vl,\n    float  *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: chbgst.f */\n#define chbgst FORTRAN_WRAPPER(chbgst)\nextern void chbgst(\n    const char   *vect,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *bb,\n    const ptrdiff_t *ldbb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chbgv.f */\n#define chbgv FORTRAN_WRAPPER(chbgv)\nextern void chbgv(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *bb,\n    const ptrdiff_t *ldbb,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chbgvd.f */\n#define chbgvd FORTRAN_WRAPPER(chbgvd)\nextern void chbgvd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *bb,\n    const ptrdiff_t *ldbb,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: chbgvx.f */\n#define chbgvx FORTRAN_WRAPPER(chbgvx)\nextern void chbgvx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *bb,\n    const ptrdiff_t *ldbb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: chbtrd.f */\n#define chbtrd FORTRAN_WRAPPER(chbtrd)\nextern void chbtrd(\n    const char   *vect,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *d,\n    float  *e,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: checon.f */\n#define checon FORTRAN_WRAPPER(checon)\nextern void checon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: checon_3.f */\n#define checon_3 FORTRAN_WRAPPER(checon_3)\nextern void checon_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: checon_rook.f */\n#define checon_rook FORTRAN_WRAPPER(checon_rook)\nextern void checon_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cheequb.f */\n#define cheequb FORTRAN_WRAPPER(cheequb)\nextern void cheequb(\n    char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cheev.f */\n#define cheev FORTRAN_WRAPPER(cheev)\nextern void cheev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *w,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cheev_2stage.f */\n#define cheev_2stage FORTRAN_WRAPPER(cheev_2stage)\nextern void cheev_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *w,\n    float  *work,\n    ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cheevd.f */\n#define cheevd FORTRAN_WRAPPER(cheevd)\nextern void cheevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *w,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: cheevd_2stage.f */\n#define cheevd_2stage FORTRAN_WRAPPER(cheevd_2stage)\nextern void cheevd_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *w,\n    float  *work,\n    ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: cheevr.f */\n#define cheevr FORTRAN_WRAPPER(cheevr)\nextern void cheevr(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: cheevr_2stage.f */\n#define cheevr_2stage FORTRAN_WRAPPER(cheevr_2stage)\nextern void cheevr_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *vl,\n    float  *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    float  *work,\n    ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: cheevx.f */\n#define cheevx FORTRAN_WRAPPER(cheevx)\nextern void cheevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: cheevx_2stage.f */\n#define cheevx_2stage FORTRAN_WRAPPER(cheevx_2stage)\nextern void cheevx_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *vl,\n    float  *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: chegs2.f */\n#define chegs2 FORTRAN_WRAPPER(chegs2)\nextern void chegs2(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: chegst.f */\n#define chegst FORTRAN_WRAPPER(chegst)\nextern void chegst(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: chegv.f */\n#define chegv FORTRAN_WRAPPER(chegv)\nextern void chegv(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *w,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chegv_2stage.f */\n#define chegv_2stage FORTRAN_WRAPPER(chegv_2stage)\nextern void chegv_2stage(\n    ptrdiff_t *itype,\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *b,\n    ptrdiff_t *ldb,\n    float  *w,\n    float  *work,\n    ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chegvd.f */\n#define chegvd FORTRAN_WRAPPER(chegvd)\nextern void chegvd(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *w,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: chegvx.f */\n#define chegvx FORTRAN_WRAPPER(chegvx)\nextern void chegvx(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: cherfs.f */\n#define cherfs FORTRAN_WRAPPER(cherfs)\nextern void cherfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chesv.f */\n#define chesv FORTRAN_WRAPPER(chesv)\nextern void chesv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chesv_aa.f */\n#define chesv_aa FORTRAN_WRAPPER(chesv_aa)\nextern void chesv_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chesv_rk.f */\n#define chesv_rk FORTRAN_WRAPPER(chesv_rk)\nextern void chesv_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *b,\n    ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chesv_rook.f */\n#define chesv_rook FORTRAN_WRAPPER(chesv_rook)\nextern void chesv_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chesvx.f */\n#define chesvx FORTRAN_WRAPPER(chesvx)\nextern void chesvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cheswapr.f */\n#define cheswapr FORTRAN_WRAPPER(cheswapr)\nextern void cheswapr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *i1,\n    const ptrdiff_t *i2\n);\n\n/* Source: chetd2.f */\n#define chetd2 FORTRAN_WRAPPER(chetd2)\nextern void chetd2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tau,\n    ptrdiff_t *info\n);\n\n/* Source: chetf2.f */\n#define chetf2 FORTRAN_WRAPPER(chetf2)\nextern void chetf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: chetf2_rk.f */\n#define chetf2_rk FORTRAN_WRAPPER(chetf2_rk)\nextern void chetf2_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: chetf2_rook.f */\n#define chetf2_rook FORTRAN_WRAPPER(chetf2_rook)\nextern void chetf2_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: chetrd.f */\n#define chetrd FORTRAN_WRAPPER(chetrd)\nextern void chetrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetrd_2stage.f */\n#define chetrd_2stage FORTRAN_WRAPPER(chetrd_2stage)\nextern void chetrd_2stage(\n    char   *vect,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tau,\n    float  *hous2,\n    ptrdiff_t *lhous2,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetrd_hb2st.f */\n#define chetrd_hb2st FORTRAN_WRAPPER(chetrd_hb2st)\nextern void chetrd_hb2st(\n    char   *stage1,\n    char   *vect,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *d,\n    float  *e,\n    float  *hous,\n    ptrdiff_t *lhous,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetrd_he2hb.f */\n#define chetrd_he2hb FORTRAN_WRAPPER(chetrd_he2hb)\nextern void chetrd_he2hb(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetrf.f */\n#define chetrf FORTRAN_WRAPPER(chetrf)\nextern void chetrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetrf_aa.f */\n#define chetrf_aa FORTRAN_WRAPPER(chetrf_aa)\nextern void chetrf_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetrf_rk.f */\n#define chetrf_rk FORTRAN_WRAPPER(chetrf_rk)\nextern void chetrf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetrf_rook.f */\n#define chetrf_rook FORTRAN_WRAPPER(chetrf_rook)\nextern void chetrf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetri.f */\n#define chetri FORTRAN_WRAPPER(chetri)\nextern void chetri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: chetri2.f */\n#define chetri2 FORTRAN_WRAPPER(chetri2)\nextern void chetri2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetri2x.f */\n#define chetri2x FORTRAN_WRAPPER(chetri2x)\nextern void chetri2x(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: chetri_3.f */\n#define chetri_3 FORTRAN_WRAPPER(chetri_3)\nextern void chetri_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetri_3x.f */\n#define chetri_3x FORTRAN_WRAPPER(chetri_3x)\nextern void chetri_3x(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: chetri_rook.f */\n#define chetri_rook FORTRAN_WRAPPER(chetri_rook)\nextern void chetri_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: chetrs.f */\n#define chetrs FORTRAN_WRAPPER(chetrs)\nextern void chetrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: chetrs2.f */\n#define chetrs2 FORTRAN_WRAPPER(chetrs2)\nextern void chetrs2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: chetrs_3.f */\n#define chetrs_3 FORTRAN_WRAPPER(chetrs_3)\nextern void chetrs_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *b,\n    ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: chetrs_aa.f */\n#define chetrs_aa FORTRAN_WRAPPER(chetrs_aa)\nextern void chetrs_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: chetrs_rook.f */\n#define chetrs_rook FORTRAN_WRAPPER(chetrs_rook)\nextern void chetrs_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: chfrk.f */\n#define chfrk FORTRAN_WRAPPER(chfrk)\nextern void chfrk(\n    const char   *transr,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *beta,\n    float  *c\n);\n\n/* Source: chgeqz.f */\n#define chgeqz FORTRAN_WRAPPER(chgeqz)\nextern void chgeqz(\n    const char   *job,\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *alpha,\n    float  *beta,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chla_transtype.f */\n#define chla_transtype FORTRAN_WRAPPER(chla_transtype)\nextern char chla_transtype(\n    const ptrdiff_t *trans\n);\n\n/* Source: chpcon.f */\n#define chpcon FORTRAN_WRAPPER(chpcon)\nextern void chpcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: chpev.f */\n#define chpev FORTRAN_WRAPPER(chpev)\nextern void chpev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chpevd.f */\n#define chpevd FORTRAN_WRAPPER(chpevd)\nextern void chpevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: chpevx.f */\n#define chpevx FORTRAN_WRAPPER(chpevx)\nextern void chpevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: chpgst.f */\n#define chpgst FORTRAN_WRAPPER(chpgst)\nextern void chpgst(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const float  *bp,\n    ptrdiff_t *info\n);\n\n/* Source: chpgv.f */\n#define chpgv FORTRAN_WRAPPER(chpgv)\nextern void chpgv(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *bp,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chpgvd.f */\n#define chpgvd FORTRAN_WRAPPER(chpgvd)\nextern void chpgvd(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *bp,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: chpgvx.f */\n#define chpgvx FORTRAN_WRAPPER(chpgvx)\nextern void chpgvx(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *bp,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: chprfs.f */\n#define chprfs FORTRAN_WRAPPER(chprfs)\nextern void chprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const float  *afp,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chpsv.f */\n#define chpsv FORTRAN_WRAPPER(chpsv)\nextern void chpsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *ap,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: chpsvx.f */\n#define chpsvx FORTRAN_WRAPPER(chpsvx)\nextern void chpsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    float  *afp,\n    ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: chptrd.f */\n#define chptrd FORTRAN_WRAPPER(chptrd)\nextern void chptrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *d,\n    float  *e,\n    float  *tau,\n    ptrdiff_t *info\n);\n\n/* Source: chptrf.f */\n#define chptrf FORTRAN_WRAPPER(chptrf)\nextern void chptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: chptri.f */\n#define chptri FORTRAN_WRAPPER(chptri)\nextern void chptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: chptrs.f */\n#define chptrs FORTRAN_WRAPPER(chptrs)\nextern void chptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: chsein.f */\n#define chsein FORTRAN_WRAPPER(chsein)\nextern void chsein(\n    const char   *side,\n    const char   *eigsrc,\n    const char   *initv,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const float  *h,\n    const ptrdiff_t *ldh,\n    float  *w,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *ifaill,\n    ptrdiff_t *ifailr,\n    ptrdiff_t *info\n);\n\n/* Source: chseqr.f */\n#define chseqr FORTRAN_WRAPPER(chseqr)\nextern void chseqr(\n    const char   *job,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: clabrd.f */\n#define clabrd FORTRAN_WRAPPER(clabrd)\nextern void clabrd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tauq,\n    float  *taup,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: clacgv.f */\n#define clacgv FORTRAN_WRAPPER(clacgv)\nextern void clacgv(\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: clacn2.f */\n#define clacn2 FORTRAN_WRAPPER(clacn2)\nextern void clacn2(\n    const ptrdiff_t *n,\n    float  *v,\n    float  *x,\n    float  *est,\n    ptrdiff_t *kase,\n    ptrdiff_t *isave\n);\n\n/* Source: clacon.f */\n#define clacon FORTRAN_WRAPPER(clacon)\nextern void clacon(\n    const ptrdiff_t *n,\n    float  *v,\n    float  *x,\n    float  *est,\n    ptrdiff_t *kase\n);\n\n/* Source: clacp2.f */\n#define clacp2 FORTRAN_WRAPPER(clacp2)\nextern void clacp2(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: clacpy.f */\n#define clacpy FORTRAN_WRAPPER(clacpy)\nextern void clacpy(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: clacrm.f */\n#define clacrm FORTRAN_WRAPPER(clacrm)\nextern void clacrm(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *rwork\n);\n\n/* Source: clacrt.f */\n#define clacrt FORTRAN_WRAPPER(clacrt)\nextern void clacrt(\n    const ptrdiff_t *n,\n    float  *cx,\n    const ptrdiff_t *incx,\n    float  *cy,\n    const ptrdiff_t *incy,\n    const float  *c,\n    const float  *s\n);\n\n/* Source: cladiv.f */\n#define cladiv FORTRAN_WRAPPER(cladiv)\nextern void cladiv(\n    complex* retval,\n    const float  *x,\n    const float  *y\n);\n\n/* Source: claed0.f */\n#define claed0 FORTRAN_WRAPPER(claed0)\nextern void claed0(\n    const ptrdiff_t *qsiz,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *qstore,\n    const ptrdiff_t *ldqs,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: claed7.f */\n#define claed7 FORTRAN_WRAPPER(claed7)\nextern void claed7(\n    const ptrdiff_t *n,\n    const ptrdiff_t *cutpnt,\n    const ptrdiff_t *qsiz,\n    const ptrdiff_t *tlvls,\n    const ptrdiff_t *curlvl,\n    const ptrdiff_t *curpbm,\n    float  *d,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const float  *rho,\n    ptrdiff_t *indxq,\n    float  *qstore,\n    ptrdiff_t *qptr,\n    const ptrdiff_t *prmptr,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const float  *givnum,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: claed8.f */\n#define claed8 FORTRAN_WRAPPER(claed8)\nextern void claed8(\n    ptrdiff_t *k,\n    const ptrdiff_t *n,\n    const ptrdiff_t *qsiz,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *d,\n    float  *rho,\n    const ptrdiff_t *cutpnt,\n    const float  *z,\n    float  *dlamda,\n    float  *q2,\n    const ptrdiff_t *ldq2,\n    float  *w,\n    ptrdiff_t *indxp,\n    ptrdiff_t *indx,\n    const ptrdiff_t *indxq,\n    ptrdiff_t *perm,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    float  *givnum,\n    ptrdiff_t *info\n);\n\n/* Source: claein.f */\n#define claein FORTRAN_WRAPPER(claein)\nextern void claein(\n    const ptrdiff_t *rightv,\n    const ptrdiff_t *noinit,\n    const ptrdiff_t *n,\n    const float  *h,\n    const ptrdiff_t *ldh,\n    const float  *w,\n    float  *v,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *rwork,\n    const float  *eps3,\n    const float  *smlnum,\n    ptrdiff_t *info\n);\n\n/* Source: claesy.f */\n#define claesy FORTRAN_WRAPPER(claesy)\nextern void claesy(\n    const float  *a,\n    const float  *b,\n    const float  *c,\n    float  *rt1,\n    float  *rt2,\n    float  *evscal,\n    float  *cs1,\n    float  *sn1\n);\n\n/* Source: claev2.f */\n#define claev2 FORTRAN_WRAPPER(claev2)\nextern void claev2(\n    const float  *a,\n    const float  *b,\n    const float  *c,\n    float  *rt1,\n    float  *rt2,\n    float  *cs1,\n    float  *sn1\n);\n\n/* Source: clag2z.f */\n#define clag2z FORTRAN_WRAPPER(clag2z)\nextern void clag2z(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *sa,\n    const ptrdiff_t *ldsa,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: clags2.f */\n#define clags2 FORTRAN_WRAPPER(clags2)\nextern void clags2(\n    const ptrdiff_t *upper,\n    const float  *a1,\n    const float  *a2,\n    const float  *a3,\n    const float  *b1,\n    const float  *b2,\n    const float  *b3,\n    float  *csu,\n    float  *snu,\n    float  *csv,\n    float  *snv,\n    float  *csq,\n    float  *snq\n);\n\n/* Source: clagtm.f */\n#define clagtm FORTRAN_WRAPPER(clagtm)\nextern void clagtm(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *alpha,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *x,\n    const ptrdiff_t *ldx,\n    const float  *beta,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: clahef.f */\n#define clahef FORTRAN_WRAPPER(clahef)\nextern void clahef(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: clahef_aa.f */\n#define clahef_aa FORTRAN_WRAPPER(clahef_aa)\nextern void clahef_aa(\n    const char   *uplo,\n    const ptrdiff_t *j1_,\n    const ptrdiff_t *m,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: clahef_rk.f */\n#define clahef_rk FORTRAN_WRAPPER(clahef_rk)\nextern void clahef_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *w,\n    ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: clahef_rook.f */\n#define clahef_rook FORTRAN_WRAPPER(clahef_rook)\nextern void clahef_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: clahqr.f */\n#define clahqr FORTRAN_WRAPPER(clahqr)\nextern void clahqr(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *w,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *info\n);\n\n/* Source: clahr2.f */\n#define clahr2 FORTRAN_WRAPPER(clahr2)\nextern void clahr2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: claic1.f */\n#define claic1 FORTRAN_WRAPPER(claic1)\nextern void claic1(\n    const ptrdiff_t *job,\n    const ptrdiff_t *j,\n    const float  *x,\n    const float  *sest,\n    const float  *w,\n    const float  *gamma_,\n    float  *sestpr,\n    float  *s,\n    float  *c\n);\n\n/* Source: clals0.f */\n#define clals0 FORTRAN_WRAPPER(clals0)\nextern void clals0(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    const ptrdiff_t *nrhs,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *bx,\n    const ptrdiff_t *ldbx,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    const float  *givnum,\n    const ptrdiff_t *ldgnum,\n    const float  *poles,\n    const float  *difl,\n    const float  *difr,\n    const float  *z,\n    const ptrdiff_t *k,\n    const float  *c,\n    const float  *s,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: clalsa.f */\n#define clalsa FORTRAN_WRAPPER(clalsa)\nextern void clalsa(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *bx,\n    const ptrdiff_t *ldbx,\n    const float  *u,\n    const ptrdiff_t *ldu,\n    const float  *vt,\n    const ptrdiff_t *k,\n    const float  *difl,\n    const float  *difr,\n    const float  *z,\n    const float  *poles,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    const ptrdiff_t *perm,\n    const float  *givnum,\n    const float  *c,\n    const float  *s,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: clalsd.f */\n#define clalsd FORTRAN_WRAPPER(clalsd)\nextern void clalsd(\n    const char   *uplo,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *d,\n    float  *e,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: clamswlq.f */\n#define clamswlq FORTRAN_WRAPPER(clamswlq)\nextern void clamswlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: clamtsqr.f */\n#define clamtsqr FORTRAN_WRAPPER(clamtsqr)\nextern void clamtsqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: clangb.f */\n#define clangb FORTRAN_WRAPPER(clangb)\nextern float clangb(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *work\n);\n\n/* Source: clange.f */\n#define clange FORTRAN_WRAPPER(clange)\nextern float clange(\n    const char   *norm,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *work\n);\n\n/* Source: clangt.f */\n#define clangt FORTRAN_WRAPPER(clangt)\nextern float clangt(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *dl,\n    const float  *d,\n    const float  *du\n);\n\n/* Source: clanhb.f */\n#define clanhb FORTRAN_WRAPPER(clanhb)\nextern float clanhb(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *work\n);\n\n/* Source: clanhe.f */\n#define clanhe FORTRAN_WRAPPER(clanhe)\nextern float clanhe(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *work\n);\n\n/* Source: clanhf.f */\n#define clanhf FORTRAN_WRAPPER(clanhf)\nextern float clanhf(\n    const char   *norm,\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    float  *work\n);\n\n/* Source: clanhp.f */\n#define clanhp FORTRAN_WRAPPER(clanhp)\nextern float clanhp(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *work\n);\n\n/* Source: clanhs.f */\n#define clanhs FORTRAN_WRAPPER(clanhs)\nextern float clanhs(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *work\n);\n\n/* Source: clanht.f */\n#define clanht FORTRAN_WRAPPER(clanht)\nextern float clanht(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *e\n);\n\n/* Source: clansb.f */\n#define clansb FORTRAN_WRAPPER(clansb)\nextern float clansb(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *work\n);\n\n/* Source: clansp.f */\n#define clansp FORTRAN_WRAPPER(clansp)\nextern float clansp(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *work\n);\n\n/* Source: clansy.f */\n#define clansy FORTRAN_WRAPPER(clansy)\nextern float clansy(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *work\n);\n\n/* Source: clantb.f */\n#define clantb FORTRAN_WRAPPER(clantb)\nextern float clantb(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *work\n);\n\n/* Source: clantp.f */\n#define clantp FORTRAN_WRAPPER(clantp)\nextern float clantp(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *work\n);\n\n/* Source: clantr.f */\n#define clantr FORTRAN_WRAPPER(clantr)\nextern float clantr(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *work\n);\n\n/* Source: clapll.f */\n#define clapll FORTRAN_WRAPPER(clapll)\nextern void clapll(\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *y,\n    const ptrdiff_t *incy,\n    float  *ssmin\n);\n\n/* Source: clapmr.f */\n#define clapmr FORTRAN_WRAPPER(clapmr)\nextern void clapmr(\n    const ptrdiff_t *forwrd,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *ldx,\n    ptrdiff_t *k\n);\n\n/* Source: clapmt.f */\n#define clapmt FORTRAN_WRAPPER(clapmt)\nextern void clapmt(\n    const ptrdiff_t *forwrd,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *ldx,\n    ptrdiff_t *k\n);\n\n/* Source: claqgb.f */\n#define claqgb FORTRAN_WRAPPER(claqgb)\nextern void claqgb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *r,\n    const float  *c,\n    const float  *rowcnd,\n    const float  *colcnd,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: claqge.f */\n#define claqge FORTRAN_WRAPPER(claqge)\nextern void claqge(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *r,\n    const float  *c,\n    const float  *rowcnd,\n    const float  *colcnd,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: claqhb.f */\n#define claqhb FORTRAN_WRAPPER(claqhb)\nextern void claqhb(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *s,\n    const float  *scond,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: claqhe.f */\n#define claqhe FORTRAN_WRAPPER(claqhe)\nextern void claqhe(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *s,\n    const float  *scond,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: claqhp.f */\n#define claqhp FORTRAN_WRAPPER(claqhp)\nextern void claqhp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const float  *s,\n    const float  *scond,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: claqp2.f */\n#define claqp2 FORTRAN_WRAPPER(claqp2)\nextern void claqp2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *offset,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    float  *tau,\n    float  *vn1,\n    float  *vn2,\n    float  *work\n);\n\n/* Source: claqps.f */\n#define claqps FORTRAN_WRAPPER(claqps)\nextern void claqps(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *offset,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    float  *tau,\n    float  *vn1,\n    float  *vn2,\n    float  *auxv,\n    float  *f,\n    const ptrdiff_t *ldf\n);\n\n/* Source: claqr0.f */\n#define claqr0 FORTRAN_WRAPPER(claqr0)\nextern void claqr0(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *w,\n    ptrdiff_t *iloz,\n    ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: claqr1.f */\n#define claqr1 FORTRAN_WRAPPER(claqr1)\nextern void claqr1(\n    const ptrdiff_t *n,\n    const float  *h,\n    const ptrdiff_t *ldh,\n    const float  *s1,\n    float  *s2,\n    float  *v\n);\n\n/* Source: claqr2.f */\n#define claqr2 FORTRAN_WRAPPER(claqr2)\nextern void claqr2(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nw,\n    float  *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ns,\n    ptrdiff_t *nd,\n    float  *sh,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const ptrdiff_t *nh,\n    float  *t,\n    const ptrdiff_t *ldt,\n    const ptrdiff_t *nv,\n    float  *wv,\n    const ptrdiff_t *ldwv,\n    float  *work,\n    const ptrdiff_t *lwork\n);\n\n/* Source: claqr3.f */\n#define claqr3 FORTRAN_WRAPPER(claqr3)\nextern void claqr3(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nw,\n    float  *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ns,\n    ptrdiff_t *nd,\n    float  *sh,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const ptrdiff_t *nh,\n    float  *t,\n    const ptrdiff_t *ldt,\n    const ptrdiff_t *nv,\n    float  *wv,\n    const ptrdiff_t *ldwv,\n    float  *work,\n    const ptrdiff_t *lwork\n);\n\n/* Source: claqr4.f */\n#define claqr4 FORTRAN_WRAPPER(claqr4)\nextern void claqr4(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *w,\n    ptrdiff_t *iloz,\n    ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: claqr5.f */\n#define claqr5 FORTRAN_WRAPPER(claqr5)\nextern void claqr5(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *kacc22,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nshfts,\n    float  *s,\n    float  *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *u,\n    const ptrdiff_t *ldu,\n    const ptrdiff_t *nv,\n    float  *wv,\n    const ptrdiff_t *ldwv,\n    const ptrdiff_t *nh,\n    float  *wh,\n    const ptrdiff_t *ldwh\n);\n\n/* Source: claqsb.f */\n#define claqsb FORTRAN_WRAPPER(claqsb)\nextern void claqsb(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *s,\n    const float  *scond,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: claqsp.f */\n#define claqsp FORTRAN_WRAPPER(claqsp)\nextern void claqsp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const float  *s,\n    const float  *scond,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: claqsy.f */\n#define claqsy FORTRAN_WRAPPER(claqsy)\nextern void claqsy(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *s,\n    const float  *scond,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: clar1v.f */\n#define clar1v FORTRAN_WRAPPER(clar1v)\nextern void clar1v(\n    const ptrdiff_t *n,\n    const ptrdiff_t *b1,\n    const ptrdiff_t *bn,\n    const float  *lambda,\n    const float  *d,\n    const float  *l,\n    const float  *ld,\n    const float  *lld,\n    const float  *pivmin,\n    const float  *gaptol,\n    float  *z,\n    const ptrdiff_t *wantnc,\n    ptrdiff_t *negcnt,\n    float  *ztz,\n    float  *mingma,\n    ptrdiff_t *r,\n    ptrdiff_t *isuppz,\n    float  *nrminv,\n    float  *resid,\n    float  *rqcorr,\n    float  *work\n);\n\n/* Source: clar2v.f */\n#define clar2v FORTRAN_WRAPPER(clar2v)\nextern void clar2v(\n    const ptrdiff_t *n,\n    float  *x,\n    float  *y,\n    float  *z,\n    const ptrdiff_t *incx,\n    const float  *c,\n    const float  *s,\n    const ptrdiff_t *incc\n);\n\n/* Source: clarcm.f */\n#define clarcm FORTRAN_WRAPPER(clarcm)\nextern void clarcm(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *rwork\n);\n\n/* Source: clarf.f */\n#define clarf FORTRAN_WRAPPER(clarf)\nextern void clarf(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *v,\n    const ptrdiff_t *incv,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: clarfb.f */\n#define clarfb FORTRAN_WRAPPER(clarfb)\nextern void clarfb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: clarfg.f */\n#define clarfg FORTRAN_WRAPPER(clarfg)\nextern void clarfg(\n    const ptrdiff_t *n,\n    float  *alpha,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *tau\n);\n\n/* Source: clarfgp.f */\n#define clarfgp FORTRAN_WRAPPER(clarfgp)\nextern void clarfgp(\n    const ptrdiff_t *n,\n    float  *alpha,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *tau\n);\n\n/* Source: clarft.f */\n#define clarft FORTRAN_WRAPPER(clarft)\nextern void clarft(\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *tau,\n    float  *t,\n    const ptrdiff_t *ldt\n);\n\n/* Source: clarfx.f */\n#define clarfx FORTRAN_WRAPPER(clarfx)\nextern void clarfx(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *v,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: clarfy.f */\n#define clarfy FORTRAN_WRAPPER(clarfy)\nextern void clarfy(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *v,\n    ptrdiff_t *incv,\n    float  *tau,\n    float  *c,\n    ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: clargv.f */\n#define clargv FORTRAN_WRAPPER(clargv)\nextern void clargv(\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *y,\n    const ptrdiff_t *incy,\n    float  *c,\n    const ptrdiff_t *incc\n);\n\n/* Source: clarnv.f */\n#define clarnv FORTRAN_WRAPPER(clarnv)\nextern void clarnv(\n    const ptrdiff_t *idist,\n    ptrdiff_t *iseed,\n    const ptrdiff_t *n,\n    float  *x\n);\n\n/* Source: clarrv.f */\n#define clarrv FORTRAN_WRAPPER(clarrv)\nextern void clarrv(\n    const ptrdiff_t *n,\n    const float  *vl,\n    const float  *vu,\n    float  *d,\n    float  *l,\n    float  *pivmin,\n    const ptrdiff_t *isplit,\n    const ptrdiff_t *m,\n    const ptrdiff_t *dol,\n    const ptrdiff_t *dou,\n    const float  *minrgp,\n    const float  *rtol1,\n    const float  *rtol2,\n    float  *w,\n    float  *werr,\n    float  *wgap,\n    const ptrdiff_t *iblock,\n    const ptrdiff_t *indexw,\n    const float  *gers,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: clartg.f */\n#define clartg FORTRAN_WRAPPER(clartg)\nextern void clartg(\n    const float  *f,\n    const float  *g,\n    float  *cs,\n    float  *sn,\n    float  *r\n);\n\n/* Source: clartv.f */\n#define clartv FORTRAN_WRAPPER(clartv)\nextern void clartv(\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *y,\n    const ptrdiff_t *incy,\n    const float  *c,\n    const float  *s,\n    const ptrdiff_t *incc\n);\n\n/* Source: clarz.f */\n#define clarz FORTRAN_WRAPPER(clarz)\nextern void clarz(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const float  *v,\n    const ptrdiff_t *incv,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: clarzb.f */\n#define clarzb FORTRAN_WRAPPER(clarzb)\nextern void clarzb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: clarzt.f */\n#define clarzt FORTRAN_WRAPPER(clarzt)\nextern void clarzt(\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const float  *tau,\n    float  *t,\n    const ptrdiff_t *ldt\n);\n\n/* Source: clascl.f */\n#define clascl FORTRAN_WRAPPER(clascl)\nextern void clascl(\n    const char   *type,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *cfrom,\n    const float  *cto,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: claset.f */\n#define claset FORTRAN_WRAPPER(claset)\nextern void claset(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *beta,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: clasr.f */\n#define clasr FORTRAN_WRAPPER(clasr)\nextern void clasr(\n    const char   *side,\n    const char   *pivot,\n    const char   *direct,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *c,\n    const float  *s,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: classq.f */\n#define classq FORTRAN_WRAPPER(classq)\nextern void classq(\n    const ptrdiff_t *n,\n    const float  *x,\n    const ptrdiff_t *incx,\n    float  *scale,\n    float  *sumsq\n);\n\n/* Source: claswlq.f */\n#define claswlq FORTRAN_WRAPPER(claswlq)\nextern void claswlq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: claswp.f */\n#define claswp FORTRAN_WRAPPER(claswp)\nextern void claswp(\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *k1,\n    const ptrdiff_t *k2,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *incx\n);\n\n/* Source: clasyf.f */\n#define clasyf FORTRAN_WRAPPER(clasyf)\nextern void clasyf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: clasyf_aa.f */\n#define clasyf_aa FORTRAN_WRAPPER(clasyf_aa)\nextern void clasyf_aa(\n    char   *uplo,\n    ptrdiff_t *j1_,\n    ptrdiff_t *m,\n    ptrdiff_t *nb,\n    float  *a,\n    ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *h,\n    ptrdiff_t *ldh,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: clasyf_rk.f */\n#define clasyf_rk FORTRAN_WRAPPER(clasyf_rk)\nextern void clasyf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *w,\n    ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: clasyf_rook.f */\n#define clasyf_rook FORTRAN_WRAPPER(clasyf_rook)\nextern void clasyf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: clatbs.f */\n#define clatbs FORTRAN_WRAPPER(clatbs)\nextern void clatbs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *x,\n    float  *scale,\n    float  *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: clatdf.f */\n#define clatdf FORTRAN_WRAPPER(clatdf)\nextern void clatdf(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *n,\n    const float  *z,\n    const ptrdiff_t *ldz,\n    float  *rhs,\n    float  *rdsum,\n    float  *rdscal,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *jpiv\n);\n\n/* Source: clatps.f */\n#define clatps FORTRAN_WRAPPER(clatps)\nextern void clatps(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *x,\n    float  *scale,\n    float  *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: clatrd.f */\n#define clatrd FORTRAN_WRAPPER(clatrd)\nextern void clatrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *e,\n    float  *tau,\n    float  *w,\n    const ptrdiff_t *ldw\n);\n\n/* Source: clatrs.f */\n#define clatrs FORTRAN_WRAPPER(clatrs)\nextern void clatrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    float  *scale,\n    float  *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: clatrz.f */\n#define clatrz FORTRAN_WRAPPER(clatrz)\nextern void clatrz(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work\n);\n\n/* Source: clatsqr.f */\n#define clatsqr FORTRAN_WRAPPER(clatsqr)\nextern void clatsqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: clauu2.f */\n#define clauu2 FORTRAN_WRAPPER(clauu2)\nextern void clauu2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: clauum.f */\n#define clauum FORTRAN_WRAPPER(clauum)\nextern void clauum(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: cpbcon.f */\n#define cpbcon FORTRAN_WRAPPER(cpbcon)\nextern void cpbcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cpbequ.f */\n#define cpbequ FORTRAN_WRAPPER(cpbequ)\nextern void cpbequ(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: cpbrfs.f */\n#define cpbrfs FORTRAN_WRAPPER(cpbrfs)\nextern void cpbrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *afb,\n    const ptrdiff_t *ldafb,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cpbstf.f */\n#define cpbstf FORTRAN_WRAPPER(cpbstf)\nextern void cpbstf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: cpbsv.f */\n#define cpbsv FORTRAN_WRAPPER(cpbsv)\nextern void cpbsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cpbsvx.f */\n#define cpbsvx FORTRAN_WRAPPER(cpbsvx)\nextern void cpbsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *afb,\n    const ptrdiff_t *ldafb,\n    char   *equed,\n    float  *s,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cpbtf2.f */\n#define cpbtf2 FORTRAN_WRAPPER(cpbtf2)\nextern void cpbtf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: cpbtrf.f */\n#define cpbtrf FORTRAN_WRAPPER(cpbtrf)\nextern void cpbtrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: cpbtrs.f */\n#define cpbtrs FORTRAN_WRAPPER(cpbtrs)\nextern void cpbtrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cpftrf.f */\n#define cpftrf FORTRAN_WRAPPER(cpftrf)\nextern void cpftrf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *info\n);\n\n/* Source: cpftri.f */\n#define cpftri FORTRAN_WRAPPER(cpftri)\nextern void cpftri(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *info\n);\n\n/* Source: cpftrs.f */\n#define cpftrs FORTRAN_WRAPPER(cpftrs)\nextern void cpftrs(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cpocon.f */\n#define cpocon FORTRAN_WRAPPER(cpocon)\nextern void cpocon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cpoequ.f */\n#define cpoequ FORTRAN_WRAPPER(cpoequ)\nextern void cpoequ(\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: cpoequb.f */\n#define cpoequb FORTRAN_WRAPPER(cpoequb)\nextern void cpoequb(\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: cporfs.f */\n#define cporfs FORTRAN_WRAPPER(cporfs)\nextern void cporfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *af,\n    const ptrdiff_t *ldaf,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cposv.f */\n#define cposv FORTRAN_WRAPPER(cposv)\nextern void cposv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cposvx.f */\n#define cposvx FORTRAN_WRAPPER(cposvx)\nextern void cposvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *af,\n    const ptrdiff_t *ldaf,\n    char   *equed,\n    float  *s,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cpotf2.f */\n#define cpotf2 FORTRAN_WRAPPER(cpotf2)\nextern void cpotf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: cpotrf.f */\n#define cpotrf FORTRAN_WRAPPER(cpotrf)\nextern void cpotrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: cpotrf2.f */\n#define cpotrf2 FORTRAN_WRAPPER(cpotrf2)\nextern void cpotrf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: cpotri.f */\n#define cpotri FORTRAN_WRAPPER(cpotri)\nextern void cpotri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: cpotrs.f */\n#define cpotrs FORTRAN_WRAPPER(cpotrs)\nextern void cpotrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cppcon.f */\n#define cppcon FORTRAN_WRAPPER(cppcon)\nextern void cppcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cppequ.f */\n#define cppequ FORTRAN_WRAPPER(cppequ)\nextern void cppequ(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: cpprfs.f */\n#define cpprfs FORTRAN_WRAPPER(cpprfs)\nextern void cpprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const float  *afp,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cppsv.f */\n#define cppsv FORTRAN_WRAPPER(cppsv)\nextern void cppsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *ap,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cppsvx.f */\n#define cppsvx FORTRAN_WRAPPER(cppsvx)\nextern void cppsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *ap,\n    float  *afp,\n    char   *equed,\n    float  *s,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cpptrf.f */\n#define cpptrf FORTRAN_WRAPPER(cpptrf)\nextern void cpptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: cpptri.f */\n#define cpptri FORTRAN_WRAPPER(cpptri)\nextern void cpptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: cpptrs.f */\n#define cpptrs FORTRAN_WRAPPER(cpptrs)\nextern void cpptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cpstf2.f */\n#define cpstf2 FORTRAN_WRAPPER(cpstf2)\nextern void cpstf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *piv,\n    ptrdiff_t *rank,\n    const float  *tol,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cpstrf.f */\n#define cpstrf FORTRAN_WRAPPER(cpstrf)\nextern void cpstrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *piv,\n    ptrdiff_t *rank,\n    const float  *tol,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cptcon.f */\n#define cptcon FORTRAN_WRAPPER(cptcon)\nextern void cptcon(\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *e,\n    const float  *anorm,\n    float  *rcond,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cpteqr.f */\n#define cpteqr FORTRAN_WRAPPER(cpteqr)\nextern void cpteqr(\n    const char   *compz,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cptrfs.f */\n#define cptrfs FORTRAN_WRAPPER(cptrfs)\nextern void cptrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *d,\n    const float  *e,\n    const float  *df,\n    const float  *ef,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cptsv.f */\n#define cptsv FORTRAN_WRAPPER(cptsv)\nextern void cptsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *d,\n    float  *e,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cptsvx.f */\n#define cptsvx FORTRAN_WRAPPER(cptsvx)\nextern void cptsvx(\n    const char   *fact,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *d,\n    const float  *e,\n    float  *df,\n    float  *ef,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cpttrf.f */\n#define cpttrf FORTRAN_WRAPPER(cpttrf)\nextern void cpttrf(\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    ptrdiff_t *info\n);\n\n/* Source: cpttrs.f */\n#define cpttrs FORTRAN_WRAPPER(cpttrs)\nextern void cpttrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *d,\n    const float  *e,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cptts2.f */\n#define cptts2 FORTRAN_WRAPPER(cptts2)\nextern void cptts2(\n    const ptrdiff_t *iuplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *d,\n    const float  *e,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: crot.f */\n#define crot FORTRAN_WRAPPER(crot)\nextern void crot(\n    const ptrdiff_t *n,\n    float  *cx,\n    const ptrdiff_t *incx,\n    float  *cy,\n    const ptrdiff_t *incy,\n    const float  *c,\n    const float  *s\n);\n\n/* Source: cspcon.f */\n#define cspcon FORTRAN_WRAPPER(cspcon)\nextern void cspcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cspmv.f */\n#define cspmv FORTRAN_WRAPPER(cspmv)\nextern void cspmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *ap,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: cspr.f */\n#define cspr FORTRAN_WRAPPER(cspr)\nextern void cspr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    float  *ap\n);\n\n/* Source: csprfs.f */\n#define csprfs FORTRAN_WRAPPER(csprfs)\nextern void csprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const float  *afp,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cspsv.f */\n#define cspsv FORTRAN_WRAPPER(cspsv)\nextern void cspsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *ap,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: cspsvx.f */\n#define cspsvx FORTRAN_WRAPPER(cspsvx)\nextern void cspsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    float  *afp,\n    ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: csptrf.f */\n#define csptrf FORTRAN_WRAPPER(csptrf)\nextern void csptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: csptri.f */\n#define csptri FORTRAN_WRAPPER(csptri)\nextern void csptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: csptrs.f */\n#define csptrs FORTRAN_WRAPPER(csptrs)\nextern void csptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: csrscl.f */\n#define csrscl FORTRAN_WRAPPER(csrscl)\nextern void csrscl(\n    const ptrdiff_t *n,\n    const float  *sa,\n    float  *sx,\n    const ptrdiff_t *incx\n);\n\n/* Source: cstedc.f */\n#define cstedc FORTRAN_WRAPPER(cstedc)\nextern void cstedc(\n    const char   *compz,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: cstegr.f */\n#define cstegr FORTRAN_WRAPPER(cstegr)\nextern void cstegr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: cstein.f */\n#define cstein FORTRAN_WRAPPER(cstein)\nextern void cstein(\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *e,\n    const ptrdiff_t *m,\n    const float  *w,\n    const ptrdiff_t *iblock,\n    const ptrdiff_t *isplit,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: cstemr.f */\n#define cstemr FORTRAN_WRAPPER(cstemr)\nextern void cstemr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *nzc,\n    ptrdiff_t *isuppz,\n    ptrdiff_t *tryrac,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: csteqr.f */\n#define csteqr FORTRAN_WRAPPER(csteqr)\nextern void csteqr(\n    const char   *compz,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: csycon.f */\n#define csycon FORTRAN_WRAPPER(csycon)\nextern void csycon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: csycon_3.f */\n#define csycon_3 FORTRAN_WRAPPER(csycon_3)\nextern void csycon_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: csycon_rook.f */\n#define csycon_rook FORTRAN_WRAPPER(csycon_rook)\nextern void csycon_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: csyconv.f */\n#define csyconv FORTRAN_WRAPPER(csyconv)\nextern void csyconv(\n    const char   *uplo,\n    const char   *way,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *e,\n    ptrdiff_t *info\n);\n\n/* Source: csyconvf.f */\n#define csyconvf FORTRAN_WRAPPER(csyconvf)\nextern void csyconvf(\n    char   *uplo,\n    char   *way,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: csyconvf_rook.f */\n#define csyconvf_rook FORTRAN_WRAPPER(csyconvf_rook)\nextern void csyconvf_rook(\n    char   *uplo,\n    char   *way,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: csyequb.f */\n#define csyequb FORTRAN_WRAPPER(csyequb)\nextern void csyequb(\n    char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: csymv.f */\n#define csymv FORTRAN_WRAPPER(csymv)\nextern void csymv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *x,\n    const ptrdiff_t *incx,\n    const float  *beta,\n    float  *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: csyr.f */\n#define csyr FORTRAN_WRAPPER(csyr)\nextern void csyr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *x,\n    const ptrdiff_t *incx,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: csyrfs.f */\n#define csyrfs FORTRAN_WRAPPER(csyrfs)\nextern void csyrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: csysv.f */\n#define csysv FORTRAN_WRAPPER(csysv)\nextern void csysv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csysv_aa.f */\n#define csysv_aa FORTRAN_WRAPPER(csysv_aa)\nextern void csysv_aa(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    float  *a,\n    ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csysv_rk.f */\n#define csysv_rk FORTRAN_WRAPPER(csysv_rk)\nextern void csysv_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *b,\n    ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csysv_rook.f */\n#define csysv_rook FORTRAN_WRAPPER(csysv_rook)\nextern void csysv_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csysvx.f */\n#define csysvx FORTRAN_WRAPPER(csysvx)\nextern void csysvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: csyswapr.f */\n#define csyswapr FORTRAN_WRAPPER(csyswapr)\nextern void csyswapr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *i1,\n    const ptrdiff_t *i2\n);\n\n/* Source: csytf2.f */\n#define csytf2 FORTRAN_WRAPPER(csytf2)\nextern void csytf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: csytf2_rk.f */\n#define csytf2_rk FORTRAN_WRAPPER(csytf2_rk)\nextern void csytf2_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: csytf2_rook.f */\n#define csytf2_rook FORTRAN_WRAPPER(csytf2_rook)\nextern void csytf2_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: csytrf.f */\n#define csytrf FORTRAN_WRAPPER(csytrf)\nextern void csytrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csytrf_aa.f */\n#define csytrf_aa FORTRAN_WRAPPER(csytrf_aa)\nextern void csytrf_aa(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csytrf_rk.f */\n#define csytrf_rk FORTRAN_WRAPPER(csytrf_rk)\nextern void csytrf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csytrf_rook.f */\n#define csytrf_rook FORTRAN_WRAPPER(csytrf_rook)\nextern void csytrf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csytri.f */\n#define csytri FORTRAN_WRAPPER(csytri)\nextern void csytri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: csytri2.f */\n#define csytri2 FORTRAN_WRAPPER(csytri2)\nextern void csytri2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csytri2x.f */\n#define csytri2x FORTRAN_WRAPPER(csytri2x)\nextern void csytri2x(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: csytri_3.f */\n#define csytri_3 FORTRAN_WRAPPER(csytri_3)\nextern void csytri_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csytri_3x.f */\n#define csytri_3x FORTRAN_WRAPPER(csytri_3x)\nextern void csytri_3x(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: csytri_rook.f */\n#define csytri_rook FORTRAN_WRAPPER(csytri_rook)\nextern void csytri_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: csytrs.f */\n#define csytrs FORTRAN_WRAPPER(csytrs)\nextern void csytrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: csytrs2.f */\n#define csytrs2 FORTRAN_WRAPPER(csytrs2)\nextern void csytrs2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: csytrs_3.f */\n#define csytrs_3 FORTRAN_WRAPPER(csytrs_3)\nextern void csytrs_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *b,\n    ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: csytrs_aa.f */\n#define csytrs_aa FORTRAN_WRAPPER(csytrs_aa)\nextern void csytrs_aa(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    float  *a,\n    ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: csytrs_rook.f */\n#define csytrs_rook FORTRAN_WRAPPER(csytrs_rook)\nextern void csytrs_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ctbcon.f */\n#define ctbcon FORTRAN_WRAPPER(ctbcon)\nextern void ctbcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *rcond,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctbrfs.f */\n#define ctbrfs FORTRAN_WRAPPER(ctbrfs)\nextern void ctbrfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctbtrs.f */\n#define ctbtrs FORTRAN_WRAPPER(ctbtrs)\nextern void ctbtrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ctfsm.f */\n#define ctfsm FORTRAN_WRAPPER(ctfsm)\nextern void ctfsm(\n    const char   *transr,\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: ctftri.f */\n#define ctftri FORTRAN_WRAPPER(ctftri)\nextern void ctftri(\n    const char   *transr,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *info\n);\n\n/* Source: ctfttp.f */\n#define ctfttp FORTRAN_WRAPPER(ctfttp)\nextern void ctfttp(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *arf,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: ctfttr.f */\n#define ctfttr FORTRAN_WRAPPER(ctfttr)\nextern void ctfttr(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *arf,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: ctgevc.f */\n#define ctgevc FORTRAN_WRAPPER(ctgevc)\nextern void ctgevc(\n    const char   *side,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const float  *s,\n    const ptrdiff_t *lds,\n    const float  *p,\n    const ptrdiff_t *ldp,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctgex2.f */\n#define ctgex2 FORTRAN_WRAPPER(ctgex2)\nextern void ctgex2(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *j1_,\n    ptrdiff_t *info\n);\n\n/* Source: ctgexc.f */\n#define ctgexc FORTRAN_WRAPPER(ctgexc)\nextern void ctgexc(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *ifst,\n    ptrdiff_t *ilst,\n    ptrdiff_t *info\n);\n\n/* Source: ctgsen.f */\n#define ctgsen FORTRAN_WRAPPER(ctgsen)\nextern void ctgsen(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *m,\n    float  *pl,\n    float  *pr,\n    float  *dif,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctgsja.f */\n#define ctgsja FORTRAN_WRAPPER(ctgsja)\nextern void ctgsja(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *tola,\n    const float  *tolb,\n    float  *alpha,\n    float  *beta,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    ptrdiff_t *ncycle,\n    ptrdiff_t *info\n);\n\n/* Source: ctgsna.f */\n#define ctgsna FORTRAN_WRAPPER(ctgsna)\nextern void ctgsna(\n    const char   *job,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *vl,\n    const ptrdiff_t *ldvl,\n    const float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *s,\n    float  *dif,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctgsy2.f */\n#define ctgsy2 FORTRAN_WRAPPER(ctgsy2)\nextern void ctgsy2(\n    const char   *trans,\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    const ptrdiff_t *ldc,\n    const float  *d,\n    const ptrdiff_t *ldd,\n    const float  *e,\n    const ptrdiff_t *lde,\n    float  *f,\n    const ptrdiff_t *ldf,\n    float  *scale,\n    float  *rdsum,\n    float  *rdscal,\n    ptrdiff_t *info\n);\n\n/* Source: ctgsyl.f */\n#define ctgsyl FORTRAN_WRAPPER(ctgsyl)\nextern void ctgsyl(\n    const char   *trans,\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    const ptrdiff_t *ldc,\n    const float  *d,\n    const ptrdiff_t *ldd,\n    const float  *e,\n    const ptrdiff_t *lde,\n    float  *f,\n    const ptrdiff_t *ldf,\n    float  *scale,\n    float  *dif,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctpcon.f */\n#define ctpcon FORTRAN_WRAPPER(ctpcon)\nextern void ctpcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *rcond,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctplqt.f */\n#define ctplqt FORTRAN_WRAPPER(ctplqt)\nextern void ctplqt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const ptrdiff_t *mb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ctplqt2.f */\n#define ctplqt2 FORTRAN_WRAPPER(ctplqt2)\nextern void ctplqt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: ctpmlqt.f */\n#define ctpmlqt FORTRAN_WRAPPER(ctpmlqt)\nextern void ctpmlqt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const ptrdiff_t *mb,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ctpmqrt.f */\n#define ctpmqrt FORTRAN_WRAPPER(ctpmqrt)\nextern void ctpmqrt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const ptrdiff_t *nb,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ctpqrt.f */\n#define ctpqrt FORTRAN_WRAPPER(ctpqrt)\nextern void ctpqrt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ctpqrt2.f */\n#define ctpqrt2 FORTRAN_WRAPPER(ctpqrt2)\nextern void ctpqrt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: ctprfb.f */\n#define ctprfb FORTRAN_WRAPPER(ctprfb)\nextern void ctprfb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: ctprfs.f */\n#define ctprfs FORTRAN_WRAPPER(ctprfs)\nextern void ctprfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctptri.f */\n#define ctptri FORTRAN_WRAPPER(ctptri)\nextern void ctptri(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: ctptrs.f */\n#define ctptrs FORTRAN_WRAPPER(ctptrs)\nextern void ctptrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ctpttf.f */\n#define ctpttf FORTRAN_WRAPPER(ctpttf)\nextern void ctpttf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *arf,\n    ptrdiff_t *info\n);\n\n/* Source: ctpttr.f */\n#define ctpttr FORTRAN_WRAPPER(ctpttr)\nextern void ctpttr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: ctrcon.f */\n#define ctrcon FORTRAN_WRAPPER(ctrcon)\nextern void ctrcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *rcond,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctrevc.f */\n#define ctrevc FORTRAN_WRAPPER(ctrevc)\nextern void ctrevc(\n    const char   *side,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctrevc3.f */\n#define ctrevc3 FORTRAN_WRAPPER(ctrevc3)\nextern void ctrevc3(\n    char   *side,\n    char   *howmny,\n    ptrdiff_t *select,\n    ptrdiff_t *n,\n    float  *t,\n    ptrdiff_t *ldt,\n    float  *vl,\n    ptrdiff_t *ldvl,\n    float  *vr,\n    ptrdiff_t *ldvr,\n    ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *lrwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctrexc.f */\n#define ctrexc FORTRAN_WRAPPER(ctrexc)\nextern void ctrexc(\n    const char   *compq,\n    const ptrdiff_t *n,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const ptrdiff_t *ifst,\n    const ptrdiff_t *ilst,\n    ptrdiff_t *info\n);\n\n/* Source: ctrrfs.f */\n#define ctrrfs FORTRAN_WRAPPER(ctrrfs)\nextern void ctrrfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctrsen.f */\n#define ctrsen FORTRAN_WRAPPER(ctrsen)\nextern void ctrsen(\n    const char   *job,\n    const char   *compq,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *w,\n    ptrdiff_t *m,\n    float  *s,\n    float  *sep,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctrsna.f */\n#define ctrsna FORTRAN_WRAPPER(ctrsna)\nextern void ctrsna(\n    const char   *job,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    const float  *vl,\n    const ptrdiff_t *ldvl,\n    const float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *s,\n    float  *sep,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    const ptrdiff_t *ldwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ctrsyl.f */\n#define ctrsyl FORTRAN_WRAPPER(ctrsyl)\nextern void ctrsyl(\n    const char   *trana,\n    const char   *tranb,\n    const ptrdiff_t *isgn,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *scale,\n    ptrdiff_t *info\n);\n\n/* Source: ctrti2.f */\n#define ctrti2 FORTRAN_WRAPPER(ctrti2)\nextern void ctrti2(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: ctrtri.f */\n#define ctrtri FORTRAN_WRAPPER(ctrtri)\nextern void ctrtri(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: ctrtrs.f */\n#define ctrtrs FORTRAN_WRAPPER(ctrtrs)\nextern void ctrtrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ctrttf.f */\n#define ctrttf FORTRAN_WRAPPER(ctrttf)\nextern void ctrttf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *arf,\n    ptrdiff_t *info\n);\n\n/* Source: ctrttp.f */\n#define ctrttp FORTRAN_WRAPPER(ctrttp)\nextern void ctrttp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: ctzrzf.f */\n#define ctzrzf FORTRAN_WRAPPER(ctzrzf)\nextern void ctzrzf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunbdb.f */\n#define cunbdb FORTRAN_WRAPPER(cunbdb)\nextern void cunbdb(\n    const char   *trans,\n    const char   *signs,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x12,\n    const ptrdiff_t *ldx12,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *x22,\n    const ptrdiff_t *ldx22,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *tauq2,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunbdb1.f */\n#define cunbdb1 FORTRAN_WRAPPER(cunbdb1)\nextern void cunbdb1(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunbdb2.f */\n#define cunbdb2 FORTRAN_WRAPPER(cunbdb2)\nextern void cunbdb2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunbdb3.f */\n#define cunbdb3 FORTRAN_WRAPPER(cunbdb3)\nextern void cunbdb3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunbdb4.f */\n#define cunbdb4 FORTRAN_WRAPPER(cunbdb4)\nextern void cunbdb4(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *phantom,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunbdb5.f */\n#define cunbdb5 FORTRAN_WRAPPER(cunbdb5)\nextern void cunbdb5(\n    const ptrdiff_t *m1,\n    const ptrdiff_t *m2,\n    const ptrdiff_t *n,\n    float  *x1,\n    const ptrdiff_t *incx1,\n    float  *x2,\n    const ptrdiff_t *incx2,\n    float  *q1,\n    const ptrdiff_t *ldq1,\n    float  *q2,\n    const ptrdiff_t *ldq2,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunbdb6.f */\n#define cunbdb6 FORTRAN_WRAPPER(cunbdb6)\nextern void cunbdb6(\n    const ptrdiff_t *m1,\n    const ptrdiff_t *m2,\n    const ptrdiff_t *n,\n    float  *x1,\n    const ptrdiff_t *incx1,\n    float  *x2,\n    const ptrdiff_t *incx2,\n    float  *q1,\n    const ptrdiff_t *ldq1,\n    float  *q2,\n    const ptrdiff_t *ldq2,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cuncsd.f */\n#define cuncsd FORTRAN_WRAPPER(cuncsd)\nextern void cuncsd(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const char   *jobv2t,\n    const char   *trans,\n    const char   *signs,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x12,\n    const ptrdiff_t *ldx12,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *x22,\n    const ptrdiff_t *ldx22,\n    float  *theta,\n    float  *u1,\n    const ptrdiff_t *ldu1,\n    float  *u2,\n    const ptrdiff_t *ldu2,\n    float  *v1t,\n    const ptrdiff_t *ldv1t,\n    float  *v2t,\n    const ptrdiff_t *ldv2t,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: cuncsd2by1.f */\n#define cuncsd2by1 FORTRAN_WRAPPER(cuncsd2by1)\nextern void cuncsd2by1(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *u1,\n    const ptrdiff_t *ldu1,\n    float  *u2,\n    const ptrdiff_t *ldu2,\n    float  *v1t,\n    const ptrdiff_t *ldv1t,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: cung2l.f */\n#define cung2l FORTRAN_WRAPPER(cung2l)\nextern void cung2l(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cung2r.f */\n#define cung2r FORTRAN_WRAPPER(cung2r)\nextern void cung2r(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cungbr.f */\n#define cungbr FORTRAN_WRAPPER(cungbr)\nextern void cungbr(\n    const char   *vect,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunghr.f */\n#define cunghr FORTRAN_WRAPPER(cunghr)\nextern void cunghr(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cungl2.f */\n#define cungl2 FORTRAN_WRAPPER(cungl2)\nextern void cungl2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cunglq.f */\n#define cunglq FORTRAN_WRAPPER(cunglq)\nextern void cunglq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cungql.f */\n#define cungql FORTRAN_WRAPPER(cungql)\nextern void cungql(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cungqr.f */\n#define cungqr FORTRAN_WRAPPER(cungqr)\nextern void cungqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cungr2.f */\n#define cungr2 FORTRAN_WRAPPER(cungr2)\nextern void cungr2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cungrq.f */\n#define cungrq FORTRAN_WRAPPER(cungrq)\nextern void cungrq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cungtr.f */\n#define cungtr FORTRAN_WRAPPER(cungtr)\nextern void cungtr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunm22.f */\n#define cunm22 FORTRAN_WRAPPER(cunm22)\nextern void cunm22(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    const float  *q,\n    const ptrdiff_t *ldq,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunm2l.f */\n#define cunm2l FORTRAN_WRAPPER(cunm2l)\nextern void cunm2l(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cunm2r.f */\n#define cunm2r FORTRAN_WRAPPER(cunm2r)\nextern void cunm2r(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cunmbr.f */\n#define cunmbr FORTRAN_WRAPPER(cunmbr)\nextern void cunmbr(\n    const char   *vect,\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunmhr.f */\n#define cunmhr FORTRAN_WRAPPER(cunmhr)\nextern void cunmhr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunml2.f */\n#define cunml2 FORTRAN_WRAPPER(cunml2)\nextern void cunml2(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cunmlq.f */\n#define cunmlq FORTRAN_WRAPPER(cunmlq)\nextern void cunmlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunmql.f */\n#define cunmql FORTRAN_WRAPPER(cunmql)\nextern void cunmql(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunmqr.f */\n#define cunmqr FORTRAN_WRAPPER(cunmqr)\nextern void cunmqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunmr2.f */\n#define cunmr2 FORTRAN_WRAPPER(cunmr2)\nextern void cunmr2(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cunmr3.f */\n#define cunmr3 FORTRAN_WRAPPER(cunmr3)\nextern void cunmr3(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cunmrq.f */\n#define cunmrq FORTRAN_WRAPPER(cunmrq)\nextern void cunmrq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunmrz.f */\n#define cunmrz FORTRAN_WRAPPER(cunmrz)\nextern void cunmrz(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cunmtr.f */\n#define cunmtr FORTRAN_WRAPPER(cunmtr)\nextern void cunmtr(\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: cupgtr.f */\n#define cupgtr FORTRAN_WRAPPER(cupgtr)\nextern void cupgtr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    const float  *tau,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: cupmtr.f */\n#define cupmtr FORTRAN_WRAPPER(cupmtr)\nextern void cupmtr(\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *ap,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: dbbcsd.f */\n#define dbbcsd FORTRAN_WRAPPER(dbbcsd)\nextern void dbbcsd(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const char   *jobv2t,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *theta,\n    double *phi,\n    double *u1,\n    const ptrdiff_t *ldu1,\n    double *u2,\n    const ptrdiff_t *ldu2,\n    double *v1t,\n    const ptrdiff_t *ldv1t,\n    double *v2t,\n    const ptrdiff_t *ldv2t,\n    double *b11d,\n    double *b11e,\n    double *b12d,\n    double *b12e,\n    double *b21d,\n    double *b21e,\n    double *b22d,\n    double *b22e,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dbdsdc.f */\n#define dbdsdc FORTRAN_WRAPPER(dbdsdc)\nextern void dbdsdc(\n    const char   *uplo,\n    const char   *compq,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *q,\n    ptrdiff_t *iq,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dbdsqr.f */\n#define dbdsqr FORTRAN_WRAPPER(dbdsqr)\nextern void dbdsqr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncvt,\n    const ptrdiff_t *nru,\n    const ptrdiff_t *ncc,\n    double *d,\n    double *e,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dbdsvdx.f */\n#define dbdsvdx FORTRAN_WRAPPER(dbdsvdx)\nextern void dbdsvdx(\n    const char   *uplo,\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    const double *d,\n    const double *e,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *ns,\n    double *s,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ddisna.f */\n#define ddisna FORTRAN_WRAPPER(ddisna)\nextern void ddisna(\n    const char   *job,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *d,\n    double *sep,\n    ptrdiff_t *info\n);\n\n/* Source: cgegs.f */\n#define cgegs FORTRAN_WRAPPER(cgegs)\nextern void cgegs(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *vsl,\n    const ptrdiff_t *ldvsl,\n    float  *vsr,\n    const ptrdiff_t *ldvsr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgegv.f */\n#define cgegv FORTRAN_WRAPPER(cgegv)\nextern void cgegv(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgelsx.f */\n#define cgelsx FORTRAN_WRAPPER(cgelsx)\nextern void cgelsx(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *jpvt,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cgeqpf.f */\n#define cgeqpf FORTRAN_WRAPPER(cgeqpf)\nextern void cgeqpf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    float  *tau,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggsvd.f */\n#define cggsvd FORTRAN_WRAPPER(cggsvd)\nextern void cggsvd(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    float  *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: cggsvp.f */\n#define cggsvp FORTRAN_WRAPPER(cggsvp)\nextern void cggsvp(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *tola,\n    const float  *tolb,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *iwork,\n    float  *rwork,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: clahrd.f */\n#define clahrd FORTRAN_WRAPPER(clahrd)\nextern void clahrd(\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: clatzm.f */\n#define clatzm FORTRAN_WRAPPER(clatzm)\nextern void clatzm(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *v,\n    const ptrdiff_t *incv,\n    const float  *tau,\n    float  *c1,\n    float  *c2,\n    const ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: ctzrqf.f */\n#define ctzrqf FORTRAN_WRAPPER(ctzrqf)\nextern void ctzrqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    ptrdiff_t *info\n);\n\n/* Source: dgegs.f */\n#define dgegs FORTRAN_WRAPPER(dgegs)\nextern void dgegs(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *vsl,\n    const ptrdiff_t *ldvsl,\n    double *vsr,\n    const ptrdiff_t *ldvsr,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgegv.f */\n#define dgegv FORTRAN_WRAPPER(dgegv)\nextern void dgegv(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgelsx.f */\n#define dgelsx FORTRAN_WRAPPER(dgelsx)\nextern void dgelsx(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *jpvt,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqpf.f */\n#define dgeqpf FORTRAN_WRAPPER(dgeqpf)\nextern void dgeqpf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dggsvd.f */\n#define dggsvd FORTRAN_WRAPPER(dggsvd)\nextern void dggsvd(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggsvp.f */\n#define dggsvp FORTRAN_WRAPPER(dggsvp)\nextern void dggsvp(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *tola,\n    const double *tolb,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *iwork,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlahrd.f */\n#define dlahrd FORTRAN_WRAPPER(dlahrd)\nextern void dlahrd(\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: dlatzm.f */\n#define dlatzm FORTRAN_WRAPPER(dlatzm)\nextern void dlatzm(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *v,\n    const ptrdiff_t *incv,\n    const double *tau,\n    double *c1,\n    double *c2,\n    const ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: dtzrqf.f */\n#define dtzrqf FORTRAN_WRAPPER(dtzrqf)\nextern void dtzrqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    ptrdiff_t *info\n);\n\n/* Source: sgegs.f */\n#define sgegs FORTRAN_WRAPPER(sgegs)\nextern void sgegs(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *vsl,\n    const ptrdiff_t *ldvsl,\n    float  *vsr,\n    const ptrdiff_t *ldvsr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgegv.f */\n#define sgegv FORTRAN_WRAPPER(sgegv)\nextern void sgegv(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgelsx.f */\n#define sgelsx FORTRAN_WRAPPER(sgelsx)\nextern void sgelsx(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *jpvt,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqpf.f */\n#define sgeqpf FORTRAN_WRAPPER(sgeqpf)\nextern void sgeqpf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sggsvd.f */\n#define sggsvd FORTRAN_WRAPPER(sggsvd)\nextern void sggsvd(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggsvp.f */\n#define sggsvp FORTRAN_WRAPPER(sggsvp)\nextern void sggsvp(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *tola,\n    const float  *tolb,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *iwork,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slahrd.f */\n#define slahrd FORTRAN_WRAPPER(slahrd)\nextern void slahrd(\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: slatzm.f */\n#define slatzm FORTRAN_WRAPPER(slatzm)\nextern void slatzm(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *v,\n    const ptrdiff_t *incv,\n    const float  *tau,\n    float  *c1,\n    float  *c2,\n    const ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: stzrqf.f */\n#define stzrqf FORTRAN_WRAPPER(stzrqf)\nextern void stzrqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    ptrdiff_t *info\n);\n\n/* Source: zgegs.f */\n#define zgegs FORTRAN_WRAPPER(zgegs)\nextern void zgegs(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *vsl,\n    const ptrdiff_t *ldvsl,\n    double *vsr,\n    const ptrdiff_t *ldvsr,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgegv.f */\n#define zgegv FORTRAN_WRAPPER(zgegv)\nextern void zgegv(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgelsx.f */\n#define zgelsx FORTRAN_WRAPPER(zgelsx)\nextern void zgelsx(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *jpvt,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqpf.f */\n#define zgeqpf FORTRAN_WRAPPER(zgeqpf)\nextern void zgeqpf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    double *tau,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggsvd.f */\n#define zggsvd FORTRAN_WRAPPER(zggsvd)\nextern void zggsvd(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggsvp.f */\n#define zggsvp FORTRAN_WRAPPER(zggsvp)\nextern void zggsvp(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *tola,\n    const double *tolb,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *iwork,\n    double *rwork,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zlahrd.f */\n#define zlahrd FORTRAN_WRAPPER(zlahrd)\nextern void zlahrd(\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: zlatzm.f */\n#define zlatzm FORTRAN_WRAPPER(zlatzm)\nextern void zlatzm(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *v,\n    const ptrdiff_t *incv,\n    const double *tau,\n    double *c1,\n    double *c2,\n    const ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: ztzrqf.f */\n#define ztzrqf FORTRAN_WRAPPER(ztzrqf)\nextern void ztzrqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    ptrdiff_t *info\n);\n\n/* Source: dgbbrd.f */\n#define dgbbrd FORTRAN_WRAPPER(dgbbrd)\nextern void dgbbrd(\n    const char   *vect,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncc,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *d,\n    double *e,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *pt,\n    const ptrdiff_t *ldpt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgbcon.f */\n#define dgbcon FORTRAN_WRAPPER(dgbcon)\nextern void dgbcon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgbequ.f */\n#define dgbequ FORTRAN_WRAPPER(dgbequ)\nextern void dgbequ(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *r,\n    double *c,\n    double *rowcnd,\n    double *colcnd,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: dgbequb.f */\n#define dgbequb FORTRAN_WRAPPER(dgbequb)\nextern void dgbequb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *r,\n    double *c,\n    double *rowcnd,\n    double *colcnd,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: dgbrfs.f */\n#define dgbrfs FORTRAN_WRAPPER(dgbrfs)\nextern void dgbrfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const double *afb,\n    const ptrdiff_t *ldafb,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgbsv.f */\n#define dgbsv FORTRAN_WRAPPER(dgbsv)\nextern void dgbsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dgbsvx.f */\n#define dgbsvx FORTRAN_WRAPPER(dgbsvx)\nextern void dgbsvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *afb,\n    const ptrdiff_t *ldafb,\n    ptrdiff_t *ipiv,\n    char   *equed,\n    double *r,\n    double *c,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgbtf2.f */\n#define dgbtf2 FORTRAN_WRAPPER(dgbtf2)\nextern void dgbtf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dgbtrf.f */\n#define dgbtrf FORTRAN_WRAPPER(dgbtrf)\nextern void dgbtrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dgbtrs.f */\n#define dgbtrs FORTRAN_WRAPPER(dgbtrs)\nextern void dgbtrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dgebak.f */\n#define dgebak FORTRAN_WRAPPER(dgebak)\nextern void dgebak(\n    const char   *job,\n    const char   *side,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const double *scale,\n    const ptrdiff_t *m,\n    double *v,\n    const ptrdiff_t *ldv,\n    ptrdiff_t *info\n);\n\n/* Source: dgebal.f */\n#define dgebal FORTRAN_WRAPPER(dgebal)\nextern void dgebal(\n    const char   *job,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    double *scale,\n    ptrdiff_t *info\n);\n\n/* Source: dgebd2.f */\n#define dgebd2 FORTRAN_WRAPPER(dgebd2)\nextern void dgebd2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tauq,\n    double *taup,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgebrd.f */\n#define dgebrd FORTRAN_WRAPPER(dgebrd)\nextern void dgebrd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tauq,\n    double *taup,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgecon.f */\n#define dgecon FORTRAN_WRAPPER(dgecon)\nextern void dgecon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgeequ.f */\n#define dgeequ FORTRAN_WRAPPER(dgeequ)\nextern void dgeequ(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *r,\n    double *c,\n    double *rowcnd,\n    double *colcnd,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: dgeequb.f */\n#define dgeequb FORTRAN_WRAPPER(dgeequb)\nextern void dgeequb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *r,\n    double *c,\n    double *rowcnd,\n    double *colcnd,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: dgees.f */\n#define dgees FORTRAN_WRAPPER(dgees)\nextern void dgees(\n    const char   *jobvs,\n    const char   *sort,\n    ptrdiff_t (*select)(),\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *sdim,\n    double *wr,\n    double *wi,\n    double *vs,\n    const ptrdiff_t *ldvs,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgeesx.f */\n#define dgeesx FORTRAN_WRAPPER(dgeesx)\nextern void dgeesx(\n    const char   *jobvs,\n    const char   *sort,\n    ptrdiff_t (*select)(),\n    const char   *sense,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *sdim,\n    double *wr,\n    double *wi,\n    double *vs,\n    const ptrdiff_t *ldvs,\n    double *rconde,\n    double *rcondv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgeev.f */\n#define dgeev FORTRAN_WRAPPER(dgeev)\nextern void dgeev(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *wr,\n    double *wi,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgeevx.f */\n#define dgeevx FORTRAN_WRAPPER(dgeevx)\nextern void dgeevx(\n    const char   *balanc,\n    const char   *jobvl,\n    const char   *jobvr,\n    const char   *sense,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *wr,\n    double *wi,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    double *scale,\n    double *abnrm,\n    double *rconde,\n    double *rcondv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgehd2.f */\n#define dgehd2 FORTRAN_WRAPPER(dgehd2)\nextern void dgehd2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgehrd.f */\n#define dgehrd FORTRAN_WRAPPER(dgehrd)\nextern void dgehrd(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgejsv.f */\n#define dgejsv FORTRAN_WRAPPER(dgejsv)\nextern void dgejsv(\n    const char   *joba,\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobr,\n    const char   *jobt,\n    const char   *jobp,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *sva,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgelq.f */\n#define dgelq FORTRAN_WRAPPER(dgelq)\nextern void dgelq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *tsize,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgelq2.f */\n#define dgelq2 FORTRAN_WRAPPER(dgelq2)\nextern void dgelq2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgelqf.f */\n#define dgelqf FORTRAN_WRAPPER(dgelqf)\nextern void dgelqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgelqt.f */\n#define dgelqt FORTRAN_WRAPPER(dgelqt)\nextern void dgelqt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgelqt3.f */\n#define dgelqt3 FORTRAN_WRAPPER(dgelqt3)\nextern void dgelqt3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: dgels.f */\n#define dgels FORTRAN_WRAPPER(dgels)\nextern void dgels(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgelsd.f */\n#define dgelsd FORTRAN_WRAPPER(dgelsd)\nextern void dgelsd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *s,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgelss.f */\n#define dgelss FORTRAN_WRAPPER(dgelss)\nextern void dgelss(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *s,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgelsy.f */\n#define dgelsy FORTRAN_WRAPPER(dgelsy)\nextern void dgelsy(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *jpvt,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgemlq.f */\n#define dgemlq FORTRAN_WRAPPER(dgemlq)\nextern void dgemlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *t,\n    const ptrdiff_t *tsize,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgemlqt.f */\n#define dgemlqt FORTRAN_WRAPPER(dgemlqt)\nextern void dgemlqt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgemqr.f */\n#define dgemqr FORTRAN_WRAPPER(dgemqr)\nextern void dgemqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *t,\n    const ptrdiff_t *tsize,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgemqrt.f */\n#define dgemqrt FORTRAN_WRAPPER(dgemqrt)\nextern void dgemqrt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgeql2.f */\n#define dgeql2 FORTRAN_WRAPPER(dgeql2)\nextern void dgeql2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqlf.f */\n#define dgeqlf FORTRAN_WRAPPER(dgeqlf)\nextern void dgeqlf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqp3.f */\n#define dgeqp3 FORTRAN_WRAPPER(dgeqp3)\nextern void dgeqp3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqr.f */\n#define dgeqr FORTRAN_WRAPPER(dgeqr)\nextern void dgeqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *tsize,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqr2.f */\n#define dgeqr2 FORTRAN_WRAPPER(dgeqr2)\nextern void dgeqr2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqr2p.f */\n#define dgeqr2p FORTRAN_WRAPPER(dgeqr2p)\nextern void dgeqr2p(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqrf.f */\n#define dgeqrf FORTRAN_WRAPPER(dgeqrf)\nextern void dgeqrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqrfp.f */\n#define dgeqrfp FORTRAN_WRAPPER(dgeqrfp)\nextern void dgeqrfp(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqrt.f */\n#define dgeqrt FORTRAN_WRAPPER(dgeqrt)\nextern void dgeqrt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqrt2.f */\n#define dgeqrt2 FORTRAN_WRAPPER(dgeqrt2)\nextern void dgeqrt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: dgeqrt3.f */\n#define dgeqrt3 FORTRAN_WRAPPER(dgeqrt3)\nextern void dgeqrt3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: dgerfs.f */\n#define dgerfs FORTRAN_WRAPPER(dgerfs)\nextern void dgerfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgerq2.f */\n#define dgerq2 FORTRAN_WRAPPER(dgerq2)\nextern void dgerq2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgerqf.f */\n#define dgerqf FORTRAN_WRAPPER(dgerqf)\nextern void dgerqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgesc2.f */\n#define dgesc2 FORTRAN_WRAPPER(dgesc2)\nextern void dgesc2(\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *rhs,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *jpiv,\n    double *scale\n);\n\n/* Source: dgesdd.f */\n#define dgesdd FORTRAN_WRAPPER(dgesdd)\nextern void dgesdd(\n    const char   *jobz,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgesv.f */\n#define dgesv FORTRAN_WRAPPER(dgesv)\nextern void dgesv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dgesvd.f */\n#define dgesvd FORTRAN_WRAPPER(dgesvd)\nextern void dgesvd(\n    const char   *jobu,\n    const char   *jobvt,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgesvdx.f */\n#define dgesvdx FORTRAN_WRAPPER(dgesvdx)\nextern void dgesvdx(\n    const char   *jobu,\n    const char   *jobvt,\n    const char   *range,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *ns,\n    double *s,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgesvj.f */\n#define dgesvj FORTRAN_WRAPPER(dgesvj)\nextern void dgesvj(\n    const char   *joba,\n    const char   *jobu,\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *sva,\n    const ptrdiff_t *mv,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgesvx.f */\n#define dgesvx FORTRAN_WRAPPER(dgesvx)\nextern void dgesvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    char   *equed,\n    double *r,\n    double *c,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgetc2.f */\n#define dgetc2 FORTRAN_WRAPPER(dgetc2)\nextern void dgetc2(\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *jpiv,\n    ptrdiff_t *info\n);\n\n/* Source: dgetf2.f */\n#define dgetf2 FORTRAN_WRAPPER(dgetf2)\nextern void dgetf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dgetrf.f */\n#define dgetrf FORTRAN_WRAPPER(dgetrf)\nextern void dgetrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dgetrf2.f */\n#define dgetrf2 FORTRAN_WRAPPER(dgetrf2)\nextern void dgetrf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dgetri.f */\n#define dgetri FORTRAN_WRAPPER(dgetri)\nextern void dgetri(\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgetrs.f */\n#define dgetrs FORTRAN_WRAPPER(dgetrs)\nextern void dgetrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dgetsls.f */\n#define dgetsls FORTRAN_WRAPPER(dgetsls)\nextern void dgetsls(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggbak.f */\n#define dggbak FORTRAN_WRAPPER(dggbak)\nextern void dggbak(\n    const char   *job,\n    const char   *side,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const double *lscale,\n    const double *rscale,\n    const ptrdiff_t *m,\n    double *v,\n    const ptrdiff_t *ldv,\n    ptrdiff_t *info\n);\n\n/* Source: dggbal.f */\n#define dggbal FORTRAN_WRAPPER(dggbal)\nextern void dggbal(\n    const char   *job,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    double *lscale,\n    double *rscale,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dgges.f */\n#define dgges FORTRAN_WRAPPER(dgges)\nextern void dgges(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *vsl,\n    const ptrdiff_t *ldvsl,\n    double *vsr,\n    const ptrdiff_t *ldvsr,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgges3.f */\n#define dgges3 FORTRAN_WRAPPER(dgges3)\nextern void dgges3(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *vsl,\n    const ptrdiff_t *ldvsl,\n    double *vsr,\n    const ptrdiff_t *ldvsr,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggesx.f */\n#define dggesx FORTRAN_WRAPPER(dggesx)\nextern void dggesx(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const char   *sense,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *vsl,\n    const ptrdiff_t *ldvsl,\n    double *vsr,\n    const ptrdiff_t *ldvsr,\n    double *rconde,\n    double *rcondv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggev.f */\n#define dggev FORTRAN_WRAPPER(dggev)\nextern void dggev(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggev3.f */\n#define dggev3 FORTRAN_WRAPPER(dggev3)\nextern void dggev3(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggevx.f */\n#define dggevx FORTRAN_WRAPPER(dggevx)\nextern void dggevx(\n    const char   *balanc,\n    const char   *jobvl,\n    const char   *jobvr,\n    const char   *sense,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    double *lscale,\n    double *rscale,\n    double *abnrm,\n    double *bbnrm,\n    double *rconde,\n    double *rcondv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggglm.f */\n#define dggglm FORTRAN_WRAPPER(dggglm)\nextern void dggglm(\n    const ptrdiff_t *n,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *d,\n    double *x,\n    double *y,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgghd3.f */\n#define dgghd3 FORTRAN_WRAPPER(dgghd3)\nextern void dgghd3(\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgghrd.f */\n#define dgghrd FORTRAN_WRAPPER(dgghrd)\nextern void dgghrd(\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *info\n);\n\n/* Source: dgglse.f */\n#define dgglse FORTRAN_WRAPPER(dgglse)\nextern void dgglse(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    double *d,\n    double *x,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggqrf.f */\n#define dggqrf FORTRAN_WRAPPER(dggqrf)\nextern void dggqrf(\n    const ptrdiff_t *n,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    double *a,\n    const ptrdiff_t *lda,\n    double *taua,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *taub,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggrqf.f */\n#define dggrqf FORTRAN_WRAPPER(dggrqf)\nextern void dggrqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *taua,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *taub,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggsvd3.f */\n#define dggsvd3 FORTRAN_WRAPPER(dggsvd3)\nextern void dggsvd3(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dggsvp3.f */\n#define dggsvp3 FORTRAN_WRAPPER(dggsvp3)\nextern void dggsvp3(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *tola,\n    const double *tolb,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *iwork,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgsvj0.f */\n#define dgsvj0 FORTRAN_WRAPPER(dgsvj0)\nextern void dgsvj0(\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *sva,\n    const ptrdiff_t *mv,\n    double *v,\n    const ptrdiff_t *ldv,\n    const double *eps,\n    const double *sfmin,\n    const double *tol,\n    const ptrdiff_t *nsweep,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgsvj1.f */\n#define dgsvj1 FORTRAN_WRAPPER(dgsvj1)\nextern void dgsvj1(\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *sva,\n    const ptrdiff_t *mv,\n    double *v,\n    const ptrdiff_t *ldv,\n    const double *eps,\n    const double *sfmin,\n    const double *tol,\n    const ptrdiff_t *nsweep,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgtcon.f */\n#define dgtcon FORTRAN_WRAPPER(dgtcon)\nextern void dgtcon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *du2,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgtrfs.f */\n#define dgtrfs FORTRAN_WRAPPER(dgtrfs)\nextern void dgtrfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *dlf,\n    const double *df,\n    const double *duf,\n    const double *du2,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgtsv.f */\n#define dgtsv FORTRAN_WRAPPER(dgtsv)\nextern void dgtsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *dl,\n    double *d,\n    double *du,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dgtsvx.f */\n#define dgtsvx FORTRAN_WRAPPER(dgtsvx)\nextern void dgtsvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *dl,\n    const double *d,\n    const double *du,\n    double *dlf,\n    double *df,\n    double *duf,\n    double *du2,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dgttrf.f */\n#define dgttrf FORTRAN_WRAPPER(dgttrf)\nextern void dgttrf(\n    const ptrdiff_t *n,\n    double *dl,\n    double *d,\n    double *du,\n    double *du2,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dgttrs.f */\n#define dgttrs FORTRAN_WRAPPER(dgttrs)\nextern void dgttrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *du2,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dgtts2.f */\n#define dgtts2 FORTRAN_WRAPPER(dgtts2)\nextern void dgtts2(\n    const ptrdiff_t *itrans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *du2,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: dhgeqz.f */\n#define dhgeqz FORTRAN_WRAPPER(dhgeqz)\nextern void dhgeqz(\n    const char   *job,\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dhsein.f */\n#define dhsein FORTRAN_WRAPPER(dhsein)\nextern void dhsein(\n    const char   *side,\n    const char   *eigsrc,\n    const char   *initv,\n    ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const double *h,\n    const ptrdiff_t *ldh,\n    double *wr,\n    const double *wi,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    ptrdiff_t *ifaill,\n    ptrdiff_t *ifailr,\n    ptrdiff_t *info\n);\n\n/* Source: dhseqr.f */\n#define dhseqr FORTRAN_WRAPPER(dhseqr)\nextern void dhseqr(\n    const char   *job,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *wr,\n    double *wi,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: disnan.f */\n#define disnan FORTRAN_WRAPPER(disnan)\nextern ptrdiff_t disnan(\n    const double *din\n);\n\n/* Source: dlabad.f */\n#define dlabad FORTRAN_WRAPPER(dlabad)\nextern void dlabad(\n    double *small,\n    double *large\n);\n\n/* Source: dlabrd.f */\n#define dlabrd FORTRAN_WRAPPER(dlabrd)\nextern void dlabrd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tauq,\n    double *taup,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: dlacn2.f */\n#define dlacn2 FORTRAN_WRAPPER(dlacn2)\nextern void dlacn2(\n    const ptrdiff_t *n,\n    double *v,\n    double *x,\n    ptrdiff_t *isgn,\n    double *est,\n    ptrdiff_t *kase,\n    ptrdiff_t *isave\n);\n\n/* Source: dlacon.f */\n#define dlacon FORTRAN_WRAPPER(dlacon)\nextern void dlacon(\n    const ptrdiff_t *n,\n    double *v,\n    double *x,\n    ptrdiff_t *isgn,\n    double *est,\n    ptrdiff_t *kase\n);\n\n/* Source: dlacpy.f */\n#define dlacpy FORTRAN_WRAPPER(dlacpy)\nextern void dlacpy(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: dladiv.f */\n#define dladiv FORTRAN_WRAPPER(dladiv)\nextern void dladiv(\n    const double *a,\n    const double *b,\n    const double *c,\n    const double *d,\n    double *p,\n    double *q\n);\n\n/* Source: dladiv.f */\n#define dladiv1 FORTRAN_WRAPPER(dladiv1)\nextern void dladiv1(\n    double *a,\n    double *b,\n    double *c,\n    double *d,\n    double *p,\n    double *q\n);\n\n/* Source: dladiv.f */\n#define dladiv2 FORTRAN_WRAPPER(dladiv2)\nextern double dladiv2(\n    double *a,\n    double *b,\n    double *c,\n    double *d,\n    double *r,\n    double *t\n);\n\n/* Source: dlae2.f */\n#define dlae2 FORTRAN_WRAPPER(dlae2)\nextern void dlae2(\n    const double *a,\n    const double *b,\n    const double *c,\n    double *rt1,\n    double *rt2\n);\n\n/* Source: dlaebz.f */\n#define dlaebz FORTRAN_WRAPPER(dlaebz)\nextern void dlaebz(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *nitmax,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mmax,\n    const ptrdiff_t *minp,\n    const ptrdiff_t *nbmin,\n    const double *abstol,\n    const double *reltol,\n    const double *pivmin,\n    const double *d,\n    const double *e,\n    const double *e2,\n    ptrdiff_t *nval,\n    double *ab,\n    double *c,\n    ptrdiff_t *mout,\n    ptrdiff_t *nab,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlaed0.f */\n#define dlaed0 FORTRAN_WRAPPER(dlaed0)\nextern void dlaed0(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *qsiz,\n    const ptrdiff_t *n,\n    double *d,\n    const double *e,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *qstore,\n    const ptrdiff_t *ldqs,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlaed1.f */\n#define dlaed1 FORTRAN_WRAPPER(dlaed1)\nextern void dlaed1(\n    const ptrdiff_t *n,\n    double *d,\n    double *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *indxq,\n    const double *rho,\n    const ptrdiff_t *cutpnt,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlaed2.f */\n#define dlaed2 FORTRAN_WRAPPER(dlaed2)\nextern void dlaed2(\n    ptrdiff_t *k,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    double *d,\n    double *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *indxq,\n    double *rho,\n    const double *z,\n    double *dlamda,\n    double *w,\n    double *q2,\n    ptrdiff_t *indx,\n    ptrdiff_t *indxc,\n    ptrdiff_t *indxp,\n    ptrdiff_t *coltyp,\n    ptrdiff_t *info\n);\n\n/* Source: dlaed3.f */\n#define dlaed3 FORTRAN_WRAPPER(dlaed3)\nextern void dlaed3(\n    const ptrdiff_t *k,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    double *d,\n    double *q,\n    const ptrdiff_t *ldq,\n    const double *rho,\n    double *dlamda,\n    const double *q2,\n    const ptrdiff_t *indx,\n    const ptrdiff_t *ctot,\n    double *w,\n    double *s,\n    ptrdiff_t *info\n);\n\n/* Source: dlaed4.f */\n#define dlaed4 FORTRAN_WRAPPER(dlaed4)\nextern void dlaed4(\n    const ptrdiff_t *n,\n    const ptrdiff_t *i,\n    const double *d,\n    const double *z,\n    double *delta,\n    const double *rho,\n    double *dlam,\n    ptrdiff_t *info\n);\n\n/* Source: dlaed5.f */\n#define dlaed5 FORTRAN_WRAPPER(dlaed5)\nextern void dlaed5(\n    const ptrdiff_t *i,\n    const double *d,\n    const double *z,\n    double *delta,\n    const double *rho,\n    double *dlam\n);\n\n/* Source: dlaed6.f */\n#define dlaed6 FORTRAN_WRAPPER(dlaed6)\nextern void dlaed6(\n    const ptrdiff_t *kniter,\n    const ptrdiff_t *orgati,\n    const double *rho,\n    const double *d,\n    const double *z,\n    const double *finit,\n    double *tau,\n    ptrdiff_t *info\n);\n\n/* Source: dlaed7.f */\n#define dlaed7 FORTRAN_WRAPPER(dlaed7)\nextern void dlaed7(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *n,\n    const ptrdiff_t *qsiz,\n    const ptrdiff_t *tlvls,\n    const ptrdiff_t *curlvl,\n    const ptrdiff_t *curpbm,\n    double *d,\n    double *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *indxq,\n    const double *rho,\n    const ptrdiff_t *cutpnt,\n    double *qstore,\n    ptrdiff_t *qptr,\n    const ptrdiff_t *prmptr,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const double *givnum,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlaed8.f */\n#define dlaed8 FORTRAN_WRAPPER(dlaed8)\nextern void dlaed8(\n    const ptrdiff_t *icompq,\n    ptrdiff_t *k,\n    const ptrdiff_t *n,\n    const ptrdiff_t *qsiz,\n    double *d,\n    double *q,\n    const ptrdiff_t *ldq,\n    const ptrdiff_t *indxq,\n    double *rho,\n    const ptrdiff_t *cutpnt,\n    const double *z,\n    double *dlamda,\n    double *q2,\n    const ptrdiff_t *ldq2,\n    double *w,\n    ptrdiff_t *perm,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    double *givnum,\n    ptrdiff_t *indxp,\n    ptrdiff_t *indx,\n    ptrdiff_t *info\n);\n\n/* Source: dlaed9.f */\n#define dlaed9 FORTRAN_WRAPPER(dlaed9)\nextern void dlaed9(\n    const ptrdiff_t *k,\n    const ptrdiff_t *kstart,\n    const ptrdiff_t *kstop,\n    const ptrdiff_t *n,\n    double *d,\n    double *q,\n    const ptrdiff_t *ldq,\n    const double *rho,\n    const double *dlamda,\n    const double *w,\n    double *s,\n    const ptrdiff_t *lds,\n    ptrdiff_t *info\n);\n\n/* Source: dlaeda.f */\n#define dlaeda FORTRAN_WRAPPER(dlaeda)\nextern void dlaeda(\n    const ptrdiff_t *n,\n    const ptrdiff_t *tlvls,\n    const ptrdiff_t *curlvl,\n    const ptrdiff_t *curpbm,\n    const ptrdiff_t *prmptr,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const double *givnum,\n    const double *q,\n    const ptrdiff_t *qptr,\n    double *z,\n    double *ztemp,\n    ptrdiff_t *info\n);\n\n/* Source: dlaein.f */\n#define dlaein FORTRAN_WRAPPER(dlaein)\nextern void dlaein(\n    const ptrdiff_t *rightv,\n    const ptrdiff_t *noinit,\n    const ptrdiff_t *n,\n    const double *h,\n    const ptrdiff_t *ldh,\n    const double *wr,\n    const double *wi,\n    double *vr,\n    double *vi,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const double *eps3,\n    const double *smlnum,\n    const double *bignum,\n    ptrdiff_t *info\n);\n\n/* Source: dlaev2.f */\n#define dlaev2 FORTRAN_WRAPPER(dlaev2)\nextern void dlaev2(\n    const double *a,\n    const double *b,\n    const double *c,\n    double *rt1,\n    double *rt2,\n    double *cs1,\n    double *sn1\n);\n\n/* Source: dlaexc.f */\n#define dlaexc FORTRAN_WRAPPER(dlaexc)\nextern void dlaexc(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *n,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *q,\n    const ptrdiff_t *ldq,\n    const ptrdiff_t *j1_,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlag2.f */\n#define dlag2 FORTRAN_WRAPPER(dlag2)\nextern void dlag2(\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *safmin,\n    double *scale1,\n    double *scale2,\n    double *wr1,\n    double *wr2,\n    double *wi\n);\n\n/* Source: dlag2s.f */\n#define dlag2s FORTRAN_WRAPPER(dlag2s)\nextern void dlag2s(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    float  *sa,\n    const ptrdiff_t *ldsa,\n    ptrdiff_t *info\n);\n\n/* Source: dlags2.f */\n#define dlags2 FORTRAN_WRAPPER(dlags2)\nextern void dlags2(\n    const ptrdiff_t *upper,\n    const double *a1,\n    const double *a2,\n    const double *a3,\n    const double *b1,\n    const double *b2,\n    const double *b3,\n    double *csu,\n    double *snu,\n    double *csv,\n    double *snv,\n    double *csq,\n    double *snq\n);\n\n/* Source: dlagtf.f */\n#define dlagtf FORTRAN_WRAPPER(dlagtf)\nextern void dlagtf(\n    const ptrdiff_t *n,\n    double *a,\n    const double *lambda,\n    double *b,\n    double *c,\n    const double *tol,\n    double *d,\n    ptrdiff_t *in,\n    ptrdiff_t *info\n);\n\n/* Source: dlagtm.f */\n#define dlagtm FORTRAN_WRAPPER(dlagtm)\nextern void dlagtm(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *alpha,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *x,\n    const ptrdiff_t *ldx,\n    const double *beta,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: dlagts.f */\n#define dlagts FORTRAN_WRAPPER(dlagts)\nextern void dlagts(\n    const ptrdiff_t *job,\n    const ptrdiff_t *n,\n    const double *a,\n    const double *b,\n    const double *c,\n    const double *d,\n    const ptrdiff_t *in,\n    double *y,\n    double *tol,\n    ptrdiff_t *info\n);\n\n/* Source: dlagv2.f */\n#define dlagv2 FORTRAN_WRAPPER(dlagv2)\nextern void dlagv2(\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *csl,\n    double *snl,\n    double *csr,\n    double *snr\n);\n\n/* Source: dlahqr.f */\n#define dlahqr FORTRAN_WRAPPER(dlahqr)\nextern void dlahqr(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *wr,\n    double *wi,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *info\n);\n\n/* Source: dlahr2.f */\n#define dlahr2 FORTRAN_WRAPPER(dlahr2)\nextern void dlahr2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: dlaic1.f */\n#define dlaic1 FORTRAN_WRAPPER(dlaic1)\nextern void dlaic1(\n    const ptrdiff_t *job,\n    const ptrdiff_t *j,\n    const double *x,\n    const double *sest,\n    const double *w,\n    const double *gamma_,\n    double *sestpr,\n    double *s,\n    double *c\n);\n\n/* Source: dlaisnan.f */\n#define dlaisnan FORTRAN_WRAPPER(dlaisnan)\nextern ptrdiff_t dlaisnan(\n    const double *din1,\n    const double *din2\n);\n\n/* Source: dlaln2.f */\n#define dlaln2 FORTRAN_WRAPPER(dlaln2)\nextern void dlaln2(\n    const ptrdiff_t *ltrans,\n    const ptrdiff_t *na,\n    const ptrdiff_t *nw,\n    const double *smin,\n    const double *ca,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *d1,\n    const double *d2,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *wr,\n    const double *wi,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *scale,\n    double *xnorm,\n    ptrdiff_t *info\n);\n\n/* Source: dlals0.f */\n#define dlals0 FORTRAN_WRAPPER(dlals0)\nextern void dlals0(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    const ptrdiff_t *nrhs,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *bx,\n    const ptrdiff_t *ldbx,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    const double *givnum,\n    const ptrdiff_t *ldgnum,\n    const double *poles,\n    const double *difl,\n    const double *difr,\n    const double *z,\n    const ptrdiff_t *k,\n    const double *c,\n    const double *s,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlalsa.f */\n#define dlalsa FORTRAN_WRAPPER(dlalsa)\nextern void dlalsa(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *bx,\n    const ptrdiff_t *ldbx,\n    const double *u,\n    const ptrdiff_t *ldu,\n    const double *vt,\n    const ptrdiff_t *k,\n    const double *difl,\n    const double *difr,\n    const double *z,\n    const double *poles,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    const ptrdiff_t *perm,\n    const double *givnum,\n    const double *c,\n    const double *s,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlalsd.f */\n#define dlalsd FORTRAN_WRAPPER(dlalsd)\nextern void dlalsd(\n    const char   *uplo,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *d,\n    double *e,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlamrg.f */\n#define dlamrg FORTRAN_WRAPPER(dlamrg)\nextern void dlamrg(\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    const double *a,\n    const ptrdiff_t *dtrd1,\n    const ptrdiff_t *dtrd2,\n    ptrdiff_t *index\n);\n\n/* Source: dlamswlq.f */\n#define dlamswlq FORTRAN_WRAPPER(dlamswlq)\nextern void dlamswlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlamtsqr.f */\n#define dlamtsqr FORTRAN_WRAPPER(dlamtsqr)\nextern void dlamtsqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlaneg.f */\n#define dlaneg FORTRAN_WRAPPER(dlaneg)\nextern ptrdiff_t dlaneg(\n    const ptrdiff_t *n,\n    const double *d,\n    const double *lld,\n    const double *sigma,\n    const double *pivmin,\n    const ptrdiff_t *r\n);\n\n/* Source: dlangb.f */\n#define dlangb FORTRAN_WRAPPER(dlangb)\nextern double dlangb(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *work\n);\n\n/* Source: dlange.f */\n#define dlange FORTRAN_WRAPPER(dlange)\nextern double dlange(\n    const char   *norm,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *work\n);\n\n/* Source: dlangt.f */\n#define dlangt FORTRAN_WRAPPER(dlangt)\nextern double dlangt(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *dl,\n    const double *d,\n    const double *du\n);\n\n/* Source: dlanhs.f */\n#define dlanhs FORTRAN_WRAPPER(dlanhs)\nextern double dlanhs(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *work\n);\n\n/* Source: dlansb.f */\n#define dlansb FORTRAN_WRAPPER(dlansb)\nextern double dlansb(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *work\n);\n\n/* Source: dlansf.f */\n#define dlansf FORTRAN_WRAPPER(dlansf)\nextern double dlansf(\n    const char   *norm,\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    double *work\n);\n\n/* Source: dlansp.f */\n#define dlansp FORTRAN_WRAPPER(dlansp)\nextern double dlansp(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *work\n);\n\n/* Source: dlanst.f */\n#define dlanst FORTRAN_WRAPPER(dlanst)\nextern double dlanst(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *d,\n    const double *e\n);\n\n/* Source: dlansy.f */\n#define dlansy FORTRAN_WRAPPER(dlansy)\nextern double dlansy(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *work\n);\n\n/* Source: dlantb.f */\n#define dlantb FORTRAN_WRAPPER(dlantb)\nextern double dlantb(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *work\n);\n\n/* Source: dlantp.f */\n#define dlantp FORTRAN_WRAPPER(dlantp)\nextern double dlantp(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *work\n);\n\n/* Source: dlantr.f */\n#define dlantr FORTRAN_WRAPPER(dlantr)\nextern double dlantr(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *work\n);\n\n/* Source: dlanv2.f */\n#define dlanv2 FORTRAN_WRAPPER(dlanv2)\nextern void dlanv2(\n    double *a,\n    double *b,\n    double *c,\n    double *d,\n    double *rt1r,\n    double *rt1i,\n    double *rt2r,\n    double *rt2i,\n    double *cs,\n    double *sn\n);\n\n/* Source: dlapll.f */\n#define dlapll FORTRAN_WRAPPER(dlapll)\nextern void dlapll(\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *incx,\n    double *y,\n    const ptrdiff_t *incy,\n    double *ssmin\n);\n\n/* Source: dlapmr.f */\n#define dlapmr FORTRAN_WRAPPER(dlapmr)\nextern void dlapmr(\n    const ptrdiff_t *forwrd,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *ldx,\n    ptrdiff_t *k\n);\n\n/* Source: dlapmt.f */\n#define dlapmt FORTRAN_WRAPPER(dlapmt)\nextern void dlapmt(\n    const ptrdiff_t *forwrd,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *ldx,\n    ptrdiff_t *k\n);\n\n/* Source: dlapy2.f */\n#define dlapy2 FORTRAN_WRAPPER(dlapy2)\nextern double dlapy2(\n    const double *x,\n    const double *y\n);\n\n/* Source: dlapy3.f */\n#define dlapy3 FORTRAN_WRAPPER(dlapy3)\nextern double dlapy3(\n    const double *x,\n    const double *y,\n    const double *z\n);\n\n/* Source: dlaqgb.f */\n#define dlaqgb FORTRAN_WRAPPER(dlaqgb)\nextern void dlaqgb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    double *ab,\n    const ptrdiff_t *ldab,\n    const double *r,\n    const double *c,\n    const double *rowcnd,\n    const double *colcnd,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: dlaqge.f */\n#define dlaqge FORTRAN_WRAPPER(dlaqge)\nextern void dlaqge(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *r,\n    const double *c,\n    const double *rowcnd,\n    const double *colcnd,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: dlaqp2.f */\n#define dlaqp2 FORTRAN_WRAPPER(dlaqp2)\nextern void dlaqp2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *offset,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    double *tau,\n    double *vn1,\n    double *vn2,\n    double *work\n);\n\n/* Source: dlaqps.f */\n#define dlaqps FORTRAN_WRAPPER(dlaqps)\nextern void dlaqps(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *offset,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    double *tau,\n    double *vn1,\n    double *vn2,\n    double *auxv,\n    double *f,\n    const ptrdiff_t *ldf\n);\n\n/* Source: dlaqr0.f */\n#define dlaqr0 FORTRAN_WRAPPER(dlaqr0)\nextern void dlaqr0(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *wr,\n    double *wi,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlaqr1.f */\n#define dlaqr1 FORTRAN_WRAPPER(dlaqr1)\nextern void dlaqr1(\n    const ptrdiff_t *n,\n    const double *h,\n    const ptrdiff_t *ldh,\n    const double *sr1,\n    double *si1,\n    double *sr2,\n    double *si2,\n    double *v\n);\n\n/* Source: dlaqr2.f */\n#define dlaqr2 FORTRAN_WRAPPER(dlaqr2)\nextern void dlaqr2(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nw,\n    double *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ns,\n    ptrdiff_t *nd,\n    double *sr,\n    double *si,\n    double *v,\n    const ptrdiff_t *ldv,\n    const ptrdiff_t *nh,\n    double *t,\n    const ptrdiff_t *ldt,\n    const ptrdiff_t *nv,\n    double *wv,\n    const ptrdiff_t *ldwv,\n    double *work,\n    const ptrdiff_t *lwork\n);\n\n/* Source: dlaqr3.f */\n#define dlaqr3 FORTRAN_WRAPPER(dlaqr3)\nextern void dlaqr3(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nw,\n    double *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ns,\n    ptrdiff_t *nd,\n    double *sr,\n    double *si,\n    double *v,\n    const ptrdiff_t *ldv,\n    const ptrdiff_t *nh,\n    double *t,\n    const ptrdiff_t *ldt,\n    const ptrdiff_t *nv,\n    double *wv,\n    const ptrdiff_t *ldwv,\n    double *work,\n    const ptrdiff_t *lwork\n);\n\n/* Source: dlaqr4.f */\n#define dlaqr4 FORTRAN_WRAPPER(dlaqr4)\nextern void dlaqr4(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *wr,\n    double *wi,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlaqr5.f */\n#define dlaqr5 FORTRAN_WRAPPER(dlaqr5)\nextern void dlaqr5(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *kacc22,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nshfts,\n    double *sr,\n    double *si,\n    double *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *u,\n    const ptrdiff_t *ldu,\n    const ptrdiff_t *nv,\n    double *wv,\n    const ptrdiff_t *ldwv,\n    const ptrdiff_t *nh,\n    double *wh,\n    const ptrdiff_t *ldwh\n);\n\n/* Source: dlaqsb.f */\n#define dlaqsb FORTRAN_WRAPPER(dlaqsb)\nextern void dlaqsb(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    const double *s,\n    const double *scond,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: dlaqsp.f */\n#define dlaqsp FORTRAN_WRAPPER(dlaqsp)\nextern void dlaqsp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const double *s,\n    const double *scond,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: dlaqsy.f */\n#define dlaqsy FORTRAN_WRAPPER(dlaqsy)\nextern void dlaqsy(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *s,\n    const double *scond,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: dlaqtr.f */\n#define dlaqtr FORTRAN_WRAPPER(dlaqtr)\nextern void dlaqtr(\n    const ptrdiff_t *ltran,\n    const ptrdiff_t *lreal,\n    const ptrdiff_t *n,\n    const double *t,\n    const ptrdiff_t *ldt,\n    const double *b,\n    const double *w,\n    double *scale,\n    double *x,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlar1v.f */\n#define dlar1v FORTRAN_WRAPPER(dlar1v)\nextern void dlar1v(\n    const ptrdiff_t *n,\n    const ptrdiff_t *b1,\n    const ptrdiff_t *bn,\n    const double *lambda,\n    const double *d,\n    const double *l,\n    const double *ld,\n    const double *lld,\n    const double *pivmin,\n    const double *gaptol,\n    double *z,\n    const ptrdiff_t *wantnc,\n    ptrdiff_t *negcnt,\n    double *ztz,\n    double *mingma,\n    ptrdiff_t *r,\n    ptrdiff_t *isuppz,\n    double *nrminv,\n    double *resid,\n    double *rqcorr,\n    double *work\n);\n\n/* Source: dlar2v.f */\n#define dlar2v FORTRAN_WRAPPER(dlar2v)\nextern void dlar2v(\n    const ptrdiff_t *n,\n    double *x,\n    double *y,\n    double *z,\n    const ptrdiff_t *incx,\n    const double *c,\n    const double *s,\n    const ptrdiff_t *incc\n);\n\n/* Source: dlarf.f */\n#define dlarf FORTRAN_WRAPPER(dlarf)\nextern void dlarf(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *v,\n    const ptrdiff_t *incv,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: dlarfb.f */\n#define dlarfb FORTRAN_WRAPPER(dlarfb)\nextern void dlarfb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: dlarfg.f */\n#define dlarfg FORTRAN_WRAPPER(dlarfg)\nextern void dlarfg(\n    const ptrdiff_t *n,\n    double *alpha,\n    double *x,\n    const ptrdiff_t *incx,\n    double *tau\n);\n\n/* Source: dlarfgp.f */\n#define dlarfgp FORTRAN_WRAPPER(dlarfgp)\nextern void dlarfgp(\n    const ptrdiff_t *n,\n    double *alpha,\n    double *x,\n    const ptrdiff_t *incx,\n    double *tau\n);\n\n/* Source: dlarft.f */\n#define dlarft FORTRAN_WRAPPER(dlarft)\nextern void dlarft(\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *tau,\n    double *t,\n    const ptrdiff_t *ldt\n);\n\n/* Source: dlarfx.f */\n#define dlarfx FORTRAN_WRAPPER(dlarfx)\nextern void dlarfx(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *v,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: dlarfy.f */\n#define dlarfy FORTRAN_WRAPPER(dlarfy)\nextern void dlarfy(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *v,\n    ptrdiff_t *incv,\n    double *tau,\n    double *c,\n    ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: dlargv.f */\n#define dlargv FORTRAN_WRAPPER(dlargv)\nextern void dlargv(\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *incx,\n    double *y,\n    const ptrdiff_t *incy,\n    double *c,\n    const ptrdiff_t *incc\n);\n\n/* Source: dlarnv.f */\n#define dlarnv FORTRAN_WRAPPER(dlarnv)\nextern void dlarnv(\n    const ptrdiff_t *idist,\n    ptrdiff_t *iseed,\n    const ptrdiff_t *n,\n    double *x\n);\n\n/* Source: dlarra.f */\n#define dlarra FORTRAN_WRAPPER(dlarra)\nextern void dlarra(\n    const ptrdiff_t *n,\n    const double *d,\n    double *e,\n    double *e2,\n    const double *spltol,\n    const double *tnrm,\n    ptrdiff_t *nsplit,\n    ptrdiff_t *isplit,\n    ptrdiff_t *info\n);\n\n/* Source: dlarrb.f */\n#define dlarrb FORTRAN_WRAPPER(dlarrb)\nextern void dlarrb(\n    const ptrdiff_t *n,\n    const double *d,\n    const double *lld,\n    const ptrdiff_t *ifirst,\n    const ptrdiff_t *ilast,\n    const double *rtol1,\n    const double *rtol2,\n    const ptrdiff_t *offset,\n    double *w,\n    double *wgap,\n    double *werr,\n    double *work,\n    ptrdiff_t *iwork,\n    const double *pivmin,\n    const double *spdiam,\n    const ptrdiff_t *twist,\n    ptrdiff_t *info\n);\n\n/* Source: dlarrc.f */\n#define dlarrc FORTRAN_WRAPPER(dlarrc)\nextern void dlarrc(\n    const char   *jobt,\n    const ptrdiff_t *n,\n    const double *vl,\n    const double *vu,\n    const double *d,\n    const double *e,\n    const double *pivmin,\n    ptrdiff_t *eigcnt,\n    ptrdiff_t *lcnt,\n    ptrdiff_t *rcnt,\n    ptrdiff_t *info\n);\n\n/* Source: dlarrd.f */\n#define dlarrd FORTRAN_WRAPPER(dlarrd)\nextern void dlarrd(\n    const char   *range,\n    const char   *order,\n    const ptrdiff_t *n,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *gers,\n    const double *reltol,\n    const double *d,\n    const double *e,\n    const double *e2,\n    const double *pivmin,\n    const ptrdiff_t *nsplit,\n    const ptrdiff_t *isplit,\n    ptrdiff_t *m,\n    double *w,\n    double *werr,\n    double *wl,\n    double *wu,\n    ptrdiff_t *iblock,\n    ptrdiff_t *indexw,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlarre.f */\n#define dlarre FORTRAN_WRAPPER(dlarre)\nextern void dlarre(\n    const char   *range,\n    const ptrdiff_t *n,\n    double *vl,\n    double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    double *d,\n    double *e,\n    double *e2,\n    const double *rtol1,\n    const double *rtol2,\n    const double *spltol,\n    ptrdiff_t *nsplit,\n    ptrdiff_t *isplit,\n    ptrdiff_t *m,\n    double *w,\n    double *werr,\n    double *wgap,\n    ptrdiff_t *iblock,\n    ptrdiff_t *indexw,\n    double *gers,\n    double *pivmin,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlarrf.f */\n#define dlarrf FORTRAN_WRAPPER(dlarrf)\nextern void dlarrf(\n    const ptrdiff_t *n,\n    const double *d,\n    const double *l,\n    const double *ld,\n    const ptrdiff_t *clstrt,\n    const ptrdiff_t *clend,\n    const double *w,\n    double *wgap,\n    const double *werr,\n    const double *spdiam,\n    const double *clgapl,\n    double *clgapr,\n    const double *pivmin,\n    double *sigma,\n    double *dplus,\n    double *lplus,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlarrj.f */\n#define dlarrj FORTRAN_WRAPPER(dlarrj)\nextern void dlarrj(\n    const ptrdiff_t *n,\n    const double *d,\n    const double *e2,\n    const ptrdiff_t *ifirst,\n    const ptrdiff_t *ilast,\n    const double *rtol,\n    const ptrdiff_t *offset,\n    double *w,\n    double *werr,\n    double *work,\n    ptrdiff_t *iwork,\n    const double *pivmin,\n    const double *spdiam,\n    ptrdiff_t *info\n);\n\n/* Source: dlarrk.f */\n#define dlarrk FORTRAN_WRAPPER(dlarrk)\nextern void dlarrk(\n    const ptrdiff_t *n,\n    const ptrdiff_t *iw,\n    const double *gl,\n    const double *gu,\n    const double *d,\n    const double *e2,\n    const double *pivmin,\n    const double *reltol,\n    double *w,\n    double *werr,\n    ptrdiff_t *info\n);\n\n/* Source: dlarrr.f */\n#define dlarrr FORTRAN_WRAPPER(dlarrr)\nextern void dlarrr(\n    const ptrdiff_t *n,\n    const double *d,\n    double *e,\n    ptrdiff_t *info\n);\n\n/* Source: dlarrv.f */\n#define dlarrv FORTRAN_WRAPPER(dlarrv)\nextern void dlarrv(\n    const ptrdiff_t *n,\n    const double *vl,\n    const double *vu,\n    double *d,\n    double *l,\n    double *pivmin,\n    const ptrdiff_t *isplit,\n    const ptrdiff_t *m,\n    const ptrdiff_t *dol,\n    const ptrdiff_t *dou,\n    const double *minrgp,\n    const double *rtol1,\n    const double *rtol2,\n    double *w,\n    double *werr,\n    double *wgap,\n    const ptrdiff_t *iblock,\n    const ptrdiff_t *indexw,\n    const double *gers,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlartg.f */\n#define dlartg FORTRAN_WRAPPER(dlartg)\nextern void dlartg(\n    const double *f,\n    const double *g,\n    double *cs,\n    double *sn,\n    double *r\n);\n\n/* Source: dlartgp.f */\n#define dlartgp FORTRAN_WRAPPER(dlartgp)\nextern void dlartgp(\n    double *f,\n    double *g,\n    double *cs,\n    double *sn,\n    double *r\n);\n\n/* Source: dlartgs.f */\n#define dlartgs FORTRAN_WRAPPER(dlartgs)\nextern void dlartgs(\n    const double *x,\n    const double *y,\n    const double *sigma,\n    double *cs,\n    double *sn\n);\n\n/* Source: dlartv.f */\n#define dlartv FORTRAN_WRAPPER(dlartv)\nextern void dlartv(\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *incx,\n    double *y,\n    const ptrdiff_t *incy,\n    const double *c,\n    const double *s,\n    const ptrdiff_t *incc\n);\n\n/* Source: dlaruv.f */\n#define dlaruv FORTRAN_WRAPPER(dlaruv)\nextern void dlaruv(\n    ptrdiff_t *iseed,\n    const ptrdiff_t *n,\n    double *x\n);\n\n/* Source: dlarz.f */\n#define dlarz FORTRAN_WRAPPER(dlarz)\nextern void dlarz(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const double *v,\n    const ptrdiff_t *incv,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: dlarzb.f */\n#define dlarzb FORTRAN_WRAPPER(dlarzb)\nextern void dlarzb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: dlarzt.f */\n#define dlarzt FORTRAN_WRAPPER(dlarzt)\nextern void dlarzt(\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *v,\n    const ptrdiff_t *ldv,\n    const double *tau,\n    double *t,\n    const ptrdiff_t *ldt\n);\n\n/* Source: dlas2.f */\n#define dlas2 FORTRAN_WRAPPER(dlas2)\nextern void dlas2(\n    const double *f,\n    const double *g,\n    const double *h,\n    double *ssmin,\n    double *ssmax\n);\n\n/* Source: dlascl.f */\n#define dlascl FORTRAN_WRAPPER(dlascl)\nextern void dlascl(\n    const char   *type,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *cfrom,\n    const double *cto,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dlasd0.f */\n#define dlasd0 FORTRAN_WRAPPER(dlasd0)\nextern void dlasd0(\n    const ptrdiff_t *n,\n    const ptrdiff_t *sqre,\n    double *d,\n    const double *e,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    const ptrdiff_t *smlsiz,\n    ptrdiff_t *iwork,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlasd1.f */\n#define dlasd1 FORTRAN_WRAPPER(dlasd1)\nextern void dlasd1(\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    double *d,\n    double *alpha,\n    double *beta,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    ptrdiff_t *idxq,\n    ptrdiff_t *iwork,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlasd2.f */\n#define dlasd2 FORTRAN_WRAPPER(dlasd2)\nextern void dlasd2(\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    ptrdiff_t *k,\n    double *d,\n    double *z,\n    const double *alpha,\n    const double *beta,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *dsigma,\n    double *u2,\n    const ptrdiff_t *ldu2,\n    double *vt2,\n    const ptrdiff_t *ldvt2,\n    ptrdiff_t *idxp,\n    ptrdiff_t *idx,\n    ptrdiff_t *idxc,\n    ptrdiff_t *idxq,\n    ptrdiff_t *coltyp,\n    ptrdiff_t *info\n);\n\n/* Source: dlasd3.f */\n#define dlasd3 FORTRAN_WRAPPER(dlasd3)\nextern void dlasd3(\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    const ptrdiff_t *k,\n    double *d,\n    double *q,\n    const ptrdiff_t *ldq,\n    const double *dsigma,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *u2,\n    const ptrdiff_t *ldu2,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *vt2,\n    const ptrdiff_t *ldvt2,\n    const ptrdiff_t *idxc,\n    const ptrdiff_t *ctot,\n    const double *z,\n    ptrdiff_t *info\n);\n\n/* Source: dlasd4.f */\n#define dlasd4 FORTRAN_WRAPPER(dlasd4)\nextern void dlasd4(\n    const ptrdiff_t *n,\n    const ptrdiff_t *i,\n    const double *d,\n    const double *z,\n    double *delta,\n    const double *rho,\n    double *sigma,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlasd5.f */\n#define dlasd5 FORTRAN_WRAPPER(dlasd5)\nextern void dlasd5(\n    const ptrdiff_t *i,\n    const double *d,\n    const double *z,\n    double *delta,\n    const double *rho,\n    double *dsigma,\n    double *work\n);\n\n/* Source: dlasd6.f */\n#define dlasd6 FORTRAN_WRAPPER(dlasd6)\nextern void dlasd6(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    double *d,\n    double *vf,\n    double *vl,\n    double *alpha,\n    double *beta,\n    ptrdiff_t *idxq,\n    ptrdiff_t *perm,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    double *givnum,\n    const ptrdiff_t *ldgnum,\n    double *poles,\n    double *difl,\n    double *difr,\n    double *z,\n    ptrdiff_t *k,\n    double *c,\n    double *s,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlasd7.f */\n#define dlasd7 FORTRAN_WRAPPER(dlasd7)\nextern void dlasd7(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    ptrdiff_t *k,\n    double *d,\n    double *z,\n    double *zw,\n    double *vf,\n    double *vfw,\n    double *vl,\n    double *vlw,\n    const double *alpha,\n    const double *beta,\n    double *dsigma,\n    ptrdiff_t *idx,\n    ptrdiff_t *idxp,\n    const ptrdiff_t *idxq,\n    ptrdiff_t *perm,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    double *givnum,\n    const ptrdiff_t *ldgnum,\n    double *c,\n    double *s,\n    ptrdiff_t *info\n);\n\n/* Source: dlasd8.f */\n#define dlasd8 FORTRAN_WRAPPER(dlasd8)\nextern void dlasd8(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *k,\n    double *d,\n    double *z,\n    double *vf,\n    double *vl,\n    double *difl,\n    double *difr,\n    const ptrdiff_t *lddifr,\n    double *dsigma,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlasda.f */\n#define dlasda FORTRAN_WRAPPER(dlasda)\nextern void dlasda(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *sqre,\n    double *d,\n    const double *e,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    ptrdiff_t *k,\n    double *difl,\n    double *difr,\n    double *z,\n    double *poles,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    ptrdiff_t *perm,\n    double *givnum,\n    double *c,\n    double *s,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlasdq.f */\n#define dlasdq FORTRAN_WRAPPER(dlasdq)\nextern void dlasdq(\n    const char   *uplo,\n    const ptrdiff_t *sqre,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncvt,\n    const ptrdiff_t *nru,\n    const ptrdiff_t *ncc,\n    double *d,\n    double *e,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlasdt.f */\n#define dlasdt FORTRAN_WRAPPER(dlasdt)\nextern void dlasdt(\n    const ptrdiff_t *n,\n    ptrdiff_t *lvl,\n    ptrdiff_t *nd,\n    ptrdiff_t *inode,\n    ptrdiff_t *ndiml,\n    ptrdiff_t *ndimr,\n    const ptrdiff_t *msub\n);\n\n/* Source: dlaset.f */\n#define dlaset FORTRAN_WRAPPER(dlaset)\nextern void dlaset(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *beta,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: dlasq1.f */\n#define dlasq1 FORTRAN_WRAPPER(dlasq1)\nextern void dlasq1(\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlasq2.f */\n#define dlasq2 FORTRAN_WRAPPER(dlasq2)\nextern void dlasq2(\n    const ptrdiff_t *n,\n    double *z,\n    ptrdiff_t *info\n);\n\n/* Source: dlasq3.f */\n#define dlasq3 FORTRAN_WRAPPER(dlasq3)\nextern void dlasq3(\n    const ptrdiff_t *i0,\n    const ptrdiff_t *n0,\n    const double *z,\n    ptrdiff_t *pp,\n    double *dmin,\n    double *sigma,\n    double *desig,\n    const double *qmax,\n    ptrdiff_t *nfail,\n    ptrdiff_t *iter,\n    ptrdiff_t *ndiv,\n    const ptrdiff_t *ieee,\n    ptrdiff_t *ttype,\n    double *dmin1,\n    double *dmin2,\n    double *dn,\n    double *dn1,\n    double *dn2,\n    double *g,\n    double *tau\n);\n\n/* Source: dlasq4.f */\n#define dlasq4 FORTRAN_WRAPPER(dlasq4)\nextern void dlasq4(\n    const ptrdiff_t *i0,\n    const ptrdiff_t *n0,\n    const double *z,\n    const ptrdiff_t *pp,\n    ptrdiff_t *n0in,\n    const double *dmin,\n    const double *dmin1,\n    const double *dmin2,\n    const double *dn,\n    const double *dn1,\n    const double *dn2,\n    double *tau,\n    ptrdiff_t *ttype,\n    double *g\n);\n\n/* Source: dlasq5.f */\n#define dlasq5 FORTRAN_WRAPPER(dlasq5)\nextern void dlasq5(\n    const ptrdiff_t *i0,\n    const ptrdiff_t *n0,\n    const double *z,\n    const ptrdiff_t *pp,\n    const double *tau,\n    const double *sigma,\n    double *dmin,\n    double *dmin1,\n    double *dmin2,\n    double *dn,\n    double *dnm1,\n    double *dnm2,\n    const ptrdiff_t *ieee,\n    const double *eps\n);\n\n/* Source: dlasq6.f */\n#define dlasq6 FORTRAN_WRAPPER(dlasq6)\nextern void dlasq6(\n    const ptrdiff_t *i0,\n    const ptrdiff_t *n0,\n    const double *z,\n    const ptrdiff_t *pp,\n    double *dmin,\n    double *dmin1,\n    double *dmin2,\n    double *dn,\n    double *dnm1,\n    double *dnm2\n);\n\n/* Source: dlasr.f */\n#define dlasr FORTRAN_WRAPPER(dlasr)\nextern void dlasr(\n    const char   *side,\n    const char   *pivot,\n    const char   *direct,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *c,\n    const double *s,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: dlasrt.f */\n#define dlasrt FORTRAN_WRAPPER(dlasrt)\nextern void dlasrt(\n    const char   *id,\n    const ptrdiff_t *n,\n    double *d,\n    ptrdiff_t *info\n);\n\n/* Source: dlassq.f */\n#define dlassq FORTRAN_WRAPPER(dlassq)\nextern void dlassq(\n    const ptrdiff_t *n,\n    const double *x,\n    const ptrdiff_t *incx,\n    double *scale,\n    double *sumsq\n);\n\n/* Source: dlasv2.f */\n#define dlasv2 FORTRAN_WRAPPER(dlasv2)\nextern void dlasv2(\n    const double *f,\n    const double *g,\n    const double *h,\n    double *ssmin,\n    double *ssmax,\n    double *snr,\n    double *csr,\n    double *snl,\n    double *csl\n);\n\n/* Source: dlaswlq.f */\n#define dlaswlq FORTRAN_WRAPPER(dlaswlq)\nextern void dlaswlq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlaswp.f */\n#define dlaswp FORTRAN_WRAPPER(dlaswp)\nextern void dlaswp(\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *k1,\n    const ptrdiff_t *k2,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *incx\n);\n\n/* Source: dlasy2.f */\n#define dlasy2 FORTRAN_WRAPPER(dlasy2)\nextern void dlasy2(\n    const ptrdiff_t *ltranl,\n    const ptrdiff_t *ltranr,\n    const ptrdiff_t *isgn,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    const double *tl,\n    const ptrdiff_t *ldtl,\n    const double *tr,\n    const ptrdiff_t *ldtr,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *scale,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *xnorm,\n    ptrdiff_t *info\n);\n\n/* Source: dlasyf.f */\n#define dlasyf FORTRAN_WRAPPER(dlasyf)\nextern void dlasyf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: dlasyf_aa.f */\n#define dlasyf_aa FORTRAN_WRAPPER(dlasyf_aa)\nextern void dlasyf_aa(\n    const char   *uplo,\n    const ptrdiff_t *j1_,\n    const ptrdiff_t *m,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dlasyf_rk.f */\n#define dlasyf_rk FORTRAN_WRAPPER(dlasyf_rk)\nextern void dlasyf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *w,\n    ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: dlasyf_rook.f */\n#define dlasyf_rook FORTRAN_WRAPPER(dlasyf_rook)\nextern void dlasyf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: dlat2s.f */\n#define dlat2s FORTRAN_WRAPPER(dlat2s)\nextern void dlat2s(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    float  *sa,\n    const ptrdiff_t *ldsa,\n    ptrdiff_t *info\n);\n\n/* Source: dlatbs.f */\n#define dlatbs FORTRAN_WRAPPER(dlatbs)\nextern void dlatbs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *x,\n    double *scale,\n    double *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: dlatdf.f */\n#define dlatdf FORTRAN_WRAPPER(dlatdf)\nextern void dlatdf(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *n,\n    const double *z,\n    const ptrdiff_t *ldz,\n    double *rhs,\n    double *rdsum,\n    double *rdscal,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *jpiv\n);\n\n/* Source: dlatps.f */\n#define dlatps FORTRAN_WRAPPER(dlatps)\nextern void dlatps(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *x,\n    double *scale,\n    double *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: dlatrd.f */\n#define dlatrd FORTRAN_WRAPPER(dlatrd)\nextern void dlatrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *e,\n    double *tau,\n    double *w,\n    const ptrdiff_t *ldw\n);\n\n/* Source: dlatrs.f */\n#define dlatrs FORTRAN_WRAPPER(dlatrs)\nextern void dlatrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    double *scale,\n    double *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: dlatrz.f */\n#define dlatrz FORTRAN_WRAPPER(dlatrz)\nextern void dlatrz(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work\n);\n\n/* Source: dlatsqr.f */\n#define dlatsqr FORTRAN_WRAPPER(dlatsqr)\nextern void dlatsqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dlauu2.f */\n#define dlauu2 FORTRAN_WRAPPER(dlauu2)\nextern void dlauu2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dlauum.f */\n#define dlauum FORTRAN_WRAPPER(dlauum)\nextern void dlauum(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dopgtr.f */\n#define dopgtr FORTRAN_WRAPPER(dopgtr)\nextern void dopgtr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    const double *tau,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dopmtr.f */\n#define dopmtr FORTRAN_WRAPPER(dopmtr)\nextern void dopmtr(\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *ap,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dorbdb.f */\n#define dorbdb FORTRAN_WRAPPER(dorbdb)\nextern void dorbdb(\n    const char   *trans,\n    const char   *signs,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x12,\n    const ptrdiff_t *ldx12,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *x22,\n    const ptrdiff_t *ldx22,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *tauq2,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorbdb1.f */\n#define dorbdb1 FORTRAN_WRAPPER(dorbdb1)\nextern void dorbdb1(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorbdb2.f */\n#define dorbdb2 FORTRAN_WRAPPER(dorbdb2)\nextern void dorbdb2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorbdb3.f */\n#define dorbdb3 FORTRAN_WRAPPER(dorbdb3)\nextern void dorbdb3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorbdb4.f */\n#define dorbdb4 FORTRAN_WRAPPER(dorbdb4)\nextern void dorbdb4(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *phantom,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorbdb5.f */\n#define dorbdb5 FORTRAN_WRAPPER(dorbdb5)\nextern void dorbdb5(\n    const ptrdiff_t *m1,\n    const ptrdiff_t *m2,\n    const ptrdiff_t *n,\n    double *x1,\n    const ptrdiff_t *incx1,\n    double *x2,\n    const ptrdiff_t *incx2,\n    double *q1,\n    const ptrdiff_t *ldq1,\n    double *q2,\n    const ptrdiff_t *ldq2,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorbdb6.f */\n#define dorbdb6 FORTRAN_WRAPPER(dorbdb6)\nextern void dorbdb6(\n    const ptrdiff_t *m1,\n    const ptrdiff_t *m2,\n    const ptrdiff_t *n,\n    double *x1,\n    const ptrdiff_t *incx1,\n    double *x2,\n    const ptrdiff_t *incx2,\n    double *q1,\n    const ptrdiff_t *ldq1,\n    double *q2,\n    const ptrdiff_t *ldq2,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorcsd.f */\n#define dorcsd FORTRAN_WRAPPER(dorcsd)\nextern void dorcsd(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const char   *jobv2t,\n    const char   *trans,\n    const char   *signs,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x12,\n    const ptrdiff_t *ldx12,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *x22,\n    const ptrdiff_t *ldx22,\n    double *theta,\n    double *u1,\n    const ptrdiff_t *ldu1,\n    double *u2,\n    const ptrdiff_t *ldu2,\n    double *v1t,\n    const ptrdiff_t *ldv1t,\n    double *v2t,\n    const ptrdiff_t *ldv2t,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorcsd2by1.f */\n#define dorcsd2by1 FORTRAN_WRAPPER(dorcsd2by1)\nextern void dorcsd2by1(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *u1,\n    const ptrdiff_t *ldu1,\n    double *u2,\n    const ptrdiff_t *ldu2,\n    double *v1t,\n    const ptrdiff_t *ldv1t,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorg2l.f */\n#define dorg2l FORTRAN_WRAPPER(dorg2l)\nextern void dorg2l(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dorg2r.f */\n#define dorg2r FORTRAN_WRAPPER(dorg2r)\nextern void dorg2r(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dorgbr.f */\n#define dorgbr FORTRAN_WRAPPER(dorgbr)\nextern void dorgbr(\n    const char   *vect,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorghr.f */\n#define dorghr FORTRAN_WRAPPER(dorghr)\nextern void dorghr(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorgl2.f */\n#define dorgl2 FORTRAN_WRAPPER(dorgl2)\nextern void dorgl2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dorglq.f */\n#define dorglq FORTRAN_WRAPPER(dorglq)\nextern void dorglq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorgql.f */\n#define dorgql FORTRAN_WRAPPER(dorgql)\nextern void dorgql(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorgqr.f */\n#define dorgqr FORTRAN_WRAPPER(dorgqr)\nextern void dorgqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorgr2.f */\n#define dorgr2 FORTRAN_WRAPPER(dorgr2)\nextern void dorgr2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dorgrq.f */\n#define dorgrq FORTRAN_WRAPPER(dorgrq)\nextern void dorgrq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorgtr.f */\n#define dorgtr FORTRAN_WRAPPER(dorgtr)\nextern void dorgtr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorm22.f */\n#define dorm22 FORTRAN_WRAPPER(dorm22)\nextern void dorm22(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    const double *q,\n    const ptrdiff_t *ldq,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorm2l.f */\n#define dorm2l FORTRAN_WRAPPER(dorm2l)\nextern void dorm2l(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dorm2r.f */\n#define dorm2r FORTRAN_WRAPPER(dorm2r)\nextern void dorm2r(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dormbr.f */\n#define dormbr FORTRAN_WRAPPER(dormbr)\nextern void dormbr(\n    const char   *vect,\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dormhr.f */\n#define dormhr FORTRAN_WRAPPER(dormhr)\nextern void dormhr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dorml2.f */\n#define dorml2 FORTRAN_WRAPPER(dorml2)\nextern void dorml2(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dormlq.f */\n#define dormlq FORTRAN_WRAPPER(dormlq)\nextern void dormlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dormql.f */\n#define dormql FORTRAN_WRAPPER(dormql)\nextern void dormql(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dormqr.f */\n#define dormqr FORTRAN_WRAPPER(dormqr)\nextern void dormqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dormr2.f */\n#define dormr2 FORTRAN_WRAPPER(dormr2)\nextern void dormr2(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dormr3.f */\n#define dormr3 FORTRAN_WRAPPER(dormr3)\nextern void dormr3(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dormrq.f */\n#define dormrq FORTRAN_WRAPPER(dormrq)\nextern void dormrq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dormrz.f */\n#define dormrz FORTRAN_WRAPPER(dormrz)\nextern void dormrz(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dormtr.f */\n#define dormtr FORTRAN_WRAPPER(dormtr)\nextern void dormtr(\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dpbcon.f */\n#define dpbcon FORTRAN_WRAPPER(dpbcon)\nextern void dpbcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dpbequ.f */\n#define dpbequ FORTRAN_WRAPPER(dpbequ)\nextern void dpbequ(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *s,\n    double *scond,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: dpbrfs.f */\n#define dpbrfs FORTRAN_WRAPPER(dpbrfs)\nextern void dpbrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const double *afb,\n    const ptrdiff_t *ldafb,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dpbstf.f */\n#define dpbstf FORTRAN_WRAPPER(dpbstf)\nextern void dpbstf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: dpbsv.f */\n#define dpbsv FORTRAN_WRAPPER(dpbsv)\nextern void dpbsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dpbsvx.f */\n#define dpbsvx FORTRAN_WRAPPER(dpbsvx)\nextern void dpbsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *afb,\n    const ptrdiff_t *ldafb,\n    char   *equed,\n    double *s,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dpbtf2.f */\n#define dpbtf2 FORTRAN_WRAPPER(dpbtf2)\nextern void dpbtf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: dpbtrf.f */\n#define dpbtrf FORTRAN_WRAPPER(dpbtrf)\nextern void dpbtrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: dpbtrs.f */\n#define dpbtrs FORTRAN_WRAPPER(dpbtrs)\nextern void dpbtrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dpftrf.f */\n#define dpftrf FORTRAN_WRAPPER(dpftrf)\nextern void dpftrf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *info\n);\n\n/* Source: dpftri.f */\n#define dpftri FORTRAN_WRAPPER(dpftri)\nextern void dpftri(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *info\n);\n\n/* Source: dpftrs.f */\n#define dpftrs FORTRAN_WRAPPER(dpftrs)\nextern void dpftrs(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dpocon.f */\n#define dpocon FORTRAN_WRAPPER(dpocon)\nextern void dpocon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dpoequ.f */\n#define dpoequ FORTRAN_WRAPPER(dpoequ)\nextern void dpoequ(\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *scond,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: dpoequb.f */\n#define dpoequb FORTRAN_WRAPPER(dpoequb)\nextern void dpoequb(\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *scond,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: dporfs.f */\n#define dporfs FORTRAN_WRAPPER(dporfs)\nextern void dporfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *af,\n    const ptrdiff_t *ldaf,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dposv.f */\n#define dposv FORTRAN_WRAPPER(dposv)\nextern void dposv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dposvx.f */\n#define dposvx FORTRAN_WRAPPER(dposvx)\nextern void dposvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *af,\n    const ptrdiff_t *ldaf,\n    char   *equed,\n    double *s,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dpotf2.f */\n#define dpotf2 FORTRAN_WRAPPER(dpotf2)\nextern void dpotf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dpotrf.f */\n#define dpotrf FORTRAN_WRAPPER(dpotrf)\nextern void dpotrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dpotrf2.f */\n#define dpotrf2 FORTRAN_WRAPPER(dpotrf2)\nextern void dpotrf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dpotri.f */\n#define dpotri FORTRAN_WRAPPER(dpotri)\nextern void dpotri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dpotrs.f */\n#define dpotrs FORTRAN_WRAPPER(dpotrs)\nextern void dpotrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dppcon.f */\n#define dppcon FORTRAN_WRAPPER(dppcon)\nextern void dppcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dppequ.f */\n#define dppequ FORTRAN_WRAPPER(dppequ)\nextern void dppequ(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *s,\n    double *scond,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: dpprfs.f */\n#define dpprfs FORTRAN_WRAPPER(dpprfs)\nextern void dpprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const double *afp,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dppsv.f */\n#define dppsv FORTRAN_WRAPPER(dppsv)\nextern void dppsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *ap,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dppsvx.f */\n#define dppsvx FORTRAN_WRAPPER(dppsvx)\nextern void dppsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *ap,\n    double *afp,\n    char   *equed,\n    double *s,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dpptrf.f */\n#define dpptrf FORTRAN_WRAPPER(dpptrf)\nextern void dpptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: dpptri.f */\n#define dpptri FORTRAN_WRAPPER(dpptri)\nextern void dpptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: dpptrs.f */\n#define dpptrs FORTRAN_WRAPPER(dpptrs)\nextern void dpptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dpstf2.f */\n#define dpstf2 FORTRAN_WRAPPER(dpstf2)\nextern void dpstf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *piv,\n    ptrdiff_t *rank,\n    const double *tol,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dpstrf.f */\n#define dpstrf FORTRAN_WRAPPER(dpstrf)\nextern void dpstrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *piv,\n    ptrdiff_t *rank,\n    const double *tol,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dptcon.f */\n#define dptcon FORTRAN_WRAPPER(dptcon)\nextern void dptcon(\n    const ptrdiff_t *n,\n    const double *d,\n    const double *e,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dpteqr.f */\n#define dpteqr FORTRAN_WRAPPER(dpteqr)\nextern void dpteqr(\n    const char   *compz,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dptrfs.f */\n#define dptrfs FORTRAN_WRAPPER(dptrfs)\nextern void dptrfs(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *d,\n    const double *e,\n    const double *df,\n    const double *ef,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dptsv.f */\n#define dptsv FORTRAN_WRAPPER(dptsv)\nextern void dptsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *d,\n    double *e,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dptsvx.f */\n#define dptsvx FORTRAN_WRAPPER(dptsvx)\nextern void dptsvx(\n    const char   *fact,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *d,\n    const double *e,\n    double *df,\n    double *ef,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dpttrf.f */\n#define dpttrf FORTRAN_WRAPPER(dpttrf)\nextern void dpttrf(\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    ptrdiff_t *info\n);\n\n/* Source: dpttrs.f */\n#define dpttrs FORTRAN_WRAPPER(dpttrs)\nextern void dpttrs(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *d,\n    const double *e,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dptts2.f */\n#define dptts2 FORTRAN_WRAPPER(dptts2)\nextern void dptts2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *d,\n    const double *e,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: drscl.f */\n#define drscl FORTRAN_WRAPPER(drscl)\nextern void drscl(\n    const ptrdiff_t *n,\n    const double *sa,\n    double *sx,\n    const ptrdiff_t *incx\n);\n\n/* Source: dsb2st_kernels.f */\n#define dsb2st_kernels FORTRAN_WRAPPER(dsb2st_kernels)\nextern void dsb2st_kernels(\n    char   *uplo,\n    ptrdiff_t *wantz,\n    ptrdiff_t *ttype,\n    ptrdiff_t *st,\n    ptrdiff_t *ed,\n    ptrdiff_t *sweep,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *ib,\n    double *a,\n    ptrdiff_t *lda,\n    double *v,\n    double *tau,\n    ptrdiff_t *ldvt,\n    double *work\n);\n\n/* Source: dsbev.f */\n#define dsbev FORTRAN_WRAPPER(dsbev)\nextern void dsbev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsbev_2stage.f */\n#define dsbev_2stage FORTRAN_WRAPPER(dsbev_2stage)\nextern void dsbev_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsbevd.f */\n#define dsbevd FORTRAN_WRAPPER(dsbevd)\nextern void dsbevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsbevd_2stage.f */\n#define dsbevd_2stage FORTRAN_WRAPPER(dsbevd_2stage)\nextern void dsbevd_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsbevx.f */\n#define dsbevx FORTRAN_WRAPPER(dsbevx)\nextern void dsbevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *q,\n    const ptrdiff_t *ldq,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dsbevx_2stage.f */\n#define dsbevx_2stage FORTRAN_WRAPPER(dsbevx_2stage)\nextern void dsbevx_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *q,\n    ptrdiff_t *ldq,\n    double *vl,\n    double *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dsbgst.f */\n#define dsbgst FORTRAN_WRAPPER(dsbgst)\nextern void dsbgst(\n    const char   *vect,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    double *ab,\n    const ptrdiff_t *ldab,\n    const double *bb,\n    const ptrdiff_t *ldbb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsbgv.f */\n#define dsbgv FORTRAN_WRAPPER(dsbgv)\nextern void dsbgv(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *bb,\n    const ptrdiff_t *ldbb,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsbgvd.f */\n#define dsbgvd FORTRAN_WRAPPER(dsbgvd)\nextern void dsbgvd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *bb,\n    const ptrdiff_t *ldbb,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsbgvx.f */\n#define dsbgvx FORTRAN_WRAPPER(dsbgvx)\nextern void dsbgvx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *bb,\n    const ptrdiff_t *ldbb,\n    double *q,\n    const ptrdiff_t *ldq,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dsbtrd.f */\n#define dsbtrd FORTRAN_WRAPPER(dsbtrd)\nextern void dsbtrd(\n    const char   *vect,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *d,\n    double *e,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsfrk.f */\n#define dsfrk FORTRAN_WRAPPER(dsfrk)\nextern void dsfrk(\n    const char   *transr,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *beta,\n    double *c\n);\n\n/* Source: dsgesv.f */\n#define dsgesv FORTRAN_WRAPPER(dsgesv)\nextern void dsgesv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *work,\n    float  *swork,\n    ptrdiff_t *iter,\n    ptrdiff_t *info\n);\n\n/* Source: dspcon.f */\n#define dspcon FORTRAN_WRAPPER(dspcon)\nextern void dspcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dspev.f */\n#define dspev FORTRAN_WRAPPER(dspev)\nextern void dspev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dspevd.f */\n#define dspevd FORTRAN_WRAPPER(dspevd)\nextern void dspevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dspevx.f */\n#define dspevx FORTRAN_WRAPPER(dspevx)\nextern void dspevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dspgst.f */\n#define dspgst FORTRAN_WRAPPER(dspgst)\nextern void dspgst(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const double *bp,\n    ptrdiff_t *info\n);\n\n/* Source: dspgv.f */\n#define dspgv FORTRAN_WRAPPER(dspgv)\nextern void dspgv(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *bp,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dspgvd.f */\n#define dspgvd FORTRAN_WRAPPER(dspgvd)\nextern void dspgvd(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *bp,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dspgvx.f */\n#define dspgvx FORTRAN_WRAPPER(dspgvx)\nextern void dspgvx(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *bp,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dsposv.f */\n#define dsposv FORTRAN_WRAPPER(dsposv)\nextern void dsposv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *work,\n    float  *swork,\n    ptrdiff_t *iter,\n    ptrdiff_t *info\n);\n\n/* Source: dsprfs.f */\n#define dsprfs FORTRAN_WRAPPER(dsprfs)\nextern void dsprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const double *afp,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dspsv.f */\n#define dspsv FORTRAN_WRAPPER(dspsv)\nextern void dspsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *ap,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dspsvx.f */\n#define dspsvx FORTRAN_WRAPPER(dspsvx)\nextern void dspsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    double *afp,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsptrd.f */\n#define dsptrd FORTRAN_WRAPPER(dsptrd)\nextern void dsptrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *d,\n    double *e,\n    double *tau,\n    ptrdiff_t *info\n);\n\n/* Source: dsptrf.f */\n#define dsptrf FORTRAN_WRAPPER(dsptrf)\nextern void dsptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dsptri.f */\n#define dsptri FORTRAN_WRAPPER(dsptri)\nextern void dsptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsptrs.f */\n#define dsptrs FORTRAN_WRAPPER(dsptrs)\nextern void dsptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dstebz.f */\n#define dstebz FORTRAN_WRAPPER(dstebz)\nextern void dstebz(\n    const char   *range,\n    const char   *order,\n    const ptrdiff_t *n,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    const double *d,\n    const double *e,\n    ptrdiff_t *m,\n    ptrdiff_t *nsplit,\n    double *w,\n    ptrdiff_t *iblock,\n    ptrdiff_t *isplit,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dstedc.f */\n#define dstedc FORTRAN_WRAPPER(dstedc)\nextern void dstedc(\n    const char   *compz,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dstegr.f */\n#define dstegr FORTRAN_WRAPPER(dstegr)\nextern void dstegr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dstein.f */\n#define dstein FORTRAN_WRAPPER(dstein)\nextern void dstein(\n    const ptrdiff_t *n,\n    const double *d,\n    const double *e,\n    const ptrdiff_t *m,\n    const double *w,\n    const ptrdiff_t *iblock,\n    const ptrdiff_t *isplit,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dstemr.f */\n#define dstemr FORTRAN_WRAPPER(dstemr)\nextern void dstemr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *nzc,\n    ptrdiff_t *isuppz,\n    ptrdiff_t *tryrac,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsteqr.f */\n#define dsteqr FORTRAN_WRAPPER(dsteqr)\nextern void dsteqr(\n    const char   *compz,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsterf.f */\n#define dsterf FORTRAN_WRAPPER(dsterf)\nextern void dsterf(\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    ptrdiff_t *info\n);\n\n/* Source: dstev.f */\n#define dstev FORTRAN_WRAPPER(dstev)\nextern void dstev(\n    const char   *jobz,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dstevd.f */\n#define dstevd FORTRAN_WRAPPER(dstevd)\nextern void dstevd(\n    const char   *jobz,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dstevr.f */\n#define dstevr FORTRAN_WRAPPER(dstevr)\nextern void dstevr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dstevx.f */\n#define dstevx FORTRAN_WRAPPER(dstevx)\nextern void dstevx(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dsycon.f */\n#define dsycon FORTRAN_WRAPPER(dsycon)\nextern void dsycon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsycon_3.f */\n#define dsycon_3 FORTRAN_WRAPPER(dsycon_3)\nextern void dsycon_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsycon_rook.f */\n#define dsycon_rook FORTRAN_WRAPPER(dsycon_rook)\nextern void dsycon_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsyconv.f */\n#define dsyconv FORTRAN_WRAPPER(dsyconv)\nextern void dsyconv(\n    const char   *uplo,\n    const char   *way,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *e,\n    ptrdiff_t *info\n);\n\n/* Source: dsyconvf.f */\n#define dsyconvf FORTRAN_WRAPPER(dsyconvf)\nextern void dsyconvf(\n    char   *uplo,\n    char   *way,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dsyconvf_rook.f */\n#define dsyconvf_rook FORTRAN_WRAPPER(dsyconvf_rook)\nextern void dsyconvf_rook(\n    char   *uplo,\n    char   *way,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dsyequb.f */\n#define dsyequb FORTRAN_WRAPPER(dsyequb)\nextern void dsyequb(\n    char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *scond,\n    double *amax,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsyev.f */\n#define dsyev FORTRAN_WRAPPER(dsyev)\nextern void dsyev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *w,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsyev_2stage.f */\n#define dsyev_2stage FORTRAN_WRAPPER(dsyev_2stage)\nextern void dsyev_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *w,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsyevd.f */\n#define dsyevd FORTRAN_WRAPPER(dsyevd)\nextern void dsyevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *w,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsyevd_2stage.f */\n#define dsyevd_2stage FORTRAN_WRAPPER(dsyevd_2stage)\nextern void dsyevd_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *w,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsyevr.f */\n#define dsyevr FORTRAN_WRAPPER(dsyevr)\nextern void dsyevr(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsyevr_2stage.f */\n#define dsyevr_2stage FORTRAN_WRAPPER(dsyevr_2stage)\nextern void dsyevr_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *vl,\n    double *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsyevx.f */\n#define dsyevx FORTRAN_WRAPPER(dsyevx)\nextern void dsyevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dsyevx_2stage.f */\n#define dsyevx_2stage FORTRAN_WRAPPER(dsyevx_2stage)\nextern void dsyevx_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *vl,\n    double *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dsygs2.f */\n#define dsygs2 FORTRAN_WRAPPER(dsygs2)\nextern void dsygs2(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dsygst.f */\n#define dsygst FORTRAN_WRAPPER(dsygst)\nextern void dsygst(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dsygv.f */\n#define dsygv FORTRAN_WRAPPER(dsygv)\nextern void dsygv(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *w,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsygv_2stage.f */\n#define dsygv_2stage FORTRAN_WRAPPER(dsygv_2stage)\nextern void dsygv_2stage(\n    ptrdiff_t *itype,\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *b,\n    ptrdiff_t *ldb,\n    double *w,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsygvd.f */\n#define dsygvd FORTRAN_WRAPPER(dsygvd)\nextern void dsygvd(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *w,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsygvx.f */\n#define dsygvx FORTRAN_WRAPPER(dsygvx)\nextern void dsygvx(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: dsyrfs.f */\n#define dsyrfs FORTRAN_WRAPPER(dsyrfs)\nextern void dsyrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsysv.f */\n#define dsysv FORTRAN_WRAPPER(dsysv)\nextern void dsysv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsysv_aa.f */\n#define dsysv_aa FORTRAN_WRAPPER(dsysv_aa)\nextern void dsysv_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsysv_rk.f */\n#define dsysv_rk FORTRAN_WRAPPER(dsysv_rk)\nextern void dsysv_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *b,\n    ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsysv_rook.f */\n#define dsysv_rook FORTRAN_WRAPPER(dsysv_rook)\nextern void dsysv_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsysvx.f */\n#define dsysvx FORTRAN_WRAPPER(dsysvx)\nextern void dsysvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsyswapr.f */\n#define dsyswapr FORTRAN_WRAPPER(dsyswapr)\nextern void dsyswapr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *i1,\n    const ptrdiff_t *i2\n);\n\n/* Source: dsytd2.f */\n#define dsytd2 FORTRAN_WRAPPER(dsytd2)\nextern void dsytd2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tau,\n    ptrdiff_t *info\n);\n\n/* Source: dsytf2.f */\n#define dsytf2 FORTRAN_WRAPPER(dsytf2)\nextern void dsytf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dsytf2_rk.f */\n#define dsytf2_rk FORTRAN_WRAPPER(dsytf2_rk)\nextern void dsytf2_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dsytf2_rook.f */\n#define dsytf2_rook FORTRAN_WRAPPER(dsytf2_rook)\nextern void dsytf2_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrd.f */\n#define dsytrd FORTRAN_WRAPPER(dsytrd)\nextern void dsytrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrd_2stage.f */\n#define dsytrd_2stage FORTRAN_WRAPPER(dsytrd_2stage)\nextern void dsytrd_2stage(\n    char   *vect,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tau,\n    double *hous2,\n    ptrdiff_t *lhous2,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrd_sb2st.f */\n#define dsytrd_sb2st FORTRAN_WRAPPER(dsytrd_sb2st)\nextern void dsytrd_sb2st(\n    char   *stage1,\n    char   *vect,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *d,\n    double *e,\n    double *hous,\n    ptrdiff_t *lhous,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrd_sy2sb.f */\n#define dsytrd_sy2sb FORTRAN_WRAPPER(dsytrd_sy2sb)\nextern void dsytrd_sy2sb(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *a,\n    ptrdiff_t *lda,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *tau,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrf.f */\n#define dsytrf FORTRAN_WRAPPER(dsytrf)\nextern void dsytrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrf_aa.f */\n#define dsytrf_aa FORTRAN_WRAPPER(dsytrf_aa)\nextern void dsytrf_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrf_rk.f */\n#define dsytrf_rk FORTRAN_WRAPPER(dsytrf_rk)\nextern void dsytrf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrf_rook.f */\n#define dsytrf_rook FORTRAN_WRAPPER(dsytrf_rook)\nextern void dsytrf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytri.f */\n#define dsytri FORTRAN_WRAPPER(dsytri)\nextern void dsytri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsytri2.f */\n#define dsytri2 FORTRAN_WRAPPER(dsytri2)\nextern void dsytri2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytri2x.f */\n#define dsytri2x FORTRAN_WRAPPER(dsytri2x)\nextern void dsytri2x(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: dsytri_3.f */\n#define dsytri_3 FORTRAN_WRAPPER(dsytri_3)\nextern void dsytri_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytri_3x.f */\n#define dsytri_3x FORTRAN_WRAPPER(dsytri_3x)\nextern void dsytri_3x(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: dsytri_rook.f */\n#define dsytri_rook FORTRAN_WRAPPER(dsytri_rook)\nextern void dsytri_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrs.f */\n#define dsytrs FORTRAN_WRAPPER(dsytrs)\nextern void dsytrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrs2.f */\n#define dsytrs2 FORTRAN_WRAPPER(dsytrs2)\nextern void dsytrs2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrs_3.f */\n#define dsytrs_3 FORTRAN_WRAPPER(dsytrs_3)\nextern void dsytrs_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *b,\n    ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrs_aa.f */\n#define dsytrs_aa FORTRAN_WRAPPER(dsytrs_aa)\nextern void dsytrs_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dsytrs_rook.f */\n#define dsytrs_rook FORTRAN_WRAPPER(dsytrs_rook)\nextern void dsytrs_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dtbcon.f */\n#define dtbcon FORTRAN_WRAPPER(dtbcon)\nextern void dtbcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtbrfs.f */\n#define dtbrfs FORTRAN_WRAPPER(dtbrfs)\nextern void dtbrfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtbtrs.f */\n#define dtbtrs FORTRAN_WRAPPER(dtbtrs)\nextern void dtbtrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dtfsm.f */\n#define dtfsm FORTRAN_WRAPPER(dtfsm)\nextern void dtfsm(\n    const char   *transr,\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: dtftri.f */\n#define dtftri FORTRAN_WRAPPER(dtftri)\nextern void dtftri(\n    const char   *transr,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *info\n);\n\n/* Source: dtfttp.f */\n#define dtfttp FORTRAN_WRAPPER(dtfttp)\nextern void dtfttp(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *arf,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: dtfttr.f */\n#define dtfttr FORTRAN_WRAPPER(dtfttr)\nextern void dtfttr(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *arf,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dtgevc.f */\n#define dtgevc FORTRAN_WRAPPER(dtgevc)\nextern void dtgevc(\n    const char   *side,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const double *s,\n    const ptrdiff_t *lds,\n    const double *p,\n    const ptrdiff_t *ldp,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dtgex2.f */\n#define dtgex2 FORTRAN_WRAPPER(dtgex2)\nextern void dtgex2(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *j1_,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtgexc.f */\n#define dtgexc FORTRAN_WRAPPER(dtgexc)\nextern void dtgexc(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ifst,\n    ptrdiff_t *ilst,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtgsen.f */\n#define dtgsen FORTRAN_WRAPPER(dtgsen)\nextern void dtgsen(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alphar,\n    double *alphai,\n    double *beta,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *m,\n    double *pl,\n    double *pr,\n    double *dif,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtgsja.f */\n#define dtgsja FORTRAN_WRAPPER(dtgsja)\nextern void dtgsja(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *tola,\n    const double *tolb,\n    double *alpha,\n    double *beta,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    ptrdiff_t *ncycle,\n    ptrdiff_t *info\n);\n\n/* Source: dtgsna.f */\n#define dtgsna FORTRAN_WRAPPER(dtgsna)\nextern void dtgsna(\n    const char   *job,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *vl,\n    const ptrdiff_t *ldvl,\n    const double *vr,\n    const ptrdiff_t *ldvr,\n    double *s,\n    double *dif,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtgsy2.f */\n#define dtgsy2 FORTRAN_WRAPPER(dtgsy2)\nextern void dtgsy2(\n    const char   *trans,\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    const ptrdiff_t *ldc,\n    const double *d,\n    const ptrdiff_t *ldd,\n    const double *e,\n    const ptrdiff_t *lde,\n    double *f,\n    const ptrdiff_t *ldf,\n    double *scale,\n    double *rdsum,\n    double *rdscal,\n    ptrdiff_t *iwork,\n    ptrdiff_t *pq,\n    ptrdiff_t *info\n);\n\n/* Source: dtgsyl.f */\n#define dtgsyl FORTRAN_WRAPPER(dtgsyl)\nextern void dtgsyl(\n    const char   *trans,\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    const ptrdiff_t *ldc,\n    const double *d,\n    const ptrdiff_t *ldd,\n    const double *e,\n    const ptrdiff_t *lde,\n    double *f,\n    const ptrdiff_t *ldf,\n    double *scale,\n    double *dif,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtpcon.f */\n#define dtpcon FORTRAN_WRAPPER(dtpcon)\nextern void dtpcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtplqt.f */\n#define dtplqt FORTRAN_WRAPPER(dtplqt)\nextern void dtplqt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const ptrdiff_t *mb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dtplqt2.f */\n#define dtplqt2 FORTRAN_WRAPPER(dtplqt2)\nextern void dtplqt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: dtpmlqt.f */\n#define dtpmlqt FORTRAN_WRAPPER(dtpmlqt)\nextern void dtpmlqt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const ptrdiff_t *mb,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dtpmqrt.f */\n#define dtpmqrt FORTRAN_WRAPPER(dtpmqrt)\nextern void dtpmqrt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const ptrdiff_t *nb,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dtpqrt.f */\n#define dtpqrt FORTRAN_WRAPPER(dtpqrt)\nextern void dtpqrt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dtpqrt2.f */\n#define dtpqrt2 FORTRAN_WRAPPER(dtpqrt2)\nextern void dtpqrt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: dtprfb.f */\n#define dtprfb FORTRAN_WRAPPER(dtprfb)\nextern void dtprfb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: dtprfs.f */\n#define dtprfs FORTRAN_WRAPPER(dtprfs)\nextern void dtprfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtptri.f */\n#define dtptri FORTRAN_WRAPPER(dtptri)\nextern void dtptri(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: dtptrs.f */\n#define dtptrs FORTRAN_WRAPPER(dtptrs)\nextern void dtptrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dtpttf.f */\n#define dtpttf FORTRAN_WRAPPER(dtpttf)\nextern void dtpttf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *arf,\n    ptrdiff_t *info\n);\n\n/* Source: dtpttr.f */\n#define dtpttr FORTRAN_WRAPPER(dtpttr)\nextern void dtpttr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dtrcon.f */\n#define dtrcon FORTRAN_WRAPPER(dtrcon)\nextern void dtrcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *rcond,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtrevc.f */\n#define dtrevc FORTRAN_WRAPPER(dtrevc)\nextern void dtrevc(\n    const char   *side,\n    const char   *howmny,\n    ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dtrevc3.f */\n#define dtrevc3 FORTRAN_WRAPPER(dtrevc3)\nextern void dtrevc3(\n    char   *side,\n    char   *howmny,\n    ptrdiff_t *select,\n    ptrdiff_t *n,\n    double *t,\n    ptrdiff_t *ldt,\n    double *vl,\n    ptrdiff_t *ldvl,\n    double *vr,\n    ptrdiff_t *ldvr,\n    ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtrexc.f */\n#define dtrexc FORTRAN_WRAPPER(dtrexc)\nextern void dtrexc(\n    const char   *compq,\n    const ptrdiff_t *n,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *ifst,\n    ptrdiff_t *ilst,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: dtrrfs.f */\n#define dtrrfs FORTRAN_WRAPPER(dtrrfs)\nextern void dtrrfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtrsen.f */\n#define dtrsen FORTRAN_WRAPPER(dtrsen)\nextern void dtrsen(\n    const char   *job,\n    const char   *compq,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *wr,\n    double *wi,\n    ptrdiff_t *m,\n    double *s,\n    double *sep,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtrsna.f */\n#define dtrsna FORTRAN_WRAPPER(dtrsna)\nextern void dtrsna(\n    const char   *job,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const double *t,\n    const ptrdiff_t *ldt,\n    const double *vl,\n    const ptrdiff_t *ldvl,\n    const double *vr,\n    const ptrdiff_t *ldvr,\n    double *s,\n    double *sep,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    const ptrdiff_t *ldwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: dtrsyl.f */\n#define dtrsyl FORTRAN_WRAPPER(dtrsyl)\nextern void dtrsyl(\n    const char   *trana,\n    const char   *tranb,\n    const ptrdiff_t *isgn,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *scale,\n    ptrdiff_t *info\n);\n\n/* Source: dtrti2.f */\n#define dtrti2 FORTRAN_WRAPPER(dtrti2)\nextern void dtrti2(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dtrtri.f */\n#define dtrtri FORTRAN_WRAPPER(dtrtri)\nextern void dtrtri(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: dtrtrs.f */\n#define dtrtrs FORTRAN_WRAPPER(dtrtrs)\nextern void dtrtrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: dtrttf.f */\n#define dtrttf FORTRAN_WRAPPER(dtrttf)\nextern void dtrttf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *arf,\n    ptrdiff_t *info\n);\n\n/* Source: dtrttp.f */\n#define dtrttp FORTRAN_WRAPPER(dtrttp)\nextern void dtrttp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: dtzrzf.f */\n#define dtzrzf FORTRAN_WRAPPER(dtzrzf)\nextern void dtzrzf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: dzsum1.f */\n#define dzsum1 FORTRAN_WRAPPER(dzsum1)\nextern double dzsum1(\n    const ptrdiff_t *n,\n    const double *cx,\n    const ptrdiff_t *incx\n);\n\n/* Source: icmax1.f */\n#define icmax1 FORTRAN_WRAPPER(icmax1)\nextern ptrdiff_t icmax1(\n    const ptrdiff_t *n,\n    const float  *cx,\n    const ptrdiff_t *incx\n);\n\n/* Source: ieeeck.f */\n#define ieeeck FORTRAN_WRAPPER(ieeeck)\nextern ptrdiff_t ieeeck(\n    const ptrdiff_t *ispec,\n    const float  *zero,\n    const float  *one\n);\n\n/* Source: ilaclc.f */\n#define ilaclc FORTRAN_WRAPPER(ilaclc)\nextern ptrdiff_t ilaclc(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: ilaclr.f */\n#define ilaclr FORTRAN_WRAPPER(ilaclr)\nextern ptrdiff_t ilaclr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: iladiag.f */\n#define iladiag FORTRAN_WRAPPER(iladiag)\nextern ptrdiff_t iladiag(\n    const char   *diag\n);\n\n/* Source: iladlc.f */\n#define iladlc FORTRAN_WRAPPER(iladlc)\nextern ptrdiff_t iladlc(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: iladlr.f */\n#define iladlr FORTRAN_WRAPPER(iladlr)\nextern ptrdiff_t iladlr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: ilaenv.f */\n#define ilaenv FORTRAN_WRAPPER(ilaenv)\nextern ptrdiff_t ilaenv(\n    const ptrdiff_t *ispec,\n    const char   *name,\n    const char   *opts,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    const ptrdiff_t *n3,\n    const ptrdiff_t *n4,\n    ptrdiff_t name_len,\n    ptrdiff_t opts_len\n);\n\n/* Source: ilaprec.f */\n#define ilaprec FORTRAN_WRAPPER(ilaprec)\nextern ptrdiff_t ilaprec(\n    const char   *prec\n);\n\n/* Source: ilaslc.f */\n#define ilaslc FORTRAN_WRAPPER(ilaslc)\nextern ptrdiff_t ilaslc(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: ilaslr.f */\n#define ilaslr FORTRAN_WRAPPER(ilaslr)\nextern ptrdiff_t ilaslr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: ilatrans.f */\n#define ilatrans FORTRAN_WRAPPER(ilatrans)\nextern ptrdiff_t ilatrans(\n    const char   *trans\n);\n\n/* Source: ilauplo.f */\n#define ilauplo FORTRAN_WRAPPER(ilauplo)\nextern ptrdiff_t ilauplo(\n    const char   *uplo\n);\n\n/* Source: ilaver.f */\n#define ilaver FORTRAN_WRAPPER(ilaver)\nextern void ilaver(\n    ptrdiff_t *vers_major,\n    ptrdiff_t *vers_minor,\n    ptrdiff_t *vers_patch\n);\n\n/* Source: ilazlc.f */\n#define ilazlc FORTRAN_WRAPPER(ilazlc)\nextern ptrdiff_t ilazlc(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: ilazlr.f */\n#define ilazlr FORTRAN_WRAPPER(ilazlr)\nextern ptrdiff_t ilazlr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: iparam2stage.f */\n#define iparam2stage FORTRAN_WRAPPER(iparam2stage)\nextern ptrdiff_t iparam2stage(\n    ptrdiff_t *ispec,\n    char   *name,\n    char   *opts,\n    ptrdiff_t *ni,\n    ptrdiff_t *nbi,\n    ptrdiff_t *ibi,\n    ptrdiff_t *nxi,\n    ptrdiff_t name_len,\n    ptrdiff_t opts_len\n);\n\n/* Source: iparmq.f */\n#define iparmq FORTRAN_WRAPPER(iparmq)\nextern ptrdiff_t iparmq(\n    const ptrdiff_t *ispec,\n    const char   *name,\n    const char   *opts,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const ptrdiff_t *lwork\n);\n\n/* Source: izmax1.f */\n#define izmax1 FORTRAN_WRAPPER(izmax1)\nextern ptrdiff_t izmax1(\n    const ptrdiff_t *n,\n    const double *zx,\n    const ptrdiff_t *incx\n);\n\n/* Source: lsamen.f */\n#define lsamen FORTRAN_WRAPPER(lsamen)\nextern ptrdiff_t lsamen(\n    const ptrdiff_t *n,\n    const char   *ca,\n    const char   *cb,\n    ptrdiff_t ca_len,\n    ptrdiff_t cb_len\n);\n\n/* Source: sbbcsd.f */\n#define sbbcsd FORTRAN_WRAPPER(sbbcsd)\nextern void sbbcsd(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const char   *jobv2t,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *theta,\n    float  *phi,\n    float  *u1,\n    const ptrdiff_t *ldu1,\n    float  *u2,\n    const ptrdiff_t *ldu2,\n    float  *v1t,\n    const ptrdiff_t *ldv1t,\n    float  *v2t,\n    const ptrdiff_t *ldv2t,\n    float  *b11d,\n    float  *b11e,\n    float  *b12d,\n    float  *b12e,\n    float  *b21d,\n    float  *b21e,\n    float  *b22d,\n    float  *b22e,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sbdsdc.f */\n#define sbdsdc FORTRAN_WRAPPER(sbdsdc)\nextern void sbdsdc(\n    const char   *uplo,\n    const char   *compq,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *q,\n    ptrdiff_t *iq,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sbdsqr.f */\n#define sbdsqr FORTRAN_WRAPPER(sbdsqr)\nextern void sbdsqr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncvt,\n    const ptrdiff_t *nru,\n    const ptrdiff_t *ncc,\n    float  *d,\n    float  *e,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sbdsvdx.f */\n#define sbdsvdx FORTRAN_WRAPPER(sbdsvdx)\nextern void sbdsvdx(\n    const char   *uplo,\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *e,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *ns,\n    float  *s,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: scsum1.f */\n#define scsum1 FORTRAN_WRAPPER(scsum1)\nextern float scsum1(\n    const ptrdiff_t *n,\n    const float  *cx,\n    const ptrdiff_t *incx\n);\n\n/* Source: sdisna.f */\n#define sdisna FORTRAN_WRAPPER(sdisna)\nextern void sdisna(\n    const char   *job,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *d,\n    float  *sep,\n    ptrdiff_t *info\n);\n\n/* Source: sgbbrd.f */\n#define sgbbrd FORTRAN_WRAPPER(sgbbrd)\nextern void sgbbrd(\n    const char   *vect,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncc,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *d,\n    float  *e,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *pt,\n    const ptrdiff_t *ldpt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgbcon.f */\n#define sgbcon FORTRAN_WRAPPER(sgbcon)\nextern void sgbcon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgbequ.f */\n#define sgbequ FORTRAN_WRAPPER(sgbequ)\nextern void sgbequ(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *r,\n    float  *c,\n    float  *rowcnd,\n    float  *colcnd,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: sgbequb.f */\n#define sgbequb FORTRAN_WRAPPER(sgbequb)\nextern void sgbequb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *r,\n    float  *c,\n    float  *rowcnd,\n    float  *colcnd,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: sgbrfs.f */\n#define sgbrfs FORTRAN_WRAPPER(sgbrfs)\nextern void sgbrfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *afb,\n    const ptrdiff_t *ldafb,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgbsv.f */\n#define sgbsv FORTRAN_WRAPPER(sgbsv)\nextern void sgbsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sgbsvx.f */\n#define sgbsvx FORTRAN_WRAPPER(sgbsvx)\nextern void sgbsvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *afb,\n    const ptrdiff_t *ldafb,\n    ptrdiff_t *ipiv,\n    char   *equed,\n    float  *r,\n    float  *c,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgbtf2.f */\n#define sgbtf2 FORTRAN_WRAPPER(sgbtf2)\nextern void sgbtf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: sgbtrf.f */\n#define sgbtrf FORTRAN_WRAPPER(sgbtrf)\nextern void sgbtrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: sgbtrs.f */\n#define sgbtrs FORTRAN_WRAPPER(sgbtrs)\nextern void sgbtrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sgebak.f */\n#define sgebak FORTRAN_WRAPPER(sgebak)\nextern void sgebak(\n    const char   *job,\n    const char   *side,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const float  *scale,\n    const ptrdiff_t *m,\n    float  *v,\n    const ptrdiff_t *ldv,\n    ptrdiff_t *info\n);\n\n/* Source: sgebal.f */\n#define sgebal FORTRAN_WRAPPER(sgebal)\nextern void sgebal(\n    const char   *job,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    float  *scale,\n    ptrdiff_t *info\n);\n\n/* Source: sgebd2.f */\n#define sgebd2 FORTRAN_WRAPPER(sgebd2)\nextern void sgebd2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tauq,\n    float  *taup,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgebrd.f */\n#define sgebrd FORTRAN_WRAPPER(sgebrd)\nextern void sgebrd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tauq,\n    float  *taup,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgecon.f */\n#define sgecon FORTRAN_WRAPPER(sgecon)\nextern void sgecon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgeequ.f */\n#define sgeequ FORTRAN_WRAPPER(sgeequ)\nextern void sgeequ(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *r,\n    float  *c,\n    float  *rowcnd,\n    float  *colcnd,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: sgeequb.f */\n#define sgeequb FORTRAN_WRAPPER(sgeequb)\nextern void sgeequb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *r,\n    float  *c,\n    float  *rowcnd,\n    float  *colcnd,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: sgees.f */\n#define sgees FORTRAN_WRAPPER(sgees)\nextern void sgees(\n    const char   *jobvs,\n    const char   *sort,\n    ptrdiff_t (*select)(),\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *sdim,\n    float  *wr,\n    float  *wi,\n    float  *vs,\n    const ptrdiff_t *ldvs,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgeesx.f */\n#define sgeesx FORTRAN_WRAPPER(sgeesx)\nextern void sgeesx(\n    const char   *jobvs,\n    const char   *sort,\n    ptrdiff_t (*select)(),\n    const char   *sense,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *sdim,\n    float  *wr,\n    float  *wi,\n    float  *vs,\n    const ptrdiff_t *ldvs,\n    float  *rconde,\n    float  *rcondv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgeev.f */\n#define sgeev FORTRAN_WRAPPER(sgeev)\nextern void sgeev(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *wr,\n    float  *wi,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgeevx.f */\n#define sgeevx FORTRAN_WRAPPER(sgeevx)\nextern void sgeevx(\n    const char   *balanc,\n    const char   *jobvl,\n    const char   *jobvr,\n    const char   *sense,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *wr,\n    float  *wi,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    float  *scale,\n    float  *abnrm,\n    float  *rconde,\n    float  *rcondv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgehd2.f */\n#define sgehd2 FORTRAN_WRAPPER(sgehd2)\nextern void sgehd2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgehrd.f */\n#define sgehrd FORTRAN_WRAPPER(sgehrd)\nextern void sgehrd(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgejsv.f */\n#define sgejsv FORTRAN_WRAPPER(sgejsv)\nextern void sgejsv(\n    const char   *joba,\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobr,\n    const char   *jobt,\n    const char   *jobp,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *sva,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgelq.f */\n#define sgelq FORTRAN_WRAPPER(sgelq)\nextern void sgelq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *tsize,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgelq2.f */\n#define sgelq2 FORTRAN_WRAPPER(sgelq2)\nextern void sgelq2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgelqf.f */\n#define sgelqf FORTRAN_WRAPPER(sgelqf)\nextern void sgelqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgelqt.f */\n#define sgelqt FORTRAN_WRAPPER(sgelqt)\nextern void sgelqt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgelqt3.f */\n#define sgelqt3 FORTRAN_WRAPPER(sgelqt3)\nextern void sgelqt3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: sgels.f */\n#define sgels FORTRAN_WRAPPER(sgels)\nextern void sgels(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgelsd.f */\n#define sgelsd FORTRAN_WRAPPER(sgelsd)\nextern void sgelsd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *s,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgelss.f */\n#define sgelss FORTRAN_WRAPPER(sgelss)\nextern void sgelss(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *s,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgelsx.f */\n#define sgelsx FORTRAN_WRAPPER(sgelsx)\nextern void sgelsx(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *jpvt,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgelsy.f */\n#define sgelsy FORTRAN_WRAPPER(sgelsy)\nextern void sgelsy(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *jpvt,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgemlq.f */\n#define sgemlq FORTRAN_WRAPPER(sgemlq)\nextern void sgemlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *t,\n    const ptrdiff_t *tsize,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgemlqt.f */\n#define sgemlqt FORTRAN_WRAPPER(sgemlqt)\nextern void sgemlqt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgemqr.f */\n#define sgemqr FORTRAN_WRAPPER(sgemqr)\nextern void sgemqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *t,\n    const ptrdiff_t *tsize,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgemqrt.f */\n#define sgemqrt FORTRAN_WRAPPER(sgemqrt)\nextern void sgemqrt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgeql2.f */\n#define sgeql2 FORTRAN_WRAPPER(sgeql2)\nextern void sgeql2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqlf.f */\n#define sgeqlf FORTRAN_WRAPPER(sgeqlf)\nextern void sgeqlf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqp3.f */\n#define sgeqp3 FORTRAN_WRAPPER(sgeqp3)\nextern void sgeqp3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqr.f */\n#define sgeqr FORTRAN_WRAPPER(sgeqr)\nextern void sgeqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *tsize,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqr2.f */\n#define sgeqr2 FORTRAN_WRAPPER(sgeqr2)\nextern void sgeqr2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqr2p.f */\n#define sgeqr2p FORTRAN_WRAPPER(sgeqr2p)\nextern void sgeqr2p(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqrf.f */\n#define sgeqrf FORTRAN_WRAPPER(sgeqrf)\nextern void sgeqrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqrfp.f */\n#define sgeqrfp FORTRAN_WRAPPER(sgeqrfp)\nextern void sgeqrfp(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqrt.f */\n#define sgeqrt FORTRAN_WRAPPER(sgeqrt)\nextern void sgeqrt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqrt2.f */\n#define sgeqrt2 FORTRAN_WRAPPER(sgeqrt2)\nextern void sgeqrt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: sgeqrt3.f */\n#define sgeqrt3 FORTRAN_WRAPPER(sgeqrt3)\nextern void sgeqrt3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: sgerfs.f */\n#define sgerfs FORTRAN_WRAPPER(sgerfs)\nextern void sgerfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgerq2.f */\n#define sgerq2 FORTRAN_WRAPPER(sgerq2)\nextern void sgerq2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgerqf.f */\n#define sgerqf FORTRAN_WRAPPER(sgerqf)\nextern void sgerqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgesc2.f */\n#define sgesc2 FORTRAN_WRAPPER(sgesc2)\nextern void sgesc2(\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *rhs,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *jpiv,\n    float  *scale\n);\n\n/* Source: sgesdd.f */\n#define sgesdd FORTRAN_WRAPPER(sgesdd)\nextern void sgesdd(\n    const char   *jobz,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgesv.f */\n#define sgesv FORTRAN_WRAPPER(sgesv)\nextern void sgesv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sgesvd.f */\n#define sgesvd FORTRAN_WRAPPER(sgesvd)\nextern void sgesvd(\n    const char   *jobu,\n    const char   *jobvt,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgesvdx.f */\n#define sgesvdx FORTRAN_WRAPPER(sgesvdx)\nextern void sgesvdx(\n    const char   *jobu,\n    const char   *jobvt,\n    const char   *range,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *ns,\n    float  *s,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgesvj.f */\n#define sgesvj FORTRAN_WRAPPER(sgesvj)\nextern void sgesvj(\n    const char   *joba,\n    const char   *jobu,\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *sva,\n    const ptrdiff_t *mv,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgesvx.f */\n#define sgesvx FORTRAN_WRAPPER(sgesvx)\nextern void sgesvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    char   *equed,\n    float  *r,\n    float  *c,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgetc2.f */\n#define sgetc2 FORTRAN_WRAPPER(sgetc2)\nextern void sgetc2(\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *jpiv,\n    ptrdiff_t *info\n);\n\n/* Source: sgetf2.f */\n#define sgetf2 FORTRAN_WRAPPER(sgetf2)\nextern void sgetf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: sgetrf.f */\n#define sgetrf FORTRAN_WRAPPER(sgetrf)\nextern void sgetrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: sgetrf2.f */\n#define sgetrf2 FORTRAN_WRAPPER(sgetrf2)\nextern void sgetrf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: sgetri.f */\n#define sgetri FORTRAN_WRAPPER(sgetri)\nextern void sgetri(\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgetrs.f */\n#define sgetrs FORTRAN_WRAPPER(sgetrs)\nextern void sgetrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sgetsls.f */\n#define sgetsls FORTRAN_WRAPPER(sgetsls)\nextern void sgetsls(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggbak.f */\n#define sggbak FORTRAN_WRAPPER(sggbak)\nextern void sggbak(\n    const char   *job,\n    const char   *side,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const float  *lscale,\n    const float  *rscale,\n    const ptrdiff_t *m,\n    float  *v,\n    const ptrdiff_t *ldv,\n    ptrdiff_t *info\n);\n\n/* Source: sggbal.f */\n#define sggbal FORTRAN_WRAPPER(sggbal)\nextern void sggbal(\n    const char   *job,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    float  *lscale,\n    float  *rscale,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sgges.f */\n#define sgges FORTRAN_WRAPPER(sgges)\nextern void sgges(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *vsl,\n    const ptrdiff_t *ldvsl,\n    float  *vsr,\n    const ptrdiff_t *ldvsr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgges3.f */\n#define sgges3 FORTRAN_WRAPPER(sgges3)\nextern void sgges3(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *vsl,\n    const ptrdiff_t *ldvsl,\n    float  *vsr,\n    const ptrdiff_t *ldvsr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggesx.f */\n#define sggesx FORTRAN_WRAPPER(sggesx)\nextern void sggesx(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const char   *sense,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *vsl,\n    const ptrdiff_t *ldvsl,\n    float  *vsr,\n    const ptrdiff_t *ldvsr,\n    float  *rconde,\n    float  *rcondv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggev.f */\n#define sggev FORTRAN_WRAPPER(sggev)\nextern void sggev(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggev3.f */\n#define sggev3 FORTRAN_WRAPPER(sggev3)\nextern void sggev3(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggevx.f */\n#define sggevx FORTRAN_WRAPPER(sggevx)\nextern void sggevx(\n    const char   *balanc,\n    const char   *jobvl,\n    const char   *jobvr,\n    const char   *sense,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    float  *lscale,\n    float  *rscale,\n    float  *abnrm,\n    float  *bbnrm,\n    float  *rconde,\n    float  *rcondv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggglm.f */\n#define sggglm FORTRAN_WRAPPER(sggglm)\nextern void sggglm(\n    const ptrdiff_t *n,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *d,\n    float  *x,\n    float  *y,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgghd3.f */\n#define sgghd3 FORTRAN_WRAPPER(sgghd3)\nextern void sgghd3(\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgghrd.f */\n#define sgghrd FORTRAN_WRAPPER(sgghrd)\nextern void sgghrd(\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *info\n);\n\n/* Source: sgglse.f */\n#define sgglse FORTRAN_WRAPPER(sgglse)\nextern void sgglse(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    float  *d,\n    float  *x,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggqrf.f */\n#define sggqrf FORTRAN_WRAPPER(sggqrf)\nextern void sggqrf(\n    const ptrdiff_t *n,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *taua,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *taub,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggrqf.f */\n#define sggrqf FORTRAN_WRAPPER(sggrqf)\nextern void sggrqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *taua,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *taub,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggsvd3.f */\n#define sggsvd3 FORTRAN_WRAPPER(sggsvd3)\nextern void sggsvd3(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alpha,\n    float  *beta,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sggsvp3.f */\n#define sggsvp3 FORTRAN_WRAPPER(sggsvp3)\nextern void sggsvp3(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *tola,\n    const float  *tolb,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *iwork,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgsvj0.f */\n#define sgsvj0 FORTRAN_WRAPPER(sgsvj0)\nextern void sgsvj0(\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *sva,\n    const ptrdiff_t *mv,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const float  *eps,\n    const float  *sfmin,\n    const float  *tol,\n    const ptrdiff_t *nsweep,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgsvj1.f */\n#define sgsvj1 FORTRAN_WRAPPER(sgsvj1)\nextern void sgsvj1(\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *sva,\n    const ptrdiff_t *mv,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const float  *eps,\n    const float  *sfmin,\n    const float  *tol,\n    const ptrdiff_t *nsweep,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgtcon.f */\n#define sgtcon FORTRAN_WRAPPER(sgtcon)\nextern void sgtcon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *du2,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgtrfs.f */\n#define sgtrfs FORTRAN_WRAPPER(sgtrfs)\nextern void sgtrfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *dlf,\n    const float  *df,\n    const float  *duf,\n    const float  *du2,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgtsv.f */\n#define sgtsv FORTRAN_WRAPPER(sgtsv)\nextern void sgtsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *dl,\n    float  *d,\n    float  *du,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sgtsvx.f */\n#define sgtsvx FORTRAN_WRAPPER(sgtsvx)\nextern void sgtsvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    float  *dlf,\n    float  *df,\n    float  *duf,\n    float  *du2,\n    ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sgttrf.f */\n#define sgttrf FORTRAN_WRAPPER(sgttrf)\nextern void sgttrf(\n    const ptrdiff_t *n,\n    float  *dl,\n    float  *d,\n    float  *du,\n    float  *du2,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: sgttrs.f */\n#define sgttrs FORTRAN_WRAPPER(sgttrs)\nextern void sgttrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *du2,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sgtts2.f */\n#define sgtts2 FORTRAN_WRAPPER(sgtts2)\nextern void sgtts2(\n    const ptrdiff_t *itrans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *du2,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: shgeqz.f */\n#define shgeqz FORTRAN_WRAPPER(shgeqz)\nextern void shgeqz(\n    const char   *job,\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: shsein.f */\n#define shsein FORTRAN_WRAPPER(shsein)\nextern void shsein(\n    const char   *side,\n    const char   *eigsrc,\n    const char   *initv,\n    ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const float  *h,\n    const ptrdiff_t *ldh,\n    float  *wr,\n    const float  *wi,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    ptrdiff_t *ifaill,\n    ptrdiff_t *ifailr,\n    ptrdiff_t *info\n);\n\n/* Source: shseqr.f */\n#define shseqr FORTRAN_WRAPPER(shseqr)\nextern void shseqr(\n    const char   *job,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *wr,\n    float  *wi,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sisnan.f */\n#define sisnan FORTRAN_WRAPPER(sisnan)\nextern ptrdiff_t sisnan(\n    const float  *sin\n);\n\n/* Source: slabad.f */\n#define slabad FORTRAN_WRAPPER(slabad)\nextern void slabad(\n    float  *small,\n    float  *large\n);\n\n/* Source: slabrd.f */\n#define slabrd FORTRAN_WRAPPER(slabrd)\nextern void slabrd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tauq,\n    float  *taup,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: slacn2.f */\n#define slacn2 FORTRAN_WRAPPER(slacn2)\nextern void slacn2(\n    const ptrdiff_t *n,\n    float  *v,\n    float  *x,\n    ptrdiff_t *isgn,\n    float  *est,\n    ptrdiff_t *kase,\n    ptrdiff_t *isave\n);\n\n/* Source: slacon.f */\n#define slacon FORTRAN_WRAPPER(slacon)\nextern void slacon(\n    const ptrdiff_t *n,\n    float  *v,\n    float  *x,\n    ptrdiff_t *isgn,\n    float  *est,\n    ptrdiff_t *kase\n);\n\n/* Source: slacpy.f */\n#define slacpy FORTRAN_WRAPPER(slacpy)\nextern void slacpy(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: sladiv.f */\n#define sladiv FORTRAN_WRAPPER(sladiv)\nextern void sladiv(\n    const float  *a,\n    const float  *b,\n    const float  *c,\n    const float  *d,\n    float  *p,\n    float  *q\n);\n\n/* Source: sladiv.f */\n#define sladiv1 FORTRAN_WRAPPER(sladiv1)\nextern void sladiv1(\n    float  *a,\n    float  *b,\n    float  *c,\n    float  *d,\n    float  *p,\n    float  *q\n);\n\n/* Source: sladiv.f */\n#define sladiv2 FORTRAN_WRAPPER(sladiv2)\nextern float sladiv2(\n    float  *a,\n    float  *b,\n    float  *c,\n    float  *d,\n    float  *r,\n    float  *t\n);\n\n/* Source: slae2.f */\n#define slae2 FORTRAN_WRAPPER(slae2)\nextern void slae2(\n    const float  *a,\n    const float  *b,\n    const float  *c,\n    float  *rt1,\n    float  *rt2\n);\n\n/* Source: slaebz.f */\n#define slaebz FORTRAN_WRAPPER(slaebz)\nextern void slaebz(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *nitmax,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mmax,\n    const ptrdiff_t *minp,\n    const ptrdiff_t *nbmin,\n    const float  *abstol,\n    const float  *reltol,\n    const float  *pivmin,\n    const float  *d,\n    const float  *e,\n    const float  *e2,\n    ptrdiff_t *nval,\n    float  *ab,\n    float  *c,\n    ptrdiff_t *mout,\n    ptrdiff_t *nab,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slaed0.f */\n#define slaed0 FORTRAN_WRAPPER(slaed0)\nextern void slaed0(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *qsiz,\n    const ptrdiff_t *n,\n    float  *d,\n    const float  *e,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *qstore,\n    const ptrdiff_t *ldqs,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slaed1.f */\n#define slaed1 FORTRAN_WRAPPER(slaed1)\nextern void slaed1(\n    const ptrdiff_t *n,\n    float  *d,\n    float  *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *indxq,\n    const float  *rho,\n    const ptrdiff_t *cutpnt,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slaed2.f */\n#define slaed2 FORTRAN_WRAPPER(slaed2)\nextern void slaed2(\n    ptrdiff_t *k,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    float  *d,\n    float  *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *indxq,\n    float  *rho,\n    const float  *z,\n    float  *dlamda,\n    float  *w,\n    float  *q2,\n    ptrdiff_t *indx,\n    ptrdiff_t *indxc,\n    ptrdiff_t *indxp,\n    ptrdiff_t *coltyp,\n    ptrdiff_t *info\n);\n\n/* Source: slaed3.f */\n#define slaed3 FORTRAN_WRAPPER(slaed3)\nextern void slaed3(\n    const ptrdiff_t *k,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    float  *d,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const float  *rho,\n    float  *dlamda,\n    const float  *q2,\n    const ptrdiff_t *indx,\n    const ptrdiff_t *ctot,\n    float  *w,\n    float  *s,\n    ptrdiff_t *info\n);\n\n/* Source: slaed4.f */\n#define slaed4 FORTRAN_WRAPPER(slaed4)\nextern void slaed4(\n    const ptrdiff_t *n,\n    const ptrdiff_t *i,\n    const float  *d,\n    const float  *z,\n    float  *delta,\n    const float  *rho,\n    float  *dlam,\n    ptrdiff_t *info\n);\n\n/* Source: slaed5.f */\n#define slaed5 FORTRAN_WRAPPER(slaed5)\nextern void slaed5(\n    const ptrdiff_t *i,\n    const float  *d,\n    const float  *z,\n    float  *delta,\n    const float  *rho,\n    float  *dlam\n);\n\n/* Source: slaed6.f */\n#define slaed6 FORTRAN_WRAPPER(slaed6)\nextern void slaed6(\n    const ptrdiff_t *kniter,\n    const ptrdiff_t *orgati,\n    const float  *rho,\n    const float  *d,\n    const float  *z,\n    const float  *finit,\n    float  *tau,\n    ptrdiff_t *info\n);\n\n/* Source: slaed7.f */\n#define slaed7 FORTRAN_WRAPPER(slaed7)\nextern void slaed7(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *n,\n    const ptrdiff_t *qsiz,\n    const ptrdiff_t *tlvls,\n    const ptrdiff_t *curlvl,\n    const ptrdiff_t *curpbm,\n    float  *d,\n    float  *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *indxq,\n    const float  *rho,\n    const ptrdiff_t *cutpnt,\n    float  *qstore,\n    ptrdiff_t *qptr,\n    const ptrdiff_t *prmptr,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const float  *givnum,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slaed8.f */\n#define slaed8 FORTRAN_WRAPPER(slaed8)\nextern void slaed8(\n    const ptrdiff_t *icompq,\n    ptrdiff_t *k,\n    const ptrdiff_t *n,\n    const ptrdiff_t *qsiz,\n    float  *d,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const ptrdiff_t *indxq,\n    float  *rho,\n    const ptrdiff_t *cutpnt,\n    const float  *z,\n    float  *dlamda,\n    float  *q2,\n    const ptrdiff_t *ldq2,\n    float  *w,\n    ptrdiff_t *perm,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    float  *givnum,\n    ptrdiff_t *indxp,\n    ptrdiff_t *indx,\n    ptrdiff_t *info\n);\n\n/* Source: slaed9.f */\n#define slaed9 FORTRAN_WRAPPER(slaed9)\nextern void slaed9(\n    const ptrdiff_t *k,\n    const ptrdiff_t *kstart,\n    const ptrdiff_t *kstop,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const float  *rho,\n    const float  *dlamda,\n    const float  *w,\n    float  *s,\n    const ptrdiff_t *lds,\n    ptrdiff_t *info\n);\n\n/* Source: slaeda.f */\n#define slaeda FORTRAN_WRAPPER(slaeda)\nextern void slaeda(\n    const ptrdiff_t *n,\n    const ptrdiff_t *tlvls,\n    const ptrdiff_t *curlvl,\n    const ptrdiff_t *curpbm,\n    const ptrdiff_t *prmptr,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const float  *givnum,\n    const float  *q,\n    const ptrdiff_t *qptr,\n    float  *z,\n    float  *ztemp,\n    ptrdiff_t *info\n);\n\n/* Source: slaein.f */\n#define slaein FORTRAN_WRAPPER(slaein)\nextern void slaein(\n    const ptrdiff_t *rightv,\n    const ptrdiff_t *noinit,\n    const ptrdiff_t *n,\n    const float  *h,\n    const ptrdiff_t *ldh,\n    const float  *wr,\n    const float  *wi,\n    float  *vr,\n    float  *vi,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const float  *eps3,\n    const float  *smlnum,\n    const float  *bignum,\n    ptrdiff_t *info\n);\n\n/* Source: slaev2.f */\n#define slaev2 FORTRAN_WRAPPER(slaev2)\nextern void slaev2(\n    const float  *a,\n    const float  *b,\n    const float  *c,\n    float  *rt1,\n    float  *rt2,\n    float  *cs1,\n    float  *sn1\n);\n\n/* Source: slaexc.f */\n#define slaexc FORTRAN_WRAPPER(slaexc)\nextern void slaexc(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *n,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const ptrdiff_t *j1_,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slag2.f */\n#define slag2 FORTRAN_WRAPPER(slag2)\nextern void slag2(\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *safmin,\n    float  *scale1,\n    float  *scale2,\n    float  *wr1,\n    float  *wr2,\n    float  *wi\n);\n\n/* Source: slag2d.f */\n#define slag2d FORTRAN_WRAPPER(slag2d)\nextern void slag2d(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *sa,\n    const ptrdiff_t *ldsa,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: slags2.f */\n#define slags2 FORTRAN_WRAPPER(slags2)\nextern void slags2(\n    const ptrdiff_t *upper,\n    const float  *a1,\n    const float  *a2,\n    const float  *a3,\n    const float  *b1,\n    const float  *b2,\n    const float  *b3,\n    float  *csu,\n    float  *snu,\n    float  *csv,\n    float  *snv,\n    float  *csq,\n    float  *snq\n);\n\n/* Source: slagtf.f */\n#define slagtf FORTRAN_WRAPPER(slagtf)\nextern void slagtf(\n    const ptrdiff_t *n,\n    float  *a,\n    const float  *lambda,\n    float  *b,\n    float  *c,\n    const float  *tol,\n    float  *d,\n    ptrdiff_t *in,\n    ptrdiff_t *info\n);\n\n/* Source: slagtm.f */\n#define slagtm FORTRAN_WRAPPER(slagtm)\nextern void slagtm(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *alpha,\n    const float  *dl,\n    const float  *d,\n    const float  *du,\n    const float  *x,\n    const ptrdiff_t *ldx,\n    const float  *beta,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: slagts.f */\n#define slagts FORTRAN_WRAPPER(slagts)\nextern void slagts(\n    const ptrdiff_t *job,\n    const ptrdiff_t *n,\n    const float  *a,\n    const float  *b,\n    const float  *c,\n    const float  *d,\n    const ptrdiff_t *in,\n    float  *y,\n    float  *tol,\n    ptrdiff_t *info\n);\n\n/* Source: slagv2.f */\n#define slagv2 FORTRAN_WRAPPER(slagv2)\nextern void slagv2(\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *csl,\n    float  *snl,\n    float  *csr,\n    float  *snr\n);\n\n/* Source: slahqr.f */\n#define slahqr FORTRAN_WRAPPER(slahqr)\nextern void slahqr(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *wr,\n    float  *wi,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *info\n);\n\n/* Source: slahr2.f */\n#define slahr2 FORTRAN_WRAPPER(slahr2)\nextern void slahr2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: slaic1.f */\n#define slaic1 FORTRAN_WRAPPER(slaic1)\nextern void slaic1(\n    const ptrdiff_t *job,\n    const ptrdiff_t *j,\n    const float  *x,\n    const float  *sest,\n    const float  *w,\n    const float  *gamma_,\n    float  *sestpr,\n    float  *s,\n    float  *c\n);\n\n/* Source: slaisnan.f */\n#define slaisnan FORTRAN_WRAPPER(slaisnan)\nextern ptrdiff_t slaisnan(\n    const float  *sin1,\n    const float  *sin2\n);\n\n/* Source: slaln2.f */\n#define slaln2 FORTRAN_WRAPPER(slaln2)\nextern void slaln2(\n    const ptrdiff_t *ltrans,\n    const ptrdiff_t *na,\n    const ptrdiff_t *nw,\n    const float  *smin,\n    const float  *ca,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *d1,\n    const float  *d2,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *wr,\n    const float  *wi,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *scale,\n    float  *xnorm,\n    ptrdiff_t *info\n);\n\n/* Source: slals0.f */\n#define slals0 FORTRAN_WRAPPER(slals0)\nextern void slals0(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    const ptrdiff_t *nrhs,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *bx,\n    const ptrdiff_t *ldbx,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    const float  *givnum,\n    const ptrdiff_t *ldgnum,\n    const float  *poles,\n    const float  *difl,\n    const float  *difr,\n    const float  *z,\n    const ptrdiff_t *k,\n    const float  *c,\n    const float  *s,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slalsa.f */\n#define slalsa FORTRAN_WRAPPER(slalsa)\nextern void slalsa(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *bx,\n    const ptrdiff_t *ldbx,\n    const float  *u,\n    const ptrdiff_t *ldu,\n    const float  *vt,\n    const ptrdiff_t *k,\n    const float  *difl,\n    const float  *difr,\n    const float  *z,\n    const float  *poles,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    const ptrdiff_t *perm,\n    const float  *givnum,\n    const float  *c,\n    const float  *s,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slalsd.f */\n#define slalsd FORTRAN_WRAPPER(slalsd)\nextern void slalsd(\n    const char   *uplo,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *d,\n    float  *e,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *rcond,\n    ptrdiff_t *rank,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slamrg.f */\n#define slamrg FORTRAN_WRAPPER(slamrg)\nextern void slamrg(\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    const float  *a,\n    const ptrdiff_t *strd1,\n    const ptrdiff_t *strd2,\n    ptrdiff_t *index\n);\n\n/* Source: slamswlq.f */\n#define slamswlq FORTRAN_WRAPPER(slamswlq)\nextern void slamswlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: slamtsqr.f */\n#define slamtsqr FORTRAN_WRAPPER(slamtsqr)\nextern void slamtsqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: slaneg.f */\n#define slaneg FORTRAN_WRAPPER(slaneg)\nextern ptrdiff_t slaneg(\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *lld,\n    const float  *sigma,\n    const float  *pivmin,\n    const ptrdiff_t *r\n);\n\n/* Source: slangb.f */\n#define slangb FORTRAN_WRAPPER(slangb)\nextern float slangb(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *work\n);\n\n/* Source: slange.f */\n#define slange FORTRAN_WRAPPER(slange)\nextern float slange(\n    const char   *norm,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *work\n);\n\n/* Source: slangt.f */\n#define slangt FORTRAN_WRAPPER(slangt)\nextern float slangt(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *dl,\n    const float  *d,\n    const float  *du\n);\n\n/* Source: slanhs.f */\n#define slanhs FORTRAN_WRAPPER(slanhs)\nextern float slanhs(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *work\n);\n\n/* Source: slansb.f */\n#define slansb FORTRAN_WRAPPER(slansb)\nextern float slansb(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *work\n);\n\n/* Source: slansf.f */\n#define slansf FORTRAN_WRAPPER(slansf)\nextern float slansf(\n    const char   *norm,\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    float  *work\n);\n\n/* Source: slansp.f */\n#define slansp FORTRAN_WRAPPER(slansp)\nextern float slansp(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *work\n);\n\n/* Source: slanst.f */\n#define slanst FORTRAN_WRAPPER(slanst)\nextern float slanst(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *e\n);\n\n/* Source: slansy.f */\n#define slansy FORTRAN_WRAPPER(slansy)\nextern float slansy(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *work\n);\n\n/* Source: slantb.f */\n#define slantb FORTRAN_WRAPPER(slantb)\nextern float slantb(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *work\n);\n\n/* Source: slantp.f */\n#define slantp FORTRAN_WRAPPER(slantp)\nextern float slantp(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *work\n);\n\n/* Source: slantr.f */\n#define slantr FORTRAN_WRAPPER(slantr)\nextern float slantr(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *work\n);\n\n/* Source: slanv2.f */\n#define slanv2 FORTRAN_WRAPPER(slanv2)\nextern void slanv2(\n    float  *a,\n    float  *b,\n    float  *c,\n    float  *d,\n    float  *rt1r,\n    float  *rt1i,\n    float  *rt2r,\n    float  *rt2i,\n    float  *cs,\n    float  *sn\n);\n\n/* Source: slapll.f */\n#define slapll FORTRAN_WRAPPER(slapll)\nextern void slapll(\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *y,\n    const ptrdiff_t *incy,\n    float  *ssmin\n);\n\n/* Source: slapmr.f */\n#define slapmr FORTRAN_WRAPPER(slapmr)\nextern void slapmr(\n    const ptrdiff_t *forwrd,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *ldx,\n    ptrdiff_t *k\n);\n\n/* Source: slapmt.f */\n#define slapmt FORTRAN_WRAPPER(slapmt)\nextern void slapmt(\n    const ptrdiff_t *forwrd,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *ldx,\n    ptrdiff_t *k\n);\n\n/* Source: slapy2.f */\n#define slapy2 FORTRAN_WRAPPER(slapy2)\nextern float slapy2(\n    const float  *x,\n    const float  *y\n);\n\n/* Source: slapy3.f */\n#define slapy3 FORTRAN_WRAPPER(slapy3)\nextern float slapy3(\n    const float  *x,\n    const float  *y,\n    const float  *z\n);\n\n/* Source: slaqgb.f */\n#define slaqgb FORTRAN_WRAPPER(slaqgb)\nextern void slaqgb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *r,\n    const float  *c,\n    const float  *rowcnd,\n    const float  *colcnd,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: slaqge.f */\n#define slaqge FORTRAN_WRAPPER(slaqge)\nextern void slaqge(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *r,\n    const float  *c,\n    const float  *rowcnd,\n    const float  *colcnd,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: slaqp2.f */\n#define slaqp2 FORTRAN_WRAPPER(slaqp2)\nextern void slaqp2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *offset,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    float  *tau,\n    float  *vn1,\n    float  *vn2,\n    float  *work\n);\n\n/* Source: slaqps.f */\n#define slaqps FORTRAN_WRAPPER(slaqps)\nextern void slaqps(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *offset,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    float  *tau,\n    float  *vn1,\n    float  *vn2,\n    float  *auxv,\n    float  *f,\n    const ptrdiff_t *ldf\n);\n\n/* Source: slaqr0.f */\n#define slaqr0 FORTRAN_WRAPPER(slaqr0)\nextern void slaqr0(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *wr,\n    float  *wi,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: slaqr1.f */\n#define slaqr1 FORTRAN_WRAPPER(slaqr1)\nextern void slaqr1(\n    const ptrdiff_t *n,\n    const float  *h,\n    const ptrdiff_t *ldh,\n    const float  *sr1,\n    float  *si1,\n    float  *sr2,\n    float  *si2,\n    float  *v\n);\n\n/* Source: slaqr2.f */\n#define slaqr2 FORTRAN_WRAPPER(slaqr2)\nextern void slaqr2(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nw,\n    float  *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ns,\n    ptrdiff_t *nd,\n    float  *sr,\n    float  *si,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const ptrdiff_t *nh,\n    float  *t,\n    const ptrdiff_t *ldt,\n    const ptrdiff_t *nv,\n    float  *wv,\n    const ptrdiff_t *ldwv,\n    float  *work,\n    const ptrdiff_t *lwork\n);\n\n/* Source: slaqr3.f */\n#define slaqr3 FORTRAN_WRAPPER(slaqr3)\nextern void slaqr3(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nw,\n    float  *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ns,\n    ptrdiff_t *nd,\n    float  *sr,\n    float  *si,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const ptrdiff_t *nh,\n    float  *t,\n    const ptrdiff_t *ldt,\n    const ptrdiff_t *nv,\n    float  *wv,\n    const ptrdiff_t *ldwv,\n    float  *work,\n    const ptrdiff_t *lwork\n);\n\n/* Source: slaqr4.f */\n#define slaqr4 FORTRAN_WRAPPER(slaqr4)\nextern void slaqr4(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *wr,\n    float  *wi,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: slaqr5.f */\n#define slaqr5 FORTRAN_WRAPPER(slaqr5)\nextern void slaqr5(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *kacc22,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nshfts,\n    float  *sr,\n    float  *si,\n    float  *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *u,\n    const ptrdiff_t *ldu,\n    const ptrdiff_t *nv,\n    float  *wv,\n    const ptrdiff_t *ldwv,\n    const ptrdiff_t *nh,\n    float  *wh,\n    const ptrdiff_t *ldwh\n);\n\n/* Source: slaqsb.f */\n#define slaqsb FORTRAN_WRAPPER(slaqsb)\nextern void slaqsb(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *s,\n    const float  *scond,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: slaqsp.f */\n#define slaqsp FORTRAN_WRAPPER(slaqsp)\nextern void slaqsp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const float  *s,\n    const float  *scond,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: slaqsy.f */\n#define slaqsy FORTRAN_WRAPPER(slaqsy)\nextern void slaqsy(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *s,\n    const float  *scond,\n    const float  *amax,\n    char   *equed\n);\n\n/* Source: slaqtr.f */\n#define slaqtr FORTRAN_WRAPPER(slaqtr)\nextern void slaqtr(\n    const ptrdiff_t *ltran,\n    const ptrdiff_t *lreal,\n    const ptrdiff_t *n,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    const float  *b,\n    const float  *w,\n    float  *scale,\n    float  *x,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slar1v.f */\n#define slar1v FORTRAN_WRAPPER(slar1v)\nextern void slar1v(\n    const ptrdiff_t *n,\n    const ptrdiff_t *b1,\n    const ptrdiff_t *bn,\n    const float  *lambda,\n    const float  *d,\n    const float  *l,\n    const float  *ld,\n    const float  *lld,\n    const float  *pivmin,\n    const float  *gaptol,\n    float  *z,\n    const ptrdiff_t *wantnc,\n    ptrdiff_t *negcnt,\n    float  *ztz,\n    float  *mingma,\n    ptrdiff_t *r,\n    ptrdiff_t *isuppz,\n    float  *nrminv,\n    float  *resid,\n    float  *rqcorr,\n    float  *work\n);\n\n/* Source: slar2v.f */\n#define slar2v FORTRAN_WRAPPER(slar2v)\nextern void slar2v(\n    const ptrdiff_t *n,\n    float  *x,\n    float  *y,\n    float  *z,\n    const ptrdiff_t *incx,\n    const float  *c,\n    const float  *s,\n    const ptrdiff_t *incc\n);\n\n/* Source: slarf.f */\n#define slarf FORTRAN_WRAPPER(slarf)\nextern void slarf(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *v,\n    const ptrdiff_t *incv,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: slarfb.f */\n#define slarfb FORTRAN_WRAPPER(slarfb)\nextern void slarfb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: slarfg.f */\n#define slarfg FORTRAN_WRAPPER(slarfg)\nextern void slarfg(\n    const ptrdiff_t *n,\n    float  *alpha,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *tau\n);\n\n/* Source: slarfgp.f */\n#define slarfgp FORTRAN_WRAPPER(slarfgp)\nextern void slarfgp(\n    const ptrdiff_t *n,\n    float  *alpha,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *tau\n);\n\n/* Source: slarft.f */\n#define slarft FORTRAN_WRAPPER(slarft)\nextern void slarft(\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *tau,\n    float  *t,\n    const ptrdiff_t *ldt\n);\n\n/* Source: slarfx.f */\n#define slarfx FORTRAN_WRAPPER(slarfx)\nextern void slarfx(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *v,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: slarfy.f */\n#define slarfy FORTRAN_WRAPPER(slarfy)\nextern void slarfy(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *v,\n    ptrdiff_t *incv,\n    float  *tau,\n    float  *c,\n    ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: slargv.f */\n#define slargv FORTRAN_WRAPPER(slargv)\nextern void slargv(\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *y,\n    const ptrdiff_t *incy,\n    float  *c,\n    const ptrdiff_t *incc\n);\n\n/* Source: slarnv.f */\n#define slarnv FORTRAN_WRAPPER(slarnv)\nextern void slarnv(\n    const ptrdiff_t *idist,\n    ptrdiff_t *iseed,\n    const ptrdiff_t *n,\n    float  *x\n);\n\n/* Source: slarra.f */\n#define slarra FORTRAN_WRAPPER(slarra)\nextern void slarra(\n    const ptrdiff_t *n,\n    const float  *d,\n    float  *e,\n    float  *e2,\n    const float  *spltol,\n    const float  *tnrm,\n    ptrdiff_t *nsplit,\n    ptrdiff_t *isplit,\n    ptrdiff_t *info\n);\n\n/* Source: slarrb.f */\n#define slarrb FORTRAN_WRAPPER(slarrb)\nextern void slarrb(\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *lld,\n    const ptrdiff_t *ifirst,\n    const ptrdiff_t *ilast,\n    const float  *rtol1,\n    const float  *rtol2,\n    const ptrdiff_t *offset,\n    float  *w,\n    float  *wgap,\n    float  *werr,\n    float  *work,\n    ptrdiff_t *iwork,\n    const float  *pivmin,\n    const float  *spdiam,\n    const ptrdiff_t *twist,\n    ptrdiff_t *info\n);\n\n/* Source: slarrc.f */\n#define slarrc FORTRAN_WRAPPER(slarrc)\nextern void slarrc(\n    const char   *jobt,\n    const ptrdiff_t *n,\n    const float  *vl,\n    const float  *vu,\n    const float  *d,\n    const float  *e,\n    const float  *pivmin,\n    ptrdiff_t *eigcnt,\n    ptrdiff_t *lcnt,\n    ptrdiff_t *rcnt,\n    ptrdiff_t *info\n);\n\n/* Source: slarrd.f */\n#define slarrd FORTRAN_WRAPPER(slarrd)\nextern void slarrd(\n    const char   *range,\n    const char   *order,\n    const ptrdiff_t *n,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *gers,\n    const float  *reltol,\n    const float  *d,\n    const float  *e,\n    const float  *e2,\n    const float  *pivmin,\n    const ptrdiff_t *nsplit,\n    const ptrdiff_t *isplit,\n    ptrdiff_t *m,\n    float  *w,\n    float  *werr,\n    float  *wl,\n    float  *wu,\n    ptrdiff_t *iblock,\n    ptrdiff_t *indexw,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slarre.f */\n#define slarre FORTRAN_WRAPPER(slarre)\nextern void slarre(\n    const char   *range,\n    const ptrdiff_t *n,\n    float  *vl,\n    float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    float  *d,\n    float  *e,\n    float  *e2,\n    const float  *rtol1,\n    const float  *rtol2,\n    const float  *spltol,\n    ptrdiff_t *nsplit,\n    ptrdiff_t *isplit,\n    ptrdiff_t *m,\n    float  *w,\n    float  *werr,\n    float  *wgap,\n    ptrdiff_t *iblock,\n    ptrdiff_t *indexw,\n    float  *gers,\n    float  *pivmin,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slarrf.f */\n#define slarrf FORTRAN_WRAPPER(slarrf)\nextern void slarrf(\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *l,\n    const float  *ld,\n    const ptrdiff_t *clstrt,\n    const ptrdiff_t *clend,\n    const float  *w,\n    float  *wgap,\n    const float  *werr,\n    const float  *spdiam,\n    const float  *clgapl,\n    float  *clgapr,\n    const float  *pivmin,\n    float  *sigma,\n    float  *dplus,\n    float  *lplus,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slarrj.f */\n#define slarrj FORTRAN_WRAPPER(slarrj)\nextern void slarrj(\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *e2,\n    const ptrdiff_t *ifirst,\n    const ptrdiff_t *ilast,\n    const float  *rtol,\n    const ptrdiff_t *offset,\n    float  *w,\n    float  *werr,\n    float  *work,\n    ptrdiff_t *iwork,\n    const float  *pivmin,\n    const float  *spdiam,\n    ptrdiff_t *info\n);\n\n/* Source: slarrk.f */\n#define slarrk FORTRAN_WRAPPER(slarrk)\nextern void slarrk(\n    const ptrdiff_t *n,\n    const ptrdiff_t *iw,\n    const float  *gl,\n    const float  *gu,\n    const float  *d,\n    const float  *e2,\n    const float  *pivmin,\n    const float  *reltol,\n    float  *w,\n    float  *werr,\n    ptrdiff_t *info\n);\n\n/* Source: slarrr.f */\n#define slarrr FORTRAN_WRAPPER(slarrr)\nextern void slarrr(\n    const ptrdiff_t *n,\n    const float  *d,\n    float  *e,\n    ptrdiff_t *info\n);\n\n/* Source: slarrv.f */\n#define slarrv FORTRAN_WRAPPER(slarrv)\nextern void slarrv(\n    const ptrdiff_t *n,\n    const float  *vl,\n    const float  *vu,\n    float  *d,\n    float  *l,\n    float  *pivmin,\n    const ptrdiff_t *isplit,\n    const ptrdiff_t *m,\n    const ptrdiff_t *dol,\n    const ptrdiff_t *dou,\n    const float  *minrgp,\n    const float  *rtol1,\n    const float  *rtol2,\n    float  *w,\n    float  *werr,\n    float  *wgap,\n    const ptrdiff_t *iblock,\n    const ptrdiff_t *indexw,\n    const float  *gers,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slartg.f */\n#define slartg FORTRAN_WRAPPER(slartg)\nextern void slartg(\n    const float  *f,\n    const float  *g,\n    float  *cs,\n    float  *sn,\n    float  *r\n);\n\n/* Source: slartgp.f */\n#define slartgp FORTRAN_WRAPPER(slartgp)\nextern void slartgp(\n    float  *f,\n    float  *g,\n    float  *cs,\n    float  *sn,\n    float  *r\n);\n\n/* Source: slartgs.f */\n#define slartgs FORTRAN_WRAPPER(slartgs)\nextern void slartgs(\n    const float  *x,\n    const float  *y,\n    const float  *sigma,\n    float  *cs,\n    float  *sn\n);\n\n/* Source: slartv.f */\n#define slartv FORTRAN_WRAPPER(slartv)\nextern void slartv(\n    const ptrdiff_t *n,\n    float  *x,\n    const ptrdiff_t *incx,\n    float  *y,\n    const ptrdiff_t *incy,\n    const float  *c,\n    const float  *s,\n    const ptrdiff_t *incc\n);\n\n/* Source: slaruv.f */\n#define slaruv FORTRAN_WRAPPER(slaruv)\nextern void slaruv(\n    ptrdiff_t *iseed,\n    const ptrdiff_t *n,\n    float  *x\n);\n\n/* Source: slarz.f */\n#define slarz FORTRAN_WRAPPER(slarz)\nextern void slarz(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const float  *v,\n    const ptrdiff_t *incv,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work\n);\n\n/* Source: slarzb.f */\n#define slarzb FORTRAN_WRAPPER(slarzb)\nextern void slarzb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: slarzt.f */\n#define slarzt FORTRAN_WRAPPER(slarzt)\nextern void slarzt(\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *v,\n    const ptrdiff_t *ldv,\n    const float  *tau,\n    float  *t,\n    const ptrdiff_t *ldt\n);\n\n/* Source: slas2.f */\n#define slas2 FORTRAN_WRAPPER(slas2)\nextern void slas2(\n    const float  *f,\n    const float  *g,\n    const float  *h,\n    float  *ssmin,\n    float  *ssmax\n);\n\n/* Source: slascl.f */\n#define slascl FORTRAN_WRAPPER(slascl)\nextern void slascl(\n    const char   *type,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const float  *cfrom,\n    const float  *cto,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: slasd0.f */\n#define slasd0 FORTRAN_WRAPPER(slasd0)\nextern void slasd0(\n    const ptrdiff_t *n,\n    const ptrdiff_t *sqre,\n    float  *d,\n    const float  *e,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    const ptrdiff_t *smlsiz,\n    ptrdiff_t *iwork,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slasd1.f */\n#define slasd1 FORTRAN_WRAPPER(slasd1)\nextern void slasd1(\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    float  *d,\n    float  *alpha,\n    float  *beta,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    ptrdiff_t *idxq,\n    ptrdiff_t *iwork,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slasd2.f */\n#define slasd2 FORTRAN_WRAPPER(slasd2)\nextern void slasd2(\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    ptrdiff_t *k,\n    float  *d,\n    float  *z,\n    const float  *alpha,\n    const float  *beta,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *dsigma,\n    float  *u2,\n    const ptrdiff_t *ldu2,\n    float  *vt2,\n    const ptrdiff_t *ldvt2,\n    ptrdiff_t *idxp,\n    ptrdiff_t *idx,\n    ptrdiff_t *idxc,\n    ptrdiff_t *idxq,\n    ptrdiff_t *coltyp,\n    ptrdiff_t *info\n);\n\n/* Source: slasd3.f */\n#define slasd3 FORTRAN_WRAPPER(slasd3)\nextern void slasd3(\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    const ptrdiff_t *k,\n    float  *d,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *dsigma,\n    float  *u,\n    const ptrdiff_t *ldu,\n    const float  *u2,\n    const ptrdiff_t *ldu2,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *vt2,\n    const ptrdiff_t *ldvt2,\n    const ptrdiff_t *idxc,\n    const ptrdiff_t *ctot,\n    float  *z,\n    ptrdiff_t *info\n);\n\n/* Source: slasd4.f */\n#define slasd4 FORTRAN_WRAPPER(slasd4)\nextern void slasd4(\n    const ptrdiff_t *n,\n    const ptrdiff_t *i,\n    const float  *d,\n    const float  *z,\n    float  *delta,\n    const float  *rho,\n    float  *sigma,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slasd5.f */\n#define slasd5 FORTRAN_WRAPPER(slasd5)\nextern void slasd5(\n    const ptrdiff_t *i,\n    const float  *d,\n    const float  *z,\n    float  *delta,\n    const float  *rho,\n    float  *dsigma,\n    float  *work\n);\n\n/* Source: slasd6.f */\n#define slasd6 FORTRAN_WRAPPER(slasd6)\nextern void slasd6(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    float  *d,\n    float  *vf,\n    float  *vl,\n    float  *alpha,\n    float  *beta,\n    ptrdiff_t *idxq,\n    ptrdiff_t *perm,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    float  *givnum,\n    const ptrdiff_t *ldgnum,\n    float  *poles,\n    float  *difl,\n    float  *difr,\n    float  *z,\n    ptrdiff_t *k,\n    float  *c,\n    float  *s,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slasd7.f */\n#define slasd7 FORTRAN_WRAPPER(slasd7)\nextern void slasd7(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    ptrdiff_t *k,\n    float  *d,\n    float  *z,\n    float  *zw,\n    float  *vf,\n    float  *vfw,\n    float  *vl,\n    float  *vlw,\n    const float  *alpha,\n    const float  *beta,\n    float  *dsigma,\n    ptrdiff_t *idx,\n    ptrdiff_t *idxp,\n    const ptrdiff_t *idxq,\n    ptrdiff_t *perm,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    float  *givnum,\n    const ptrdiff_t *ldgnum,\n    float  *c,\n    float  *s,\n    ptrdiff_t *info\n);\n\n/* Source: slasd8.f */\n#define slasd8 FORTRAN_WRAPPER(slasd8)\nextern void slasd8(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *k,\n    float  *d,\n    float  *z,\n    float  *vf,\n    float  *vl,\n    float  *difl,\n    float  *difr,\n    const ptrdiff_t *lddifr,\n    float  *dsigma,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slasda.f */\n#define slasda FORTRAN_WRAPPER(slasda)\nextern void slasda(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *sqre,\n    float  *d,\n    const float  *e,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *vt,\n    ptrdiff_t *k,\n    float  *difl,\n    float  *difr,\n    float  *z,\n    float  *poles,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    ptrdiff_t *perm,\n    float  *givnum,\n    float  *c,\n    float  *s,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: slasdq.f */\n#define slasdq FORTRAN_WRAPPER(slasdq)\nextern void slasdq(\n    const char   *uplo,\n    const ptrdiff_t *sqre,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncvt,\n    const ptrdiff_t *nru,\n    const ptrdiff_t *ncc,\n    float  *d,\n    float  *e,\n    float  *vt,\n    const ptrdiff_t *ldvt,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slasdt.f */\n#define slasdt FORTRAN_WRAPPER(slasdt)\nextern void slasdt(\n    const ptrdiff_t *n,\n    ptrdiff_t *lvl,\n    ptrdiff_t *nd,\n    ptrdiff_t *inode,\n    ptrdiff_t *ndiml,\n    ptrdiff_t *ndimr,\n    const ptrdiff_t *msub\n);\n\n/* Source: slaset.f */\n#define slaset FORTRAN_WRAPPER(slaset)\nextern void slaset(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *beta,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: slasq1.f */\n#define slasq1 FORTRAN_WRAPPER(slasq1)\nextern void slasq1(\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slasq2.f */\n#define slasq2 FORTRAN_WRAPPER(slasq2)\nextern void slasq2(\n    const ptrdiff_t *n,\n    float  *z,\n    ptrdiff_t *info\n);\n\n/* Source: slasq3.f */\n#define slasq3 FORTRAN_WRAPPER(slasq3)\nextern void slasq3(\n    const ptrdiff_t *i0,\n    const ptrdiff_t *n0,\n    const float  *z,\n    ptrdiff_t *pp,\n    float  *dmin,\n    float  *sigma,\n    float  *desig,\n    const float  *qmax,\n    ptrdiff_t *nfail,\n    ptrdiff_t *iter,\n    ptrdiff_t *ndiv,\n    const ptrdiff_t *ieee,\n    ptrdiff_t *ttype,\n    float  *dmin1,\n    float  *dmin2,\n    float  *dn,\n    float  *dn1,\n    float  *dn2,\n    float  *g,\n    float  *tau\n);\n\n/* Source: slasq4.f */\n#define slasq4 FORTRAN_WRAPPER(slasq4)\nextern void slasq4(\n    const ptrdiff_t *i0,\n    const ptrdiff_t *n0,\n    const float  *z,\n    const ptrdiff_t *pp,\n    ptrdiff_t *n0in,\n    const float  *dmin,\n    const float  *dmin1,\n    const float  *dmin2,\n    const float  *dn,\n    const float  *dn1,\n    const float  *dn2,\n    float  *tau,\n    ptrdiff_t *ttype,\n    float  *g\n);\n\n/* Source: slasq5.f */\n#define slasq5 FORTRAN_WRAPPER(slasq5)\nextern void slasq5(\n    const ptrdiff_t *i0,\n    const ptrdiff_t *n0,\n    const float  *z,\n    const ptrdiff_t *pp,\n    const float  *tau,\n    const float  *sigma,\n    float  *dmin,\n    float  *dmin1,\n    float  *dmin2,\n    float  *dn,\n    float  *dnm1,\n    float  *dnm2,\n    const ptrdiff_t *ieee,\n    const float  *eps\n);\n\n/* Source: slasq6.f */\n#define slasq6 FORTRAN_WRAPPER(slasq6)\nextern void slasq6(\n    const ptrdiff_t *i0,\n    const ptrdiff_t *n0,\n    const float  *z,\n    const ptrdiff_t *pp,\n    float  *dmin,\n    float  *dmin1,\n    float  *dmin2,\n    float  *dn,\n    float  *dnm1,\n    float  *dnm2\n);\n\n/* Source: slasr.f */\n#define slasr FORTRAN_WRAPPER(slasr)\nextern void slasr(\n    const char   *side,\n    const char   *pivot,\n    const char   *direct,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *c,\n    const float  *s,\n    float  *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: slasrt.f */\n#define slasrt FORTRAN_WRAPPER(slasrt)\nextern void slasrt(\n    const char   *id,\n    const ptrdiff_t *n,\n    float  *d,\n    ptrdiff_t *info\n);\n\n/* Source: slassq.f */\n#define slassq FORTRAN_WRAPPER(slassq)\nextern void slassq(\n    const ptrdiff_t *n,\n    const float  *x,\n    const ptrdiff_t *incx,\n    float  *scale,\n    float  *sumsq\n);\n\n/* Source: slasv2.f */\n#define slasv2 FORTRAN_WRAPPER(slasv2)\nextern void slasv2(\n    const float  *f,\n    const float  *g,\n    const float  *h,\n    float  *ssmin,\n    float  *ssmax,\n    float  *snr,\n    float  *csr,\n    float  *snl,\n    float  *csl\n);\n\n/* Source: slaswlq.f */\n#define slaswlq FORTRAN_WRAPPER(slaswlq)\nextern void slaswlq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: slaswp.f */\n#define slaswp FORTRAN_WRAPPER(slaswp)\nextern void slaswp(\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *k1,\n    const ptrdiff_t *k2,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *incx\n);\n\n/* Source: slasy2.f */\n#define slasy2 FORTRAN_WRAPPER(slasy2)\nextern void slasy2(\n    const ptrdiff_t *ltranl,\n    const ptrdiff_t *ltranr,\n    const ptrdiff_t *isgn,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    const float  *tl,\n    const ptrdiff_t *ldtl,\n    const float  *tr,\n    const ptrdiff_t *ldtr,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *scale,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *xnorm,\n    ptrdiff_t *info\n);\n\n/* Source: slasyf.f */\n#define slasyf FORTRAN_WRAPPER(slasyf)\nextern void slasyf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: slasyf_aa.f */\n#define slasyf_aa FORTRAN_WRAPPER(slasyf_aa)\nextern void slasyf_aa(\n    const char   *uplo,\n    const ptrdiff_t *j1_,\n    const ptrdiff_t *m,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *h,\n    const ptrdiff_t *ldh,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: slasyf_rk.f */\n#define slasyf_rk FORTRAN_WRAPPER(slasyf_rk)\nextern void slasyf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *w,\n    ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: slasyf_rook.f */\n#define slasyf_rook FORTRAN_WRAPPER(slasyf_rook)\nextern void slasyf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: slatbs.f */\n#define slatbs FORTRAN_WRAPPER(slatbs)\nextern void slatbs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *x,\n    float  *scale,\n    float  *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: slatdf.f */\n#define slatdf FORTRAN_WRAPPER(slatdf)\nextern void slatdf(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *n,\n    const float  *z,\n    const ptrdiff_t *ldz,\n    float  *rhs,\n    float  *rdsum,\n    float  *rdscal,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *jpiv\n);\n\n/* Source: slatps.f */\n#define slatps FORTRAN_WRAPPER(slatps)\nextern void slatps(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *x,\n    float  *scale,\n    float  *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: slatrd.f */\n#define slatrd FORTRAN_WRAPPER(slatrd)\nextern void slatrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *e,\n    float  *tau,\n    float  *w,\n    const ptrdiff_t *ldw\n);\n\n/* Source: slatrs.f */\n#define slatrs FORTRAN_WRAPPER(slatrs)\nextern void slatrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *x,\n    float  *scale,\n    float  *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: slatrz.f */\n#define slatrz FORTRAN_WRAPPER(slatrz)\nextern void slatrz(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work\n);\n\n/* Source: slatsqr.f */\n#define slatsqr FORTRAN_WRAPPER(slatsqr)\nextern void slatsqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: slauu2.f */\n#define slauu2 FORTRAN_WRAPPER(slauu2)\nextern void slauu2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: slauum.f */\n#define slauum FORTRAN_WRAPPER(slauum)\nextern void slauum(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: sopgtr.f */\n#define sopgtr FORTRAN_WRAPPER(sopgtr)\nextern void sopgtr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    const float  *tau,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sopmtr.f */\n#define sopmtr FORTRAN_WRAPPER(sopmtr)\nextern void sopmtr(\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *ap,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sorbdb.f */\n#define sorbdb FORTRAN_WRAPPER(sorbdb)\nextern void sorbdb(\n    const char   *trans,\n    const char   *signs,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x12,\n    const ptrdiff_t *ldx12,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *x22,\n    const ptrdiff_t *ldx22,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *tauq2,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorbdb1.f */\n#define sorbdb1 FORTRAN_WRAPPER(sorbdb1)\nextern void sorbdb1(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorbdb2.f */\n#define sorbdb2 FORTRAN_WRAPPER(sorbdb2)\nextern void sorbdb2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorbdb3.f */\n#define sorbdb3 FORTRAN_WRAPPER(sorbdb3)\nextern void sorbdb3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorbdb4.f */\n#define sorbdb4 FORTRAN_WRAPPER(sorbdb4)\nextern void sorbdb4(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *phi,\n    float  *taup1,\n    float  *taup2,\n    float  *tauq1,\n    float  *phantom,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorbdb5.f */\n#define sorbdb5 FORTRAN_WRAPPER(sorbdb5)\nextern void sorbdb5(\n    const ptrdiff_t *m1,\n    const ptrdiff_t *m2,\n    const ptrdiff_t *n,\n    float  *x1,\n    const ptrdiff_t *incx1,\n    float  *x2,\n    const ptrdiff_t *incx2,\n    float  *q1,\n    const ptrdiff_t *ldq1,\n    float  *q2,\n    const ptrdiff_t *ldq2,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorbdb6.f */\n#define sorbdb6 FORTRAN_WRAPPER(sorbdb6)\nextern void sorbdb6(\n    const ptrdiff_t *m1,\n    const ptrdiff_t *m2,\n    const ptrdiff_t *n,\n    float  *x1,\n    const ptrdiff_t *incx1,\n    float  *x2,\n    const ptrdiff_t *incx2,\n    float  *q1,\n    const ptrdiff_t *ldq1,\n    float  *q2,\n    const ptrdiff_t *ldq2,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorcsd.f */\n#define sorcsd FORTRAN_WRAPPER(sorcsd)\nextern void sorcsd(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const char   *jobv2t,\n    const char   *trans,\n    const char   *signs,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x12,\n    const ptrdiff_t *ldx12,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *x22,\n    const ptrdiff_t *ldx22,\n    float  *theta,\n    float  *u1,\n    const ptrdiff_t *ldu1,\n    float  *u2,\n    const ptrdiff_t *ldu2,\n    float  *v1t,\n    const ptrdiff_t *ldv1t,\n    float  *v2t,\n    const ptrdiff_t *ldv2t,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorcsd2by1.f */\n#define sorcsd2by1 FORTRAN_WRAPPER(sorcsd2by1)\nextern void sorcsd2by1(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    float  *x11,\n    const ptrdiff_t *ldx11,\n    float  *x21,\n    const ptrdiff_t *ldx21,\n    float  *theta,\n    float  *u1,\n    const ptrdiff_t *ldu1,\n    float  *u2,\n    const ptrdiff_t *ldu2,\n    float  *v1t,\n    const ptrdiff_t *ldv1t,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorg2l.f */\n#define sorg2l FORTRAN_WRAPPER(sorg2l)\nextern void sorg2l(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sorg2r.f */\n#define sorg2r FORTRAN_WRAPPER(sorg2r)\nextern void sorg2r(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sorgbr.f */\n#define sorgbr FORTRAN_WRAPPER(sorgbr)\nextern void sorgbr(\n    const char   *vect,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorghr.f */\n#define sorghr FORTRAN_WRAPPER(sorghr)\nextern void sorghr(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorgl2.f */\n#define sorgl2 FORTRAN_WRAPPER(sorgl2)\nextern void sorgl2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sorglq.f */\n#define sorglq FORTRAN_WRAPPER(sorglq)\nextern void sorglq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorgql.f */\n#define sorgql FORTRAN_WRAPPER(sorgql)\nextern void sorgql(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorgqr.f */\n#define sorgqr FORTRAN_WRAPPER(sorgqr)\nextern void sorgqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorgr2.f */\n#define sorgr2 FORTRAN_WRAPPER(sorgr2)\nextern void sorgr2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sorgrq.f */\n#define sorgrq FORTRAN_WRAPPER(sorgrq)\nextern void sorgrq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorgtr.f */\n#define sorgtr FORTRAN_WRAPPER(sorgtr)\nextern void sorgtr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorm22.f */\n#define sorm22 FORTRAN_WRAPPER(sorm22)\nextern void sorm22(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    const float  *q,\n    const ptrdiff_t *ldq,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorm2l.f */\n#define sorm2l FORTRAN_WRAPPER(sorm2l)\nextern void sorm2l(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sorm2r.f */\n#define sorm2r FORTRAN_WRAPPER(sorm2r)\nextern void sorm2r(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sormbr.f */\n#define sormbr FORTRAN_WRAPPER(sormbr)\nextern void sormbr(\n    const char   *vect,\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sormhr.f */\n#define sormhr FORTRAN_WRAPPER(sormhr)\nextern void sormhr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sorml2.f */\n#define sorml2 FORTRAN_WRAPPER(sorml2)\nextern void sorml2(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sormlq.f */\n#define sormlq FORTRAN_WRAPPER(sormlq)\nextern void sormlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sormql.f */\n#define sormql FORTRAN_WRAPPER(sormql)\nextern void sormql(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sormqr.f */\n#define sormqr FORTRAN_WRAPPER(sormqr)\nextern void sormqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sormr2.f */\n#define sormr2 FORTRAN_WRAPPER(sormr2)\nextern void sormr2(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sormr3.f */\n#define sormr3 FORTRAN_WRAPPER(sormr3)\nextern void sormr3(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sormrq.f */\n#define sormrq FORTRAN_WRAPPER(sormrq)\nextern void sormrq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sormrz.f */\n#define sormrz FORTRAN_WRAPPER(sormrz)\nextern void sormrz(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: sormtr.f */\n#define sormtr FORTRAN_WRAPPER(sormtr)\nextern void sormtr(\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *tau,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: spbcon.f */\n#define spbcon FORTRAN_WRAPPER(spbcon)\nextern void spbcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: spbequ.f */\n#define spbequ FORTRAN_WRAPPER(spbequ)\nextern void spbequ(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: spbrfs.f */\n#define spbrfs FORTRAN_WRAPPER(spbrfs)\nextern void spbrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *afb,\n    const ptrdiff_t *ldafb,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: spbstf.f */\n#define spbstf FORTRAN_WRAPPER(spbstf)\nextern void spbstf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: spbsv.f */\n#define spbsv FORTRAN_WRAPPER(spbsv)\nextern void spbsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: spbsvx.f */\n#define spbsvx FORTRAN_WRAPPER(spbsvx)\nextern void spbsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *afb,\n    const ptrdiff_t *ldafb,\n    char   *equed,\n    float  *s,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: spbtf2.f */\n#define spbtf2 FORTRAN_WRAPPER(spbtf2)\nextern void spbtf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: spbtrf.f */\n#define spbtrf FORTRAN_WRAPPER(spbtrf)\nextern void spbtrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: spbtrs.f */\n#define spbtrs FORTRAN_WRAPPER(spbtrs)\nextern void spbtrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: spftrf.f */\n#define spftrf FORTRAN_WRAPPER(spftrf)\nextern void spftrf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *info\n);\n\n/* Source: spftri.f */\n#define spftri FORTRAN_WRAPPER(spftri)\nextern void spftri(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *info\n);\n\n/* Source: spftrs.f */\n#define spftrs FORTRAN_WRAPPER(spftrs)\nextern void spftrs(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: spocon.f */\n#define spocon FORTRAN_WRAPPER(spocon)\nextern void spocon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: spoequ.f */\n#define spoequ FORTRAN_WRAPPER(spoequ)\nextern void spoequ(\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: spoequb.f */\n#define spoequb FORTRAN_WRAPPER(spoequb)\nextern void spoequb(\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: sporfs.f */\n#define sporfs FORTRAN_WRAPPER(sporfs)\nextern void sporfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *af,\n    const ptrdiff_t *ldaf,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sposv.f */\n#define sposv FORTRAN_WRAPPER(sposv)\nextern void sposv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sposvx.f */\n#define sposvx FORTRAN_WRAPPER(sposvx)\nextern void sposvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *af,\n    const ptrdiff_t *ldaf,\n    char   *equed,\n    float  *s,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: spotf2.f */\n#define spotf2 FORTRAN_WRAPPER(spotf2)\nextern void spotf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: spotrf.f */\n#define spotrf FORTRAN_WRAPPER(spotrf)\nextern void spotrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: spotrf2.f */\n#define spotrf2 FORTRAN_WRAPPER(spotrf2)\nextern void spotrf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: spotri.f */\n#define spotri FORTRAN_WRAPPER(spotri)\nextern void spotri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: spotrs.f */\n#define spotrs FORTRAN_WRAPPER(spotrs)\nextern void spotrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sppcon.f */\n#define sppcon FORTRAN_WRAPPER(sppcon)\nextern void sppcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sppequ.f */\n#define sppequ FORTRAN_WRAPPER(sppequ)\nextern void sppequ(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    ptrdiff_t *info\n);\n\n/* Source: spprfs.f */\n#define spprfs FORTRAN_WRAPPER(spprfs)\nextern void spprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const float  *afp,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sppsv.f */\n#define sppsv FORTRAN_WRAPPER(sppsv)\nextern void sppsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *ap,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sppsvx.f */\n#define sppsvx FORTRAN_WRAPPER(sppsvx)\nextern void sppsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *ap,\n    float  *afp,\n    char   *equed,\n    float  *s,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: spptrf.f */\n#define spptrf FORTRAN_WRAPPER(spptrf)\nextern void spptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: spptri.f */\n#define spptri FORTRAN_WRAPPER(spptri)\nextern void spptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: spptrs.f */\n#define spptrs FORTRAN_WRAPPER(spptrs)\nextern void spptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: spstf2.f */\n#define spstf2 FORTRAN_WRAPPER(spstf2)\nextern void spstf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *piv,\n    ptrdiff_t *rank,\n    const float  *tol,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: spstrf.f */\n#define spstrf FORTRAN_WRAPPER(spstrf)\nextern void spstrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *piv,\n    ptrdiff_t *rank,\n    const float  *tol,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sptcon.f */\n#define sptcon FORTRAN_WRAPPER(sptcon)\nextern void sptcon(\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *e,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: spteqr.f */\n#define spteqr FORTRAN_WRAPPER(spteqr)\nextern void spteqr(\n    const char   *compz,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sptrfs.f */\n#define sptrfs FORTRAN_WRAPPER(sptrfs)\nextern void sptrfs(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *d,\n    const float  *e,\n    const float  *df,\n    const float  *ef,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sptsv.f */\n#define sptsv FORTRAN_WRAPPER(sptsv)\nextern void sptsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *d,\n    float  *e,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sptsvx.f */\n#define sptsvx FORTRAN_WRAPPER(sptsvx)\nextern void sptsvx(\n    const char   *fact,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *d,\n    const float  *e,\n    float  *df,\n    float  *ef,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: spttrf.f */\n#define spttrf FORTRAN_WRAPPER(spttrf)\nextern void spttrf(\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    ptrdiff_t *info\n);\n\n/* Source: spttrs.f */\n#define spttrs FORTRAN_WRAPPER(spttrs)\nextern void spttrs(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *d,\n    const float  *e,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sptts2.f */\n#define sptts2 FORTRAN_WRAPPER(sptts2)\nextern void sptts2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *d,\n    const float  *e,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: srscl.f */\n#define srscl FORTRAN_WRAPPER(srscl)\nextern void srscl(\n    const ptrdiff_t *n,\n    const float  *sa,\n    float  *sx,\n    const ptrdiff_t *incx\n);\n\n/* Source: ssb2st_kernels.f */\n#define ssb2st_kernels FORTRAN_WRAPPER(ssb2st_kernels)\nextern void ssb2st_kernels(\n    char   *uplo,\n    ptrdiff_t *wantz,\n    ptrdiff_t *ttype,\n    ptrdiff_t *st,\n    ptrdiff_t *ed,\n    ptrdiff_t *sweep,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *ib,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *v,\n    float  *tau,\n    ptrdiff_t *ldvt,\n    float  *work\n);\n\n/* Source: ssbev.f */\n#define ssbev FORTRAN_WRAPPER(ssbev)\nextern void ssbev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssbev_2stage.f */\n#define ssbev_2stage FORTRAN_WRAPPER(ssbev_2stage)\nextern void ssbev_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssbevd.f */\n#define ssbevd FORTRAN_WRAPPER(ssbevd)\nextern void ssbevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssbevd_2stage.f */\n#define ssbevd_2stage FORTRAN_WRAPPER(ssbevd_2stage)\nextern void ssbevd_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssbevx.f */\n#define ssbevx FORTRAN_WRAPPER(ssbevx)\nextern void ssbevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: ssbevx_2stage.f */\n#define ssbevx_2stage FORTRAN_WRAPPER(ssbevx_2stage)\nextern void ssbevx_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *q,\n    ptrdiff_t *ldq,\n    float  *vl,\n    float  *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: ssbgst.f */\n#define ssbgst FORTRAN_WRAPPER(ssbgst)\nextern void ssbgst(\n    const char   *vect,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *bb,\n    const ptrdiff_t *ldbb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssbgv.f */\n#define ssbgv FORTRAN_WRAPPER(ssbgv)\nextern void ssbgv(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *bb,\n    const ptrdiff_t *ldbb,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssbgvd.f */\n#define ssbgvd FORTRAN_WRAPPER(ssbgvd)\nextern void ssbgvd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *bb,\n    const ptrdiff_t *ldbb,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssbgvx.f */\n#define ssbgvx FORTRAN_WRAPPER(ssbgvx)\nextern void ssbgvx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *bb,\n    const ptrdiff_t *ldbb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: ssbtrd.f */\n#define ssbtrd FORTRAN_WRAPPER(ssbtrd)\nextern void ssbtrd(\n    const char   *vect,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    float  *ab,\n    const ptrdiff_t *ldab,\n    float  *d,\n    float  *e,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssfrk.f */\n#define ssfrk FORTRAN_WRAPPER(ssfrk)\nextern void ssfrk(\n    const char   *transr,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const float  *alpha,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *beta,\n    float  *c\n);\n\n/* Source: sspcon.f */\n#define sspcon FORTRAN_WRAPPER(sspcon)\nextern void sspcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sspev.f */\n#define sspev FORTRAN_WRAPPER(sspev)\nextern void sspev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sspevd.f */\n#define sspevd FORTRAN_WRAPPER(sspevd)\nextern void sspevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: sspevx.f */\n#define sspevx FORTRAN_WRAPPER(sspevx)\nextern void sspevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: sspgst.f */\n#define sspgst FORTRAN_WRAPPER(sspgst)\nextern void sspgst(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const float  *bp,\n    ptrdiff_t *info\n);\n\n/* Source: sspgv.f */\n#define sspgv FORTRAN_WRAPPER(sspgv)\nextern void sspgv(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *bp,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sspgvd.f */\n#define sspgvd FORTRAN_WRAPPER(sspgvd)\nextern void sspgvd(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *bp,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: sspgvx.f */\n#define sspgvx FORTRAN_WRAPPER(sspgvx)\nextern void sspgvx(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *bp,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: ssprfs.f */\n#define ssprfs FORTRAN_WRAPPER(ssprfs)\nextern void ssprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const float  *afp,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sspsv.f */\n#define sspsv FORTRAN_WRAPPER(sspsv)\nextern void sspsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *ap,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sspsvx.f */\n#define sspsvx FORTRAN_WRAPPER(sspsvx)\nextern void sspsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    float  *afp,\n    ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssptrd.f */\n#define ssptrd FORTRAN_WRAPPER(ssptrd)\nextern void ssptrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    float  *d,\n    float  *e,\n    float  *tau,\n    ptrdiff_t *info\n);\n\n/* Source: ssptrf.f */\n#define ssptrf FORTRAN_WRAPPER(ssptrf)\nextern void ssptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: ssptri.f */\n#define ssptri FORTRAN_WRAPPER(ssptri)\nextern void ssptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *ap,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssptrs.f */\n#define ssptrs FORTRAN_WRAPPER(ssptrs)\nextern void ssptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: sstebz.f */\n#define sstebz FORTRAN_WRAPPER(sstebz)\nextern void sstebz(\n    const char   *range,\n    const char   *order,\n    const ptrdiff_t *n,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    const float  *d,\n    const float  *e,\n    ptrdiff_t *m,\n    ptrdiff_t *nsplit,\n    float  *w,\n    ptrdiff_t *iblock,\n    ptrdiff_t *isplit,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: sstedc.f */\n#define sstedc FORTRAN_WRAPPER(sstedc)\nextern void sstedc(\n    const char   *compz,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: sstegr.f */\n#define sstegr FORTRAN_WRAPPER(sstegr)\nextern void sstegr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: sstein.f */\n#define sstein FORTRAN_WRAPPER(sstein)\nextern void sstein(\n    const ptrdiff_t *n,\n    const float  *d,\n    const float  *e,\n    const ptrdiff_t *m,\n    const float  *w,\n    const ptrdiff_t *iblock,\n    const ptrdiff_t *isplit,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: sstemr.f */\n#define sstemr FORTRAN_WRAPPER(sstemr)\nextern void sstemr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *nzc,\n    ptrdiff_t *isuppz,\n    ptrdiff_t *tryrac,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssteqr.f */\n#define ssteqr FORTRAN_WRAPPER(ssteqr)\nextern void ssteqr(\n    const char   *compz,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssterf.f */\n#define ssterf FORTRAN_WRAPPER(ssterf)\nextern void ssterf(\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    ptrdiff_t *info\n);\n\n/* Source: sstev.f */\n#define sstev FORTRAN_WRAPPER(sstev)\nextern void sstev(\n    const char   *jobz,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: sstevd.f */\n#define sstevd FORTRAN_WRAPPER(sstevd)\nextern void sstevd(\n    const char   *jobz,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: sstevr.f */\n#define sstevr FORTRAN_WRAPPER(sstevr)\nextern void sstevr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: sstevx.f */\n#define sstevx FORTRAN_WRAPPER(sstevx)\nextern void sstevx(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    float  *d,\n    float  *e,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: ssycon.f */\n#define ssycon FORTRAN_WRAPPER(ssycon)\nextern void ssycon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssycon_3.f */\n#define ssycon_3 FORTRAN_WRAPPER(ssycon_3)\nextern void ssycon_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssycon_rook.f */\n#define ssycon_rook FORTRAN_WRAPPER(ssycon_rook)\nextern void ssycon_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const float  *anorm,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssyconv.f */\n#define ssyconv FORTRAN_WRAPPER(ssyconv)\nextern void ssyconv(\n    const char   *uplo,\n    const char   *way,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *e,\n    ptrdiff_t *info\n);\n\n/* Source: ssyconvf.f */\n#define ssyconvf FORTRAN_WRAPPER(ssyconvf)\nextern void ssyconvf(\n    char   *uplo,\n    char   *way,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: ssyconvf_rook.f */\n#define ssyconvf_rook FORTRAN_WRAPPER(ssyconvf_rook)\nextern void ssyconvf_rook(\n    char   *uplo,\n    char   *way,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: ssyequb.f */\n#define ssyequb FORTRAN_WRAPPER(ssyequb)\nextern void ssyequb(\n    char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *s,\n    float  *scond,\n    float  *amax,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssyev.f */\n#define ssyev FORTRAN_WRAPPER(ssyev)\nextern void ssyev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *w,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssyev_2stage.f */\n#define ssyev_2stage FORTRAN_WRAPPER(ssyev_2stage)\nextern void ssyev_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *w,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssyevd.f */\n#define ssyevd FORTRAN_WRAPPER(ssyevd)\nextern void ssyevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *w,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssyevd_2stage.f */\n#define ssyevd_2stage FORTRAN_WRAPPER(ssyevd_2stage)\nextern void ssyevd_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *w,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssyevr.f */\n#define ssyevr FORTRAN_WRAPPER(ssyevr)\nextern void ssyevr(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssyevr_2stage.f */\n#define ssyevr_2stage FORTRAN_WRAPPER(ssyevr_2stage)\nextern void ssyevr_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *vl,\n    float  *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssyevx.f */\n#define ssyevx FORTRAN_WRAPPER(ssyevx)\nextern void ssyevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: ssyevx_2stage.f */\n#define ssyevx_2stage FORTRAN_WRAPPER(ssyevx_2stage)\nextern void ssyevx_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *vl,\n    float  *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    ptrdiff_t *ldz,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: ssygs2.f */\n#define ssygs2 FORTRAN_WRAPPER(ssygs2)\nextern void ssygs2(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ssygst.f */\n#define ssygst FORTRAN_WRAPPER(ssygst)\nextern void ssygst(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ssygv.f */\n#define ssygv FORTRAN_WRAPPER(ssygv)\nextern void ssygv(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *w,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssygv_2stage.f */\n#define ssygv_2stage FORTRAN_WRAPPER(ssygv_2stage)\nextern void ssygv_2stage(\n    ptrdiff_t *itype,\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *b,\n    ptrdiff_t *ldb,\n    float  *w,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssygvd.f */\n#define ssygvd FORTRAN_WRAPPER(ssygvd)\nextern void ssygvd(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *w,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssygvx.f */\n#define ssygvx FORTRAN_WRAPPER(ssygvx)\nextern void ssygvx(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *vl,\n    const float  *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const float  *abstol,\n    ptrdiff_t *m,\n    float  *w,\n    float  *z,\n    const ptrdiff_t *ldz,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: ssyrfs.f */\n#define ssyrfs FORTRAN_WRAPPER(ssyrfs)\nextern void ssyrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssysv.f */\n#define ssysv FORTRAN_WRAPPER(ssysv)\nextern void ssysv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssysv_aa.f */\n#define ssysv_aa FORTRAN_WRAPPER(ssysv_aa)\nextern void ssysv_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssysv_rk.f */\n#define ssysv_rk FORTRAN_WRAPPER(ssysv_rk)\nextern void ssysv_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *b,\n    ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssysv_rook.f */\n#define ssysv_rook FORTRAN_WRAPPER(ssysv_rook)\nextern void ssysv_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssysvx.f */\n#define ssysvx FORTRAN_WRAPPER(ssysvx)\nextern void ssysvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *x,\n    const ptrdiff_t *ldx,\n    float  *rcond,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssyswapr.f */\n#define ssyswapr FORTRAN_WRAPPER(ssyswapr)\nextern void ssyswapr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *i1,\n    const ptrdiff_t *i2\n);\n\n/* Source: ssytd2.f */\n#define ssytd2 FORTRAN_WRAPPER(ssytd2)\nextern void ssytd2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tau,\n    ptrdiff_t *info\n);\n\n/* Source: ssytf2.f */\n#define ssytf2 FORTRAN_WRAPPER(ssytf2)\nextern void ssytf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: ssytf2_rk.f */\n#define ssytf2_rk FORTRAN_WRAPPER(ssytf2_rk)\nextern void ssytf2_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: ssytf2_rook.f */\n#define ssytf2_rook FORTRAN_WRAPPER(ssytf2_rook)\nextern void ssytf2_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrd.f */\n#define ssytrd FORTRAN_WRAPPER(ssytrd)\nextern void ssytrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrd_2stage.f */\n#define ssytrd_2stage FORTRAN_WRAPPER(ssytrd_2stage)\nextern void ssytrd_2stage(\n    char   *vect,\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *d,\n    float  *e,\n    float  *tau,\n    float  *hous2,\n    ptrdiff_t *lhous2,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrd_sb2st.f */\n#define ssytrd_sb2st FORTRAN_WRAPPER(ssytrd_sb2st)\nextern void ssytrd_sb2st(\n    char   *stage1,\n    char   *vect,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *d,\n    float  *e,\n    float  *hous,\n    ptrdiff_t *lhous,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrd_sy2sb.f */\n#define ssytrd_sy2sb FORTRAN_WRAPPER(ssytrd_sy2sb)\nextern void ssytrd_sy2sb(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *ab,\n    ptrdiff_t *ldab,\n    float  *tau,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrf.f */\n#define ssytrf FORTRAN_WRAPPER(ssytrf)\nextern void ssytrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrf_aa.f */\n#define ssytrf_aa FORTRAN_WRAPPER(ssytrf_aa)\nextern void ssytrf_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrf_rk.f */\n#define ssytrf_rk FORTRAN_WRAPPER(ssytrf_rk)\nextern void ssytrf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrf_rook.f */\n#define ssytrf_rook FORTRAN_WRAPPER(ssytrf_rook)\nextern void ssytrf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytri.f */\n#define ssytri FORTRAN_WRAPPER(ssytri)\nextern void ssytri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssytri2.f */\n#define ssytri2 FORTRAN_WRAPPER(ssytri2)\nextern void ssytri2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytri2x.f */\n#define ssytri2x FORTRAN_WRAPPER(ssytri2x)\nextern void ssytri2x(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: ssytri_3.f */\n#define ssytri_3 FORTRAN_WRAPPER(ssytri_3)\nextern void ssytri_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytri_3x.f */\n#define ssytri_3x FORTRAN_WRAPPER(ssytri_3x)\nextern void ssytri_3x(\n    char   *uplo,\n    ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: ssytri_rook.f */\n#define ssytri_rook FORTRAN_WRAPPER(ssytri_rook)\nextern void ssytri_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrs.f */\n#define ssytrs FORTRAN_WRAPPER(ssytrs)\nextern void ssytrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrs2.f */\n#define ssytrs2 FORTRAN_WRAPPER(ssytrs2)\nextern void ssytrs2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrs_3.f */\n#define ssytrs_3 FORTRAN_WRAPPER(ssytrs_3)\nextern void ssytrs_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    float  *a,\n    ptrdiff_t *lda,\n    float  *e,\n    ptrdiff_t *ipiv,\n    float  *b,\n    ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrs_aa.f */\n#define ssytrs_aa FORTRAN_WRAPPER(ssytrs_aa)\nextern void ssytrs_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ssytrs_rook.f */\n#define ssytrs_rook FORTRAN_WRAPPER(ssytrs_rook)\nextern void ssytrs_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: stbcon.f */\n#define stbcon FORTRAN_WRAPPER(stbcon)\nextern void stbcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: stbrfs.f */\n#define stbrfs FORTRAN_WRAPPER(stbrfs)\nextern void stbrfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: stbtrs.f */\n#define stbtrs FORTRAN_WRAPPER(stbtrs)\nextern void stbtrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const float  *ab,\n    const ptrdiff_t *ldab,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: stfsm.f */\n#define stfsm FORTRAN_WRAPPER(stfsm)\nextern void stfsm(\n    const char   *transr,\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *alpha,\n    const float  *a,\n    float  *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: stftri.f */\n#define stftri FORTRAN_WRAPPER(stftri)\nextern void stftri(\n    const char   *transr,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    float  *a,\n    ptrdiff_t *info\n);\n\n/* Source: stfttp.f */\n#define stfttp FORTRAN_WRAPPER(stfttp)\nextern void stfttp(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *arf,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: stfttr.f */\n#define stfttr FORTRAN_WRAPPER(stfttr)\nextern void stfttr(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *arf,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: stgevc.f */\n#define stgevc FORTRAN_WRAPPER(stgevc)\nextern void stgevc(\n    const char   *side,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const float  *s,\n    const ptrdiff_t *lds,\n    const float  *p,\n    const ptrdiff_t *ldp,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: stgex2.f */\n#define stgex2 FORTRAN_WRAPPER(stgex2)\nextern void stgex2(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *j1_,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: stgexc.f */\n#define stgexc FORTRAN_WRAPPER(stgexc)\nextern void stgexc(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ifst,\n    ptrdiff_t *ilst,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: stgsen.f */\n#define stgsen FORTRAN_WRAPPER(stgsen)\nextern void stgsen(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *alphar,\n    float  *alphai,\n    float  *beta,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *m,\n    float  *pl,\n    float  *pr,\n    float  *dif,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: stgsja.f */\n#define stgsja FORTRAN_WRAPPER(stgsja)\nextern void stgsja(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    const float  *tola,\n    const float  *tolb,\n    float  *alpha,\n    float  *beta,\n    float  *u,\n    const ptrdiff_t *ldu,\n    float  *v,\n    const ptrdiff_t *ldv,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *work,\n    ptrdiff_t *ncycle,\n    ptrdiff_t *info\n);\n\n/* Source: stgsna.f */\n#define stgsna FORTRAN_WRAPPER(stgsna)\nextern void stgsna(\n    const char   *job,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *vl,\n    const ptrdiff_t *ldvl,\n    const float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *s,\n    float  *dif,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: stgsy2.f */\n#define stgsy2 FORTRAN_WRAPPER(stgsy2)\nextern void stgsy2(\n    const char   *trans,\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    const ptrdiff_t *ldc,\n    const float  *d,\n    const ptrdiff_t *ldd,\n    const float  *e,\n    const ptrdiff_t *lde,\n    float  *f,\n    const ptrdiff_t *ldf,\n    float  *scale,\n    float  *rdsum,\n    float  *rdscal,\n    ptrdiff_t *iwork,\n    ptrdiff_t *pq,\n    ptrdiff_t *info\n);\n\n/* Source: stgsyl.f */\n#define stgsyl FORTRAN_WRAPPER(stgsyl)\nextern void stgsyl(\n    const char   *trans,\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    const ptrdiff_t *ldc,\n    const float  *d,\n    const ptrdiff_t *ldd,\n    const float  *e,\n    const ptrdiff_t *lde,\n    float  *f,\n    const ptrdiff_t *ldf,\n    float  *scale,\n    float  *dif,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: stpcon.f */\n#define stpcon FORTRAN_WRAPPER(stpcon)\nextern void stpcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: stplqt.f */\n#define stplqt FORTRAN_WRAPPER(stplqt)\nextern void stplqt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const ptrdiff_t *mb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: stplqt2.f */\n#define stplqt2 FORTRAN_WRAPPER(stplqt2)\nextern void stplqt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: stpmlqt.f */\n#define stpmlqt FORTRAN_WRAPPER(stpmlqt)\nextern void stpmlqt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const ptrdiff_t *mb,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: stpmqrt.f */\n#define stpmqrt FORTRAN_WRAPPER(stpmqrt)\nextern void stpmqrt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const ptrdiff_t *nb,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: stpqrt.f */\n#define stpqrt FORTRAN_WRAPPER(stpqrt)\nextern void stpqrt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const ptrdiff_t *nb,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: stpqrt2.f */\n#define stpqrt2 FORTRAN_WRAPPER(stpqrt2)\nextern void stpqrt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: stprfb.f */\n#define stprfb FORTRAN_WRAPPER(stprfb)\nextern void stprfb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const float  *v,\n    const ptrdiff_t *ldv,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    float  *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: stprfs.f */\n#define stprfs FORTRAN_WRAPPER(stprfs)\nextern void stprfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: stptri.f */\n#define stptri FORTRAN_WRAPPER(stptri)\nextern void stptri(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: stptrs.f */\n#define stptrs FORTRAN_WRAPPER(stptrs)\nextern void stptrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *ap,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: stpttf.f */\n#define stpttf FORTRAN_WRAPPER(stpttf)\nextern void stpttf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *arf,\n    ptrdiff_t *info\n);\n\n/* Source: stpttr.f */\n#define stpttr FORTRAN_WRAPPER(stpttr)\nextern void stpttr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *ap,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: strcon.f */\n#define strcon FORTRAN_WRAPPER(strcon)\nextern void strcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *rcond,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: strevc.f */\n#define strevc FORTRAN_WRAPPER(strevc)\nextern void strevc(\n    const char   *side,\n    const char   *howmny,\n    ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    float  *vl,\n    const ptrdiff_t *ldvl,\n    float  *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: strevc3.f */\n#define strevc3 FORTRAN_WRAPPER(strevc3)\nextern void strevc3(\n    char   *side,\n    char   *howmny,\n    ptrdiff_t *select,\n    ptrdiff_t *n,\n    float  *t,\n    ptrdiff_t *ldt,\n    float  *vl,\n    ptrdiff_t *ldvl,\n    float  *vr,\n    ptrdiff_t *ldvr,\n    ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: strexc.f */\n#define strexc FORTRAN_WRAPPER(strexc)\nextern void strexc(\n    const char   *compq,\n    const ptrdiff_t *n,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *ifst,\n    ptrdiff_t *ilst,\n    float  *work,\n    ptrdiff_t *info\n);\n\n/* Source: strrfs.f */\n#define strrfs FORTRAN_WRAPPER(strrfs)\nextern void strrfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    const float  *x,\n    const ptrdiff_t *ldx,\n    float  *ferr,\n    float  *berr,\n    float  *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: strsen.f */\n#define strsen FORTRAN_WRAPPER(strsen)\nextern void strsen(\n    const char   *job,\n    const char   *compq,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    float  *t,\n    const ptrdiff_t *ldt,\n    float  *q,\n    const ptrdiff_t *ldq,\n    float  *wr,\n    float  *wi,\n    ptrdiff_t *m,\n    float  *s,\n    float  *sep,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: strsna.f */\n#define strsna FORTRAN_WRAPPER(strsna)\nextern void strsna(\n    const char   *job,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const float  *t,\n    const ptrdiff_t *ldt,\n    const float  *vl,\n    const ptrdiff_t *ldvl,\n    const float  *vr,\n    const ptrdiff_t *ldvr,\n    float  *s,\n    float  *sep,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    float  *work,\n    const ptrdiff_t *ldwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: strsyl.f */\n#define strsyl FORTRAN_WRAPPER(strsyl)\nextern void strsyl(\n    const char   *trana,\n    const char   *tranb,\n    const ptrdiff_t *isgn,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    const float  *b,\n    const ptrdiff_t *ldb,\n    float  *c,\n    const ptrdiff_t *ldc,\n    float  *scale,\n    ptrdiff_t *info\n);\n\n/* Source: strti2.f */\n#define strti2 FORTRAN_WRAPPER(strti2)\nextern void strti2(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: strtri.f */\n#define strtri FORTRAN_WRAPPER(strtri)\nextern void strtri(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: strtrs.f */\n#define strtrs FORTRAN_WRAPPER(strtrs)\nextern void strtrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: strttf.f */\n#define strttf FORTRAN_WRAPPER(strttf)\nextern void strttf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *arf,\n    ptrdiff_t *info\n);\n\n/* Source: strttp.f */\n#define strttp FORTRAN_WRAPPER(strttp)\nextern void strttp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const float  *a,\n    const ptrdiff_t *lda,\n    float  *ap,\n    ptrdiff_t *info\n);\n\n/* Source: stzrzf.f */\n#define stzrzf FORTRAN_WRAPPER(stzrzf)\nextern void stzrzf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    float  *a,\n    const ptrdiff_t *lda,\n    float  *tau,\n    float  *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: xerbla_array.f */\n#define xerbla_array FORTRAN_WRAPPER(xerbla_array)\nextern void xerbla_array(\n    const char   *srname_array,\n    const ptrdiff_t *srname_len,\n    const ptrdiff_t *info\n);\n\n/* Source: zbbcsd.f */\n#define zbbcsd FORTRAN_WRAPPER(zbbcsd)\nextern void zbbcsd(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const char   *jobv2t,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *theta,\n    double *phi,\n    double *u1,\n    const ptrdiff_t *ldu1,\n    double *u2,\n    const ptrdiff_t *ldu2,\n    double *v1t,\n    const ptrdiff_t *ldv1t,\n    double *v2t,\n    const ptrdiff_t *ldv2t,\n    double *b11d,\n    double *b11e,\n    double *b12d,\n    double *b12e,\n    double *b21d,\n    double *b21e,\n    double *b22d,\n    double *b22e,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *info\n);\n\n/* Source: zbdsqr.f */\n#define zbdsqr FORTRAN_WRAPPER(zbdsqr)\nextern void zbdsqr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncvt,\n    const ptrdiff_t *nru,\n    const ptrdiff_t *ncc,\n    double *d,\n    double *e,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zcgesv.f */\n#define zcgesv FORTRAN_WRAPPER(zcgesv)\nextern void zcgesv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *work,\n    float  *swork,\n    double *rwork,\n    ptrdiff_t *iter,\n    ptrdiff_t *info\n);\n\n/* Source: zcposv.f */\n#define zcposv FORTRAN_WRAPPER(zcposv)\nextern void zcposv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *work,\n    float  *swork,\n    double *rwork,\n    ptrdiff_t *iter,\n    ptrdiff_t *info\n);\n\n/* Source: zdrscl.f */\n#define zdrscl FORTRAN_WRAPPER(zdrscl)\nextern void zdrscl(\n    const ptrdiff_t *n,\n    const double *sa,\n    double *sx,\n    const ptrdiff_t *incx\n);\n\n/* Source: zgbbrd.f */\n#define zgbbrd FORTRAN_WRAPPER(zgbbrd)\nextern void zgbbrd(\n    const char   *vect,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ncc,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *d,\n    double *e,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *pt,\n    const ptrdiff_t *ldpt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgbcon.f */\n#define zgbcon FORTRAN_WRAPPER(zgbcon)\nextern void zgbcon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgbequ.f */\n#define zgbequ FORTRAN_WRAPPER(zgbequ)\nextern void zgbequ(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *r,\n    double *c,\n    double *rowcnd,\n    double *colcnd,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: zgbequb.f */\n#define zgbequb FORTRAN_WRAPPER(zgbequb)\nextern void zgbequb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *r,\n    double *c,\n    double *rowcnd,\n    double *colcnd,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: zgbrfs.f */\n#define zgbrfs FORTRAN_WRAPPER(zgbrfs)\nextern void zgbrfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const double *afb,\n    const ptrdiff_t *ldafb,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgbsv.f */\n#define zgbsv FORTRAN_WRAPPER(zgbsv)\nextern void zgbsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zgbsvx.f */\n#define zgbsvx FORTRAN_WRAPPER(zgbsvx)\nextern void zgbsvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *afb,\n    const ptrdiff_t *ldafb,\n    ptrdiff_t *ipiv,\n    char   *equed,\n    double *r,\n    double *c,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgbtf2.f */\n#define zgbtf2 FORTRAN_WRAPPER(zgbtf2)\nextern void zgbtf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zgbtrf.f */\n#define zgbtrf FORTRAN_WRAPPER(zgbtrf)\nextern void zgbtrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zgbtrs.f */\n#define zgbtrs FORTRAN_WRAPPER(zgbtrs)\nextern void zgbtrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zgebak.f */\n#define zgebak FORTRAN_WRAPPER(zgebak)\nextern void zgebak(\n    const char   *job,\n    const char   *side,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const double *scale,\n    const ptrdiff_t *m,\n    double *v,\n    const ptrdiff_t *ldv,\n    ptrdiff_t *info\n);\n\n/* Source: zgebal.f */\n#define zgebal FORTRAN_WRAPPER(zgebal)\nextern void zgebal(\n    const char   *job,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    double *scale,\n    ptrdiff_t *info\n);\n\n/* Source: zgebd2.f */\n#define zgebd2 FORTRAN_WRAPPER(zgebd2)\nextern void zgebd2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tauq,\n    double *taup,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgebrd.f */\n#define zgebrd FORTRAN_WRAPPER(zgebrd)\nextern void zgebrd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tauq,\n    double *taup,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgecon.f */\n#define zgecon FORTRAN_WRAPPER(zgecon)\nextern void zgecon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeequ.f */\n#define zgeequ FORTRAN_WRAPPER(zgeequ)\nextern void zgeequ(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *r,\n    double *c,\n    double *rowcnd,\n    double *colcnd,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: zgeequb.f */\n#define zgeequb FORTRAN_WRAPPER(zgeequb)\nextern void zgeequb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *r,\n    double *c,\n    double *rowcnd,\n    double *colcnd,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: zgees.f */\n#define zgees FORTRAN_WRAPPER(zgees)\nextern void zgees(\n    const char   *jobvs,\n    const char   *sort,\n    ptrdiff_t (*select)(),\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *sdim,\n    double *w,\n    double *vs,\n    const ptrdiff_t *ldvs,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeesx.f */\n#define zgeesx FORTRAN_WRAPPER(zgeesx)\nextern void zgeesx(\n    const char   *jobvs,\n    const char   *sort,\n    ptrdiff_t (*select)(),\n    const char   *sense,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *sdim,\n    double *w,\n    double *vs,\n    const ptrdiff_t *ldvs,\n    double *rconde,\n    double *rcondv,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeev.f */\n#define zgeev FORTRAN_WRAPPER(zgeev)\nextern void zgeev(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *w,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeevx.f */\n#define zgeevx FORTRAN_WRAPPER(zgeevx)\nextern void zgeevx(\n    const char   *balanc,\n    const char   *jobvl,\n    const char   *jobvr,\n    const char   *sense,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *w,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    double *scale,\n    double *abnrm,\n    double *rconde,\n    double *rcondv,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgehd2.f */\n#define zgehd2 FORTRAN_WRAPPER(zgehd2)\nextern void zgehd2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgehrd.f */\n#define zgehrd FORTRAN_WRAPPER(zgehrd)\nextern void zgehrd(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgejsv.f */\n#define zgejsv FORTRAN_WRAPPER(zgejsv)\nextern void zgejsv(\n    const char   *joba,\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobr,\n    const char   *jobt,\n    const char   *jobp,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *sva,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *cwork,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgelq.f */\n#define zgelq FORTRAN_WRAPPER(zgelq)\nextern void zgelq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *tsize,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgelq2.f */\n#define zgelq2 FORTRAN_WRAPPER(zgelq2)\nextern void zgelq2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgelqf.f */\n#define zgelqf FORTRAN_WRAPPER(zgelqf)\nextern void zgelqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgelqt.f */\n#define zgelqt FORTRAN_WRAPPER(zgelqt)\nextern void zgelqt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgelqt3.f */\n#define zgelqt3 FORTRAN_WRAPPER(zgelqt3)\nextern void zgelqt3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: zgels.f */\n#define zgels FORTRAN_WRAPPER(zgels)\nextern void zgels(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgelsd.f */\n#define zgelsd FORTRAN_WRAPPER(zgelsd)\nextern void zgelsd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *s,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgelss.f */\n#define zgelss FORTRAN_WRAPPER(zgelss)\nextern void zgelss(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *s,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgelsy.f */\n#define zgelsy FORTRAN_WRAPPER(zgelsy)\nextern void zgelsy(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *jpvt,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgemlq.f */\n#define zgemlq FORTRAN_WRAPPER(zgemlq)\nextern void zgemlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *t,\n    const ptrdiff_t *tsize,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgemlqt.f */\n#define zgemlqt FORTRAN_WRAPPER(zgemlqt)\nextern void zgemlqt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgemqr.f */\n#define zgemqr FORTRAN_WRAPPER(zgemqr)\nextern void zgemqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *t,\n    const ptrdiff_t *tsize,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgemqrt.f */\n#define zgemqrt FORTRAN_WRAPPER(zgemqrt)\nextern void zgemqrt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgeql2.f */\n#define zgeql2 FORTRAN_WRAPPER(zgeql2)\nextern void zgeql2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqlf.f */\n#define zgeqlf FORTRAN_WRAPPER(zgeqlf)\nextern void zgeqlf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqp3.f */\n#define zgeqp3 FORTRAN_WRAPPER(zgeqp3)\nextern void zgeqp3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqpf.f */\n#define zgeqpf FORTRAN_WRAPPER(zgeqpf)\nextern void zgeqpf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    double *tau,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqr.f */\n#define zgeqr FORTRAN_WRAPPER(zgeqr)\nextern void zgeqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *tsize,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqr2.f */\n#define zgeqr2 FORTRAN_WRAPPER(zgeqr2)\nextern void zgeqr2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqr2p.f */\n#define zgeqr2p FORTRAN_WRAPPER(zgeqr2p)\nextern void zgeqr2p(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqrf.f */\n#define zgeqrf FORTRAN_WRAPPER(zgeqrf)\nextern void zgeqrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqrfp.f */\n#define zgeqrfp FORTRAN_WRAPPER(zgeqrfp)\nextern void zgeqrfp(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqrt.f */\n#define zgeqrt FORTRAN_WRAPPER(zgeqrt)\nextern void zgeqrt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqrt2.f */\n#define zgeqrt2 FORTRAN_WRAPPER(zgeqrt2)\nextern void zgeqrt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: zgeqrt3.f */\n#define zgeqrt3 FORTRAN_WRAPPER(zgeqrt3)\nextern void zgeqrt3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: zgerfs.f */\n#define zgerfs FORTRAN_WRAPPER(zgerfs)\nextern void zgerfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgerq2.f */\n#define zgerq2 FORTRAN_WRAPPER(zgerq2)\nextern void zgerq2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgerqf.f */\n#define zgerqf FORTRAN_WRAPPER(zgerqf)\nextern void zgerqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgesc2.f */\n#define zgesc2 FORTRAN_WRAPPER(zgesc2)\nextern void zgesc2(\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *rhs,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *jpiv,\n    double *scale\n);\n\n/* Source: zgesdd.f */\n#define zgesdd FORTRAN_WRAPPER(zgesdd)\nextern void zgesdd(\n    const char   *jobz,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgesv.f */\n#define zgesv FORTRAN_WRAPPER(zgesv)\nextern void zgesv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zgesvd.f */\n#define zgesvd FORTRAN_WRAPPER(zgesvd)\nextern void zgesvd(\n    const char   *jobu,\n    const char   *jobvt,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgesvdx.f */\n#define zgesvdx FORTRAN_WRAPPER(zgesvdx)\nextern void zgesvdx(\n    const char   *jobu,\n    const char   *jobvt,\n    const char   *range,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *ns,\n    double *s,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *vt,\n    const ptrdiff_t *ldvt,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgesvj.f */\n#define zgesvj FORTRAN_WRAPPER(zgesvj)\nextern void zgesvj(\n    const char   *joba,\n    const char   *jobu,\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *sva,\n    const ptrdiff_t *mv,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *cwork,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgesvx.f */\n#define zgesvx FORTRAN_WRAPPER(zgesvx)\nextern void zgesvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    char   *equed,\n    double *r,\n    double *c,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgetc2.f */\n#define zgetc2 FORTRAN_WRAPPER(zgetc2)\nextern void zgetc2(\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *jpiv,\n    ptrdiff_t *info\n);\n\n/* Source: zgetf2.f */\n#define zgetf2 FORTRAN_WRAPPER(zgetf2)\nextern void zgetf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zgetrf.f */\n#define zgetrf FORTRAN_WRAPPER(zgetrf)\nextern void zgetrf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zgetrf2.f */\n#define zgetrf2 FORTRAN_WRAPPER(zgetrf2)\nextern void zgetrf2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zgetri.f */\n#define zgetri FORTRAN_WRAPPER(zgetri)\nextern void zgetri(\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgetrs.f */\n#define zgetrs FORTRAN_WRAPPER(zgetrs)\nextern void zgetrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zgetsls.f */\n#define zgetsls FORTRAN_WRAPPER(zgetsls)\nextern void zgetsls(\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggbak.f */\n#define zggbak FORTRAN_WRAPPER(zggbak)\nextern void zggbak(\n    const char   *job,\n    const char   *side,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const double *lscale,\n    const double *rscale,\n    const ptrdiff_t *m,\n    double *v,\n    const ptrdiff_t *ldv,\n    ptrdiff_t *info\n);\n\n/* Source: zggbal.f */\n#define zggbal FORTRAN_WRAPPER(zggbal)\nextern void zggbal(\n    const char   *job,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    double *lscale,\n    double *rscale,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgges.f */\n#define zgges FORTRAN_WRAPPER(zgges)\nextern void zgges(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    double *alpha,\n    double *beta,\n    double *vsl,\n    const ptrdiff_t *ldvsl,\n    double *vsr,\n    const ptrdiff_t *ldvsr,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgges3.f */\n#define zgges3 FORTRAN_WRAPPER(zgges3)\nextern void zgges3(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    double *alpha,\n    double *beta,\n    double *vsl,\n    const ptrdiff_t *ldvsl,\n    double *vsr,\n    const ptrdiff_t *ldvsr,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggesx.f */\n#define zggesx FORTRAN_WRAPPER(zggesx)\nextern void zggesx(\n    const char   *jobvsl,\n    const char   *jobvsr,\n    const char   *sort,\n    ptrdiff_t (*selctg)(),\n    const char   *sense,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *sdim,\n    double *alpha,\n    double *beta,\n    double *vsl,\n    const ptrdiff_t *ldvsl,\n    double *vsr,\n    const ptrdiff_t *ldvsr,\n    double *rconde,\n    double *rcondv,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggev.f */\n#define zggev FORTRAN_WRAPPER(zggev)\nextern void zggev(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggev3.f */\n#define zggev3 FORTRAN_WRAPPER(zggev3)\nextern void zggev3(\n    const char   *jobvl,\n    const char   *jobvr,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggevx.f */\n#define zggevx FORTRAN_WRAPPER(zggevx)\nextern void zggevx(\n    const char   *balanc,\n    const char   *jobvl,\n    const char   *jobvr,\n    const char   *sense,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    ptrdiff_t *ilo,\n    ptrdiff_t *ihi,\n    double *lscale,\n    double *rscale,\n    double *abnrm,\n    double *bbnrm,\n    double *rconde,\n    double *rcondv,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *bwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggglm.f */\n#define zggglm FORTRAN_WRAPPER(zggglm)\nextern void zggglm(\n    const ptrdiff_t *n,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *d,\n    double *x,\n    double *y,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgghd3.f */\n#define zgghd3 FORTRAN_WRAPPER(zgghd3)\nextern void zgghd3(\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgghrd.f */\n#define zgghrd FORTRAN_WRAPPER(zgghrd)\nextern void zgghrd(\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *info\n);\n\n/* Source: zgglse.f */\n#define zgglse FORTRAN_WRAPPER(zgglse)\nextern void zgglse(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    double *d,\n    double *x,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggqrf.f */\n#define zggqrf FORTRAN_WRAPPER(zggqrf)\nextern void zggqrf(\n    const ptrdiff_t *n,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    double *a,\n    const ptrdiff_t *lda,\n    double *taua,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *taub,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggrqf.f */\n#define zggrqf FORTRAN_WRAPPER(zggrqf)\nextern void zggrqf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *taua,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *taub,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggsvd3.f */\n#define zggsvd3 FORTRAN_WRAPPER(zggsvd3)\nextern void zggsvd3(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *p,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zggsvp3.f */\n#define zggsvp3 FORTRAN_WRAPPER(zggsvp3)\nextern void zggsvp3(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *tola,\n    const double *tolb,\n    ptrdiff_t *k,\n    ptrdiff_t *l,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    ptrdiff_t *iwork,\n    double *rwork,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgsvj0.f */\n#define zgsvj0 FORTRAN_WRAPPER(zgsvj0)\nextern void zgsvj0(\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *sva,\n    const ptrdiff_t *mv,\n    double *v,\n    const ptrdiff_t *ldv,\n    const double *eps,\n    const double *sfmin,\n    const double *tol,\n    const ptrdiff_t *nsweep,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgsvj1.f */\n#define zgsvj1 FORTRAN_WRAPPER(zgsvj1)\nextern void zgsvj1(\n    const char   *jobv,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *sva,\n    const ptrdiff_t *mv,\n    double *v,\n    const ptrdiff_t *ldv,\n    const double *eps,\n    const double *sfmin,\n    const double *tol,\n    const ptrdiff_t *nsweep,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgtcon.f */\n#define zgtcon FORTRAN_WRAPPER(zgtcon)\nextern void zgtcon(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *du2,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zgtrfs.f */\n#define zgtrfs FORTRAN_WRAPPER(zgtrfs)\nextern void zgtrfs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *dlf,\n    const double *df,\n    const double *duf,\n    const double *du2,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgtsv.f */\n#define zgtsv FORTRAN_WRAPPER(zgtsv)\nextern void zgtsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *dl,\n    double *d,\n    double *du,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zgtsvx.f */\n#define zgtsvx FORTRAN_WRAPPER(zgtsvx)\nextern void zgtsvx(\n    const char   *fact,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *dl,\n    const double *d,\n    const double *du,\n    double *dlf,\n    double *df,\n    double *duf,\n    double *du2,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zgttrf.f */\n#define zgttrf FORTRAN_WRAPPER(zgttrf)\nextern void zgttrf(\n    const ptrdiff_t *n,\n    double *dl,\n    double *d,\n    double *du,\n    double *du2,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zgttrs.f */\n#define zgttrs FORTRAN_WRAPPER(zgttrs)\nextern void zgttrs(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *du2,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zgtts2.f */\n#define zgtts2 FORTRAN_WRAPPER(zgtts2)\nextern void zgtts2(\n    const ptrdiff_t *itrans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *du2,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: zhb2st_kernels.f */\n#define zhb2st_kernels FORTRAN_WRAPPER(zhb2st_kernels)\nextern void zhb2st_kernels(\n    char   *uplo,\n    ptrdiff_t *wantz,\n    ptrdiff_t *ttype,\n    ptrdiff_t *st,\n    ptrdiff_t *ed,\n    ptrdiff_t *sweep,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *ib,\n    double *a,\n    ptrdiff_t *lda,\n    double *v,\n    double *tau,\n    ptrdiff_t *ldvt,\n    double *work\n);\n\n/* Source: zhbev.f */\n#define zhbev FORTRAN_WRAPPER(zhbev)\nextern void zhbev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhbev_2stage.f */\n#define zhbev_2stage FORTRAN_WRAPPER(zhbev_2stage)\nextern void zhbev_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhbevd.f */\n#define zhbevd FORTRAN_WRAPPER(zhbevd)\nextern void zhbevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhbevd_2stage.f */\n#define zhbevd_2stage FORTRAN_WRAPPER(zhbevd_2stage)\nextern void zhbevd_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhbevx.f */\n#define zhbevx FORTRAN_WRAPPER(zhbevx)\nextern void zhbevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *q,\n    const ptrdiff_t *ldq,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: zhbevx_2stage.f */\n#define zhbevx_2stage FORTRAN_WRAPPER(zhbevx_2stage)\nextern void zhbevx_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *q,\n    ptrdiff_t *ldq,\n    double *vl,\n    double *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: zhbgst.f */\n#define zhbgst FORTRAN_WRAPPER(zhbgst)\nextern void zhbgst(\n    const char   *vect,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    double *ab,\n    const ptrdiff_t *ldab,\n    const double *bb,\n    const ptrdiff_t *ldbb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhbgv.f */\n#define zhbgv FORTRAN_WRAPPER(zhbgv)\nextern void zhbgv(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *bb,\n    const ptrdiff_t *ldbb,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhbgvd.f */\n#define zhbgvd FORTRAN_WRAPPER(zhbgvd)\nextern void zhbgvd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *bb,\n    const ptrdiff_t *ldbb,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhbgvx.f */\n#define zhbgvx FORTRAN_WRAPPER(zhbgvx)\nextern void zhbgvx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ka,\n    const ptrdiff_t *kb,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *bb,\n    const ptrdiff_t *ldbb,\n    double *q,\n    const ptrdiff_t *ldq,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: zhbtrd.f */\n#define zhbtrd FORTRAN_WRAPPER(zhbtrd)\nextern void zhbtrd(\n    const char   *vect,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *d,\n    double *e,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zhecon.f */\n#define zhecon FORTRAN_WRAPPER(zhecon)\nextern void zhecon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zhecon_3.f */\n#define zhecon_3 FORTRAN_WRAPPER(zhecon_3)\nextern void zhecon_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zhecon_rook.f */\n#define zhecon_rook FORTRAN_WRAPPER(zhecon_rook)\nextern void zhecon_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zheequb.f */\n#define zheequb FORTRAN_WRAPPER(zheequb)\nextern void zheequb(\n    char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *scond,\n    double *amax,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zheev.f */\n#define zheev FORTRAN_WRAPPER(zheev)\nextern void zheev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *w,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zheev_2stage.f */\n#define zheev_2stage FORTRAN_WRAPPER(zheev_2stage)\nextern void zheev_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *w,\n    double *work,\n    ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zheevd.f */\n#define zheevd FORTRAN_WRAPPER(zheevd)\nextern void zheevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *w,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zheevd_2stage.f */\n#define zheevd_2stage FORTRAN_WRAPPER(zheevd_2stage)\nextern void zheevd_2stage(\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *w,\n    double *work,\n    ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zheevr.f */\n#define zheevr FORTRAN_WRAPPER(zheevr)\nextern void zheevr(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zheevr_2stage.f */\n#define zheevr_2stage FORTRAN_WRAPPER(zheevr_2stage)\nextern void zheevr_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *vl,\n    double *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    double *work,\n    ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zheevx.f */\n#define zheevx FORTRAN_WRAPPER(zheevx)\nextern void zheevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: zheevx_2stage.f */\n#define zheevx_2stage FORTRAN_WRAPPER(zheevx_2stage)\nextern void zheevx_2stage(\n    char   *jobz,\n    char   *range,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *vl,\n    double *vu,\n    ptrdiff_t *il,\n    ptrdiff_t *iu,\n    double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: zhegs2.f */\n#define zhegs2 FORTRAN_WRAPPER(zhegs2)\nextern void zhegs2(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zhegst.f */\n#define zhegst FORTRAN_WRAPPER(zhegst)\nextern void zhegst(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zhegv.f */\n#define zhegv FORTRAN_WRAPPER(zhegv)\nextern void zhegv(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *w,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhegv_2stage.f */\n#define zhegv_2stage FORTRAN_WRAPPER(zhegv_2stage)\nextern void zhegv_2stage(\n    ptrdiff_t *itype,\n    char   *jobz,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *b,\n    ptrdiff_t *ldb,\n    double *w,\n    double *work,\n    ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhegvd.f */\n#define zhegvd FORTRAN_WRAPPER(zhegvd)\nextern void zhegvd(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *w,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhegvx.f */\n#define zhegvx FORTRAN_WRAPPER(zhegvx)\nextern void zhegvx(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: zherfs.f */\n#define zherfs FORTRAN_WRAPPER(zherfs)\nextern void zherfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhesv.f */\n#define zhesv FORTRAN_WRAPPER(zhesv)\nextern void zhesv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhesv_aa.f */\n#define zhesv_aa FORTRAN_WRAPPER(zhesv_aa)\nextern void zhesv_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhesv_rk.f */\n#define zhesv_rk FORTRAN_WRAPPER(zhesv_rk)\nextern void zhesv_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *b,\n    ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhesv_rook.f */\n#define zhesv_rook FORTRAN_WRAPPER(zhesv_rook)\nextern void zhesv_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhesvx.f */\n#define zhesvx FORTRAN_WRAPPER(zhesvx)\nextern void zhesvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zheswapr.f */\n#define zheswapr FORTRAN_WRAPPER(zheswapr)\nextern void zheswapr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *i1,\n    const ptrdiff_t *i2\n);\n\n/* Source: zhetd2.f */\n#define zhetd2 FORTRAN_WRAPPER(zhetd2)\nextern void zhetd2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tau,\n    ptrdiff_t *info\n);\n\n/* Source: zhetf2.f */\n#define zhetf2 FORTRAN_WRAPPER(zhetf2)\nextern void zhetf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zhetf2_rk.f */\n#define zhetf2_rk FORTRAN_WRAPPER(zhetf2_rk)\nextern void zhetf2_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zhetf2_rook.f */\n#define zhetf2_rook FORTRAN_WRAPPER(zhetf2_rook)\nextern void zhetf2_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrd.f */\n#define zhetrd FORTRAN_WRAPPER(zhetrd)\nextern void zhetrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrd_2stage.f */\n#define zhetrd_2stage FORTRAN_WRAPPER(zhetrd_2stage)\nextern void zhetrd_2stage(\n    char   *vect,\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tau,\n    double *hous2,\n    ptrdiff_t *lhous2,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrd_hb2st.f */\n#define zhetrd_hb2st FORTRAN_WRAPPER(zhetrd_hb2st)\nextern void zhetrd_hb2st(\n    char   *stage1,\n    char   *vect,\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *d,\n    double *e,\n    double *hous,\n    ptrdiff_t *lhous,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrd_he2hb.f */\n#define zhetrd_he2hb FORTRAN_WRAPPER(zhetrd_he2hb)\nextern void zhetrd_he2hb(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *kd,\n    double *a,\n    ptrdiff_t *lda,\n    double *ab,\n    ptrdiff_t *ldab,\n    double *tau,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrf.f */\n#define zhetrf FORTRAN_WRAPPER(zhetrf)\nextern void zhetrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrf_aa.f */\n#define zhetrf_aa FORTRAN_WRAPPER(zhetrf_aa)\nextern void zhetrf_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrf_rk.f */\n#define zhetrf_rk FORTRAN_WRAPPER(zhetrf_rk)\nextern void zhetrf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrf_rook.f */\n#define zhetrf_rook FORTRAN_WRAPPER(zhetrf_rook)\nextern void zhetrf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetri.f */\n#define zhetri FORTRAN_WRAPPER(zhetri)\nextern void zhetri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zhetri2.f */\n#define zhetri2 FORTRAN_WRAPPER(zhetri2)\nextern void zhetri2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetri2x.f */\n#define zhetri2x FORTRAN_WRAPPER(zhetri2x)\nextern void zhetri2x(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: zhetri_3.f */\n#define zhetri_3 FORTRAN_WRAPPER(zhetri_3)\nextern void zhetri_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetri_3x.f */\n#define zhetri_3x FORTRAN_WRAPPER(zhetri_3x)\nextern void zhetri_3x(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: zhetri_rook.f */\n#define zhetri_rook FORTRAN_WRAPPER(zhetri_rook)\nextern void zhetri_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrs.f */\n#define zhetrs FORTRAN_WRAPPER(zhetrs)\nextern void zhetrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrs2.f */\n#define zhetrs2 FORTRAN_WRAPPER(zhetrs2)\nextern void zhetrs2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrs_3.f */\n#define zhetrs_3 FORTRAN_WRAPPER(zhetrs_3)\nextern void zhetrs_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *b,\n    ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrs_aa.f */\n#define zhetrs_aa FORTRAN_WRAPPER(zhetrs_aa)\nextern void zhetrs_aa(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhetrs_rook.f */\n#define zhetrs_rook FORTRAN_WRAPPER(zhetrs_rook)\nextern void zhetrs_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zhfrk.f */\n#define zhfrk FORTRAN_WRAPPER(zhfrk)\nextern void zhfrk(\n    const char   *transr,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *beta,\n    double *c\n);\n\n/* Source: zhgeqz.f */\n#define zhgeqz FORTRAN_WRAPPER(zhgeqz)\nextern void zhgeqz(\n    const char   *job,\n    const char   *compq,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *alpha,\n    double *beta,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhpcon.f */\n#define zhpcon FORTRAN_WRAPPER(zhpcon)\nextern void zhpcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zhpev.f */\n#define zhpev FORTRAN_WRAPPER(zhpev)\nextern void zhpev(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhpevd.f */\n#define zhpevd FORTRAN_WRAPPER(zhpevd)\nextern void zhpevd(\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhpevx.f */\n#define zhpevx FORTRAN_WRAPPER(zhpevx)\nextern void zhpevx(\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: zhpgst.f */\n#define zhpgst FORTRAN_WRAPPER(zhpgst)\nextern void zhpgst(\n    const ptrdiff_t *itype,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const double *bp,\n    ptrdiff_t *info\n);\n\n/* Source: zhpgv.f */\n#define zhpgv FORTRAN_WRAPPER(zhpgv)\nextern void zhpgv(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *bp,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhpgvd.f */\n#define zhpgvd FORTRAN_WRAPPER(zhpgvd)\nextern void zhpgvd(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *bp,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhpgvx.f */\n#define zhpgvx FORTRAN_WRAPPER(zhpgvx)\nextern void zhpgvx(\n    const ptrdiff_t *itype,\n    const char   *jobz,\n    const char   *range,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *bp,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: zhprfs.f */\n#define zhprfs FORTRAN_WRAPPER(zhprfs)\nextern void zhprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const double *afp,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhpsv.f */\n#define zhpsv FORTRAN_WRAPPER(zhpsv)\nextern void zhpsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *ap,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zhpsvx.f */\n#define zhpsvx FORTRAN_WRAPPER(zhpsvx)\nextern void zhpsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    double *afp,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zhptrd.f */\n#define zhptrd FORTRAN_WRAPPER(zhptrd)\nextern void zhptrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    double *d,\n    double *e,\n    double *tau,\n    ptrdiff_t *info\n);\n\n/* Source: zhptrf.f */\n#define zhptrf FORTRAN_WRAPPER(zhptrf)\nextern void zhptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zhptri.f */\n#define zhptri FORTRAN_WRAPPER(zhptri)\nextern void zhptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zhptrs.f */\n#define zhptrs FORTRAN_WRAPPER(zhptrs)\nextern void zhptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zhsein.f */\n#define zhsein FORTRAN_WRAPPER(zhsein)\nextern void zhsein(\n    const char   *side,\n    const char   *eigsrc,\n    const char   *initv,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const double *h,\n    const ptrdiff_t *ldh,\n    double *w,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    double *rwork,\n    ptrdiff_t *ifaill,\n    ptrdiff_t *ifailr,\n    ptrdiff_t *info\n);\n\n/* Source: zhseqr.f */\n#define zhseqr FORTRAN_WRAPPER(zhseqr)\nextern void zhseqr(\n    const char   *job,\n    const char   *compz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlabrd.f */\n#define zlabrd FORTRAN_WRAPPER(zlabrd)\nextern void zlabrd(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *d,\n    double *e,\n    double *tauq,\n    double *taup,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: zlacgv.f */\n#define zlacgv FORTRAN_WRAPPER(zlacgv)\nextern void zlacgv(\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *incx\n);\n\n/* Source: zlacn2.f */\n#define zlacn2 FORTRAN_WRAPPER(zlacn2)\nextern void zlacn2(\n    const ptrdiff_t *n,\n    double *v,\n    double *x,\n    double *est,\n    ptrdiff_t *kase,\n    ptrdiff_t *isave\n);\n\n/* Source: zlacon.f */\n#define zlacon FORTRAN_WRAPPER(zlacon)\nextern void zlacon(\n    const ptrdiff_t *n,\n    double *v,\n    double *x,\n    double *est,\n    ptrdiff_t *kase\n);\n\n/* Source: zlacp2.f */\n#define zlacp2 FORTRAN_WRAPPER(zlacp2)\nextern void zlacp2(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: zlacpy.f */\n#define zlacpy FORTRAN_WRAPPER(zlacpy)\nextern void zlacpy(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: zlacrm.f */\n#define zlacrm FORTRAN_WRAPPER(zlacrm)\nextern void zlacrm(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *rwork\n);\n\n/* Source: zlacrt.f */\n#define zlacrt FORTRAN_WRAPPER(zlacrt)\nextern void zlacrt(\n    const ptrdiff_t *n,\n    double *cx,\n    const ptrdiff_t *incx,\n    double *cy,\n    const ptrdiff_t *incy,\n    const double *c,\n    const double *s\n);\n\n/* Source: zladiv.f */\n#define zladiv FORTRAN_WRAPPER(zladiv)\nextern void zladiv(\n    doublecomplex* retval,\n    const double *x,\n    const double *y\n);\n\n/* Source: zlaed0.f */\n#define zlaed0 FORTRAN_WRAPPER(zlaed0)\nextern void zlaed0(\n    const ptrdiff_t *qsiz,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *qstore,\n    const ptrdiff_t *ldqs,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlaed7.f */\n#define zlaed7 FORTRAN_WRAPPER(zlaed7)\nextern void zlaed7(\n    const ptrdiff_t *n,\n    const ptrdiff_t *cutpnt,\n    const ptrdiff_t *qsiz,\n    const ptrdiff_t *tlvls,\n    const ptrdiff_t *curlvl,\n    const ptrdiff_t *curpbm,\n    double *d,\n    double *q,\n    const ptrdiff_t *ldq,\n    const double *rho,\n    ptrdiff_t *indxq,\n    double *qstore,\n    ptrdiff_t *qptr,\n    const ptrdiff_t *prmptr,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const double *givnum,\n    double *work,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlaed8.f */\n#define zlaed8 FORTRAN_WRAPPER(zlaed8)\nextern void zlaed8(\n    ptrdiff_t *k,\n    const ptrdiff_t *n,\n    const ptrdiff_t *qsiz,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *d,\n    double *rho,\n    const ptrdiff_t *cutpnt,\n    const double *z,\n    double *dlamda,\n    double *q2,\n    const ptrdiff_t *ldq2,\n    double *w,\n    ptrdiff_t *indxp,\n    ptrdiff_t *indx,\n    const ptrdiff_t *indxq,\n    ptrdiff_t *perm,\n    ptrdiff_t *givptr,\n    ptrdiff_t *givcol,\n    double *givnum,\n    ptrdiff_t *info\n);\n\n/* Source: zlaein.f */\n#define zlaein FORTRAN_WRAPPER(zlaein)\nextern void zlaein(\n    const ptrdiff_t *rightv,\n    const ptrdiff_t *noinit,\n    const ptrdiff_t *n,\n    const double *h,\n    const ptrdiff_t *ldh,\n    const double *w,\n    double *v,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *rwork,\n    const double *eps3,\n    const double *smlnum,\n    ptrdiff_t *info\n);\n\n/* Source: zlaesy.f */\n#define zlaesy FORTRAN_WRAPPER(zlaesy)\nextern void zlaesy(\n    const double *a,\n    const double *b,\n    const double *c,\n    double *rt1,\n    double *rt2,\n    double *evscal,\n    double *cs1,\n    double *sn1\n);\n\n/* Source: zlaev2.f */\n#define zlaev2 FORTRAN_WRAPPER(zlaev2)\nextern void zlaev2(\n    const double *a,\n    const double *b,\n    const double *c,\n    double *rt1,\n    double *rt2,\n    double *cs1,\n    double *sn1\n);\n\n/* Source: zlag2c.f */\n#define zlag2c FORTRAN_WRAPPER(zlag2c)\nextern void zlag2c(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    float  *sa,\n    const ptrdiff_t *ldsa,\n    ptrdiff_t *info\n);\n\n/* Source: zlags2.f */\n#define zlags2 FORTRAN_WRAPPER(zlags2)\nextern void zlags2(\n    const ptrdiff_t *upper,\n    const double *a1,\n    const double *a2,\n    const double *a3,\n    const double *b1,\n    const double *b2,\n    const double *b3,\n    double *csu,\n    double *snu,\n    double *csv,\n    double *snv,\n    double *csq,\n    double *snq\n);\n\n/* Source: zlagtm.f */\n#define zlagtm FORTRAN_WRAPPER(zlagtm)\nextern void zlagtm(\n    const char   *trans,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *alpha,\n    const double *dl,\n    const double *d,\n    const double *du,\n    const double *x,\n    const ptrdiff_t *ldx,\n    const double *beta,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: zlahef.f */\n#define zlahef FORTRAN_WRAPPER(zlahef)\nextern void zlahef(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: zlahef_aa.f */\n#define zlahef_aa FORTRAN_WRAPPER(zlahef_aa)\nextern void zlahef_aa(\n    const char   *uplo,\n    const ptrdiff_t *j1_,\n    const ptrdiff_t *m,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zlahef_rk.f */\n#define zlahef_rk FORTRAN_WRAPPER(zlahef_rk)\nextern void zlahef_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *w,\n    ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: zlahef_rook.f */\n#define zlahef_rook FORTRAN_WRAPPER(zlahef_rook)\nextern void zlahef_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: zlahqr.f */\n#define zlahqr FORTRAN_WRAPPER(zlahqr)\nextern void zlahqr(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *w,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *info\n);\n\n/* Source: zlahr2.f */\n#define zlahr2 FORTRAN_WRAPPER(zlahr2)\nextern void zlahr2(\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *y,\n    const ptrdiff_t *ldy\n);\n\n/* Source: zlaic1.f */\n#define zlaic1 FORTRAN_WRAPPER(zlaic1)\nextern void zlaic1(\n    const ptrdiff_t *job,\n    const ptrdiff_t *j,\n    const double *x,\n    const double *sest,\n    const double *w,\n    const double *gamma_,\n    double *sestpr,\n    double *s,\n    double *c\n);\n\n/* Source: zlals0.f */\n#define zlals0 FORTRAN_WRAPPER(zlals0)\nextern void zlals0(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *nl,\n    const ptrdiff_t *nr,\n    const ptrdiff_t *sqre,\n    const ptrdiff_t *nrhs,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *bx,\n    const ptrdiff_t *ldbx,\n    const ptrdiff_t *perm,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    const double *givnum,\n    const ptrdiff_t *ldgnum,\n    const double *poles,\n    const double *difl,\n    const double *difr,\n    const double *z,\n    const ptrdiff_t *k,\n    const double *c,\n    const double *s,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlalsa.f */\n#define zlalsa FORTRAN_WRAPPER(zlalsa)\nextern void zlalsa(\n    const ptrdiff_t *icompq,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *bx,\n    const ptrdiff_t *ldbx,\n    const double *u,\n    const ptrdiff_t *ldu,\n    const double *vt,\n    const ptrdiff_t *k,\n    const double *difl,\n    const double *difr,\n    const double *z,\n    const double *poles,\n    const ptrdiff_t *givptr,\n    const ptrdiff_t *givcol,\n    const ptrdiff_t *ldgcol,\n    const ptrdiff_t *perm,\n    const double *givnum,\n    const double *c,\n    const double *s,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlalsd.f */\n#define zlalsd FORTRAN_WRAPPER(zlalsd)\nextern void zlalsd(\n    const char   *uplo,\n    const ptrdiff_t *smlsiz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *d,\n    double *e,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *rcond,\n    ptrdiff_t *rank,\n    double *work,\n    double *rwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlamswlq.f */\n#define zlamswlq FORTRAN_WRAPPER(zlamswlq)\nextern void zlamswlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlamtsqr.f */\n#define zlamtsqr FORTRAN_WRAPPER(zlamtsqr)\nextern void zlamtsqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlangb.f */\n#define zlangb FORTRAN_WRAPPER(zlangb)\nextern double zlangb(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *work\n);\n\n/* Source: zlange.f */\n#define zlange FORTRAN_WRAPPER(zlange)\nextern double zlange(\n    const char   *norm,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *work\n);\n\n/* Source: zlangt.f */\n#define zlangt FORTRAN_WRAPPER(zlangt)\nextern double zlangt(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *dl,\n    const double *d,\n    const double *du\n);\n\n/* Source: zlanhb.f */\n#define zlanhb FORTRAN_WRAPPER(zlanhb)\nextern double zlanhb(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *work\n);\n\n/* Source: zlanhe.f */\n#define zlanhe FORTRAN_WRAPPER(zlanhe)\nextern double zlanhe(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *work\n);\n\n/* Source: zlanhf.f */\n#define zlanhf FORTRAN_WRAPPER(zlanhf)\nextern double zlanhf(\n    const char   *norm,\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    double *work\n);\n\n/* Source: zlanhp.f */\n#define zlanhp FORTRAN_WRAPPER(zlanhp)\nextern double zlanhp(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *work\n);\n\n/* Source: zlanhs.f */\n#define zlanhs FORTRAN_WRAPPER(zlanhs)\nextern double zlanhs(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *work\n);\n\n/* Source: zlanht.f */\n#define zlanht FORTRAN_WRAPPER(zlanht)\nextern double zlanht(\n    const char   *norm,\n    const ptrdiff_t *n,\n    const double *d,\n    const double *e\n);\n\n/* Source: zlansb.f */\n#define zlansb FORTRAN_WRAPPER(zlansb)\nextern double zlansb(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *work\n);\n\n/* Source: zlansp.f */\n#define zlansp FORTRAN_WRAPPER(zlansp)\nextern double zlansp(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *work\n);\n\n/* Source: zlansy.f */\n#define zlansy FORTRAN_WRAPPER(zlansy)\nextern double zlansy(\n    const char   *norm,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *work\n);\n\n/* Source: zlantb.f */\n#define zlantb FORTRAN_WRAPPER(zlantb)\nextern double zlantb(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *work\n);\n\n/* Source: zlantp.f */\n#define zlantp FORTRAN_WRAPPER(zlantp)\nextern double zlantp(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *work\n);\n\n/* Source: zlantr.f */\n#define zlantr FORTRAN_WRAPPER(zlantr)\nextern double zlantr(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *work\n);\n\n/* Source: zlapll.f */\n#define zlapll FORTRAN_WRAPPER(zlapll)\nextern void zlapll(\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *incx,\n    double *y,\n    const ptrdiff_t *incy,\n    double *ssmin\n);\n\n/* Source: zlapmr.f */\n#define zlapmr FORTRAN_WRAPPER(zlapmr)\nextern void zlapmr(\n    const ptrdiff_t *forwrd,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *ldx,\n    ptrdiff_t *k\n);\n\n/* Source: zlapmt.f */\n#define zlapmt FORTRAN_WRAPPER(zlapmt)\nextern void zlapmt(\n    const ptrdiff_t *forwrd,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *ldx,\n    ptrdiff_t *k\n);\n\n/* Source: zlaqgb.f */\n#define zlaqgb FORTRAN_WRAPPER(zlaqgb)\nextern void zlaqgb(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    double *ab,\n    const ptrdiff_t *ldab,\n    const double *r,\n    const double *c,\n    const double *rowcnd,\n    const double *colcnd,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: zlaqge.f */\n#define zlaqge FORTRAN_WRAPPER(zlaqge)\nextern void zlaqge(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *r,\n    const double *c,\n    const double *rowcnd,\n    const double *colcnd,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: zlaqhb.f */\n#define zlaqhb FORTRAN_WRAPPER(zlaqhb)\nextern void zlaqhb(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *s,\n    const double *scond,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: zlaqhe.f */\n#define zlaqhe FORTRAN_WRAPPER(zlaqhe)\nextern void zlaqhe(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *s,\n    const double *scond,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: zlaqhp.f */\n#define zlaqhp FORTRAN_WRAPPER(zlaqhp)\nextern void zlaqhp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const double *s,\n    const double *scond,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: zlaqp2.f */\n#define zlaqp2 FORTRAN_WRAPPER(zlaqp2)\nextern void zlaqp2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *offset,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    double *tau,\n    double *vn1,\n    double *vn2,\n    double *work\n);\n\n/* Source: zlaqps.f */\n#define zlaqps FORTRAN_WRAPPER(zlaqps)\nextern void zlaqps(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *offset,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *jpvt,\n    double *tau,\n    double *vn1,\n    double *vn2,\n    double *auxv,\n    double *f,\n    const ptrdiff_t *ldf\n);\n\n/* Source: zlaqr0.f */\n#define zlaqr0 FORTRAN_WRAPPER(zlaqr0)\nextern void zlaqr0(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *w,\n    ptrdiff_t *iloz,\n    ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlaqr1.f */\n#define zlaqr1 FORTRAN_WRAPPER(zlaqr1)\nextern void zlaqr1(\n    const ptrdiff_t *n,\n    const double *h,\n    const ptrdiff_t *ldh,\n    const double *s1,\n    double *s2,\n    double *v\n);\n\n/* Source: zlaqr2.f */\n#define zlaqr2 FORTRAN_WRAPPER(zlaqr2)\nextern void zlaqr2(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nw,\n    double *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ns,\n    ptrdiff_t *nd,\n    double *sh,\n    double *v,\n    const ptrdiff_t *ldv,\n    const ptrdiff_t *nh,\n    double *t,\n    const ptrdiff_t *ldt,\n    const ptrdiff_t *nv,\n    double *wv,\n    const ptrdiff_t *ldwv,\n    double *work,\n    const ptrdiff_t *lwork\n);\n\n/* Source: zlaqr3.f */\n#define zlaqr3 FORTRAN_WRAPPER(zlaqr3)\nextern void zlaqr3(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nw,\n    double *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *ns,\n    ptrdiff_t *nd,\n    double *sh,\n    double *v,\n    const ptrdiff_t *ldv,\n    const ptrdiff_t *nh,\n    double *t,\n    const ptrdiff_t *ldt,\n    const ptrdiff_t *nv,\n    double *wv,\n    const ptrdiff_t *ldwv,\n    double *work,\n    const ptrdiff_t *lwork\n);\n\n/* Source: zlaqr4.f */\n#define zlaqr4 FORTRAN_WRAPPER(zlaqr4)\nextern void zlaqr4(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *h,\n    const ptrdiff_t *ldh,\n    double *w,\n    ptrdiff_t *iloz,\n    ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlaqr5.f */\n#define zlaqr5 FORTRAN_WRAPPER(zlaqr5)\nextern void zlaqr5(\n    const ptrdiff_t *wantt,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *kacc22,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ktop,\n    const ptrdiff_t *kbot,\n    const ptrdiff_t *nshfts,\n    double *s,\n    double *h,\n    const ptrdiff_t *ldh,\n    const ptrdiff_t *iloz,\n    const ptrdiff_t *ihiz,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *u,\n    const ptrdiff_t *ldu,\n    const ptrdiff_t *nv,\n    double *wv,\n    const ptrdiff_t *ldwv,\n    const ptrdiff_t *nh,\n    double *wh,\n    const ptrdiff_t *ldwh\n);\n\n/* Source: zlaqsb.f */\n#define zlaqsb FORTRAN_WRAPPER(zlaqsb)\nextern void zlaqsb(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    const double *s,\n    const double *scond,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: zlaqsp.f */\n#define zlaqsp FORTRAN_WRAPPER(zlaqsp)\nextern void zlaqsp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const double *s,\n    const double *scond,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: zlaqsy.f */\n#define zlaqsy FORTRAN_WRAPPER(zlaqsy)\nextern void zlaqsy(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *s,\n    const double *scond,\n    const double *amax,\n    char   *equed\n);\n\n/* Source: zlar1v.f */\n#define zlar1v FORTRAN_WRAPPER(zlar1v)\nextern void zlar1v(\n    const ptrdiff_t *n,\n    const ptrdiff_t *b1,\n    const ptrdiff_t *bn,\n    const double *lambda,\n    const double *d,\n    const double *l,\n    const double *ld,\n    const double *lld,\n    const double *pivmin,\n    const double *gaptol,\n    double *z,\n    const ptrdiff_t *wantnc,\n    ptrdiff_t *negcnt,\n    double *ztz,\n    double *mingma,\n    ptrdiff_t *r,\n    ptrdiff_t *isuppz,\n    double *nrminv,\n    double *resid,\n    double *rqcorr,\n    double *work\n);\n\n/* Source: zlar2v.f */\n#define zlar2v FORTRAN_WRAPPER(zlar2v)\nextern void zlar2v(\n    const ptrdiff_t *n,\n    double *x,\n    double *y,\n    double *z,\n    const ptrdiff_t *incx,\n    const double *c,\n    const double *s,\n    const ptrdiff_t *incc\n);\n\n/* Source: zlarcm.f */\n#define zlarcm FORTRAN_WRAPPER(zlarcm)\nextern void zlarcm(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *rwork\n);\n\n/* Source: zlarf.f */\n#define zlarf FORTRAN_WRAPPER(zlarf)\nextern void zlarf(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *v,\n    const ptrdiff_t *incv,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: zlarfb.f */\n#define zlarfb FORTRAN_WRAPPER(zlarfb)\nextern void zlarfb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: zlarfg.f */\n#define zlarfg FORTRAN_WRAPPER(zlarfg)\nextern void zlarfg(\n    const ptrdiff_t *n,\n    double *alpha,\n    double *x,\n    const ptrdiff_t *incx,\n    double *tau\n);\n\n/* Source: zlarfgp.f */\n#define zlarfgp FORTRAN_WRAPPER(zlarfgp)\nextern void zlarfgp(\n    const ptrdiff_t *n,\n    double *alpha,\n    double *x,\n    const ptrdiff_t *incx,\n    double *tau\n);\n\n/* Source: zlarft.f */\n#define zlarft FORTRAN_WRAPPER(zlarft)\nextern void zlarft(\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *tau,\n    double *t,\n    const ptrdiff_t *ldt\n);\n\n/* Source: zlarfx.f */\n#define zlarfx FORTRAN_WRAPPER(zlarfx)\nextern void zlarfx(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *v,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: zlarfy.f */\n#define zlarfy FORTRAN_WRAPPER(zlarfy)\nextern void zlarfy(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *v,\n    ptrdiff_t *incv,\n    double *tau,\n    double *c,\n    ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: zlargv.f */\n#define zlargv FORTRAN_WRAPPER(zlargv)\nextern void zlargv(\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *incx,\n    double *y,\n    const ptrdiff_t *incy,\n    double *c,\n    const ptrdiff_t *incc\n);\n\n/* Source: zlarnv.f */\n#define zlarnv FORTRAN_WRAPPER(zlarnv)\nextern void zlarnv(\n    const ptrdiff_t *idist,\n    ptrdiff_t *iseed,\n    const ptrdiff_t *n,\n    double *x\n);\n\n/* Source: zlarrv.f */\n#define zlarrv FORTRAN_WRAPPER(zlarrv)\nextern void zlarrv(\n    const ptrdiff_t *n,\n    const double *vl,\n    const double *vu,\n    double *d,\n    double *l,\n    double *pivmin,\n    const ptrdiff_t *isplit,\n    const ptrdiff_t *m,\n    const ptrdiff_t *dol,\n    const ptrdiff_t *dou,\n    const double *minrgp,\n    const double *rtol1,\n    const double *rtol2,\n    double *w,\n    double *werr,\n    double *wgap,\n    const ptrdiff_t *iblock,\n    const ptrdiff_t *indexw,\n    const double *gers,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlartg.f */\n#define zlartg FORTRAN_WRAPPER(zlartg)\nextern void zlartg(\n    const double *f,\n    const double *g,\n    double *cs,\n    double *sn,\n    double *r\n);\n\n/* Source: zlartv.f */\n#define zlartv FORTRAN_WRAPPER(zlartv)\nextern void zlartv(\n    const ptrdiff_t *n,\n    double *x,\n    const ptrdiff_t *incx,\n    double *y,\n    const ptrdiff_t *incy,\n    const double *c,\n    const double *s,\n    const ptrdiff_t *incc\n);\n\n/* Source: zlarz.f */\n#define zlarz FORTRAN_WRAPPER(zlarz)\nextern void zlarz(\n    const char   *side,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const double *v,\n    const ptrdiff_t *incv,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work\n);\n\n/* Source: zlarzb.f */\n#define zlarzb FORTRAN_WRAPPER(zlarzb)\nextern void zlarzb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: zlarzt.f */\n#define zlarzt FORTRAN_WRAPPER(zlarzt)\nextern void zlarzt(\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *v,\n    const ptrdiff_t *ldv,\n    const double *tau,\n    double *t,\n    const ptrdiff_t *ldt\n);\n\n/* Source: zlascl.f */\n#define zlascl FORTRAN_WRAPPER(zlascl)\nextern void zlascl(\n    const char   *type,\n    const ptrdiff_t *kl,\n    const ptrdiff_t *ku,\n    const double *cfrom,\n    const double *cto,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: zlaset.f */\n#define zlaset FORTRAN_WRAPPER(zlaset)\nextern void zlaset(\n    const char   *uplo,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *beta,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: zlasr.f */\n#define zlasr FORTRAN_WRAPPER(zlasr)\nextern void zlasr(\n    const char   *side,\n    const char   *pivot,\n    const char   *direct,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *c,\n    const double *s,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: zlassq.f */\n#define zlassq FORTRAN_WRAPPER(zlassq)\nextern void zlassq(\n    const ptrdiff_t *n,\n    const double *x,\n    const ptrdiff_t *incx,\n    double *scale,\n    double *sumsq\n);\n\n/* Source: zlaswlq.f */\n#define zlaswlq FORTRAN_WRAPPER(zlaswlq)\nextern void zlaswlq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlaswp.f */\n#define zlaswp FORTRAN_WRAPPER(zlaswp)\nextern void zlaswp(\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *k1,\n    const ptrdiff_t *k2,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *incx\n);\n\n/* Source: zlasyf.f */\n#define zlasyf FORTRAN_WRAPPER(zlasyf)\nextern void zlasyf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: zlasyf_aa.f */\n#define zlasyf_aa FORTRAN_WRAPPER(zlasyf_aa)\nextern void zlasyf_aa(\n    char   *uplo,\n    ptrdiff_t *j1_,\n    ptrdiff_t *m,\n    ptrdiff_t *nb,\n    double *a,\n    ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *h,\n    ptrdiff_t *ldh,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zlasyf_rk.f */\n#define zlasyf_rk FORTRAN_WRAPPER(zlasyf_rk)\nextern void zlasyf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *w,\n    ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: zlasyf_rook.f */\n#define zlasyf_rook FORTRAN_WRAPPER(zlasyf_rook)\nextern void zlasyf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    ptrdiff_t *kb,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *w,\n    const ptrdiff_t *ldw,\n    ptrdiff_t *info\n);\n\n/* Source: zlat2c.f */\n#define zlat2c FORTRAN_WRAPPER(zlat2c)\nextern void zlat2c(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    float  *sa,\n    const ptrdiff_t *ldsa,\n    ptrdiff_t *info\n);\n\n/* Source: zlatbs.f */\n#define zlatbs FORTRAN_WRAPPER(zlatbs)\nextern void zlatbs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *x,\n    double *scale,\n    double *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: zlatdf.f */\n#define zlatdf FORTRAN_WRAPPER(zlatdf)\nextern void zlatdf(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *n,\n    const double *z,\n    const ptrdiff_t *ldz,\n    double *rhs,\n    double *rdsum,\n    double *rdscal,\n    const ptrdiff_t *ipiv,\n    const ptrdiff_t *jpiv\n);\n\n/* Source: zlatps.f */\n#define zlatps FORTRAN_WRAPPER(zlatps)\nextern void zlatps(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *x,\n    double *scale,\n    double *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: zlatrd.f */\n#define zlatrd FORTRAN_WRAPPER(zlatrd)\nextern void zlatrd(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *e,\n    double *tau,\n    double *w,\n    const ptrdiff_t *ldw\n);\n\n/* Source: zlatrs.f */\n#define zlatrs FORTRAN_WRAPPER(zlatrs)\nextern void zlatrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const char   *normin,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *x,\n    double *scale,\n    double *cnorm,\n    ptrdiff_t *info\n);\n\n/* Source: zlatrz.f */\n#define zlatrz FORTRAN_WRAPPER(zlatrz)\nextern void zlatrz(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work\n);\n\n/* Source: zlatsqr.f */\n#define zlatsqr FORTRAN_WRAPPER(zlatsqr)\nextern void zlatsqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *mb,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zlauu2.f */\n#define zlauu2 FORTRAN_WRAPPER(zlauu2)\nextern void zlauu2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: zlauum.f */\n#define zlauum FORTRAN_WRAPPER(zlauum)\nextern void zlauum(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: zpbcon.f */\n#define zpbcon FORTRAN_WRAPPER(zpbcon)\nextern void zpbcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zpbequ.f */\n#define zpbequ FORTRAN_WRAPPER(zpbequ)\nextern void zpbequ(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *s,\n    double *scond,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: zpbrfs.f */\n#define zpbrfs FORTRAN_WRAPPER(zpbrfs)\nextern void zpbrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const double *afb,\n    const ptrdiff_t *ldafb,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zpbstf.f */\n#define zpbstf FORTRAN_WRAPPER(zpbstf)\nextern void zpbstf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: zpbsv.f */\n#define zpbsv FORTRAN_WRAPPER(zpbsv)\nextern void zpbsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zpbsvx.f */\n#define zpbsvx FORTRAN_WRAPPER(zpbsvx)\nextern void zpbsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    double *ab,\n    const ptrdiff_t *ldab,\n    double *afb,\n    const ptrdiff_t *ldafb,\n    char   *equed,\n    double *s,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zpbtf2.f */\n#define zpbtf2 FORTRAN_WRAPPER(zpbtf2)\nextern void zpbtf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: zpbtrf.f */\n#define zpbtrf FORTRAN_WRAPPER(zpbtrf)\nextern void zpbtrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    double *ab,\n    const ptrdiff_t *ldab,\n    ptrdiff_t *info\n);\n\n/* Source: zpbtrs.f */\n#define zpbtrs FORTRAN_WRAPPER(zpbtrs)\nextern void zpbtrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zpftrf.f */\n#define zpftrf FORTRAN_WRAPPER(zpftrf)\nextern void zpftrf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *info\n);\n\n/* Source: zpftri.f */\n#define zpftri FORTRAN_WRAPPER(zpftri)\nextern void zpftri(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *info\n);\n\n/* Source: zpftrs.f */\n#define zpftrs FORTRAN_WRAPPER(zpftrs)\nextern void zpftrs(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zpocon.f */\n#define zpocon FORTRAN_WRAPPER(zpocon)\nextern void zpocon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zpoequ.f */\n#define zpoequ FORTRAN_WRAPPER(zpoequ)\nextern void zpoequ(\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *scond,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: zpoequb.f */\n#define zpoequb FORTRAN_WRAPPER(zpoequb)\nextern void zpoequb(\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *scond,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: zporfs.f */\n#define zporfs FORTRAN_WRAPPER(zporfs)\nextern void zporfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *af,\n    const ptrdiff_t *ldaf,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zposv.f */\n#define zposv FORTRAN_WRAPPER(zposv)\nextern void zposv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zposvx.f */\n#define zposvx FORTRAN_WRAPPER(zposvx)\nextern void zposvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    double *af,\n    const ptrdiff_t *ldaf,\n    char   *equed,\n    double *s,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zpotf2.f */\n#define zpotf2 FORTRAN_WRAPPER(zpotf2)\nextern void zpotf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: zpotrf.f */\n#define zpotrf FORTRAN_WRAPPER(zpotrf)\nextern void zpotrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: zpotrf2.f */\n#define zpotrf2 FORTRAN_WRAPPER(zpotrf2)\nextern void zpotrf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: zpotri.f */\n#define zpotri FORTRAN_WRAPPER(zpotri)\nextern void zpotri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: zpotrs.f */\n#define zpotrs FORTRAN_WRAPPER(zpotrs)\nextern void zpotrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zppcon.f */\n#define zppcon FORTRAN_WRAPPER(zppcon)\nextern void zppcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zppequ.f */\n#define zppequ FORTRAN_WRAPPER(zppequ)\nextern void zppequ(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *s,\n    double *scond,\n    double *amax,\n    ptrdiff_t *info\n);\n\n/* Source: zpprfs.f */\n#define zpprfs FORTRAN_WRAPPER(zpprfs)\nextern void zpprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const double *afp,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zppsv.f */\n#define zppsv FORTRAN_WRAPPER(zppsv)\nextern void zppsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *ap,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zppsvx.f */\n#define zppsvx FORTRAN_WRAPPER(zppsvx)\nextern void zppsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *ap,\n    double *afp,\n    char   *equed,\n    double *s,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zpptrf.f */\n#define zpptrf FORTRAN_WRAPPER(zpptrf)\nextern void zpptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: zpptri.f */\n#define zpptri FORTRAN_WRAPPER(zpptri)\nextern void zpptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: zpptrs.f */\n#define zpptrs FORTRAN_WRAPPER(zpptrs)\nextern void zpptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zpstf2.f */\n#define zpstf2 FORTRAN_WRAPPER(zpstf2)\nextern void zpstf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *piv,\n    ptrdiff_t *rank,\n    const double *tol,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zpstrf.f */\n#define zpstrf FORTRAN_WRAPPER(zpstrf)\nextern void zpstrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *piv,\n    ptrdiff_t *rank,\n    const double *tol,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zptcon.f */\n#define zptcon FORTRAN_WRAPPER(zptcon)\nextern void zptcon(\n    const ptrdiff_t *n,\n    const double *d,\n    const double *e,\n    const double *anorm,\n    double *rcond,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zpteqr.f */\n#define zpteqr FORTRAN_WRAPPER(zpteqr)\nextern void zpteqr(\n    const char   *compz,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zptrfs.f */\n#define zptrfs FORTRAN_WRAPPER(zptrfs)\nextern void zptrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *d,\n    const double *e,\n    const double *df,\n    const double *ef,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zptsv.f */\n#define zptsv FORTRAN_WRAPPER(zptsv)\nextern void zptsv(\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *d,\n    double *e,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zptsvx.f */\n#define zptsvx FORTRAN_WRAPPER(zptsvx)\nextern void zptsvx(\n    const char   *fact,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *d,\n    const double *e,\n    double *df,\n    double *ef,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zpttrf.f */\n#define zpttrf FORTRAN_WRAPPER(zpttrf)\nextern void zpttrf(\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    ptrdiff_t *info\n);\n\n/* Source: zpttrs.f */\n#define zpttrs FORTRAN_WRAPPER(zpttrs)\nextern void zpttrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *d,\n    const double *e,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zptts2.f */\n#define zptts2 FORTRAN_WRAPPER(zptts2)\nextern void zptts2(\n    const ptrdiff_t *iuplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *d,\n    const double *e,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: zrot.f */\n#define zrot FORTRAN_WRAPPER(zrot)\nextern void zrot(\n    const ptrdiff_t *n,\n    double *cx,\n    const ptrdiff_t *incx,\n    double *cy,\n    const ptrdiff_t *incy,\n    const double *c,\n    const double *s\n);\n\n/* Source: zspcon.f */\n#define zspcon FORTRAN_WRAPPER(zspcon)\nextern void zspcon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zspmv.f */\n#define zspmv FORTRAN_WRAPPER(zspmv)\nextern void zspmv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *ap,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: zspr.f */\n#define zspr FORTRAN_WRAPPER(zspr)\nextern void zspr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    double *ap\n);\n\n/* Source: zsprfs.f */\n#define zsprfs FORTRAN_WRAPPER(zsprfs)\nextern void zsprfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const double *afp,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zspsv.f */\n#define zspsv FORTRAN_WRAPPER(zspsv)\nextern void zspsv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *ap,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zspsvx.f */\n#define zspsvx FORTRAN_WRAPPER(zspsvx)\nextern void zspsvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    double *afp,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsptrf.f */\n#define zsptrf FORTRAN_WRAPPER(zsptrf)\nextern void zsptrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zsptri.f */\n#define zsptri FORTRAN_WRAPPER(zsptri)\nextern void zsptri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *ap,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zsptrs.f */\n#define zsptrs FORTRAN_WRAPPER(zsptrs)\nextern void zsptrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zstedc.f */\n#define zstedc FORTRAN_WRAPPER(zstedc)\nextern void zstedc(\n    const char   *compz,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zstegr.f */\n#define zstegr FORTRAN_WRAPPER(zstegr)\nextern void zstegr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    const double *abstol,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *isuppz,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zstein.f */\n#define zstein FORTRAN_WRAPPER(zstein)\nextern void zstein(\n    const ptrdiff_t *n,\n    const double *d,\n    const double *e,\n    const ptrdiff_t *m,\n    const double *w,\n    const ptrdiff_t *iblock,\n    const ptrdiff_t *isplit,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *iwork,\n    ptrdiff_t *ifail,\n    ptrdiff_t *info\n);\n\n/* Source: zstemr.f */\n#define zstemr FORTRAN_WRAPPER(zstemr)\nextern void zstemr(\n    const char   *jobz,\n    const char   *range,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    const double *vl,\n    const double *vu,\n    const ptrdiff_t *il,\n    const ptrdiff_t *iu,\n    ptrdiff_t *m,\n    double *w,\n    double *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *nzc,\n    ptrdiff_t *isuppz,\n    ptrdiff_t *tryrac,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsteqr.f */\n#define zsteqr FORTRAN_WRAPPER(zsteqr)\nextern void zsteqr(\n    const char   *compz,\n    const ptrdiff_t *n,\n    double *d,\n    double *e,\n    double *z,\n    const ptrdiff_t *ldz,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zsycon.f */\n#define zsycon FORTRAN_WRAPPER(zsycon)\nextern void zsycon(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zsycon_3.f */\n#define zsycon_3 FORTRAN_WRAPPER(zsycon_3)\nextern void zsycon_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zsycon_rook.f */\n#define zsycon_rook FORTRAN_WRAPPER(zsycon_rook)\nextern void zsycon_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    const double *anorm,\n    double *rcond,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zsyconv.f */\n#define zsyconv FORTRAN_WRAPPER(zsyconv)\nextern void zsyconv(\n    const char   *uplo,\n    const char   *way,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *e,\n    ptrdiff_t *info\n);\n\n/* Source: zsyconvf.f */\n#define zsyconvf FORTRAN_WRAPPER(zsyconvf)\nextern void zsyconvf(\n    char   *uplo,\n    char   *way,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zsyconvf_rook.f */\n#define zsyconvf_rook FORTRAN_WRAPPER(zsyconvf_rook)\nextern void zsyconvf_rook(\n    char   *uplo,\n    char   *way,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zsyequb.f */\n#define zsyequb FORTRAN_WRAPPER(zsyequb)\nextern void zsyequb(\n    char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *s,\n    double *scond,\n    double *amax,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zsymv.f */\n#define zsymv FORTRAN_WRAPPER(zsymv)\nextern void zsymv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *x,\n    const ptrdiff_t *incx,\n    const double *beta,\n    double *y,\n    const ptrdiff_t *incy\n);\n\n/* Source: zsyr.f */\n#define zsyr FORTRAN_WRAPPER(zsyr)\nextern void zsyr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *x,\n    const ptrdiff_t *incx,\n    double *a,\n    const ptrdiff_t *lda\n);\n\n/* Source: zsyrfs.f */\n#define zsyrfs FORTRAN_WRAPPER(zsyrfs)\nextern void zsyrfs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *af,\n    const ptrdiff_t *ldaf,\n    const ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsysv.f */\n#define zsysv FORTRAN_WRAPPER(zsysv)\nextern void zsysv(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsysv_aa.f */\n#define zsysv_aa FORTRAN_WRAPPER(zsysv_aa)\nextern void zsysv_aa(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    double *a,\n    ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsysv_rk.f */\n#define zsysv_rk FORTRAN_WRAPPER(zsysv_rk)\nextern void zsysv_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *b,\n    ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsysv_rook.f */\n#define zsysv_rook FORTRAN_WRAPPER(zsysv_rook)\nextern void zsysv_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsysvx.f */\n#define zsysvx FORTRAN_WRAPPER(zsysvx)\nextern void zsysvx(\n    const char   *fact,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *af,\n    const ptrdiff_t *ldaf,\n    ptrdiff_t *ipiv,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *x,\n    const ptrdiff_t *ldx,\n    double *rcond,\n    double *ferr,\n    double *berr,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsyswapr.f */\n#define zsyswapr FORTRAN_WRAPPER(zsyswapr)\nextern void zsyswapr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *i1,\n    const ptrdiff_t *i2\n);\n\n/* Source: zsytf2.f */\n#define zsytf2 FORTRAN_WRAPPER(zsytf2)\nextern void zsytf2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zsytf2_rk.f */\n#define zsytf2_rk FORTRAN_WRAPPER(zsytf2_rk)\nextern void zsytf2_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zsytf2_rook.f */\n#define zsytf2_rook FORTRAN_WRAPPER(zsytf2_rook)\nextern void zsytf2_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    ptrdiff_t *info\n);\n\n/* Source: zsytrf.f */\n#define zsytrf FORTRAN_WRAPPER(zsytrf)\nextern void zsytrf(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsytrf_aa.f */\n#define zsytrf_aa FORTRAN_WRAPPER(zsytrf_aa)\nextern void zsytrf_aa(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsytrf_rk.f */\n#define zsytrf_rk FORTRAN_WRAPPER(zsytrf_rk)\nextern void zsytrf_rk(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsytrf_rook.f */\n#define zsytrf_rook FORTRAN_WRAPPER(zsytrf_rook)\nextern void zsytrf_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsytri.f */\n#define zsytri FORTRAN_WRAPPER(zsytri)\nextern void zsytri(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zsytri2.f */\n#define zsytri2 FORTRAN_WRAPPER(zsytri2)\nextern void zsytri2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsytri2x.f */\n#define zsytri2x FORTRAN_WRAPPER(zsytri2x)\nextern void zsytri2x(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: zsytri_3.f */\n#define zsytri_3 FORTRAN_WRAPPER(zsytri_3)\nextern void zsytri_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsytri_3x.f */\n#define zsytri_3x FORTRAN_WRAPPER(zsytri_3x)\nextern void zsytri_3x(\n    char   *uplo,\n    ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *nb,\n    ptrdiff_t *info\n);\n\n/* Source: zsytri_rook.f */\n#define zsytri_rook FORTRAN_WRAPPER(zsytri_rook)\nextern void zsytri_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zsytrs.f */\n#define zsytrs FORTRAN_WRAPPER(zsytrs)\nextern void zsytrs(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zsytrs2.f */\n#define zsytrs2 FORTRAN_WRAPPER(zsytrs2)\nextern void zsytrs2(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zsytrs_3.f */\n#define zsytrs_3 FORTRAN_WRAPPER(zsytrs_3)\nextern void zsytrs_3(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    double *a,\n    ptrdiff_t *lda,\n    double *e,\n    ptrdiff_t *ipiv,\n    double *b,\n    ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: zsytrs_aa.f */\n#define zsytrs_aa FORTRAN_WRAPPER(zsytrs_aa)\nextern void zsytrs_aa(\n    char   *uplo,\n    ptrdiff_t *n,\n    ptrdiff_t *nrhs,\n    double *a,\n    ptrdiff_t *lda,\n    ptrdiff_t *ipiv,\n    double *b,\n    ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zsytrs_rook.f */\n#define zsytrs_rook FORTRAN_WRAPPER(zsytrs_rook)\nextern void zsytrs_rook(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const ptrdiff_t *ipiv,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ztbcon.f */\n#define ztbcon FORTRAN_WRAPPER(ztbcon)\nextern void ztbcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *rcond,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztbrfs.f */\n#define ztbrfs FORTRAN_WRAPPER(ztbrfs)\nextern void ztbrfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztbtrs.f */\n#define ztbtrs FORTRAN_WRAPPER(ztbtrs)\nextern void ztbtrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *kd,\n    const ptrdiff_t *nrhs,\n    const double *ab,\n    const ptrdiff_t *ldab,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ztfsm.f */\n#define ztfsm FORTRAN_WRAPPER(ztfsm)\nextern void ztfsm(\n    const char   *transr,\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *alpha,\n    const double *a,\n    double *b,\n    const ptrdiff_t *ldb\n);\n\n/* Source: ztftri.f */\n#define ztftri FORTRAN_WRAPPER(ztftri)\nextern void ztftri(\n    const char   *transr,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    double *a,\n    ptrdiff_t *info\n);\n\n/* Source: ztfttp.f */\n#define ztfttp FORTRAN_WRAPPER(ztfttp)\nextern void ztfttp(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *arf,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: ztfttr.f */\n#define ztfttr FORTRAN_WRAPPER(ztfttr)\nextern void ztfttr(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *arf,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: ztgevc.f */\n#define ztgevc FORTRAN_WRAPPER(ztgevc)\nextern void ztgevc(\n    const char   *side,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const double *s,\n    const ptrdiff_t *lds,\n    const double *p,\n    const ptrdiff_t *ldp,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztgex2.f */\n#define ztgex2 FORTRAN_WRAPPER(ztgex2)\nextern void ztgex2(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *j1_,\n    ptrdiff_t *info\n);\n\n/* Source: ztgexc.f */\n#define ztgexc FORTRAN_WRAPPER(ztgexc)\nextern void ztgexc(\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    const ptrdiff_t *ifst,\n    ptrdiff_t *ilst,\n    ptrdiff_t *info\n);\n\n/* Source: ztgsen.f */\n#define ztgsen FORTRAN_WRAPPER(ztgsen)\nextern void ztgsen(\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *wantq,\n    const ptrdiff_t *wantz,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *alpha,\n    double *beta,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *z,\n    const ptrdiff_t *ldz,\n    ptrdiff_t *m,\n    double *pl,\n    double *pr,\n    double *dif,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    const ptrdiff_t *liwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztgsja.f */\n#define ztgsja FORTRAN_WRAPPER(ztgsja)\nextern void ztgsja(\n    const char   *jobu,\n    const char   *jobv,\n    const char   *jobq,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    const double *tola,\n    const double *tolb,\n    double *alpha,\n    double *beta,\n    double *u,\n    const ptrdiff_t *ldu,\n    double *v,\n    const ptrdiff_t *ldv,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    ptrdiff_t *ncycle,\n    ptrdiff_t *info\n);\n\n/* Source: ztgsna.f */\n#define ztgsna FORTRAN_WRAPPER(ztgsna)\nextern void ztgsna(\n    const char   *job,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *vl,\n    const ptrdiff_t *ldvl,\n    const double *vr,\n    const ptrdiff_t *ldvr,\n    double *s,\n    double *dif,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztgsy2.f */\n#define ztgsy2 FORTRAN_WRAPPER(ztgsy2)\nextern void ztgsy2(\n    const char   *trans,\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    const ptrdiff_t *ldc,\n    const double *d,\n    const ptrdiff_t *ldd,\n    const double *e,\n    const ptrdiff_t *lde,\n    double *f,\n    const ptrdiff_t *ldf,\n    double *scale,\n    double *rdsum,\n    double *rdscal,\n    ptrdiff_t *info\n);\n\n/* Source: ztgsyl.f */\n#define ztgsyl FORTRAN_WRAPPER(ztgsyl)\nextern void ztgsyl(\n    const char   *trans,\n    const ptrdiff_t *ijob,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    const ptrdiff_t *ldc,\n    const double *d,\n    const ptrdiff_t *ldd,\n    const double *e,\n    const ptrdiff_t *lde,\n    double *f,\n    const ptrdiff_t *ldf,\n    double *scale,\n    double *dif,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztpcon.f */\n#define ztpcon FORTRAN_WRAPPER(ztpcon)\nextern void ztpcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *rcond,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztplqt.f */\n#define ztplqt FORTRAN_WRAPPER(ztplqt)\nextern void ztplqt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const ptrdiff_t *mb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: ztplqt2.f */\n#define ztplqt2 FORTRAN_WRAPPER(ztplqt2)\nextern void ztplqt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: ztpmlqt.f */\n#define ztpmlqt FORTRAN_WRAPPER(ztpmlqt)\nextern void ztpmlqt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const ptrdiff_t *mb,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: ztpmqrt.f */\n#define ztpmqrt FORTRAN_WRAPPER(ztpmqrt)\nextern void ztpmqrt(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const ptrdiff_t *nb,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: ztpqrt.f */\n#define ztpqrt FORTRAN_WRAPPER(ztpqrt)\nextern void ztpqrt(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    const ptrdiff_t *nb,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: ztpqrt2.f */\n#define ztpqrt2 FORTRAN_WRAPPER(ztpqrt2)\nextern void ztpqrt2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *l,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *t,\n    const ptrdiff_t *ldt,\n    ptrdiff_t *info\n);\n\n/* Source: ztprfb.f */\n#define ztprfb FORTRAN_WRAPPER(ztprfb)\nextern void ztprfb(\n    const char   *side,\n    const char   *trans,\n    const char   *direct,\n    const char   *storev,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const double *v,\n    const ptrdiff_t *ldv,\n    const double *t,\n    const ptrdiff_t *ldt,\n    double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    double *work,\n    const ptrdiff_t *ldwork\n);\n\n/* Source: ztprfs.f */\n#define ztprfs FORTRAN_WRAPPER(ztprfs)\nextern void ztprfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztptri.f */\n#define ztptri FORTRAN_WRAPPER(ztptri)\nextern void ztptri(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: ztptrs.f */\n#define ztptrs FORTRAN_WRAPPER(ztptrs)\nextern void ztptrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *ap,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ztpttf.f */\n#define ztpttf FORTRAN_WRAPPER(ztpttf)\nextern void ztpttf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *arf,\n    ptrdiff_t *info\n);\n\n/* Source: ztpttr.f */\n#define ztpttr FORTRAN_WRAPPER(ztpttr)\nextern void ztpttr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: ztrcon.f */\n#define ztrcon FORTRAN_WRAPPER(ztrcon)\nextern void ztrcon(\n    const char   *norm,\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *rcond,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztrevc.f */\n#define ztrevc FORTRAN_WRAPPER(ztrevc)\nextern void ztrevc(\n    const char   *side,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *vl,\n    const ptrdiff_t *ldvl,\n    double *vr,\n    const ptrdiff_t *ldvr,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztrevc3.f */\n#define ztrevc3 FORTRAN_WRAPPER(ztrevc3)\nextern void ztrevc3(\n    char   *side,\n    char   *howmny,\n    ptrdiff_t *select,\n    ptrdiff_t *n,\n    double *t,\n    ptrdiff_t *ldt,\n    double *vl,\n    ptrdiff_t *ldvl,\n    double *vr,\n    ptrdiff_t *ldvr,\n    ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    ptrdiff_t *lwork,\n    double *rwork,\n    ptrdiff_t *lrwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztrexc.f */\n#define ztrexc FORTRAN_WRAPPER(ztrexc)\nextern void ztrexc(\n    const char   *compq,\n    const ptrdiff_t *n,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *q,\n    const ptrdiff_t *ldq,\n    const ptrdiff_t *ifst,\n    const ptrdiff_t *ilst,\n    ptrdiff_t *info\n);\n\n/* Source: ztrrfs.f */\n#define ztrrfs FORTRAN_WRAPPER(ztrrfs)\nextern void ztrrfs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    const double *x,\n    const ptrdiff_t *ldx,\n    double *ferr,\n    double *berr,\n    double *work,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztrsen.f */\n#define ztrsen FORTRAN_WRAPPER(ztrsen)\nextern void ztrsen(\n    const char   *job,\n    const char   *compq,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    double *t,\n    const ptrdiff_t *ldt,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *w,\n    ptrdiff_t *m,\n    double *s,\n    double *sep,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztrsna.f */\n#define ztrsna FORTRAN_WRAPPER(ztrsna)\nextern void ztrsna(\n    const char   *job,\n    const char   *howmny,\n    const ptrdiff_t *select,\n    const ptrdiff_t *n,\n    const double *t,\n    const ptrdiff_t *ldt,\n    const double *vl,\n    const ptrdiff_t *ldvl,\n    const double *vr,\n    const ptrdiff_t *ldvr,\n    double *s,\n    double *sep,\n    const ptrdiff_t *mm,\n    ptrdiff_t *m,\n    double *work,\n    const ptrdiff_t *ldwork,\n    double *rwork,\n    ptrdiff_t *info\n);\n\n/* Source: ztrsyl.f */\n#define ztrsyl FORTRAN_WRAPPER(ztrsyl)\nextern void ztrsyl(\n    const char   *trana,\n    const char   *tranb,\n    const ptrdiff_t *isgn,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *b,\n    const ptrdiff_t *ldb,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *scale,\n    ptrdiff_t *info\n);\n\n/* Source: ztrti2.f */\n#define ztrti2 FORTRAN_WRAPPER(ztrti2)\nextern void ztrti2(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: ztrtri.f */\n#define ztrtri FORTRAN_WRAPPER(ztrtri)\nextern void ztrtri(\n    const char   *uplo,\n    const char   *diag,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    ptrdiff_t *info\n);\n\n/* Source: ztrtrs.f */\n#define ztrtrs FORTRAN_WRAPPER(ztrtrs)\nextern void ztrtrs(\n    const char   *uplo,\n    const char   *trans,\n    const char   *diag,\n    const ptrdiff_t *n,\n    const ptrdiff_t *nrhs,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *b,\n    const ptrdiff_t *ldb,\n    ptrdiff_t *info\n);\n\n/* Source: ztrttf.f */\n#define ztrttf FORTRAN_WRAPPER(ztrttf)\nextern void ztrttf(\n    const char   *transr,\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *arf,\n    ptrdiff_t *info\n);\n\n/* Source: ztrttp.f */\n#define ztrttp FORTRAN_WRAPPER(ztrttp)\nextern void ztrttp(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    double *ap,\n    ptrdiff_t *info\n);\n\n/* Source: ztzrzf.f */\n#define ztzrzf FORTRAN_WRAPPER(ztzrzf)\nextern void ztzrzf(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunbdb.f */\n#define zunbdb FORTRAN_WRAPPER(zunbdb)\nextern void zunbdb(\n    const char   *trans,\n    const char   *signs,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x12,\n    const ptrdiff_t *ldx12,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *x22,\n    const ptrdiff_t *ldx22,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *tauq2,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunbdb1.f */\n#define zunbdb1 FORTRAN_WRAPPER(zunbdb1)\nextern void zunbdb1(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunbdb2.f */\n#define zunbdb2 FORTRAN_WRAPPER(zunbdb2)\nextern void zunbdb2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunbdb3.f */\n#define zunbdb3 FORTRAN_WRAPPER(zunbdb3)\nextern void zunbdb3(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunbdb4.f */\n#define zunbdb4 FORTRAN_WRAPPER(zunbdb4)\nextern void zunbdb4(\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *phi,\n    double *taup1,\n    double *taup2,\n    double *tauq1,\n    double *phantom,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunbdb5.f */\n#define zunbdb5 FORTRAN_WRAPPER(zunbdb5)\nextern void zunbdb5(\n    const ptrdiff_t *m1,\n    const ptrdiff_t *m2,\n    const ptrdiff_t *n,\n    double *x1,\n    const ptrdiff_t *incx1,\n    double *x2,\n    const ptrdiff_t *incx2,\n    double *q1,\n    const ptrdiff_t *ldq1,\n    double *q2,\n    const ptrdiff_t *ldq2,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunbdb6.f */\n#define zunbdb6 FORTRAN_WRAPPER(zunbdb6)\nextern void zunbdb6(\n    const ptrdiff_t *m1,\n    const ptrdiff_t *m2,\n    const ptrdiff_t *n,\n    double *x1,\n    const ptrdiff_t *incx1,\n    double *x2,\n    const ptrdiff_t *incx2,\n    double *q1,\n    const ptrdiff_t *ldq1,\n    double *q2,\n    const ptrdiff_t *ldq2,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zuncsd.f */\n#define zuncsd FORTRAN_WRAPPER(zuncsd)\nextern void zuncsd(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const char   *jobv2t,\n    const char   *trans,\n    const char   *signs,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x12,\n    const ptrdiff_t *ldx12,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *x22,\n    const ptrdiff_t *ldx22,\n    double *theta,\n    double *u1,\n    const ptrdiff_t *ldu1,\n    double *u2,\n    const ptrdiff_t *ldu2,\n    double *v1t,\n    const ptrdiff_t *ldv1t,\n    double *v2t,\n    const ptrdiff_t *ldv2t,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zuncsd2by1.f */\n#define zuncsd2by1 FORTRAN_WRAPPER(zuncsd2by1)\nextern void zuncsd2by1(\n    const char   *jobu1,\n    const char   *jobu2,\n    const char   *jobv1t,\n    const ptrdiff_t *m,\n    const ptrdiff_t *p,\n    const ptrdiff_t *q,\n    double *x11,\n    const ptrdiff_t *ldx11,\n    double *x21,\n    const ptrdiff_t *ldx21,\n    double *theta,\n    double *u1,\n    const ptrdiff_t *ldu1,\n    double *u2,\n    const ptrdiff_t *ldu2,\n    double *v1t,\n    const ptrdiff_t *ldv1t,\n    double *work,\n    const ptrdiff_t *lwork,\n    double *rwork,\n    const ptrdiff_t *lrwork,\n    ptrdiff_t *iwork,\n    ptrdiff_t *info\n);\n\n/* Source: zung2l.f */\n#define zung2l FORTRAN_WRAPPER(zung2l)\nextern void zung2l(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zung2r.f */\n#define zung2r FORTRAN_WRAPPER(zung2r)\nextern void zung2r(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zungbr.f */\n#define zungbr FORTRAN_WRAPPER(zungbr)\nextern void zungbr(\n    const char   *vect,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunghr.f */\n#define zunghr FORTRAN_WRAPPER(zunghr)\nextern void zunghr(\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zungl2.f */\n#define zungl2 FORTRAN_WRAPPER(zungl2)\nextern void zungl2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zunglq.f */\n#define zunglq FORTRAN_WRAPPER(zunglq)\nextern void zunglq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zungql.f */\n#define zungql FORTRAN_WRAPPER(zungql)\nextern void zungql(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zungqr.f */\n#define zungqr FORTRAN_WRAPPER(zungqr)\nextern void zungqr(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zungr2.f */\n#define zungr2 FORTRAN_WRAPPER(zungr2)\nextern void zungr2(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zungrq.f */\n#define zungrq FORTRAN_WRAPPER(zungrq)\nextern void zungrq(\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zungtr.f */\n#define zungtr FORTRAN_WRAPPER(zungtr)\nextern void zungtr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunm22.f */\n#define zunm22 FORTRAN_WRAPPER(zunm22)\nextern void zunm22(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *n1,\n    const ptrdiff_t *n2,\n    const double *q,\n    const ptrdiff_t *ldq,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunm2l.f */\n#define zunm2l FORTRAN_WRAPPER(zunm2l)\nextern void zunm2l(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zunm2r.f */\n#define zunm2r FORTRAN_WRAPPER(zunm2r)\nextern void zunm2r(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zunmbr.f */\n#define zunmbr FORTRAN_WRAPPER(zunmbr)\nextern void zunmbr(\n    const char   *vect,\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunmhr.f */\n#define zunmhr FORTRAN_WRAPPER(zunmhr)\nextern void zunmhr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *ilo,\n    const ptrdiff_t *ihi,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunml2.f */\n#define zunml2 FORTRAN_WRAPPER(zunml2)\nextern void zunml2(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zunmlq.f */\n#define zunmlq FORTRAN_WRAPPER(zunmlq)\nextern void zunmlq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunmql.f */\n#define zunmql FORTRAN_WRAPPER(zunmql)\nextern void zunmql(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunmqr.f */\n#define zunmqr FORTRAN_WRAPPER(zunmqr)\nextern void zunmqr(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunmr2.f */\n#define zunmr2 FORTRAN_WRAPPER(zunmr2)\nextern void zunmr2(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zunmr3.f */\n#define zunmr3 FORTRAN_WRAPPER(zunmr3)\nextern void zunmr3(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zunmrq.f */\n#define zunmrq FORTRAN_WRAPPER(zunmrq)\nextern void zunmrq(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunmrz.f */\n#define zunmrz FORTRAN_WRAPPER(zunmrz)\nextern void zunmrz(\n    const char   *side,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const ptrdiff_t *k,\n    const ptrdiff_t *l,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zunmtr.f */\n#define zunmtr FORTRAN_WRAPPER(zunmtr)\nextern void zunmtr(\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *a,\n    const ptrdiff_t *lda,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    const ptrdiff_t *lwork,\n    ptrdiff_t *info\n);\n\n/* Source: zupgtr.f */\n#define zupgtr FORTRAN_WRAPPER(zupgtr)\nextern void zupgtr(\n    const char   *uplo,\n    const ptrdiff_t *n,\n    const double *ap,\n    const double *tau,\n    double *q,\n    const ptrdiff_t *ldq,\n    double *work,\n    ptrdiff_t *info\n);\n\n/* Source: zupmtr.f */\n#define zupmtr FORTRAN_WRAPPER(zupmtr)\nextern void zupmtr(\n    const char   *side,\n    const char   *uplo,\n    const char   *trans,\n    const ptrdiff_t *m,\n    const ptrdiff_t *n,\n    const double *ap,\n    const double *tau,\n    double *c,\n    const ptrdiff_t *ldc,\n    double *work,\n    ptrdiff_t *info\n);\n\n#endif /* !defined(MW_HAVE_LAPACK_DECLS) && defined(_LAPACKE_H_) %#ok */\n#ifdef __cplusplus\n    }   /* extern \"C\" */\n#endif\n\n#endif /* mllapack_h */\n"},{"name":"lapacke.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*****************************************************************************\n  Copyright (c) 2014, Intel Corp.\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of Intel Corporation nor the names of its contributors\n      may be used to endorse or promote products derived from this software\n      without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n  THE POSSIBILITY OF SUCH DAMAGE.\n******************************************************************************\n* Contents: Native C interface to LAPACK\n* Author: Intel Corporation\n* Generated August, 2015\n*****************************************************************************/\n\n#ifndef _LAPACKE_H_\n#define _LAPACKE_H_\n\n/*\n * No C99 complex with MSVC so default to complex structure if the user has not\n * requested anything else\n */\n#if defined(_WIN32) && !defined(HAVE_LAPACK_CONFIG_H)\n#define HAVE_LAPACK_CONFIG_H\n#define LAPACK_COMPLEX_STRUCTURE\n#endif\n\n/*\n*  Turn on HAVE_LAPACK_CONFIG_H to redefine C-LAPACK datatypes\n*/\n#ifdef HAVE_LAPACK_CONFIG_H\n#include \"lapacke_config.h\"\n#endif\n\n#include <stdlib.h>\n#include <stddef.h>\n\n#ifndef lapack_int\n#define lapack_int     ptrdiff_t\n#endif\n\n#ifndef lapack_logical\n#define lapack_logical lapack_int\n#endif\n\n/* Complex types are structures equivalent to the\n* Fortran complex types COMPLEX(4) and COMPLEX(8).\n*\n* One can also redefine the types with his own types\n* for example by including in the code definitions like\n*\n* #define lapack_complex_float std::complex<float>\n* #define lapack_complex_double std::complex<double>\n*\n* or define these types in the command line:\n*\n* -Dlapack_complex_float=\"std::complex<float>\"\n* -Dlapack_complex_double=\"std::complex<double>\"\n*/\n\n#ifndef LAPACK_COMPLEX_CUSTOM\n\n/* Complex type (single precision) */\n#ifndef lapack_complex_float\n#include <complex.h>\n#define lapack_complex_float    float _Complex\n#endif\n\n#ifndef lapack_complex_float_real\n#define lapack_complex_float_real(z)       (creal(z))\n#endif\n\n#ifndef lapack_complex_float_imag\n#define lapack_complex_float_imag(z)       (cimag(z))\n#endif\n\nlapack_complex_float lapack_make_complex_float( float re, float im );\n\n/* Complex type (double precision) */\n#ifndef lapack_complex_double\n#include <complex.h>\n#define lapack_complex_double   double _Complex\n#endif\n\n#ifndef lapack_complex_double_real\n#define lapack_complex_double_real(z)      (creal(z))\n#endif\n\n#ifndef lapack_complex_double_imag\n#define lapack_complex_double_imag(z)       (cimag(z))\n#endif\n\nlapack_complex_double lapack_make_complex_double( double re, double im );\n\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef LAPACKE_malloc\n#define LAPACKE_malloc( size ) malloc( size )\n#endif\n#ifndef LAPACKE_free\n#define LAPACKE_free( p )      free( p )\n#endif\n\n#define LAPACK_C2INT( x ) (lapack_int)(*((float*)&x ))\n#define LAPACK_Z2INT( x ) (lapack_int)(*((double*)&x ))\n\n#define LAPACK_ROW_MAJOR               101\n#define LAPACK_COL_MAJOR               102\n\n#define LAPACK_WORK_MEMORY_ERROR       -1010\n#define LAPACK_TRANSPOSE_MEMORY_ERROR  -1011\n\n/* Callback logical functions of one, two, or three arguments are used\n*  to select eigenvalues to sort to the top left of the Schur form.\n*  The value is selected if function returns TRUE (non-zero). */\n\ntypedef lapack_logical (*LAPACK_S_SELECT2) ( const float*, const float* );\ntypedef lapack_logical (*LAPACK_S_SELECT3)\n    ( const float*, const float*, const float* );\ntypedef lapack_logical (*LAPACK_D_SELECT2) ( const double*, const double* );\ntypedef lapack_logical (*LAPACK_D_SELECT3)\n    ( const double*, const double*, const double* );\n\ntypedef lapack_logical (*LAPACK_C_SELECT1) ( const lapack_complex_float* );\ntypedef lapack_logical (*LAPACK_C_SELECT2)\n    ( const lapack_complex_float*, const lapack_complex_float* );\ntypedef lapack_logical (*LAPACK_Z_SELECT1) ( const lapack_complex_double* );\ntypedef lapack_logical (*LAPACK_Z_SELECT2)\n    ( const lapack_complex_double*, const lapack_complex_double* );\n\n/* #include \"lapacke_mangling.h\" */\n/* MathWorks-compatible name mangling */\n#if defined(_WIN32)\n#define LAPACK_GLOBAL(lcname,UCNAME)  lcname\n#else\n#define LAPACK_GLOBAL(lcname,UCNAME)  lcname##_\n#endif\n\n/* Filter lsame to prevent blas.h collisions */\n#ifdef MW_BUILDING_LAPACK\n#define LAPACK_lsame LAPACK_GLOBAL(lsame,LSAME)\nlapack_logical LAPACK_lsame( char* ca,  char* cb,\n                             lapack_int lca, lapack_int lcb );\n#endif /* MW_BUILDING_LAPACK */\n\n/* C-LAPACK function prototypes */\n\nlapack_int LAPACKE_sbdsdc( int matrix_layout, char uplo, char compq,\n                           lapack_int n, float* d, float* e, float* u,\n                           lapack_int ldu, float* vt, lapack_int ldvt, float* q,\n                           lapack_int* iq );\nlapack_int LAPACKE_dbdsdc( int matrix_layout, char uplo, char compq,\n                           lapack_int n, double* d, double* e, double* u,\n                           lapack_int ldu, double* vt, lapack_int ldvt,\n                           double* q, lapack_int* iq );\n\nlapack_int LAPACKE_sbdsqr( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int ncvt, lapack_int nru, lapack_int ncc,\n                           float* d, float* e, float* vt, lapack_int ldvt,\n                           float* u, lapack_int ldu, float* c, lapack_int ldc );\nlapack_int LAPACKE_dbdsqr( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int ncvt, lapack_int nru, lapack_int ncc,\n                           double* d, double* e, double* vt, lapack_int ldvt,\n                           double* u, lapack_int ldu, double* c,\n                           lapack_int ldc );\nlapack_int LAPACKE_cbdsqr( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int ncvt, lapack_int nru, lapack_int ncc,\n                           float* d, float* e, lapack_complex_float* vt,\n                           lapack_int ldvt, lapack_complex_float* u,\n                           lapack_int ldu, lapack_complex_float* c,\n                           lapack_int ldc );\nlapack_int LAPACKE_zbdsqr( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int ncvt, lapack_int nru, lapack_int ncc,\n                           double* d, double* e, lapack_complex_double* vt,\n                           lapack_int ldvt, lapack_complex_double* u,\n                           lapack_int ldu, lapack_complex_double* c,\n                           lapack_int ldc );\nlapack_int LAPACKE_sbdsvdx( int matrix_layout, char uplo, char jobz, char range,\n                           lapack_int n, float* d, float* e,\n                           float vl, float vu,\n                           lapack_int il, lapack_int iu, lapack_int* ns,\n                           float* s, float* z, lapack_int ldz,\n                           lapack_int* superb );\nlapack_int LAPACKE_dbdsvdx( int matrix_layout, char uplo, char jobz, char range,\n                           lapack_int n, double* d, double* e,\n                           double vl, double vu,\n                           lapack_int il, lapack_int iu, lapack_int* ns,\n                           double* s, double* z, lapack_int ldz,\n                           lapack_int* superb );\nlapack_int LAPACKE_sdisna( char job, lapack_int m, lapack_int n, const float* d,\n                           float* sep );\nlapack_int LAPACKE_ddisna( char job, lapack_int m, lapack_int n,\n                           const double* d, double* sep );\n\nlapack_int LAPACKE_sgbbrd( int matrix_layout, char vect, lapack_int m,\n                           lapack_int n, lapack_int ncc, lapack_int kl,\n                           lapack_int ku, float* ab, lapack_int ldab, float* d,\n                           float* e, float* q, lapack_int ldq, float* pt,\n                           lapack_int ldpt, float* c, lapack_int ldc );\nlapack_int LAPACKE_dgbbrd( int matrix_layout, char vect, lapack_int m,\n                           lapack_int n, lapack_int ncc, lapack_int kl,\n                           lapack_int ku, double* ab, lapack_int ldab,\n                           double* d, double* e, double* q, lapack_int ldq,\n                           double* pt, lapack_int ldpt, double* c,\n                           lapack_int ldc );\nlapack_int LAPACKE_cgbbrd( int matrix_layout, char vect, lapack_int m,\n                           lapack_int n, lapack_int ncc, lapack_int kl,\n                           lapack_int ku, lapack_complex_float* ab,\n                           lapack_int ldab, float* d, float* e,\n                           lapack_complex_float* q, lapack_int ldq,\n                           lapack_complex_float* pt, lapack_int ldpt,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zgbbrd( int matrix_layout, char vect, lapack_int m,\n                           lapack_int n, lapack_int ncc, lapack_int kl,\n                           lapack_int ku, lapack_complex_double* ab,\n                           lapack_int ldab, double* d, double* e,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_complex_double* pt, lapack_int ldpt,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sgbcon( int matrix_layout, char norm, lapack_int n,\n                           lapack_int kl, lapack_int ku, const float* ab,\n                           lapack_int ldab, const lapack_int* ipiv, float anorm,\n                           float* rcond );\nlapack_int LAPACKE_dgbcon( int matrix_layout, char norm, lapack_int n,\n                           lapack_int kl, lapack_int ku, const double* ab,\n                           lapack_int ldab, const lapack_int* ipiv,\n                           double anorm, double* rcond );\nlapack_int LAPACKE_cgbcon( int matrix_layout, char norm, lapack_int n,\n                           lapack_int kl, lapack_int ku,\n                           const lapack_complex_float* ab, lapack_int ldab,\n                           const lapack_int* ipiv, float anorm, float* rcond );\nlapack_int LAPACKE_zgbcon( int matrix_layout, char norm, lapack_int n,\n                           lapack_int kl, lapack_int ku,\n                           const lapack_complex_double* ab, lapack_int ldab,\n                           const lapack_int* ipiv, double anorm,\n                           double* rcond );\n\nlapack_int LAPACKE_sgbequ( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int kl, lapack_int ku, const float* ab,\n                           lapack_int ldab, float* r, float* c, float* rowcnd,\n                           float* colcnd, float* amax );\nlapack_int LAPACKE_dgbequ( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int kl, lapack_int ku, const double* ab,\n                           lapack_int ldab, double* r, double* c,\n                           double* rowcnd, double* colcnd, double* amax );\nlapack_int LAPACKE_cgbequ( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int kl, lapack_int ku,\n                           const lapack_complex_float* ab, lapack_int ldab,\n                           float* r, float* c, float* rowcnd, float* colcnd,\n                           float* amax );\nlapack_int LAPACKE_zgbequ( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int kl, lapack_int ku,\n                           const lapack_complex_double* ab, lapack_int ldab,\n                           double* r, double* c, double* rowcnd, double* colcnd,\n                           double* amax );\n\nlapack_int LAPACKE_sgbequb( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_int kl, lapack_int ku, const float* ab,\n                            lapack_int ldab, float* r, float* c, float* rowcnd,\n                            float* colcnd, float* amax );\nlapack_int LAPACKE_dgbequb( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_int kl, lapack_int ku, const double* ab,\n                            lapack_int ldab, double* r, double* c,\n                            double* rowcnd, double* colcnd, double* amax );\nlapack_int LAPACKE_cgbequb( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_int kl, lapack_int ku,\n                            const lapack_complex_float* ab, lapack_int ldab,\n                            float* r, float* c, float* rowcnd, float* colcnd,\n                            float* amax );\nlapack_int LAPACKE_zgbequb( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_int kl, lapack_int ku,\n                            const lapack_complex_double* ab, lapack_int ldab,\n                            double* r, double* c, double* rowcnd,\n                            double* colcnd, double* amax );\n\nlapack_int LAPACKE_sgbrfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int kl, lapack_int ku, lapack_int nrhs,\n                           const float* ab, lapack_int ldab, const float* afb,\n                           lapack_int ldafb, const lapack_int* ipiv,\n                           const float* b, lapack_int ldb, float* x,\n                           lapack_int ldx, float* ferr, float* berr );\nlapack_int LAPACKE_dgbrfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int kl, lapack_int ku, lapack_int nrhs,\n                           const double* ab, lapack_int ldab, const double* afb,\n                           lapack_int ldafb, const lapack_int* ipiv,\n                           const double* b, lapack_int ldb, double* x,\n                           lapack_int ldx, double* ferr, double* berr );\nlapack_int LAPACKE_cgbrfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int kl, lapack_int ku, lapack_int nrhs,\n                           const lapack_complex_float* ab, lapack_int ldab,\n                           const lapack_complex_float* afb, lapack_int ldafb,\n                           const lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zgbrfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int kl, lapack_int ku, lapack_int nrhs,\n                           const lapack_complex_double* ab, lapack_int ldab,\n                           const lapack_complex_double* afb, lapack_int ldafb,\n                           const lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_sgbsv( int matrix_layout, lapack_int n, lapack_int kl,\n                          lapack_int ku, lapack_int nrhs, float* ab,\n                          lapack_int ldab, lapack_int* ipiv, float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_dgbsv( int matrix_layout, lapack_int n, lapack_int kl,\n                          lapack_int ku, lapack_int nrhs, double* ab,\n                          lapack_int ldab, lapack_int* ipiv, double* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_cgbsv( int matrix_layout, lapack_int n, lapack_int kl,\n                          lapack_int ku, lapack_int nrhs,\n                          lapack_complex_float* ab, lapack_int ldab,\n                          lapack_int* ipiv, lapack_complex_float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_zgbsv( int matrix_layout, lapack_int n, lapack_int kl,\n                          lapack_int ku, lapack_int nrhs,\n                          lapack_complex_double* ab, lapack_int ldab,\n                          lapack_int* ipiv, lapack_complex_double* b,\n                          lapack_int ldb );\n\nlapack_int LAPACKE_sgbsvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int kl, lapack_int ku,\n                           lapack_int nrhs, float* ab, lapack_int ldab,\n                           float* afb, lapack_int ldafb, lapack_int* ipiv,\n                           char* equed, float* r, float* c, float* b,\n                           lapack_int ldb, float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr,\n                           float* rpivot );\nlapack_int LAPACKE_dgbsvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int kl, lapack_int ku,\n                           lapack_int nrhs, double* ab, lapack_int ldab,\n                           double* afb, lapack_int ldafb, lapack_int* ipiv,\n                           char* equed, double* r, double* c, double* b,\n                           lapack_int ldb, double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr,\n                           double* rpivot );\nlapack_int LAPACKE_cgbsvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int kl, lapack_int ku,\n                           lapack_int nrhs, lapack_complex_float* ab,\n                           lapack_int ldab, lapack_complex_float* afb,\n                           lapack_int ldafb, lapack_int* ipiv, char* equed,\n                           float* r, float* c, lapack_complex_float* b,\n                           lapack_int ldb, lapack_complex_float* x,\n                           lapack_int ldx, float* rcond, float* ferr,\n                           float* berr, float* rpivot );\nlapack_int LAPACKE_zgbsvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int kl, lapack_int ku,\n                           lapack_int nrhs, lapack_complex_double* ab,\n                           lapack_int ldab, lapack_complex_double* afb,\n                           lapack_int ldafb, lapack_int* ipiv, char* equed,\n                           double* r, double* c, lapack_complex_double* b,\n                           lapack_int ldb, lapack_complex_double* x,\n                           lapack_int ldx, double* rcond, double* ferr,\n                           double* berr, double* rpivot );\n\nlapack_int LAPACKE_sgbtrf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int kl, lapack_int ku, float* ab,\n                           lapack_int ldab, lapack_int* ipiv );\nlapack_int LAPACKE_dgbtrf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int kl, lapack_int ku, double* ab,\n                           lapack_int ldab, lapack_int* ipiv );\nlapack_int LAPACKE_cgbtrf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int kl, lapack_int ku,\n                           lapack_complex_float* ab, lapack_int ldab,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_zgbtrf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int kl, lapack_int ku,\n                           lapack_complex_double* ab, lapack_int ldab,\n                           lapack_int* ipiv );\n\nlapack_int LAPACKE_sgbtrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int kl, lapack_int ku, lapack_int nrhs,\n                           const float* ab, lapack_int ldab,\n                           const lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_dgbtrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int kl, lapack_int ku, lapack_int nrhs,\n                           const double* ab, lapack_int ldab,\n                           const lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_cgbtrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int kl, lapack_int ku, lapack_int nrhs,\n                           const lapack_complex_float* ab, lapack_int ldab,\n                           const lapack_int* ipiv, lapack_complex_float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_zgbtrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int kl, lapack_int ku, lapack_int nrhs,\n                           const lapack_complex_double* ab, lapack_int ldab,\n                           const lapack_int* ipiv, lapack_complex_double* b,\n                           lapack_int ldb );\n\nlapack_int LAPACKE_sgebak( int matrix_layout, char job, char side, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, const float* scale,\n                           lapack_int m, float* v, lapack_int ldv );\nlapack_int LAPACKE_dgebak( int matrix_layout, char job, char side, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, const double* scale,\n                           lapack_int m, double* v, lapack_int ldv );\nlapack_int LAPACKE_cgebak( int matrix_layout, char job, char side, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, const float* scale,\n                           lapack_int m, lapack_complex_float* v,\n                           lapack_int ldv );\nlapack_int LAPACKE_zgebak( int matrix_layout, char job, char side, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, const double* scale,\n                           lapack_int m, lapack_complex_double* v,\n                           lapack_int ldv );\n\nlapack_int LAPACKE_sgebal( int matrix_layout, char job, lapack_int n, float* a,\n                           lapack_int lda, lapack_int* ilo, lapack_int* ihi,\n                           float* scale );\nlapack_int LAPACKE_dgebal( int matrix_layout, char job, lapack_int n, double* a,\n                           lapack_int lda, lapack_int* ilo, lapack_int* ihi,\n                           double* scale );\nlapack_int LAPACKE_cgebal( int matrix_layout, char job, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* ilo, lapack_int* ihi, float* scale );\nlapack_int LAPACKE_zgebal( int matrix_layout, char job, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ilo, lapack_int* ihi, double* scale );\n\nlapack_int LAPACKE_sgebrd( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, float* d, float* e,\n                           float* tauq, float* taup );\nlapack_int LAPACKE_dgebrd( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, double* d, double* e,\n                           double* tauq, double* taup );\nlapack_int LAPACKE_cgebrd( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda, float* d,\n                           float* e, lapack_complex_float* tauq,\n                           lapack_complex_float* taup );\nlapack_int LAPACKE_zgebrd( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda, double* d,\n                           double* e, lapack_complex_double* tauq,\n                           lapack_complex_double* taup );\n\nlapack_int LAPACKE_sgecon( int matrix_layout, char norm, lapack_int n,\n                           const float* a, lapack_int lda, float anorm,\n                           float* rcond );\nlapack_int LAPACKE_dgecon( int matrix_layout, char norm, lapack_int n,\n                           const double* a, lapack_int lda, double anorm,\n                           double* rcond );\nlapack_int LAPACKE_cgecon( int matrix_layout, char norm, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           float anorm, float* rcond );\nlapack_int LAPACKE_zgecon( int matrix_layout, char norm, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           double anorm, double* rcond );\n\nlapack_int LAPACKE_sgeequ( int matrix_layout, lapack_int m, lapack_int n,\n                           const float* a, lapack_int lda, float* r, float* c,\n                           float* rowcnd, float* colcnd, float* amax );\nlapack_int LAPACKE_dgeequ( int matrix_layout, lapack_int m, lapack_int n,\n                           const double* a, lapack_int lda, double* r,\n                           double* c, double* rowcnd, double* colcnd,\n                           double* amax );\nlapack_int LAPACKE_cgeequ( int matrix_layout, lapack_int m, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           float* r, float* c, float* rowcnd, float* colcnd,\n                           float* amax );\nlapack_int LAPACKE_zgeequ( int matrix_layout, lapack_int m, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           double* r, double* c, double* rowcnd, double* colcnd,\n                           double* amax );\n\nlapack_int LAPACKE_sgeequb( int matrix_layout, lapack_int m, lapack_int n,\n                            const float* a, lapack_int lda, float* r, float* c,\n                            float* rowcnd, float* colcnd, float* amax );\nlapack_int LAPACKE_dgeequb( int matrix_layout, lapack_int m, lapack_int n,\n                            const double* a, lapack_int lda, double* r,\n                            double* c, double* rowcnd, double* colcnd,\n                            double* amax );\nlapack_int LAPACKE_cgeequb( int matrix_layout, lapack_int m, lapack_int n,\n                            const lapack_complex_float* a, lapack_int lda,\n                            float* r, float* c, float* rowcnd, float* colcnd,\n                            float* amax );\nlapack_int LAPACKE_zgeequb( int matrix_layout, lapack_int m, lapack_int n,\n                            const lapack_complex_double* a, lapack_int lda,\n                            double* r, double* c, double* rowcnd,\n                            double* colcnd, double* amax );\n\nlapack_int LAPACKE_sgees( int matrix_layout, char jobvs, char sort,\n                          LAPACK_S_SELECT2 select, lapack_int n, float* a,\n                          lapack_int lda, lapack_int* sdim, float* wr,\n                          float* wi, float* vs, lapack_int ldvs );\nlapack_int LAPACKE_dgees( int matrix_layout, char jobvs, char sort,\n                          LAPACK_D_SELECT2 select, lapack_int n, double* a,\n                          lapack_int lda, lapack_int* sdim, double* wr,\n                          double* wi, double* vs, lapack_int ldvs );\nlapack_int LAPACKE_cgees( int matrix_layout, char jobvs, char sort,\n                          LAPACK_C_SELECT1 select, lapack_int n,\n                          lapack_complex_float* a, lapack_int lda,\n                          lapack_int* sdim, lapack_complex_float* w,\n                          lapack_complex_float* vs, lapack_int ldvs );\nlapack_int LAPACKE_zgees( int matrix_layout, char jobvs, char sort,\n                          LAPACK_Z_SELECT1 select, lapack_int n,\n                          lapack_complex_double* a, lapack_int lda,\n                          lapack_int* sdim, lapack_complex_double* w,\n                          lapack_complex_double* vs, lapack_int ldvs );\n\nlapack_int LAPACKE_sgeesx( int matrix_layout, char jobvs, char sort,\n                           LAPACK_S_SELECT2 select, char sense, lapack_int n,\n                           float* a, lapack_int lda, lapack_int* sdim,\n                           float* wr, float* wi, float* vs, lapack_int ldvs,\n                           float* rconde, float* rcondv );\nlapack_int LAPACKE_dgeesx( int matrix_layout, char jobvs, char sort,\n                           LAPACK_D_SELECT2 select, char sense, lapack_int n,\n                           double* a, lapack_int lda, lapack_int* sdim,\n                           double* wr, double* wi, double* vs, lapack_int ldvs,\n                           double* rconde, double* rcondv );\nlapack_int LAPACKE_cgeesx( int matrix_layout, char jobvs, char sort,\n                           LAPACK_C_SELECT1 select, char sense, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* sdim, lapack_complex_float* w,\n                           lapack_complex_float* vs, lapack_int ldvs,\n                           float* rconde, float* rcondv );\nlapack_int LAPACKE_zgeesx( int matrix_layout, char jobvs, char sort,\n                           LAPACK_Z_SELECT1 select, char sense, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* sdim, lapack_complex_double* w,\n                           lapack_complex_double* vs, lapack_int ldvs,\n                           double* rconde, double* rcondv );\n\nlapack_int LAPACKE_sgeev( int matrix_layout, char jobvl, char jobvr,\n                          lapack_int n, float* a, lapack_int lda, float* wr,\n                          float* wi, float* vl, lapack_int ldvl, float* vr,\n                          lapack_int ldvr );\nlapack_int LAPACKE_dgeev( int matrix_layout, char jobvl, char jobvr,\n                          lapack_int n, double* a, lapack_int lda, double* wr,\n                          double* wi, double* vl, lapack_int ldvl, double* vr,\n                          lapack_int ldvr );\nlapack_int LAPACKE_cgeev( int matrix_layout, char jobvl, char jobvr,\n                          lapack_int n, lapack_complex_float* a, lapack_int lda,\n                          lapack_complex_float* w, lapack_complex_float* vl,\n                          lapack_int ldvl, lapack_complex_float* vr,\n                          lapack_int ldvr );\nlapack_int LAPACKE_zgeev( int matrix_layout, char jobvl, char jobvr,\n                          lapack_int n, lapack_complex_double* a,\n                          lapack_int lda, lapack_complex_double* w,\n                          lapack_complex_double* vl, lapack_int ldvl,\n                          lapack_complex_double* vr, lapack_int ldvr );\n\nlapack_int LAPACKE_sgeevx( int matrix_layout, char balanc, char jobvl,\n                           char jobvr, char sense, lapack_int n, float* a,\n                           lapack_int lda, float* wr, float* wi, float* vl,\n                           lapack_int ldvl, float* vr, lapack_int ldvr,\n                           lapack_int* ilo, lapack_int* ihi, float* scale,\n                           float* abnrm, float* rconde, float* rcondv );\nlapack_int LAPACKE_dgeevx( int matrix_layout, char balanc, char jobvl,\n                           char jobvr, char sense, lapack_int n, double* a,\n                           lapack_int lda, double* wr, double* wi, double* vl,\n                           lapack_int ldvl, double* vr, lapack_int ldvr,\n                           lapack_int* ilo, lapack_int* ihi, double* scale,\n                           double* abnrm, double* rconde, double* rcondv );\nlapack_int LAPACKE_cgeevx( int matrix_layout, char balanc, char jobvl,\n                           char jobvr, char sense, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* w, lapack_complex_float* vl,\n                           lapack_int ldvl, lapack_complex_float* vr,\n                           lapack_int ldvr, lapack_int* ilo, lapack_int* ihi,\n                           float* scale, float* abnrm, float* rconde,\n                           float* rcondv );\nlapack_int LAPACKE_zgeevx( int matrix_layout, char balanc, char jobvl,\n                           char jobvr, char sense, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* w, lapack_complex_double* vl,\n                           lapack_int ldvl, lapack_complex_double* vr,\n                           lapack_int ldvr, lapack_int* ilo, lapack_int* ihi,\n                           double* scale, double* abnrm, double* rconde,\n                           double* rcondv );\n\nlapack_int LAPACKE_sgehrd( int matrix_layout, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, float* a, lapack_int lda,\n                           float* tau );\nlapack_int LAPACKE_dgehrd( int matrix_layout, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, double* a, lapack_int lda,\n                           double* tau );\nlapack_int LAPACKE_cgehrd( int matrix_layout, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* tau );\nlapack_int LAPACKE_zgehrd( int matrix_layout, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgejsv( int matrix_layout, char joba, char jobu, char jobv,\n                           char jobr, char jobt, char jobp, lapack_int m,\n                           lapack_int n, float* a, lapack_int lda, float* sva,\n                           float* u, lapack_int ldu, float* v, lapack_int ldv,\n                           float* stat, lapack_int* istat );\nlapack_int LAPACKE_dgejsv( int matrix_layout, char joba, char jobu, char jobv,\n                           char jobr, char jobt, char jobp, lapack_int m,\n                           lapack_int n, double* a, lapack_int lda, double* sva,\n                           double* u, lapack_int ldu, double* v, lapack_int ldv,\n                           double* stat, lapack_int* istat );\nlapack_int LAPACKE_cgejsv( int matrix_layout, char joba, char jobu, char jobv,\n                           char jobr, char jobt, char jobp, lapack_int m,\n                           lapack_int n, lapack_complex_float* a, lapack_int lda, float* sva,\n                           lapack_complex_float* u, lapack_int ldu, lapack_complex_float* v, lapack_int ldv,\n                           float* stat, lapack_int* istat );\nlapack_int LAPACKE_zgejsv( int matrix_layout, char joba, char jobu, char jobv,\n                           char jobr, char jobt, char jobp, lapack_int m,\n                           lapack_int n, lapack_complex_double* a, lapack_int lda, double* sva,\n                           lapack_complex_double* u, lapack_int ldu, lapack_complex_double* v, lapack_int ldv,\n                           double* stat, lapack_int* istat );\n\nlapack_int LAPACKE_sgelq2( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, float* tau );\nlapack_int LAPACKE_dgelq2( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, double* tau );\nlapack_int LAPACKE_cgelq2( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* tau );\nlapack_int LAPACKE_zgelq2( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgelqf( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, float* tau );\nlapack_int LAPACKE_dgelqf( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, double* tau );\nlapack_int LAPACKE_cgelqf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* tau );\nlapack_int LAPACKE_zgelqf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgels( int matrix_layout, char trans, lapack_int m,\n                          lapack_int n, lapack_int nrhs, float* a,\n                          lapack_int lda, float* b, lapack_int ldb );\nlapack_int LAPACKE_dgels( int matrix_layout, char trans, lapack_int m,\n                          lapack_int n, lapack_int nrhs, double* a,\n                          lapack_int lda, double* b, lapack_int ldb );\nlapack_int LAPACKE_cgels( int matrix_layout, char trans, lapack_int m,\n                          lapack_int n, lapack_int nrhs,\n                          lapack_complex_float* a, lapack_int lda,\n                          lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zgels( int matrix_layout, char trans, lapack_int m,\n                          lapack_int n, lapack_int nrhs,\n                          lapack_complex_double* a, lapack_int lda,\n                          lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sgelsd( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, float* a, lapack_int lda, float* b,\n                           lapack_int ldb, float* s, float rcond,\n                           lapack_int* rank );\nlapack_int LAPACKE_dgelsd( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, double* a, lapack_int lda,\n                           double* b, lapack_int ldb, double* s, double rcond,\n                           lapack_int* rank );\nlapack_int LAPACKE_cgelsd( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb, float* s, float rcond,\n                           lapack_int* rank );\nlapack_int LAPACKE_zgelsd( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb, double* s, double rcond,\n                           lapack_int* rank );\n\nlapack_int LAPACKE_sgelss( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, float* a, lapack_int lda, float* b,\n                           lapack_int ldb, float* s, float rcond,\n                           lapack_int* rank );\nlapack_int LAPACKE_dgelss( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, double* a, lapack_int lda,\n                           double* b, lapack_int ldb, double* s, double rcond,\n                           lapack_int* rank );\nlapack_int LAPACKE_cgelss( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb, float* s, float rcond,\n                           lapack_int* rank );\nlapack_int LAPACKE_zgelss( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb, double* s, double rcond,\n                           lapack_int* rank );\n\nlapack_int LAPACKE_sgelsy( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, float* a, lapack_int lda, float* b,\n                           lapack_int ldb, lapack_int* jpvt, float rcond,\n                           lapack_int* rank );\nlapack_int LAPACKE_dgelsy( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, double* a, lapack_int lda,\n                           double* b, lapack_int ldb, lapack_int* jpvt,\n                           double rcond, lapack_int* rank );\nlapack_int LAPACKE_cgelsy( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb, lapack_int* jpvt, float rcond,\n                           lapack_int* rank );\nlapack_int LAPACKE_zgelsy( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nrhs, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb, lapack_int* jpvt, double rcond,\n                           lapack_int* rank );\n\nlapack_int LAPACKE_sgeqlf( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, float* tau );\nlapack_int LAPACKE_dgeqlf( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, double* tau );\nlapack_int LAPACKE_cgeqlf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* tau );\nlapack_int LAPACKE_zgeqlf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgeqp3( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, lapack_int* jpvt,\n                           float* tau );\nlapack_int LAPACKE_dgeqp3( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, lapack_int* jpvt,\n                           double* tau );\nlapack_int LAPACKE_cgeqp3( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* jpvt, lapack_complex_float* tau );\nlapack_int LAPACKE_zgeqp3( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* jpvt, lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgeqpf( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, lapack_int* jpvt,\n                           float* tau );\nlapack_int LAPACKE_dgeqpf( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, lapack_int* jpvt,\n                           double* tau );\nlapack_int LAPACKE_cgeqpf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* jpvt, lapack_complex_float* tau );\nlapack_int LAPACKE_zgeqpf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* jpvt, lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgeqr2( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, float* tau );\nlapack_int LAPACKE_dgeqr2( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, double* tau );\nlapack_int LAPACKE_cgeqr2( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* tau );\nlapack_int LAPACKE_zgeqr2( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgeqrf( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, float* tau );\nlapack_int LAPACKE_dgeqrf( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, double* tau );\nlapack_int LAPACKE_cgeqrf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* tau );\nlapack_int LAPACKE_zgeqrf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgeqrfp( int matrix_layout, lapack_int m, lapack_int n,\n                            float* a, lapack_int lda, float* tau );\nlapack_int LAPACKE_dgeqrfp( int matrix_layout, lapack_int m, lapack_int n,\n                            double* a, lapack_int lda, double* tau );\nlapack_int LAPACKE_cgeqrfp( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_complex_float* a, lapack_int lda,\n                            lapack_complex_float* tau );\nlapack_int LAPACKE_zgeqrfp( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_complex_double* a, lapack_int lda,\n                            lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgerfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const float* a, lapack_int lda,\n                           const float* af, lapack_int ldaf,\n                           const lapack_int* ipiv, const float* b,\n                           lapack_int ldb, float* x, lapack_int ldx,\n                           float* ferr, float* berr );\nlapack_int LAPACKE_dgerfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const double* a, lapack_int lda,\n                           const double* af, lapack_int ldaf,\n                           const lapack_int* ipiv, const double* b,\n                           lapack_int ldb, double* x, lapack_int ldx,\n                           double* ferr, double* berr );\nlapack_int LAPACKE_cgerfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* af,\n                           lapack_int ldaf, const lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zgerfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* af,\n                           lapack_int ldaf, const lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_sgerqf( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, float* tau );\nlapack_int LAPACKE_dgerqf( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, double* tau );\nlapack_int LAPACKE_cgerqf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* tau );\nlapack_int LAPACKE_zgerqf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* tau );\n\nlapack_int LAPACKE_sgesdd( int matrix_layout, char jobz, lapack_int m,\n                           lapack_int n, float* a, lapack_int lda, float* s,\n                           float* u, lapack_int ldu, float* vt,\n                           lapack_int ldvt );\nlapack_int LAPACKE_dgesdd( int matrix_layout, char jobz, lapack_int m,\n                           lapack_int n, double* a, lapack_int lda, double* s,\n                           double* u, lapack_int ldu, double* vt,\n                           lapack_int ldvt );\nlapack_int LAPACKE_cgesdd( int matrix_layout, char jobz, lapack_int m,\n                           lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, float* s, lapack_complex_float* u,\n                           lapack_int ldu, lapack_complex_float* vt,\n                           lapack_int ldvt );\nlapack_int LAPACKE_zgesdd( int matrix_layout, char jobz, lapack_int m,\n                           lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, double* s, lapack_complex_double* u,\n                           lapack_int ldu, lapack_complex_double* vt,\n                           lapack_int ldvt );\n\nlapack_int LAPACKE_sgesv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          float* a, lapack_int lda, lapack_int* ipiv, float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_dgesv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          double* a, lapack_int lda, lapack_int* ipiv,\n                          double* b, lapack_int ldb );\nlapack_int LAPACKE_cgesv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          lapack_complex_float* a, lapack_int lda,\n                          lapack_int* ipiv, lapack_complex_float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_zgesv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          lapack_complex_double* a, lapack_int lda,\n                          lapack_int* ipiv, lapack_complex_double* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_dsgesv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                           double* a, lapack_int lda, lapack_int* ipiv,\n                           double* b, lapack_int ldb, double* x, lapack_int ldx,\n                           lapack_int* iter );\nlapack_int LAPACKE_zcgesv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ipiv, lapack_complex_double* b,\n                           lapack_int ldb, lapack_complex_double* x,\n                           lapack_int ldx, lapack_int* iter );\n\nlapack_int LAPACKE_sgesvd( int matrix_layout, char jobu, char jobvt,\n                           lapack_int m, lapack_int n, float* a, lapack_int lda,\n                           float* s, float* u, lapack_int ldu, float* vt,\n                           lapack_int ldvt, float* superb );\nlapack_int LAPACKE_dgesvd( int matrix_layout, char jobu, char jobvt,\n                           lapack_int m, lapack_int n, double* a,\n                           lapack_int lda, double* s, double* u, lapack_int ldu,\n                           double* vt, lapack_int ldvt, double* superb );\nlapack_int LAPACKE_cgesvd( int matrix_layout, char jobu, char jobvt,\n                           lapack_int m, lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, float* s, lapack_complex_float* u,\n                           lapack_int ldu, lapack_complex_float* vt,\n                           lapack_int ldvt, float* superb );\nlapack_int LAPACKE_zgesvd( int matrix_layout, char jobu, char jobvt,\n                           lapack_int m, lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, double* s, lapack_complex_double* u,\n                           lapack_int ldu, lapack_complex_double* vt,\n                           lapack_int ldvt, double* superb );\n\nlapack_int LAPACKE_sgesvdx( int matrix_layout, char jobu, char jobvt, char range,\n                           lapack_int m, lapack_int n, float* a,\n                           lapack_int lda, float vl, float vu,\n                           lapack_int il, lapack_int iu, lapack_int* ns,\n                           float* s, float* u, lapack_int ldu,\n                           float* vt, lapack_int ldvt,\n                           lapack_int* superb );\nlapack_int LAPACKE_dgesvdx( int matrix_layout, char jobu, char jobvt, char range,\n                           lapack_int m, lapack_int n, double* a,\n                           lapack_int lda, double vl, double vu,\n                           lapack_int il, lapack_int iu, lapack_int* ns,\n                           double* s, double* u, lapack_int ldu,\n                           double* vt, lapack_int ldvt,\n                           lapack_int* superb );\nlapack_int LAPACKE_cgesvdx( int matrix_layout, char jobu, char jobvt, char range,\n                           lapack_int m, lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, float vl, float vu,\n                           lapack_int il, lapack_int iu, lapack_int* ns,\n                           float* s, lapack_complex_float* u, lapack_int ldu,\n                           lapack_complex_float* vt, lapack_int ldvt,\n                           lapack_int* superb );\nlapack_int LAPACKE_zgesvdx( int matrix_layout, char jobu, char jobvt, char range,\n                           lapack_int m, lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, double vl, double vu,\n                           lapack_int il, lapack_int iu, lapack_int* ns,\n                           double* s, lapack_complex_double* u, lapack_int ldu,\n                           lapack_complex_double* vt, lapack_int ldvt,\n                           lapack_int* superb );\n\nlapack_int LAPACKE_sgesvj( int matrix_layout, char joba, char jobu, char jobv,\n                           lapack_int m, lapack_int n, float* a, lapack_int lda,\n                           float* sva, lapack_int mv, float* v, lapack_int ldv,\n                           float* stat );\nlapack_int LAPACKE_dgesvj( int matrix_layout, char joba, char jobu, char jobv,\n                           lapack_int m, lapack_int n, double* a,\n                           lapack_int lda, double* sva, lapack_int mv,\n                           double* v, lapack_int ldv, double* stat );\nlapack_int LAPACKE_cgesvj( int matrix_layout, char joba, char jobu, char jobv,\n                           lapack_int m, lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, float* sva, lapack_int mv,\n                           lapack_complex_float* v, lapack_int ldv, float* stat );\nlapack_int LAPACKE_zgesvj( int matrix_layout, char joba, char jobu, char jobv,\n                           lapack_int m, lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, double* sva, lapack_int mv,\n                           lapack_complex_double* v, lapack_int ldv, double* stat );\n\nlapack_int LAPACKE_sgesvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int nrhs, float* a,\n                           lapack_int lda, float* af, lapack_int ldaf,\n                           lapack_int* ipiv, char* equed, float* r, float* c,\n                           float* b, lapack_int ldb, float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr,\n                           float* rpivot );\nlapack_int LAPACKE_dgesvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int nrhs, double* a,\n                           lapack_int lda, double* af, lapack_int ldaf,\n                           lapack_int* ipiv, char* equed, double* r, double* c,\n                           double* b, lapack_int ldb, double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr,\n                           double* rpivot );\nlapack_int LAPACKE_cgesvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int nrhs,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* af, lapack_int ldaf,\n                           lapack_int* ipiv, char* equed, float* r, float* c,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr,\n                           float* rpivot );\nlapack_int LAPACKE_zgesvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int nrhs,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* af, lapack_int ldaf,\n                           lapack_int* ipiv, char* equed, double* r, double* c,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr,\n                           double* rpivot );\n\nlapack_int LAPACKE_sgetf2( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_dgetf2( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_cgetf2( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_zgetf2( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ipiv );\n\nlapack_int LAPACKE_sgetrf( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_dgetrf( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_cgetrf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_zgetrf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ipiv );\n\nlapack_int LAPACKE_sgetrf2( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_dgetrf2( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_cgetrf2( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_zgetrf2( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ipiv );\n\nlapack_int LAPACKE_sgetri( int matrix_layout, lapack_int n, float* a,\n                           lapack_int lda, const lapack_int* ipiv );\nlapack_int LAPACKE_dgetri( int matrix_layout, lapack_int n, double* a,\n                           lapack_int lda, const lapack_int* ipiv );\nlapack_int LAPACKE_cgetri( int matrix_layout, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           const lapack_int* ipiv );\nlapack_int LAPACKE_zgetri( int matrix_layout, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           const lapack_int* ipiv );\n\nlapack_int LAPACKE_sgetrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const float* a, lapack_int lda,\n                           const lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_dgetrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const double* a, lapack_int lda,\n                           const lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_cgetrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zgetrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sggbak( int matrix_layout, char job, char side, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, const float* lscale,\n                           const float* rscale, lapack_int m, float* v,\n                           lapack_int ldv );\nlapack_int LAPACKE_dggbak( int matrix_layout, char job, char side, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, const double* lscale,\n                           const double* rscale, lapack_int m, double* v,\n                           lapack_int ldv );\nlapack_int LAPACKE_cggbak( int matrix_layout, char job, char side, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, const float* lscale,\n                           const float* rscale, lapack_int m,\n                           lapack_complex_float* v, lapack_int ldv );\nlapack_int LAPACKE_zggbak( int matrix_layout, char job, char side, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, const double* lscale,\n                           const double* rscale, lapack_int m,\n                           lapack_complex_double* v, lapack_int ldv );\n\nlapack_int LAPACKE_sggbal( int matrix_layout, char job, lapack_int n, float* a,\n                           lapack_int lda, float* b, lapack_int ldb,\n                           lapack_int* ilo, lapack_int* ihi, float* lscale,\n                           float* rscale );\nlapack_int LAPACKE_dggbal( int matrix_layout, char job, lapack_int n, double* a,\n                           lapack_int lda, double* b, lapack_int ldb,\n                           lapack_int* ilo, lapack_int* ihi, double* lscale,\n                           double* rscale );\nlapack_int LAPACKE_cggbal( int matrix_layout, char job, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_int* ilo, lapack_int* ihi, float* lscale,\n                           float* rscale );\nlapack_int LAPACKE_zggbal( int matrix_layout, char job, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_int* ilo, lapack_int* ihi, double* lscale,\n                           double* rscale );\n\nlapack_int LAPACKE_sgges( int matrix_layout, char jobvsl, char jobvsr, char sort,\n                          LAPACK_S_SELECT3 selctg, lapack_int n, float* a,\n                          lapack_int lda, float* b, lapack_int ldb,\n                          lapack_int* sdim, float* alphar, float* alphai,\n                          float* beta, float* vsl, lapack_int ldvsl, float* vsr,\n                          lapack_int ldvsr );\nlapack_int LAPACKE_dgges( int matrix_layout, char jobvsl, char jobvsr, char sort,\n                          LAPACK_D_SELECT3 selctg, lapack_int n, double* a,\n                          lapack_int lda, double* b, lapack_int ldb,\n                          lapack_int* sdim, double* alphar, double* alphai,\n                          double* beta, double* vsl, lapack_int ldvsl,\n                          double* vsr, lapack_int ldvsr );\nlapack_int LAPACKE_cgges( int matrix_layout, char jobvsl, char jobvsr, char sort,\n                          LAPACK_C_SELECT2 selctg, lapack_int n,\n                          lapack_complex_float* a, lapack_int lda,\n                          lapack_complex_float* b, lapack_int ldb,\n                          lapack_int* sdim, lapack_complex_float* alpha,\n                          lapack_complex_float* beta, lapack_complex_float* vsl,\n                          lapack_int ldvsl, lapack_complex_float* vsr,\n                          lapack_int ldvsr );\nlapack_int LAPACKE_zgges( int matrix_layout, char jobvsl, char jobvsr, char sort,\n                          LAPACK_Z_SELECT2 selctg, lapack_int n,\n                          lapack_complex_double* a, lapack_int lda,\n                          lapack_complex_double* b, lapack_int ldb,\n                          lapack_int* sdim, lapack_complex_double* alpha,\n                          lapack_complex_double* beta,\n                          lapack_complex_double* vsl, lapack_int ldvsl,\n                          lapack_complex_double* vsr, lapack_int ldvsr );\n\nlapack_int LAPACKE_sgges3( int matrix_layout, char jobvsl, char jobvsr,\n                           char sort, LAPACK_S_SELECT3 selctg, lapack_int n,\n                           float* a, lapack_int lda, float* b, lapack_int ldb,\n                           lapack_int* sdim, float* alphar, float* alphai,\n                           float* beta, float* vsl, lapack_int ldvsl,\n                           float* vsr, lapack_int ldvsr );\nlapack_int LAPACKE_dgges3( int matrix_layout, char jobvsl, char jobvsr,\n                           char sort, LAPACK_D_SELECT3 selctg, lapack_int n,\n                           double* a, lapack_int lda, double* b, lapack_int ldb,\n                           lapack_int* sdim, double* alphar, double* alphai,\n                           double* beta, double* vsl, lapack_int ldvsl,\n                           double* vsr, lapack_int ldvsr );\nlapack_int LAPACKE_cgges3( int matrix_layout, char jobvsl, char jobvsr,\n                           char sort, LAPACK_C_SELECT2 selctg, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_int* sdim, lapack_complex_float* alpha,\n                           lapack_complex_float* beta,\n                           lapack_complex_float* vsl, lapack_int ldvsl,\n                           lapack_complex_float* vsr, lapack_int ldvsr );\nlapack_int LAPACKE_zgges3( int matrix_layout, char jobvsl, char jobvsr,\n                           char sort, LAPACK_Z_SELECT2 selctg, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_int* sdim, lapack_complex_double* alpha,\n                           lapack_complex_double* beta,\n                           lapack_complex_double* vsl, lapack_int ldvsl,\n                           lapack_complex_double* vsr, lapack_int ldvsr );\n\nlapack_int LAPACKE_sggesx( int matrix_layout, char jobvsl, char jobvsr,\n                           char sort, LAPACK_S_SELECT3 selctg, char sense,\n                           lapack_int n, float* a, lapack_int lda, float* b,\n                           lapack_int ldb, lapack_int* sdim, float* alphar,\n                           float* alphai, float* beta, float* vsl,\n                           lapack_int ldvsl, float* vsr, lapack_int ldvsr,\n                           float* rconde, float* rcondv );\nlapack_int LAPACKE_dggesx( int matrix_layout, char jobvsl, char jobvsr,\n                           char sort, LAPACK_D_SELECT3 selctg, char sense,\n                           lapack_int n, double* a, lapack_int lda, double* b,\n                           lapack_int ldb, lapack_int* sdim, double* alphar,\n                           double* alphai, double* beta, double* vsl,\n                           lapack_int ldvsl, double* vsr, lapack_int ldvsr,\n                           double* rconde, double* rcondv );\nlapack_int LAPACKE_cggesx( int matrix_layout, char jobvsl, char jobvsr,\n                           char sort, LAPACK_C_SELECT2 selctg, char sense,\n                           lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb, lapack_int* sdim,\n                           lapack_complex_float* alpha,\n                           lapack_complex_float* beta,\n                           lapack_complex_float* vsl, lapack_int ldvsl,\n                           lapack_complex_float* vsr, lapack_int ldvsr,\n                           float* rconde, float* rcondv );\nlapack_int LAPACKE_zggesx( int matrix_layout, char jobvsl, char jobvsr,\n                           char sort, LAPACK_Z_SELECT2 selctg, char sense,\n                           lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb, lapack_int* sdim,\n                           lapack_complex_double* alpha,\n                           lapack_complex_double* beta,\n                           lapack_complex_double* vsl, lapack_int ldvsl,\n                           lapack_complex_double* vsr, lapack_int ldvsr,\n                           double* rconde, double* rcondv );\n\nlapack_int LAPACKE_sggev( int matrix_layout, char jobvl, char jobvr,\n                          lapack_int n, float* a, lapack_int lda, float* b,\n                          lapack_int ldb, float* alphar, float* alphai,\n                          float* beta, float* vl, lapack_int ldvl, float* vr,\n                          lapack_int ldvr );\nlapack_int LAPACKE_dggev( int matrix_layout, char jobvl, char jobvr,\n                          lapack_int n, double* a, lapack_int lda, double* b,\n                          lapack_int ldb, double* alphar, double* alphai,\n                          double* beta, double* vl, lapack_int ldvl, double* vr,\n                          lapack_int ldvr );\nlapack_int LAPACKE_cggev( int matrix_layout, char jobvl, char jobvr,\n                          lapack_int n, lapack_complex_float* a, lapack_int lda,\n                          lapack_complex_float* b, lapack_int ldb,\n                          lapack_complex_float* alpha,\n                          lapack_complex_float* beta, lapack_complex_float* vl,\n                          lapack_int ldvl, lapack_complex_float* vr,\n                          lapack_int ldvr );\nlapack_int LAPACKE_zggev( int matrix_layout, char jobvl, char jobvr,\n                          lapack_int n, lapack_complex_double* a,\n                          lapack_int lda, lapack_complex_double* b,\n                          lapack_int ldb, lapack_complex_double* alpha,\n                          lapack_complex_double* beta,\n                          lapack_complex_double* vl, lapack_int ldvl,\n                          lapack_complex_double* vr, lapack_int ldvr );\n\nlapack_int LAPACKE_sggev3( int matrix_layout, char jobvl, char jobvr,\n                           lapack_int n, float* a, lapack_int lda,\n                           float* b, lapack_int ldb,\n                           float* alphar, float* alphai, float* beta,\n                           float* vl, lapack_int ldvl,\n                           float* vr, lapack_int ldvr );\nlapack_int LAPACKE_dggev3( int matrix_layout, char jobvl, char jobvr,\n                           lapack_int n, double* a, lapack_int lda,\n                           double* b, lapack_int ldb,\n                           double* alphar, double* alphai, double* beta,\n                           double* vl, lapack_int ldvl,\n                           double* vr, lapack_int ldvr );\nlapack_int LAPACKE_cggev3( int matrix_layout, char jobvl, char jobvr,\n                           lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* alpha,\n                           lapack_complex_float* beta,\n                           lapack_complex_float* vl, lapack_int ldvl,\n                           lapack_complex_float* vr, lapack_int ldvr );\nlapack_int LAPACKE_zggev3( int matrix_layout, char jobvl, char jobvr,\n                           lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* alpha,\n                           lapack_complex_double* beta,\n                           lapack_complex_double* vl, lapack_int ldvl,\n                           lapack_complex_double* vr, lapack_int ldvr );\n\nlapack_int LAPACKE_sggevx( int matrix_layout, char balanc, char jobvl,\n                           char jobvr, char sense, lapack_int n, float* a,\n                           lapack_int lda, float* b, lapack_int ldb,\n                           float* alphar, float* alphai, float* beta, float* vl,\n                           lapack_int ldvl, float* vr, lapack_int ldvr,\n                           lapack_int* ilo, lapack_int* ihi, float* lscale,\n                           float* rscale, float* abnrm, float* bbnrm,\n                           float* rconde, float* rcondv );\nlapack_int LAPACKE_dggevx( int matrix_layout, char balanc, char jobvl,\n                           char jobvr, char sense, lapack_int n, double* a,\n                           lapack_int lda, double* b, lapack_int ldb,\n                           double* alphar, double* alphai, double* beta,\n                           double* vl, lapack_int ldvl, double* vr,\n                           lapack_int ldvr, lapack_int* ilo, lapack_int* ihi,\n                           double* lscale, double* rscale, double* abnrm,\n                           double* bbnrm, double* rconde, double* rcondv );\nlapack_int LAPACKE_cggevx( int matrix_layout, char balanc, char jobvl,\n                           char jobvr, char sense, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* alpha,\n                           lapack_complex_float* beta, lapack_complex_float* vl,\n                           lapack_int ldvl, lapack_complex_float* vr,\n                           lapack_int ldvr, lapack_int* ilo, lapack_int* ihi,\n                           float* lscale, float* rscale, float* abnrm,\n                           float* bbnrm, float* rconde, float* rcondv );\nlapack_int LAPACKE_zggevx( int matrix_layout, char balanc, char jobvl,\n                           char jobvr, char sense, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* alpha,\n                           lapack_complex_double* beta,\n                           lapack_complex_double* vl, lapack_int ldvl,\n                           lapack_complex_double* vr, lapack_int ldvr,\n                           lapack_int* ilo, lapack_int* ihi, double* lscale,\n                           double* rscale, double* abnrm, double* bbnrm,\n                           double* rconde, double* rcondv );\n\nlapack_int LAPACKE_sggglm( int matrix_layout, lapack_int n, lapack_int m,\n                           lapack_int p, float* a, lapack_int lda, float* b,\n                           lapack_int ldb, float* d, float* x, float* y );\nlapack_int LAPACKE_dggglm( int matrix_layout, lapack_int n, lapack_int m,\n                           lapack_int p, double* a, lapack_int lda, double* b,\n                           lapack_int ldb, double* d, double* x, double* y );\nlapack_int LAPACKE_cggglm( int matrix_layout, lapack_int n, lapack_int m,\n                           lapack_int p, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb, lapack_complex_float* d,\n                           lapack_complex_float* x, lapack_complex_float* y );\nlapack_int LAPACKE_zggglm( int matrix_layout, lapack_int n, lapack_int m,\n                           lapack_int p, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb, lapack_complex_double* d,\n                           lapack_complex_double* x, lapack_complex_double* y );\n\nlapack_int LAPACKE_sgghrd( int matrix_layout, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           float* a, lapack_int lda, float* b, lapack_int ldb,\n                           float* q, lapack_int ldq, float* z, lapack_int ldz );\nlapack_int LAPACKE_dgghrd( int matrix_layout, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           double* a, lapack_int lda, double* b, lapack_int ldb,\n                           double* q, lapack_int ldq, double* z,\n                           lapack_int ldz );\nlapack_int LAPACKE_cgghrd( int matrix_layout, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* q, lapack_int ldq,\n                           lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zgghrd( int matrix_layout, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_complex_double* z, lapack_int ldz );\n\nlapack_int LAPACKE_sgghd3( int matrix_layout, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           float* a, lapack_int lda, float* b, lapack_int ldb,\n                           float* q, lapack_int ldq, float* z, lapack_int ldz );\nlapack_int LAPACKE_dgghd3( int matrix_layout, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           double* a, lapack_int lda, double* b, lapack_int ldb,\n                           double* q, lapack_int ldq, double* z,\n                           lapack_int ldz );\nlapack_int LAPACKE_cgghd3( int matrix_layout, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* q, lapack_int ldq,\n                           lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zgghd3( int matrix_layout, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_complex_double* z, lapack_int ldz );\n\nlapack_int LAPACKE_sgglse( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int p, float* a, lapack_int lda, float* b,\n                           lapack_int ldb, float* c, float* d, float* x );\nlapack_int LAPACKE_dgglse( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int p, double* a, lapack_int lda, double* b,\n                           lapack_int ldb, double* c, double* d, double* x );\nlapack_int LAPACKE_cgglse( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int p, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb, lapack_complex_float* c,\n                           lapack_complex_float* d, lapack_complex_float* x );\nlapack_int LAPACKE_zgglse( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int p, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb, lapack_complex_double* c,\n                           lapack_complex_double* d, lapack_complex_double* x );\n\nlapack_int LAPACKE_sggqrf( int matrix_layout, lapack_int n, lapack_int m,\n                           lapack_int p, float* a, lapack_int lda, float* taua,\n                           float* b, lapack_int ldb, float* taub );\nlapack_int LAPACKE_dggqrf( int matrix_layout, lapack_int n, lapack_int m,\n                           lapack_int p, double* a, lapack_int lda,\n                           double* taua, double* b, lapack_int ldb,\n                           double* taub );\nlapack_int LAPACKE_cggqrf( int matrix_layout, lapack_int n, lapack_int m,\n                           lapack_int p, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* taua,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* taub );\nlapack_int LAPACKE_zggqrf( int matrix_layout, lapack_int n, lapack_int m,\n                           lapack_int p, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* taua,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* taub );\n\nlapack_int LAPACKE_sggrqf( int matrix_layout, lapack_int m, lapack_int p,\n                           lapack_int n, float* a, lapack_int lda, float* taua,\n                           float* b, lapack_int ldb, float* taub );\nlapack_int LAPACKE_dggrqf( int matrix_layout, lapack_int m, lapack_int p,\n                           lapack_int n, double* a, lapack_int lda,\n                           double* taua, double* b, lapack_int ldb,\n                           double* taub );\nlapack_int LAPACKE_cggrqf( int matrix_layout, lapack_int m, lapack_int p,\n                           lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* taua,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* taub );\nlapack_int LAPACKE_zggrqf( int matrix_layout, lapack_int m, lapack_int p,\n                           lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* taua,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* taub );\n\nlapack_int LAPACKE_sggsvd( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int n, lapack_int p,\n                           lapack_int* k, lapack_int* l, float* a,\n                           lapack_int lda, float* b, lapack_int ldb,\n                           float* alpha, float* beta, float* u, lapack_int ldu,\n                           float* v, lapack_int ldv, float* q, lapack_int ldq,\n                           lapack_int* iwork );\nlapack_int LAPACKE_dggsvd( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int n, lapack_int p,\n                           lapack_int* k, lapack_int* l, double* a,\n                           lapack_int lda, double* b, lapack_int ldb,\n                           double* alpha, double* beta, double* u,\n                           lapack_int ldu, double* v, lapack_int ldv, double* q,\n                           lapack_int ldq, lapack_int* iwork );\nlapack_int LAPACKE_cggsvd( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int n, lapack_int p,\n                           lapack_int* k, lapack_int* l,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           float* alpha, float* beta, lapack_complex_float* u,\n                           lapack_int ldu, lapack_complex_float* v,\n                           lapack_int ldv, lapack_complex_float* q,\n                           lapack_int ldq, lapack_int* iwork );\nlapack_int LAPACKE_zggsvd( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int n, lapack_int p,\n                           lapack_int* k, lapack_int* l,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           double* alpha, double* beta,\n                           lapack_complex_double* u, lapack_int ldu,\n                           lapack_complex_double* v, lapack_int ldv,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_int* iwork );\n\nlapack_int LAPACKE_sggsvd3( int matrix_layout, char jobu, char jobv, char jobq,\n                            lapack_int m, lapack_int n, lapack_int p,\n                            lapack_int* k, lapack_int* l, float* a,\n                            lapack_int lda, float* b, lapack_int ldb,\n                            float* alpha, float* beta, float* u, lapack_int ldu,\n                            float* v, lapack_int ldv, float* q, lapack_int ldq,\n                            lapack_int* iwork );\nlapack_int LAPACKE_dggsvd3( int matrix_layout, char jobu, char jobv, char jobq,\n                            lapack_int m, lapack_int n, lapack_int p,\n                            lapack_int* k, lapack_int* l, double* a,\n                            lapack_int lda, double* b, lapack_int ldb,\n                            double* alpha, double* beta, double* u,\n                            lapack_int ldu, double* v, lapack_int ldv, double* q,\n                            lapack_int ldq, lapack_int* iwork );\nlapack_int LAPACKE_cggsvd3( int matrix_layout, char jobu, char jobv, char jobq,\n                            lapack_int m, lapack_int n, lapack_int p,\n                            lapack_int* k, lapack_int* l,\n                            lapack_complex_float* a, lapack_int lda,\n                            lapack_complex_float* b, lapack_int ldb,\n                            float* alpha, float* beta, lapack_complex_float* u,\n                            lapack_int ldu, lapack_complex_float* v,\n                            lapack_int ldv, lapack_complex_float* q,\n                            lapack_int ldq, lapack_int* iwork );\nlapack_int LAPACKE_zggsvd3( int matrix_layout, char jobu, char jobv, char jobq,\n                            lapack_int m, lapack_int n, lapack_int p,\n                            lapack_int* k, lapack_int* l,\n                            lapack_complex_double* a, lapack_int lda,\n                            lapack_complex_double* b, lapack_int ldb,\n                            double* alpha, double* beta,\n                            lapack_complex_double* u, lapack_int ldu,\n                            lapack_complex_double* v, lapack_int ldv,\n                            lapack_complex_double* q, lapack_int ldq,\n                            lapack_int* iwork );\n\nlapack_int LAPACKE_sggsvp( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int p, lapack_int n, float* a,\n                           lapack_int lda, float* b, lapack_int ldb, float tola,\n                           float tolb, lapack_int* k, lapack_int* l, float* u,\n                           lapack_int ldu, float* v, lapack_int ldv, float* q,\n                           lapack_int ldq );\nlapack_int LAPACKE_dggsvp( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int p, lapack_int n, double* a,\n                           lapack_int lda, double* b, lapack_int ldb,\n                           double tola, double tolb, lapack_int* k,\n                           lapack_int* l, double* u, lapack_int ldu, double* v,\n                           lapack_int ldv, double* q, lapack_int ldq );\nlapack_int LAPACKE_cggsvp( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int p, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb, float tola,\n                           float tolb, lapack_int* k, lapack_int* l,\n                           lapack_complex_float* u, lapack_int ldu,\n                           lapack_complex_float* v, lapack_int ldv,\n                           lapack_complex_float* q, lapack_int ldq );\nlapack_int LAPACKE_zggsvp( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int p, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           double tola, double tolb, lapack_int* k,\n                           lapack_int* l, lapack_complex_double* u,\n                           lapack_int ldu, lapack_complex_double* v,\n                           lapack_int ldv, lapack_complex_double* q,\n                           lapack_int ldq );\n\nlapack_int LAPACKE_sggsvp3( int matrix_layout, char jobu, char jobv, char jobq,\n                            lapack_int m, lapack_int p, lapack_int n, float* a,\n                            lapack_int lda, float* b, lapack_int ldb, float tola,\n                            float tolb, lapack_int* k, lapack_int* l, float* u,\n                            lapack_int ldu, float* v, lapack_int ldv, float* q,\n                            lapack_int ldq );\nlapack_int LAPACKE_dggsvp3( int matrix_layout, char jobu, char jobv, char jobq,\n                            lapack_int m, lapack_int p, lapack_int n, double* a,\n                            lapack_int lda, double* b, lapack_int ldb,\n                            double tola, double tolb, lapack_int* k,\n                            lapack_int* l, double* u, lapack_int ldu, double* v,\n                            lapack_int ldv, double* q, lapack_int ldq );\nlapack_int LAPACKE_cggsvp3( int matrix_layout, char jobu, char jobv, char jobq,\n                            lapack_int m, lapack_int p, lapack_int n,\n                            lapack_complex_float* a, lapack_int lda,\n                            lapack_complex_float* b, lapack_int ldb, float tola,\n                            float tolb, lapack_int* k, lapack_int* l,\n                            lapack_complex_float* u, lapack_int ldu,\n                            lapack_complex_float* v, lapack_int ldv,\n                            lapack_complex_float* q, lapack_int ldq );\nlapack_int LAPACKE_zggsvp3( int matrix_layout, char jobu, char jobv, char jobq,\n                            lapack_int m, lapack_int p, lapack_int n,\n                            lapack_complex_double* a, lapack_int lda,\n                            lapack_complex_double* b, lapack_int ldb,\n                            double tola, double tolb, lapack_int* k,\n                            lapack_int* l, lapack_complex_double* u,\n                            lapack_int ldu, lapack_complex_double* v,\n                            lapack_int ldv, lapack_complex_double* q,\n                            lapack_int ldq );\n\nlapack_int LAPACKE_sgtcon( char norm, lapack_int n, const float* dl,\n                           const float* d, const float* du, const float* du2,\n                           const lapack_int* ipiv, float anorm, float* rcond );\nlapack_int LAPACKE_dgtcon( char norm, lapack_int n, const double* dl,\n                           const double* d, const double* du, const double* du2,\n                           const lapack_int* ipiv, double anorm,\n                           double* rcond );\nlapack_int LAPACKE_cgtcon( char norm, lapack_int n,\n                           const lapack_complex_float* dl,\n                           const lapack_complex_float* d,\n                           const lapack_complex_float* du,\n                           const lapack_complex_float* du2,\n                           const lapack_int* ipiv, float anorm, float* rcond );\nlapack_int LAPACKE_zgtcon( char norm, lapack_int n,\n                           const lapack_complex_double* dl,\n                           const lapack_complex_double* d,\n                           const lapack_complex_double* du,\n                           const lapack_complex_double* du2,\n                           const lapack_int* ipiv, double anorm,\n                           double* rcond );\n\nlapack_int LAPACKE_sgtrfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const float* dl, const float* d,\n                           const float* du, const float* dlf, const float* df,\n                           const float* duf, const float* du2,\n                           const lapack_int* ipiv, const float* b,\n                           lapack_int ldb, float* x, lapack_int ldx,\n                           float* ferr, float* berr );\nlapack_int LAPACKE_dgtrfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const double* dl, const double* d,\n                           const double* du, const double* dlf,\n                           const double* df, const double* duf,\n                           const double* du2, const lapack_int* ipiv,\n                           const double* b, lapack_int ldb, double* x,\n                           lapack_int ldx, double* ferr, double* berr );\nlapack_int LAPACKE_cgtrfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* dl,\n                           const lapack_complex_float* d,\n                           const lapack_complex_float* du,\n                           const lapack_complex_float* dlf,\n                           const lapack_complex_float* df,\n                           const lapack_complex_float* duf,\n                           const lapack_complex_float* du2,\n                           const lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zgtrfs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* dl,\n                           const lapack_complex_double* d,\n                           const lapack_complex_double* du,\n                           const lapack_complex_double* dlf,\n                           const lapack_complex_double* df,\n                           const lapack_complex_double* duf,\n                           const lapack_complex_double* du2,\n                           const lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_sgtsv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          float* dl, float* d, float* du, float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_dgtsv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          double* dl, double* d, double* du, double* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_cgtsv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          lapack_complex_float* dl, lapack_complex_float* d,\n                          lapack_complex_float* du, lapack_complex_float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_zgtsv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          lapack_complex_double* dl, lapack_complex_double* d,\n                          lapack_complex_double* du, lapack_complex_double* b,\n                          lapack_int ldb );\n\nlapack_int LAPACKE_sgtsvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int nrhs, const float* dl,\n                           const float* d, const float* du, float* dlf,\n                           float* df, float* duf, float* du2, lapack_int* ipiv,\n                           const float* b, lapack_int ldb, float* x,\n                           lapack_int ldx, float* rcond, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_dgtsvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int nrhs, const double* dl,\n                           const double* d, const double* du, double* dlf,\n                           double* df, double* duf, double* du2,\n                           lapack_int* ipiv, const double* b, lapack_int ldb,\n                           double* x, lapack_int ldx, double* rcond,\n                           double* ferr, double* berr );\nlapack_int LAPACKE_cgtsvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_float* dl,\n                           const lapack_complex_float* d,\n                           const lapack_complex_float* du,\n                           lapack_complex_float* dlf, lapack_complex_float* df,\n                           lapack_complex_float* duf, lapack_complex_float* du2,\n                           lapack_int* ipiv, const lapack_complex_float* b,\n                           lapack_int ldb, lapack_complex_float* x,\n                           lapack_int ldx, float* rcond, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zgtsvx( int matrix_layout, char fact, char trans,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_double* dl,\n                           const lapack_complex_double* d,\n                           const lapack_complex_double* du,\n                           lapack_complex_double* dlf,\n                           lapack_complex_double* df,\n                           lapack_complex_double* duf,\n                           lapack_complex_double* du2, lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\n\nlapack_int LAPACKE_sgttrf( lapack_int n, float* dl, float* d, float* du,\n                           float* du2, lapack_int* ipiv );\nlapack_int LAPACKE_dgttrf( lapack_int n, double* dl, double* d, double* du,\n                           double* du2, lapack_int* ipiv );\nlapack_int LAPACKE_cgttrf( lapack_int n, lapack_complex_float* dl,\n                           lapack_complex_float* d, lapack_complex_float* du,\n                           lapack_complex_float* du2, lapack_int* ipiv );\nlapack_int LAPACKE_zgttrf( lapack_int n, lapack_complex_double* dl,\n                           lapack_complex_double* d, lapack_complex_double* du,\n                           lapack_complex_double* du2, lapack_int* ipiv );\n\nlapack_int LAPACKE_sgttrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const float* dl, const float* d,\n                           const float* du, const float* du2,\n                           const lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_dgttrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const double* dl, const double* d,\n                           const double* du, const double* du2,\n                           const lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_cgttrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* dl,\n                           const lapack_complex_float* d,\n                           const lapack_complex_float* du,\n                           const lapack_complex_float* du2,\n                           const lapack_int* ipiv, lapack_complex_float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_zgttrs( int matrix_layout, char trans, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* dl,\n                           const lapack_complex_double* d,\n                           const lapack_complex_double* du,\n                           const lapack_complex_double* du2,\n                           const lapack_int* ipiv, lapack_complex_double* b,\n                           lapack_int ldb );\n\nlapack_int LAPACKE_chbev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_int kd, lapack_complex_float* ab,\n                          lapack_int ldab, float* w, lapack_complex_float* z,\n                          lapack_int ldz );\nlapack_int LAPACKE_zhbev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_int kd, lapack_complex_double* ab,\n                          lapack_int ldab, double* w, lapack_complex_double* z,\n                          lapack_int ldz );\n\nlapack_int LAPACKE_chbevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_int kd, lapack_complex_float* ab,\n                           lapack_int ldab, float* w, lapack_complex_float* z,\n                           lapack_int ldz );\nlapack_int LAPACKE_zhbevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_int kd, lapack_complex_double* ab,\n                           lapack_int ldab, double* w, lapack_complex_double* z,\n                           lapack_int ldz );\n\nlapack_int LAPACKE_chbevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_int kd,\n                           lapack_complex_float* ab, lapack_int ldab,\n                           lapack_complex_float* q, lapack_int ldq, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, lapack_complex_float* z,\n                           lapack_int ldz, lapack_int* ifail );\nlapack_int LAPACKE_zhbevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_int kd,\n                           lapack_complex_double* ab, lapack_int ldab,\n                           lapack_complex_double* q, lapack_int ldq, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w,\n                           lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* ifail );\n\nlapack_int LAPACKE_chbgst( int matrix_layout, char vect, char uplo, lapack_int n,\n                           lapack_int ka, lapack_int kb,\n                           lapack_complex_float* ab, lapack_int ldab,\n                           const lapack_complex_float* bb, lapack_int ldbb,\n                           lapack_complex_float* x, lapack_int ldx );\nlapack_int LAPACKE_zhbgst( int matrix_layout, char vect, char uplo, lapack_int n,\n                           lapack_int ka, lapack_int kb,\n                           lapack_complex_double* ab, lapack_int ldab,\n                           const lapack_complex_double* bb, lapack_int ldbb,\n                           lapack_complex_double* x, lapack_int ldx );\n\nlapack_int LAPACKE_chbgv( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_int ka, lapack_int kb,\n                          lapack_complex_float* ab, lapack_int ldab,\n                          lapack_complex_float* bb, lapack_int ldbb, float* w,\n                          lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zhbgv( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_int ka, lapack_int kb,\n                          lapack_complex_double* ab, lapack_int ldab,\n                          lapack_complex_double* bb, lapack_int ldbb, double* w,\n                          lapack_complex_double* z, lapack_int ldz );\n\nlapack_int LAPACKE_chbgvd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_int ka, lapack_int kb,\n                           lapack_complex_float* ab, lapack_int ldab,\n                           lapack_complex_float* bb, lapack_int ldbb, float* w,\n                           lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zhbgvd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_int ka, lapack_int kb,\n                           lapack_complex_double* ab, lapack_int ldab,\n                           lapack_complex_double* bb, lapack_int ldbb,\n                           double* w, lapack_complex_double* z,\n                           lapack_int ldz );\n\nlapack_int LAPACKE_chbgvx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_int ka, lapack_int kb,\n                           lapack_complex_float* ab, lapack_int ldab,\n                           lapack_complex_float* bb, lapack_int ldbb,\n                           lapack_complex_float* q, lapack_int ldq, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, lapack_complex_float* z,\n                           lapack_int ldz, lapack_int* ifail );\nlapack_int LAPACKE_zhbgvx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_int ka, lapack_int kb,\n                           lapack_complex_double* ab, lapack_int ldab,\n                           lapack_complex_double* bb, lapack_int ldbb,\n                           lapack_complex_double* q, lapack_int ldq, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w,\n                           lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* ifail );\n\nlapack_int LAPACKE_chbtrd( int matrix_layout, char vect, char uplo, lapack_int n,\n                           lapack_int kd, lapack_complex_float* ab,\n                           lapack_int ldab, float* d, float* e,\n                           lapack_complex_float* q, lapack_int ldq );\nlapack_int LAPACKE_zhbtrd( int matrix_layout, char vect, char uplo, lapack_int n,\n                           lapack_int kd, lapack_complex_double* ab,\n                           lapack_int ldab, double* d, double* e,\n                           lapack_complex_double* q, lapack_int ldq );\n\nlapack_int LAPACKE_checon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_int* ipiv, float anorm, float* rcond );\nlapack_int LAPACKE_zhecon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_int* ipiv, double anorm,\n                           double* rcond );\n\nlapack_int LAPACKE_cheequb( int matrix_layout, char uplo, lapack_int n,\n                            const lapack_complex_float* a, lapack_int lda,\n                            float* s, float* scond, float* amax );\nlapack_int LAPACKE_zheequb( int matrix_layout, char uplo, lapack_int n,\n                            const lapack_complex_double* a, lapack_int lda,\n                            double* s, double* scond, double* amax );\n\nlapack_int LAPACKE_cheev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_complex_float* a, lapack_int lda, float* w );\nlapack_int LAPACKE_zheev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_complex_double* a, lapack_int lda, double* w );\n\nlapack_int LAPACKE_cheevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda, float* w );\nlapack_int LAPACKE_zheevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           double* w );\n\nlapack_int LAPACKE_cheevr( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, float vl, float vu, lapack_int il,\n                           lapack_int iu, float abstol, lapack_int* m, float* w,\n                           lapack_complex_float* z, lapack_int ldz,\n                           lapack_int* isuppz );\nlapack_int LAPACKE_zheevr( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, double vl, double vu, lapack_int il,\n                           lapack_int iu, double abstol, lapack_int* m,\n                           double* w, lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* isuppz );\n\nlapack_int LAPACKE_cheevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, float vl, float vu, lapack_int il,\n                           lapack_int iu, float abstol, lapack_int* m, float* w,\n                           lapack_complex_float* z, lapack_int ldz,\n                           lapack_int* ifail );\nlapack_int LAPACKE_zheevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, double vl, double vu, lapack_int il,\n                           lapack_int iu, double abstol, lapack_int* m,\n                           double* w, lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* ifail );\n\nlapack_int LAPACKE_chegst( int matrix_layout, lapack_int itype, char uplo,\n                           lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_zhegst( int matrix_layout, lapack_int itype, char uplo,\n                           lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* b,\n                           lapack_int ldb );\n\nlapack_int LAPACKE_chegv( int matrix_layout, lapack_int itype, char jobz,\n                          char uplo, lapack_int n, lapack_complex_float* a,\n                          lapack_int lda, lapack_complex_float* b,\n                          lapack_int ldb, float* w );\nlapack_int LAPACKE_zhegv( int matrix_layout, lapack_int itype, char jobz,\n                          char uplo, lapack_int n, lapack_complex_double* a,\n                          lapack_int lda, lapack_complex_double* b,\n                          lapack_int ldb, double* w );\n\nlapack_int LAPACKE_chegvd( int matrix_layout, lapack_int itype, char jobz,\n                           char uplo, lapack_int n, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb, float* w );\nlapack_int LAPACKE_zhegvd( int matrix_layout, lapack_int itype, char jobz,\n                           char uplo, lapack_int n, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb, double* w );\n\nlapack_int LAPACKE_chegvx( int matrix_layout, lapack_int itype, char jobz,\n                           char range, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, lapack_complex_float* z,\n                           lapack_int ldz, lapack_int* ifail );\nlapack_int LAPACKE_zhegvx( int matrix_layout, lapack_int itype, char jobz,\n                           char range, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w,\n                           lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* ifail );\n\nlapack_int LAPACKE_cherfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* af,\n                           lapack_int ldaf, const lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zherfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* af,\n                           lapack_int ldaf, const lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_chesv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_float* a,\n                          lapack_int lda, lapack_int* ipiv,\n                          lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zhesv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_double* a,\n                          lapack_int lda, lapack_int* ipiv,\n                          lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_chesvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* af,\n                           lapack_int ldaf, lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr );\nlapack_int LAPACKE_zhesvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* af,\n                           lapack_int ldaf, lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\n\nlapack_int LAPACKE_chetrd( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda, float* d,\n                           float* e, lapack_complex_float* tau );\nlapack_int LAPACKE_zhetrd( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda, double* d,\n                           double* e, lapack_complex_double* tau );\n\nlapack_int LAPACKE_chetrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_zhetrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ipiv );\n\nlapack_int LAPACKE_chetri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           const lapack_int* ipiv );\nlapack_int LAPACKE_zhetri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           const lapack_int* ipiv );\n\nlapack_int LAPACKE_chetrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zhetrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_chfrk( int matrix_layout, char transr, char uplo, char trans,\n                          lapack_int n, lapack_int k, float alpha,\n                          const lapack_complex_float* a, lapack_int lda,\n                          float beta, lapack_complex_float* c );\nlapack_int LAPACKE_zhfrk( int matrix_layout, char transr, char uplo, char trans,\n                          lapack_int n, lapack_int k, double alpha,\n                          const lapack_complex_double* a, lapack_int lda,\n                          double beta, lapack_complex_double* c );\n\nlapack_int LAPACKE_shgeqz( int matrix_layout, char job, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           float* h, lapack_int ldh, float* t, lapack_int ldt,\n                           float* alphar, float* alphai, float* beta, float* q,\n                           lapack_int ldq, float* z, lapack_int ldz );\nlapack_int LAPACKE_dhgeqz( int matrix_layout, char job, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           double* h, lapack_int ldh, double* t, lapack_int ldt,\n                           double* alphar, double* alphai, double* beta,\n                           double* q, lapack_int ldq, double* z,\n                           lapack_int ldz );\nlapack_int LAPACKE_chgeqz( int matrix_layout, char job, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           lapack_complex_float* h, lapack_int ldh,\n                           lapack_complex_float* t, lapack_int ldt,\n                           lapack_complex_float* alpha,\n                           lapack_complex_float* beta, lapack_complex_float* q,\n                           lapack_int ldq, lapack_complex_float* z,\n                           lapack_int ldz );\nlapack_int LAPACKE_zhgeqz( int matrix_layout, char job, char compq, char compz,\n                           lapack_int n, lapack_int ilo, lapack_int ihi,\n                           lapack_complex_double* h, lapack_int ldh,\n                           lapack_complex_double* t, lapack_int ldt,\n                           lapack_complex_double* alpha,\n                           lapack_complex_double* beta,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_complex_double* z, lapack_int ldz );\n\nlapack_int LAPACKE_chpcon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* ap,\n                           const lapack_int* ipiv, float anorm, float* rcond );\nlapack_int LAPACKE_zhpcon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* ap,\n                           const lapack_int* ipiv, double anorm,\n                           double* rcond );\n\nlapack_int LAPACKE_chpev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_complex_float* ap, float* w,\n                          lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zhpev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_complex_double* ap, double* w,\n                          lapack_complex_double* z, lapack_int ldz );\n\nlapack_int LAPACKE_chpevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_complex_float* ap, float* w,\n                           lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zhpevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_complex_double* ap, double* w,\n                           lapack_complex_double* z, lapack_int ldz );\n\nlapack_int LAPACKE_chpevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_complex_float* ap, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, lapack_complex_float* z,\n                           lapack_int ldz, lapack_int* ifail );\nlapack_int LAPACKE_zhpevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_complex_double* ap, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w,\n                           lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* ifail );\n\nlapack_int LAPACKE_chpgst( int matrix_layout, lapack_int itype, char uplo,\n                           lapack_int n, lapack_complex_float* ap,\n                           const lapack_complex_float* bp );\nlapack_int LAPACKE_zhpgst( int matrix_layout, lapack_int itype, char uplo,\n                           lapack_int n, lapack_complex_double* ap,\n                           const lapack_complex_double* bp );\n\nlapack_int LAPACKE_chpgv( int matrix_layout, lapack_int itype, char jobz,\n                          char uplo, lapack_int n, lapack_complex_float* ap,\n                          lapack_complex_float* bp, float* w,\n                          lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zhpgv( int matrix_layout, lapack_int itype, char jobz,\n                          char uplo, lapack_int n, lapack_complex_double* ap,\n                          lapack_complex_double* bp, double* w,\n                          lapack_complex_double* z, lapack_int ldz );\n\nlapack_int LAPACKE_chpgvd( int matrix_layout, lapack_int itype, char jobz,\n                           char uplo, lapack_int n, lapack_complex_float* ap,\n                           lapack_complex_float* bp, float* w,\n                           lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zhpgvd( int matrix_layout, lapack_int itype, char jobz,\n                           char uplo, lapack_int n, lapack_complex_double* ap,\n                           lapack_complex_double* bp, double* w,\n                           lapack_complex_double* z, lapack_int ldz );\n\nlapack_int LAPACKE_chpgvx( int matrix_layout, lapack_int itype, char jobz,\n                           char range, char uplo, lapack_int n,\n                           lapack_complex_float* ap, lapack_complex_float* bp,\n                           float vl, float vu, lapack_int il, lapack_int iu,\n                           float abstol, lapack_int* m, float* w,\n                           lapack_complex_float* z, lapack_int ldz,\n                           lapack_int* ifail );\nlapack_int LAPACKE_zhpgvx( int matrix_layout, lapack_int itype, char jobz,\n                           char range, char uplo, lapack_int n,\n                           lapack_complex_double* ap, lapack_complex_double* bp,\n                           double vl, double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w,\n                           lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* ifail );\n\nlapack_int LAPACKE_chprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* ap,\n                           const lapack_complex_float* afp,\n                           const lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zhprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* ap,\n                           const lapack_complex_double* afp,\n                           const lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_chpsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_float* ap,\n                          lapack_int* ipiv, lapack_complex_float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_zhpsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_double* ap,\n                          lapack_int* ipiv, lapack_complex_double* b,\n                          lapack_int ldb );\n\nlapack_int LAPACKE_chpsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* ap,\n                           lapack_complex_float* afp, lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr );\nlapack_int LAPACKE_zhpsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* ap,\n                           lapack_complex_double* afp, lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\n\nlapack_int LAPACKE_chptrd( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* ap, float* d, float* e,\n                           lapack_complex_float* tau );\nlapack_int LAPACKE_zhptrd( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* ap, double* d, double* e,\n                           lapack_complex_double* tau );\n\nlapack_int LAPACKE_chptrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* ap, lapack_int* ipiv );\nlapack_int LAPACKE_zhptrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* ap, lapack_int* ipiv );\n\nlapack_int LAPACKE_chptri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* ap, const lapack_int* ipiv );\nlapack_int LAPACKE_zhptri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* ap, const lapack_int* ipiv );\n\nlapack_int LAPACKE_chptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* ap,\n                           const lapack_int* ipiv, lapack_complex_float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_zhptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* ap,\n                           const lapack_int* ipiv, lapack_complex_double* b,\n                           lapack_int ldb );\n\nlapack_int LAPACKE_shsein( int matrix_layout, char job, char eigsrc, char initv,\n                           lapack_logical* select, lapack_int n, const float* h,\n                           lapack_int ldh, float* wr, const float* wi,\n                           float* vl, lapack_int ldvl, float* vr,\n                           lapack_int ldvr, lapack_int mm, lapack_int* m,\n                           lapack_int* ifaill, lapack_int* ifailr );\nlapack_int LAPACKE_dhsein( int matrix_layout, char job, char eigsrc, char initv,\n                           lapack_logical* select, lapack_int n,\n                           const double* h, lapack_int ldh, double* wr,\n                           const double* wi, double* vl, lapack_int ldvl,\n                           double* vr, lapack_int ldvr, lapack_int mm,\n                           lapack_int* m, lapack_int* ifaill,\n                           lapack_int* ifailr );\nlapack_int LAPACKE_chsein( int matrix_layout, char job, char eigsrc, char initv,\n                           const lapack_logical* select, lapack_int n,\n                           const lapack_complex_float* h, lapack_int ldh,\n                           lapack_complex_float* w, lapack_complex_float* vl,\n                           lapack_int ldvl, lapack_complex_float* vr,\n                           lapack_int ldvr, lapack_int mm, lapack_int* m,\n                           lapack_int* ifaill, lapack_int* ifailr );\nlapack_int LAPACKE_zhsein( int matrix_layout, char job, char eigsrc, char initv,\n                           const lapack_logical* select, lapack_int n,\n                           const lapack_complex_double* h, lapack_int ldh,\n                           lapack_complex_double* w, lapack_complex_double* vl,\n                           lapack_int ldvl, lapack_complex_double* vr,\n                           lapack_int ldvr, lapack_int mm, lapack_int* m,\n                           lapack_int* ifaill, lapack_int* ifailr );\n\nlapack_int LAPACKE_shseqr( int matrix_layout, char job, char compz, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, float* h,\n                           lapack_int ldh, float* wr, float* wi, float* z,\n                           lapack_int ldz );\nlapack_int LAPACKE_dhseqr( int matrix_layout, char job, char compz, lapack_int n,\n                           lapack_int ilo, lapack_int ihi, double* h,\n                           lapack_int ldh, double* wr, double* wi, double* z,\n                           lapack_int ldz );\nlapack_int LAPACKE_chseqr( int matrix_layout, char job, char compz, lapack_int n,\n                           lapack_int ilo, lapack_int ihi,\n                           lapack_complex_float* h, lapack_int ldh,\n                           lapack_complex_float* w, lapack_complex_float* z,\n                           lapack_int ldz );\nlapack_int LAPACKE_zhseqr( int matrix_layout, char job, char compz, lapack_int n,\n                           lapack_int ilo, lapack_int ihi,\n                           lapack_complex_double* h, lapack_int ldh,\n                           lapack_complex_double* w, lapack_complex_double* z,\n                           lapack_int ldz );\n\nlapack_int LAPACKE_clacgv( lapack_int n, lapack_complex_float* x,\n                           lapack_int incx );\nlapack_int LAPACKE_zlacgv( lapack_int n, lapack_complex_double* x,\n                           lapack_int incx );\n\nlapack_int LAPACKE_slacn2( lapack_int n, float* v, float* x, lapack_int* isgn,\n                           float* est, lapack_int* kase, lapack_int* isave );\nlapack_int LAPACKE_dlacn2( lapack_int n, double* v, double* x, lapack_int* isgn,\n                           double* est, lapack_int* kase, lapack_int* isave );\nlapack_int LAPACKE_clacn2( lapack_int n, lapack_complex_float* v,\n                           lapack_complex_float* x,\n                           float* est, lapack_int* kase, lapack_int* isave );\nlapack_int LAPACKE_zlacn2( lapack_int n, lapack_complex_double* v,\n                           lapack_complex_double* x,\n                           double* est, lapack_int* kase, lapack_int* isave );\n\nlapack_int LAPACKE_slacpy( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, const float* a, lapack_int lda, float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_dlacpy( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, const double* a, lapack_int lda, double* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_clacpy( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, const lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_zlacpy( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, const lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb );\n\nlapack_int LAPACKE_clacp2( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, const float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zlacp2( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, const double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_zlag2c( int matrix_layout, lapack_int m, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_float* sa, lapack_int ldsa );\n\nlapack_int LAPACKE_slag2d( int matrix_layout, lapack_int m, lapack_int n,\n                           const float* sa, lapack_int ldsa, double* a,\n                           lapack_int lda );\n\nlapack_int LAPACKE_dlag2s( int matrix_layout, lapack_int m, lapack_int n,\n                           const double* a, lapack_int lda, float* sa,\n                           lapack_int ldsa );\n\nlapack_int LAPACKE_clag2z( int matrix_layout, lapack_int m, lapack_int n,\n                           const lapack_complex_float* sa, lapack_int ldsa,\n                           lapack_complex_double* a, lapack_int lda );\n\nfloat LAPACKE_slamch( char cmach );\ndouble LAPACKE_dlamch( char cmach );\n\nfloat LAPACKE_slange( int matrix_layout, char norm, lapack_int m,\n                           lapack_int n, const float* a, lapack_int lda );\ndouble LAPACKE_dlange( int matrix_layout, char norm, lapack_int m,\n                           lapack_int n, const double* a, lapack_int lda );\nfloat LAPACKE_clange( int matrix_layout, char norm, lapack_int m,\n                           lapack_int n, const lapack_complex_float* a,\n                           lapack_int lda );\ndouble LAPACKE_zlange( int matrix_layout, char norm, lapack_int m,\n                           lapack_int n, const lapack_complex_double* a,\n                           lapack_int lda );\n\nfloat LAPACKE_clanhe( int matrix_layout, char norm, char uplo, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda );\ndouble LAPACKE_zlanhe( int matrix_layout, char norm, char uplo, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda );\n\nfloat LAPACKE_slansy( int matrix_layout, char norm, char uplo, lapack_int n,\n                           const float* a, lapack_int lda );\ndouble LAPACKE_dlansy( int matrix_layout, char norm, char uplo, lapack_int n,\n                           const double* a, lapack_int lda );\nfloat LAPACKE_clansy( int matrix_layout, char norm, char uplo, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda );\ndouble LAPACKE_zlansy( int matrix_layout, char norm, char uplo, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda );\n\nfloat LAPACKE_slantr( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int m, lapack_int n, const float* a,\n                           lapack_int lda );\ndouble LAPACKE_dlantr( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int m, lapack_int n, const double* a,\n                           lapack_int lda );\nfloat LAPACKE_clantr( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int m, lapack_int n, const lapack_complex_float* a,\n                           lapack_int lda );\ndouble LAPACKE_zlantr( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int m, lapack_int n, const lapack_complex_double* a,\n                           lapack_int lda );\n\n\nlapack_int LAPACKE_slarfb( int matrix_layout, char side, char trans, char direct,\n                           char storev, lapack_int m, lapack_int n,\n                           lapack_int k, const float* v, lapack_int ldv,\n                           const float* t, lapack_int ldt, float* c,\n                           lapack_int ldc );\nlapack_int LAPACKE_dlarfb( int matrix_layout, char side, char trans, char direct,\n                           char storev, lapack_int m, lapack_int n,\n                           lapack_int k, const double* v, lapack_int ldv,\n                           const double* t, lapack_int ldt, double* c,\n                           lapack_int ldc );\nlapack_int LAPACKE_clarfb( int matrix_layout, char side, char trans, char direct,\n                           char storev, lapack_int m, lapack_int n,\n                           lapack_int k, const lapack_complex_float* v,\n                           lapack_int ldv, const lapack_complex_float* t,\n                           lapack_int ldt, lapack_complex_float* c,\n                           lapack_int ldc );\nlapack_int LAPACKE_zlarfb( int matrix_layout, char side, char trans, char direct,\n                           char storev, lapack_int m, lapack_int n,\n                           lapack_int k, const lapack_complex_double* v,\n                           lapack_int ldv, const lapack_complex_double* t,\n                           lapack_int ldt, lapack_complex_double* c,\n                           lapack_int ldc );\n\nlapack_int LAPACKE_slarfg( lapack_int n, float* alpha, float* x,\n                           lapack_int incx, float* tau );\nlapack_int LAPACKE_dlarfg( lapack_int n, double* alpha, double* x,\n                           lapack_int incx, double* tau );\nlapack_int LAPACKE_clarfg( lapack_int n, lapack_complex_float* alpha,\n                           lapack_complex_float* x, lapack_int incx,\n                           lapack_complex_float* tau );\nlapack_int LAPACKE_zlarfg( lapack_int n, lapack_complex_double* alpha,\n                           lapack_complex_double* x, lapack_int incx,\n                           lapack_complex_double* tau );\n\nlapack_int LAPACKE_slarft( int matrix_layout, char direct, char storev,\n                           lapack_int n, lapack_int k, const float* v,\n                           lapack_int ldv, const float* tau, float* t,\n                           lapack_int ldt );\nlapack_int LAPACKE_dlarft( int matrix_layout, char direct, char storev,\n                           lapack_int n, lapack_int k, const double* v,\n                           lapack_int ldv, const double* tau, double* t,\n                           lapack_int ldt );\nlapack_int LAPACKE_clarft( int matrix_layout, char direct, char storev,\n                           lapack_int n, lapack_int k,\n                           const lapack_complex_float* v, lapack_int ldv,\n                           const lapack_complex_float* tau,\n                           lapack_complex_float* t, lapack_int ldt );\nlapack_int LAPACKE_zlarft( int matrix_layout, char direct, char storev,\n                           lapack_int n, lapack_int k,\n                           const lapack_complex_double* v, lapack_int ldv,\n                           const lapack_complex_double* tau,\n                           lapack_complex_double* t, lapack_int ldt );\n\nlapack_int LAPACKE_slarfx( int matrix_layout, char side, lapack_int m,\n                           lapack_int n, const float* v, float tau, float* c,\n                           lapack_int ldc, float* work );\nlapack_int LAPACKE_dlarfx( int matrix_layout, char side, lapack_int m,\n                           lapack_int n, const double* v, double tau, double* c,\n                           lapack_int ldc, double* work );\nlapack_int LAPACKE_clarfx( int matrix_layout, char side, lapack_int m,\n                           lapack_int n, const lapack_complex_float* v,\n                           lapack_complex_float tau, lapack_complex_float* c,\n                           lapack_int ldc, lapack_complex_float* work );\nlapack_int LAPACKE_zlarfx( int matrix_layout, char side, lapack_int m,\n                           lapack_int n, const lapack_complex_double* v,\n                           lapack_complex_double tau, lapack_complex_double* c,\n                           lapack_int ldc, lapack_complex_double* work );\n\nlapack_int LAPACKE_slarnv( lapack_int idist, lapack_int* iseed, lapack_int n,\n                           float* x );\nlapack_int LAPACKE_dlarnv( lapack_int idist, lapack_int* iseed, lapack_int n,\n                           double* x );\nlapack_int LAPACKE_clarnv( lapack_int idist, lapack_int* iseed, lapack_int n,\n                           lapack_complex_float* x );\nlapack_int LAPACKE_zlarnv( lapack_int idist, lapack_int* iseed, lapack_int n,\n                           lapack_complex_double* x );\n\nlapack_int LAPACKE_slascl( int matrix_layout, char type, lapack_int kl,\n                           lapack_int ku, float cfrom, float cto, \n                           lapack_int m, lapack_int n, float* a, \n                           lapack_int lda );\nlapack_int LAPACKE_dlascl( int matrix_layout, char type, lapack_int kl,\n                           lapack_int ku, double cfrom, double cto, \n                           lapack_int m, lapack_int n, double* a, \n                           lapack_int lda );\nlapack_int LAPACKE_clascl( int matrix_layout, char type, lapack_int kl,\n                           lapack_int ku, float cfrom, float cto, \n                           lapack_int m, lapack_int n, lapack_complex_float* a, \n                           lapack_int lda );\nlapack_int LAPACKE_zlascl( int matrix_layout, char type, lapack_int kl,\n                           lapack_int ku, double cfrom, double cto, \n                           lapack_int m, lapack_int n, lapack_complex_double* a, \n                           lapack_int lda );\n\nlapack_int LAPACKE_slaset( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, float alpha, float beta, float* a,\n                           lapack_int lda );\nlapack_int LAPACKE_dlaset( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, double alpha, double beta, double* a,\n                           lapack_int lda );\nlapack_int LAPACKE_claset( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, lapack_complex_float alpha,\n                           lapack_complex_float beta, lapack_complex_float* a,\n                           lapack_int lda );\nlapack_int LAPACKE_zlaset( int matrix_layout, char uplo, lapack_int m,\n                           lapack_int n, lapack_complex_double alpha,\n                           lapack_complex_double beta, lapack_complex_double* a,\n                           lapack_int lda );\n\nlapack_int LAPACKE_slasrt( char id, lapack_int n, float* d );\nlapack_int LAPACKE_dlasrt( char id, lapack_int n, double* d );\n\nlapack_int LAPACKE_slaswp( int matrix_layout, lapack_int n, float* a,\n                           lapack_int lda, lapack_int k1, lapack_int k2,\n                           const lapack_int* ipiv, lapack_int incx );\nlapack_int LAPACKE_dlaswp( int matrix_layout, lapack_int n, double* a,\n                           lapack_int lda, lapack_int k1, lapack_int k2,\n                           const lapack_int* ipiv, lapack_int incx );\nlapack_int LAPACKE_claswp( int matrix_layout, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int k1, lapack_int k2, const lapack_int* ipiv,\n                           lapack_int incx );\nlapack_int LAPACKE_zlaswp( int matrix_layout, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int k1, lapack_int k2, const lapack_int* ipiv,\n                           lapack_int incx );\n\nlapack_int LAPACKE_slauum( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda );\nlapack_int LAPACKE_dlauum( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda );\nlapack_int LAPACKE_clauum( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_zlauum( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_sopgtr( int matrix_layout, char uplo, lapack_int n,\n                           const float* ap, const float* tau, float* q,\n                           lapack_int ldq );\nlapack_int LAPACKE_dopgtr( int matrix_layout, char uplo, lapack_int n,\n                           const double* ap, const double* tau, double* q,\n                           lapack_int ldq );\n\nlapack_int LAPACKE_sopmtr( int matrix_layout, char side, char uplo, char trans,\n                           lapack_int m, lapack_int n, const float* ap,\n                           const float* tau, float* c, lapack_int ldc );\nlapack_int LAPACKE_dopmtr( int matrix_layout, char side, char uplo, char trans,\n                           lapack_int m, lapack_int n, const double* ap,\n                           const double* tau, double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sorgbr( int matrix_layout, char vect, lapack_int m,\n                           lapack_int n, lapack_int k, float* a, lapack_int lda,\n                           const float* tau );\nlapack_int LAPACKE_dorgbr( int matrix_layout, char vect, lapack_int m,\n                           lapack_int n, lapack_int k, double* a,\n                           lapack_int lda, const double* tau );\n\nlapack_int LAPACKE_sorghr( int matrix_layout, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, float* a, lapack_int lda,\n                           const float* tau );\nlapack_int LAPACKE_dorghr( int matrix_layout, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, double* a, lapack_int lda,\n                           const double* tau );\n\nlapack_int LAPACKE_sorglq( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, float* a, lapack_int lda,\n                           const float* tau );\nlapack_int LAPACKE_dorglq( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, double* a, lapack_int lda,\n                           const double* tau );\n\nlapack_int LAPACKE_sorgql( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, float* a, lapack_int lda,\n                           const float* tau );\nlapack_int LAPACKE_dorgql( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, double* a, lapack_int lda,\n                           const double* tau );\n\nlapack_int LAPACKE_sorgqr( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, float* a, lapack_int lda,\n                           const float* tau );\nlapack_int LAPACKE_dorgqr( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, double* a, lapack_int lda,\n                           const double* tau );\n\nlapack_int LAPACKE_sorgrq( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, float* a, lapack_int lda,\n                           const float* tau );\nlapack_int LAPACKE_dorgrq( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, double* a, lapack_int lda,\n                           const double* tau );\n\nlapack_int LAPACKE_sorgtr( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda, const float* tau );\nlapack_int LAPACKE_dorgtr( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda, const double* tau );\n\nlapack_int LAPACKE_sormbr( int matrix_layout, char vect, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const float* a, lapack_int lda, const float* tau,\n                           float* c, lapack_int ldc );\nlapack_int LAPACKE_dormbr( int matrix_layout, char vect, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const double* a, lapack_int lda, const double* tau,\n                           double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sormhr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, const float* a, lapack_int lda,\n                           const float* tau, float* c, lapack_int ldc );\nlapack_int LAPACKE_dormhr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, const double* a, lapack_int lda,\n                           const double* tau, double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sormlq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const float* a, lapack_int lda, const float* tau,\n                           float* c, lapack_int ldc );\nlapack_int LAPACKE_dormlq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const double* a, lapack_int lda, const double* tau,\n                           double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sormql( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const float* a, lapack_int lda, const float* tau,\n                           float* c, lapack_int ldc );\nlapack_int LAPACKE_dormql( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const double* a, lapack_int lda, const double* tau,\n                           double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sormqr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const float* a, lapack_int lda, const float* tau,\n                           float* c, lapack_int ldc );\nlapack_int LAPACKE_dormqr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const double* a, lapack_int lda, const double* tau,\n                           double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sormrq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const float* a, lapack_int lda, const float* tau,\n                           float* c, lapack_int ldc );\nlapack_int LAPACKE_dormrq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const double* a, lapack_int lda, const double* tau,\n                           double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sormrz( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           lapack_int l, const float* a, lapack_int lda,\n                           const float* tau, float* c, lapack_int ldc );\nlapack_int LAPACKE_dormrz( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           lapack_int l, const double* a, lapack_int lda,\n                           const double* tau, double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sormtr( int matrix_layout, char side, char uplo, char trans,\n                           lapack_int m, lapack_int n, const float* a,\n                           lapack_int lda, const float* tau, float* c,\n                           lapack_int ldc );\nlapack_int LAPACKE_dormtr( int matrix_layout, char side, char uplo, char trans,\n                           lapack_int m, lapack_int n, const double* a,\n                           lapack_int lda, const double* tau, double* c,\n                           lapack_int ldc );\n\nlapack_int LAPACKE_spbcon( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, const float* ab, lapack_int ldab,\n                           float anorm, float* rcond );\nlapack_int LAPACKE_dpbcon( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, const double* ab, lapack_int ldab,\n                           double anorm, double* rcond );\nlapack_int LAPACKE_cpbcon( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, const lapack_complex_float* ab,\n                           lapack_int ldab, float anorm, float* rcond );\nlapack_int LAPACKE_zpbcon( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, const lapack_complex_double* ab,\n                           lapack_int ldab, double anorm, double* rcond );\n\nlapack_int LAPACKE_spbequ( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, const float* ab, lapack_int ldab,\n                           float* s, float* scond, float* amax );\nlapack_int LAPACKE_dpbequ( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, const double* ab, lapack_int ldab,\n                           double* s, double* scond, double* amax );\nlapack_int LAPACKE_cpbequ( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, const lapack_complex_float* ab,\n                           lapack_int ldab, float* s, float* scond,\n                           float* amax );\nlapack_int LAPACKE_zpbequ( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, const lapack_complex_double* ab,\n                           lapack_int ldab, double* s, double* scond,\n                           double* amax );\n\nlapack_int LAPACKE_spbrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs, const float* ab,\n                           lapack_int ldab, const float* afb, lapack_int ldafb,\n                           const float* b, lapack_int ldb, float* x,\n                           lapack_int ldx, float* ferr, float* berr );\nlapack_int LAPACKE_dpbrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs, const double* ab,\n                           lapack_int ldab, const double* afb, lapack_int ldafb,\n                           const double* b, lapack_int ldb, double* x,\n                           lapack_int ldx, double* ferr, double* berr );\nlapack_int LAPACKE_cpbrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs,\n                           const lapack_complex_float* ab, lapack_int ldab,\n                           const lapack_complex_float* afb, lapack_int ldafb,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zpbrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs,\n                           const lapack_complex_double* ab, lapack_int ldab,\n                           const lapack_complex_double* afb, lapack_int ldafb,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_spbstf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kb, float* bb, lapack_int ldbb );\nlapack_int LAPACKE_dpbstf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kb, double* bb, lapack_int ldbb );\nlapack_int LAPACKE_cpbstf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kb, lapack_complex_float* bb,\n                           lapack_int ldbb );\nlapack_int LAPACKE_zpbstf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kb, lapack_complex_double* bb,\n                           lapack_int ldbb );\n\nlapack_int LAPACKE_spbsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int kd, lapack_int nrhs, float* ab,\n                          lapack_int ldab, float* b, lapack_int ldb );\nlapack_int LAPACKE_dpbsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int kd, lapack_int nrhs, double* ab,\n                          lapack_int ldab, double* b, lapack_int ldb );\nlapack_int LAPACKE_cpbsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int kd, lapack_int nrhs,\n                          lapack_complex_float* ab, lapack_int ldab,\n                          lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpbsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int kd, lapack_int nrhs,\n                          lapack_complex_double* ab, lapack_int ldab,\n                          lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_spbsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs, float* ab,\n                           lapack_int ldab, float* afb, lapack_int ldafb,\n                           char* equed, float* s, float* b, lapack_int ldb,\n                           float* x, lapack_int ldx, float* rcond, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_dpbsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs, double* ab,\n                           lapack_int ldab, double* afb, lapack_int ldafb,\n                           char* equed, double* s, double* b, lapack_int ldb,\n                           double* x, lapack_int ldx, double* rcond,\n                           double* ferr, double* berr );\nlapack_int LAPACKE_cpbsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs,\n                           lapack_complex_float* ab, lapack_int ldab,\n                           lapack_complex_float* afb, lapack_int ldafb,\n                           char* equed, float* s, lapack_complex_float* b,\n                           lapack_int ldb, lapack_complex_float* x,\n                           lapack_int ldx, float* rcond, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zpbsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs,\n                           lapack_complex_double* ab, lapack_int ldab,\n                           lapack_complex_double* afb, lapack_int ldafb,\n                           char* equed, double* s, lapack_complex_double* b,\n                           lapack_int ldb, lapack_complex_double* x,\n                           lapack_int ldx, double* rcond, double* ferr,\n                           double* berr );\n\nlapack_int LAPACKE_spbtrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, float* ab, lapack_int ldab );\nlapack_int LAPACKE_dpbtrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, double* ab, lapack_int ldab );\nlapack_int LAPACKE_cpbtrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_complex_float* ab,\n                           lapack_int ldab );\nlapack_int LAPACKE_zpbtrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_complex_double* ab,\n                           lapack_int ldab );\n\nlapack_int LAPACKE_spbtrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs, const float* ab,\n                           lapack_int ldab, float* b, lapack_int ldb );\nlapack_int LAPACKE_dpbtrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs, const double* ab,\n                           lapack_int ldab, double* b, lapack_int ldb );\nlapack_int LAPACKE_cpbtrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs,\n                           const lapack_complex_float* ab, lapack_int ldab,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpbtrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int kd, lapack_int nrhs,\n                           const lapack_complex_double* ab, lapack_int ldab,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_spftrf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, float* a );\nlapack_int LAPACKE_dpftrf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, double* a );\nlapack_int LAPACKE_cpftrf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, lapack_complex_float* a );\nlapack_int LAPACKE_zpftrf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, lapack_complex_double* a );\n\nlapack_int LAPACKE_spftri( int matrix_layout, char transr, char uplo,\n                           lapack_int n, float* a );\nlapack_int LAPACKE_dpftri( int matrix_layout, char transr, char uplo,\n                           lapack_int n, double* a );\nlapack_int LAPACKE_cpftri( int matrix_layout, char transr, char uplo,\n                           lapack_int n, lapack_complex_float* a );\nlapack_int LAPACKE_zpftri( int matrix_layout, char transr, char uplo,\n                           lapack_int n, lapack_complex_double* a );\n\nlapack_int LAPACKE_spftrs( int matrix_layout, char transr, char uplo,\n                           lapack_int n, lapack_int nrhs, const float* a,\n                           float* b, lapack_int ldb );\nlapack_int LAPACKE_dpftrs( int matrix_layout, char transr, char uplo,\n                           lapack_int n, lapack_int nrhs, const double* a,\n                           double* b, lapack_int ldb );\nlapack_int LAPACKE_cpftrs( int matrix_layout, char transr, char uplo,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_float* a,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpftrs( int matrix_layout, char transr, char uplo,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_double* a,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_spocon( int matrix_layout, char uplo, lapack_int n,\n                           const float* a, lapack_int lda, float anorm,\n                           float* rcond );\nlapack_int LAPACKE_dpocon( int matrix_layout, char uplo, lapack_int n,\n                           const double* a, lapack_int lda, double anorm,\n                           double* rcond );\nlapack_int LAPACKE_cpocon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           float anorm, float* rcond );\nlapack_int LAPACKE_zpocon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           double anorm, double* rcond );\n\nlapack_int LAPACKE_spoequ( int matrix_layout, lapack_int n, const float* a,\n                           lapack_int lda, float* s, float* scond,\n                           float* amax );\nlapack_int LAPACKE_dpoequ( int matrix_layout, lapack_int n, const double* a,\n                           lapack_int lda, double* s, double* scond,\n                           double* amax );\nlapack_int LAPACKE_cpoequ( int matrix_layout, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           float* s, float* scond, float* amax );\nlapack_int LAPACKE_zpoequ( int matrix_layout, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           double* s, double* scond, double* amax );\n\nlapack_int LAPACKE_spoequb( int matrix_layout, lapack_int n, const float* a,\n                            lapack_int lda, float* s, float* scond,\n                            float* amax );\nlapack_int LAPACKE_dpoequb( int matrix_layout, lapack_int n, const double* a,\n                            lapack_int lda, double* s, double* scond,\n                            double* amax );\nlapack_int LAPACKE_cpoequb( int matrix_layout, lapack_int n,\n                            const lapack_complex_float* a, lapack_int lda,\n                            float* s, float* scond, float* amax );\nlapack_int LAPACKE_zpoequb( int matrix_layout, lapack_int n,\n                            const lapack_complex_double* a, lapack_int lda,\n                            double* s, double* scond, double* amax );\n\nlapack_int LAPACKE_sporfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* a, lapack_int lda,\n                           const float* af, lapack_int ldaf, const float* b,\n                           lapack_int ldb, float* x, lapack_int ldx,\n                           float* ferr, float* berr );\nlapack_int LAPACKE_dporfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* a, lapack_int lda,\n                           const double* af, lapack_int ldaf, const double* b,\n                           lapack_int ldb, double* x, lapack_int ldx,\n                           double* ferr, double* berr );\nlapack_int LAPACKE_cporfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* af,\n                           lapack_int ldaf, const lapack_complex_float* b,\n                           lapack_int ldb, lapack_complex_float* x,\n                           lapack_int ldx, float* ferr, float* berr );\nlapack_int LAPACKE_zporfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* af,\n                           lapack_int ldaf, const lapack_complex_double* b,\n                           lapack_int ldb, lapack_complex_double* x,\n                           lapack_int ldx, double* ferr, double* berr );\n\nlapack_int LAPACKE_sposv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, float* a, lapack_int lda, float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_dposv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, double* a, lapack_int lda, double* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_cposv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_float* a,\n                          lapack_int lda, lapack_complex_float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_zposv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_double* a,\n                          lapack_int lda, lapack_complex_double* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_dsposv( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, double* a, lapack_int lda,\n                           double* b, lapack_int ldb, double* x, lapack_int ldx,\n                           lapack_int* iter );\nlapack_int LAPACKE_zcposv( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb, lapack_complex_double* x,\n                           lapack_int ldx, lapack_int* iter );\n\nlapack_int LAPACKE_sposvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, float* a, lapack_int lda, float* af,\n                           lapack_int ldaf, char* equed, float* s, float* b,\n                           lapack_int ldb, float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr );\nlapack_int LAPACKE_dposvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, double* a, lapack_int lda,\n                           double* af, lapack_int ldaf, char* equed, double* s,\n                           double* b, lapack_int ldb, double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\nlapack_int LAPACKE_cposvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* af,\n                           lapack_int ldaf, char* equed, float* s,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr );\nlapack_int LAPACKE_zposvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* af,\n                           lapack_int ldaf, char* equed, double* s,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\n\nlapack_int LAPACKE_spotrf2( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda );\nlapack_int LAPACKE_dpotrf2( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda );\nlapack_int LAPACKE_cpotrf2( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_zpotrf2( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_spotrf( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda );\nlapack_int LAPACKE_dpotrf( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda );\nlapack_int LAPACKE_cpotrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_zpotrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_spotri( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda );\nlapack_int LAPACKE_dpotri( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda );\nlapack_int LAPACKE_cpotri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_zpotri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_spotrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* a, lapack_int lda,\n                           float* b, lapack_int ldb );\nlapack_int LAPACKE_dpotrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* a, lapack_int lda,\n                           double* b, lapack_int ldb );\nlapack_int LAPACKE_cpotrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_zpotrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb );\n\nlapack_int LAPACKE_sppcon( int matrix_layout, char uplo, lapack_int n,\n                           const float* ap, float anorm, float* rcond );\nlapack_int LAPACKE_dppcon( int matrix_layout, char uplo, lapack_int n,\n                           const double* ap, double anorm, double* rcond );\nlapack_int LAPACKE_cppcon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* ap, float anorm,\n                           float* rcond );\nlapack_int LAPACKE_zppcon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* ap, double anorm,\n                           double* rcond );\n\nlapack_int LAPACKE_sppequ( int matrix_layout, char uplo, lapack_int n,\n                           const float* ap, float* s, float* scond,\n                           float* amax );\nlapack_int LAPACKE_dppequ( int matrix_layout, char uplo, lapack_int n,\n                           const double* ap, double* s, double* scond,\n                           double* amax );\nlapack_int LAPACKE_cppequ( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* ap, float* s,\n                           float* scond, float* amax );\nlapack_int LAPACKE_zppequ( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* ap, double* s,\n                           double* scond, double* amax );\n\nlapack_int LAPACKE_spprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* ap, const float* afp,\n                           const float* b, lapack_int ldb, float* x,\n                           lapack_int ldx, float* ferr, float* berr );\nlapack_int LAPACKE_dpprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* ap, const double* afp,\n                           const double* b, lapack_int ldb, double* x,\n                           lapack_int ldx, double* ferr, double* berr );\nlapack_int LAPACKE_cpprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* ap,\n                           const lapack_complex_float* afp,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zpprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* ap,\n                           const lapack_complex_double* afp,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_sppsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, float* ap, float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_dppsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, double* ap, double* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_cppsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_float* ap,\n                          lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zppsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_double* ap,\n                          lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sppsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, float* ap, float* afp, char* equed,\n                           float* s, float* b, lapack_int ldb, float* x,\n                           lapack_int ldx, float* rcond, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_dppsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, double* ap, double* afp,\n                           char* equed, double* s, double* b, lapack_int ldb,\n                           double* x, lapack_int ldx, double* rcond,\n                           double* ferr, double* berr );\nlapack_int LAPACKE_cppsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, lapack_complex_float* ap,\n                           lapack_complex_float* afp, char* equed, float* s,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr );\nlapack_int LAPACKE_zppsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, lapack_complex_double* ap,\n                           lapack_complex_double* afp, char* equed, double* s,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\n\nlapack_int LAPACKE_spptrf( int matrix_layout, char uplo, lapack_int n,\n                           float* ap );\nlapack_int LAPACKE_dpptrf( int matrix_layout, char uplo, lapack_int n,\n                           double* ap );\nlapack_int LAPACKE_cpptrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* ap );\nlapack_int LAPACKE_zpptrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* ap );\n\nlapack_int LAPACKE_spptri( int matrix_layout, char uplo, lapack_int n,\n                           float* ap );\nlapack_int LAPACKE_dpptri( int matrix_layout, char uplo, lapack_int n,\n                           double* ap );\nlapack_int LAPACKE_cpptri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* ap );\nlapack_int LAPACKE_zpptri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* ap );\n\nlapack_int LAPACKE_spptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* ap, float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_dpptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* ap, double* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_cpptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* ap,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* ap,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_spstrf( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda, lapack_int* piv, lapack_int* rank,\n                           float tol );\nlapack_int LAPACKE_dpstrf( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda, lapack_int* piv, lapack_int* rank,\n                           double tol );\nlapack_int LAPACKE_cpstrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* piv, lapack_int* rank, float tol );\nlapack_int LAPACKE_zpstrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* piv, lapack_int* rank, double tol );\n\nlapack_int LAPACKE_sptcon( lapack_int n, const float* d, const float* e,\n                           float anorm, float* rcond );\nlapack_int LAPACKE_dptcon( lapack_int n, const double* d, const double* e,\n                           double anorm, double* rcond );\nlapack_int LAPACKE_cptcon( lapack_int n, const float* d,\n                           const lapack_complex_float* e, float anorm,\n                           float* rcond );\nlapack_int LAPACKE_zptcon( lapack_int n, const double* d,\n                           const lapack_complex_double* e, double anorm,\n                           double* rcond );\n\nlapack_int LAPACKE_spteqr( int matrix_layout, char compz, lapack_int n, float* d,\n                           float* e, float* z, lapack_int ldz );\nlapack_int LAPACKE_dpteqr( int matrix_layout, char compz, lapack_int n,\n                           double* d, double* e, double* z, lapack_int ldz );\nlapack_int LAPACKE_cpteqr( int matrix_layout, char compz, lapack_int n, float* d,\n                           float* e, lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zpteqr( int matrix_layout, char compz, lapack_int n,\n                           double* d, double* e, lapack_complex_double* z,\n                           lapack_int ldz );\n\nlapack_int LAPACKE_sptrfs( int matrix_layout, lapack_int n, lapack_int nrhs,\n                           const float* d, const float* e, const float* df,\n                           const float* ef, const float* b, lapack_int ldb,\n                           float* x, lapack_int ldx, float* ferr, float* berr );\nlapack_int LAPACKE_dptrfs( int matrix_layout, lapack_int n, lapack_int nrhs,\n                           const double* d, const double* e, const double* df,\n                           const double* ef, const double* b, lapack_int ldb,\n                           double* x, lapack_int ldx, double* ferr,\n                           double* berr );\nlapack_int LAPACKE_cptrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* d,\n                           const lapack_complex_float* e, const float* df,\n                           const lapack_complex_float* ef,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zptrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* d,\n                           const lapack_complex_double* e, const double* df,\n                           const lapack_complex_double* ef,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_sptsv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          float* d, float* e, float* b, lapack_int ldb );\nlapack_int LAPACKE_dptsv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          double* d, double* e, double* b, lapack_int ldb );\nlapack_int LAPACKE_cptsv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          float* d, lapack_complex_float* e,\n                          lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zptsv( int matrix_layout, lapack_int n, lapack_int nrhs,\n                          double* d, lapack_complex_double* e,\n                          lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sptsvx( int matrix_layout, char fact, lapack_int n,\n                           lapack_int nrhs, const float* d, const float* e,\n                           float* df, float* ef, const float* b, lapack_int ldb,\n                           float* x, lapack_int ldx, float* rcond, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_dptsvx( int matrix_layout, char fact, lapack_int n,\n                           lapack_int nrhs, const double* d, const double* e,\n                           double* df, double* ef, const double* b,\n                           lapack_int ldb, double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\nlapack_int LAPACKE_cptsvx( int matrix_layout, char fact, lapack_int n,\n                           lapack_int nrhs, const float* d,\n                           const lapack_complex_float* e, float* df,\n                           lapack_complex_float* ef,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr );\nlapack_int LAPACKE_zptsvx( int matrix_layout, char fact, lapack_int n,\n                           lapack_int nrhs, const double* d,\n                           const lapack_complex_double* e, double* df,\n                           lapack_complex_double* ef,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\n\nlapack_int LAPACKE_spttrf( lapack_int n, float* d, float* e );\nlapack_int LAPACKE_dpttrf( lapack_int n, double* d, double* e );\nlapack_int LAPACKE_cpttrf( lapack_int n, float* d, lapack_complex_float* e );\nlapack_int LAPACKE_zpttrf( lapack_int n, double* d, lapack_complex_double* e );\n\nlapack_int LAPACKE_spttrs( int matrix_layout, lapack_int n, lapack_int nrhs,\n                           const float* d, const float* e, float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_dpttrs( int matrix_layout, lapack_int n, lapack_int nrhs,\n                           const double* d, const double* e, double* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_cpttrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* d,\n                           const lapack_complex_float* e,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpttrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* d,\n                           const lapack_complex_double* e,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_ssbev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_int kd, float* ab, lapack_int ldab, float* w,\n                          float* z, lapack_int ldz );\nlapack_int LAPACKE_dsbev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_int kd, double* ab, lapack_int ldab, double* w,\n                          double* z, lapack_int ldz );\n\nlapack_int LAPACKE_ssbevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_int kd, float* ab, lapack_int ldab, float* w,\n                           float* z, lapack_int ldz );\nlapack_int LAPACKE_dsbevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_int kd, double* ab, lapack_int ldab,\n                           double* w, double* z, lapack_int ldz );\n\nlapack_int LAPACKE_ssbevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_int kd, float* ab,\n                           lapack_int ldab, float* q, lapack_int ldq, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, float* z, lapack_int ldz,\n                           lapack_int* ifail );\nlapack_int LAPACKE_dsbevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_int kd, double* ab,\n                           lapack_int ldab, double* q, lapack_int ldq,\n                           double vl, double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w, double* z,\n                           lapack_int ldz, lapack_int* ifail );\n\nlapack_int LAPACKE_ssbgst( int matrix_layout, char vect, char uplo, lapack_int n,\n                           lapack_int ka, lapack_int kb, float* ab,\n                           lapack_int ldab, const float* bb, lapack_int ldbb,\n                           float* x, lapack_int ldx );\nlapack_int LAPACKE_dsbgst( int matrix_layout, char vect, char uplo, lapack_int n,\n                           lapack_int ka, lapack_int kb, double* ab,\n                           lapack_int ldab, const double* bb, lapack_int ldbb,\n                           double* x, lapack_int ldx );\n\nlapack_int LAPACKE_ssbgv( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_int ka, lapack_int kb, float* ab,\n                          lapack_int ldab, float* bb, lapack_int ldbb, float* w,\n                          float* z, lapack_int ldz );\nlapack_int LAPACKE_dsbgv( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          lapack_int ka, lapack_int kb, double* ab,\n                          lapack_int ldab, double* bb, lapack_int ldbb,\n                          double* w, double* z, lapack_int ldz );\n\nlapack_int LAPACKE_ssbgvd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_int ka, lapack_int kb, float* ab,\n                           lapack_int ldab, float* bb, lapack_int ldbb,\n                           float* w, float* z, lapack_int ldz );\nlapack_int LAPACKE_dsbgvd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           lapack_int ka, lapack_int kb, double* ab,\n                           lapack_int ldab, double* bb, lapack_int ldbb,\n                           double* w, double* z, lapack_int ldz );\n\nlapack_int LAPACKE_ssbgvx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_int ka, lapack_int kb,\n                           float* ab, lapack_int ldab, float* bb,\n                           lapack_int ldbb, float* q, lapack_int ldq, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, float* z, lapack_int ldz,\n                           lapack_int* ifail );\nlapack_int LAPACKE_dsbgvx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, lapack_int ka, lapack_int kb,\n                           double* ab, lapack_int ldab, double* bb,\n                           lapack_int ldbb, double* q, lapack_int ldq,\n                           double vl, double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w, double* z,\n                           lapack_int ldz, lapack_int* ifail );\n\nlapack_int LAPACKE_ssbtrd( int matrix_layout, char vect, char uplo, lapack_int n,\n                           lapack_int kd, float* ab, lapack_int ldab, float* d,\n                           float* e, float* q, lapack_int ldq );\nlapack_int LAPACKE_dsbtrd( int matrix_layout, char vect, char uplo, lapack_int n,\n                           lapack_int kd, double* ab, lapack_int ldab,\n                           double* d, double* e, double* q, lapack_int ldq );\n\nlapack_int LAPACKE_ssfrk( int matrix_layout, char transr, char uplo, char trans,\n                          lapack_int n, lapack_int k, float alpha,\n                          const float* a, lapack_int lda, float beta,\n                          float* c );\nlapack_int LAPACKE_dsfrk( int matrix_layout, char transr, char uplo, char trans,\n                          lapack_int n, lapack_int k, double alpha,\n                          const double* a, lapack_int lda, double beta,\n                          double* c );\n\nlapack_int LAPACKE_sspcon( int matrix_layout, char uplo, lapack_int n,\n                           const float* ap, const lapack_int* ipiv, float anorm,\n                           float* rcond );\nlapack_int LAPACKE_dspcon( int matrix_layout, char uplo, lapack_int n,\n                           const double* ap, const lapack_int* ipiv,\n                           double anorm, double* rcond );\nlapack_int LAPACKE_cspcon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* ap,\n                           const lapack_int* ipiv, float anorm, float* rcond );\nlapack_int LAPACKE_zspcon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* ap,\n                           const lapack_int* ipiv, double anorm,\n                           double* rcond );\n\nlapack_int LAPACKE_sspev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          float* ap, float* w, float* z, lapack_int ldz );\nlapack_int LAPACKE_dspev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          double* ap, double* w, double* z, lapack_int ldz );\n\nlapack_int LAPACKE_sspevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           float* ap, float* w, float* z, lapack_int ldz );\nlapack_int LAPACKE_dspevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           double* ap, double* w, double* z, lapack_int ldz );\n\nlapack_int LAPACKE_sspevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, float* ap, float vl, float vu,\n                           lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, float* z, lapack_int ldz,\n                           lapack_int* ifail );\nlapack_int LAPACKE_dspevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, double* ap, double vl, double vu,\n                           lapack_int il, lapack_int iu, double abstol,\n                           lapack_int* m, double* w, double* z, lapack_int ldz,\n                           lapack_int* ifail );\n\nlapack_int LAPACKE_sspgst( int matrix_layout, lapack_int itype, char uplo,\n                           lapack_int n, float* ap, const float* bp );\nlapack_int LAPACKE_dspgst( int matrix_layout, lapack_int itype, char uplo,\n                           lapack_int n, double* ap, const double* bp );\n\nlapack_int LAPACKE_sspgv( int matrix_layout, lapack_int itype, char jobz,\n                          char uplo, lapack_int n, float* ap, float* bp,\n                          float* w, float* z, lapack_int ldz );\nlapack_int LAPACKE_dspgv( int matrix_layout, lapack_int itype, char jobz,\n                          char uplo, lapack_int n, double* ap, double* bp,\n                          double* w, double* z, lapack_int ldz );\n\nlapack_int LAPACKE_sspgvd( int matrix_layout, lapack_int itype, char jobz,\n                           char uplo, lapack_int n, float* ap, float* bp,\n                           float* w, float* z, lapack_int ldz );\nlapack_int LAPACKE_dspgvd( int matrix_layout, lapack_int itype, char jobz,\n                           char uplo, lapack_int n, double* ap, double* bp,\n                           double* w, double* z, lapack_int ldz );\n\nlapack_int LAPACKE_sspgvx( int matrix_layout, lapack_int itype, char jobz,\n                           char range, char uplo, lapack_int n, float* ap,\n                           float* bp, float vl, float vu, lapack_int il,\n                           lapack_int iu, float abstol, lapack_int* m, float* w,\n                           float* z, lapack_int ldz, lapack_int* ifail );\nlapack_int LAPACKE_dspgvx( int matrix_layout, lapack_int itype, char jobz,\n                           char range, char uplo, lapack_int n, double* ap,\n                           double* bp, double vl, double vu, lapack_int il,\n                           lapack_int iu, double abstol, lapack_int* m,\n                           double* w, double* z, lapack_int ldz,\n                           lapack_int* ifail );\n\nlapack_int LAPACKE_ssprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* ap, const float* afp,\n                           const lapack_int* ipiv, const float* b,\n                           lapack_int ldb, float* x, lapack_int ldx,\n                           float* ferr, float* berr );\nlapack_int LAPACKE_dsprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* ap, const double* afp,\n                           const lapack_int* ipiv, const double* b,\n                           lapack_int ldb, double* x, lapack_int ldx,\n                           double* ferr, double* berr );\nlapack_int LAPACKE_csprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* ap,\n                           const lapack_complex_float* afp,\n                           const lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zsprfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* ap,\n                           const lapack_complex_double* afp,\n                           const lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_sspsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, float* ap, lapack_int* ipiv,\n                          float* b, lapack_int ldb );\nlapack_int LAPACKE_dspsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, double* ap, lapack_int* ipiv,\n                          double* b, lapack_int ldb );\nlapack_int LAPACKE_cspsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_float* ap,\n                          lapack_int* ipiv, lapack_complex_float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_zspsv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_double* ap,\n                          lapack_int* ipiv, lapack_complex_double* b,\n                          lapack_int ldb );\n\nlapack_int LAPACKE_sspsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* ap, float* afp,\n                           lapack_int* ipiv, const float* b, lapack_int ldb,\n                           float* x, lapack_int ldx, float* rcond, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_dspsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* ap, double* afp,\n                           lapack_int* ipiv, const double* b, lapack_int ldb,\n                           double* x, lapack_int ldx, double* rcond,\n                           double* ferr, double* berr );\nlapack_int LAPACKE_cspsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* ap,\n                           lapack_complex_float* afp, lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr );\nlapack_int LAPACKE_zspsvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* ap,\n                           lapack_complex_double* afp, lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\n\nlapack_int LAPACKE_ssptrd( int matrix_layout, char uplo, lapack_int n, float* ap,\n                           float* d, float* e, float* tau );\nlapack_int LAPACKE_dsptrd( int matrix_layout, char uplo, lapack_int n,\n                           double* ap, double* d, double* e, double* tau );\n\nlapack_int LAPACKE_ssptrf( int matrix_layout, char uplo, lapack_int n, float* ap,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_dsptrf( int matrix_layout, char uplo, lapack_int n,\n                           double* ap, lapack_int* ipiv );\nlapack_int LAPACKE_csptrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* ap, lapack_int* ipiv );\nlapack_int LAPACKE_zsptrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* ap, lapack_int* ipiv );\n\nlapack_int LAPACKE_ssptri( int matrix_layout, char uplo, lapack_int n, float* ap,\n                           const lapack_int* ipiv );\nlapack_int LAPACKE_dsptri( int matrix_layout, char uplo, lapack_int n,\n                           double* ap, const lapack_int* ipiv );\nlapack_int LAPACKE_csptri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* ap, const lapack_int* ipiv );\nlapack_int LAPACKE_zsptri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* ap, const lapack_int* ipiv );\n\nlapack_int LAPACKE_ssptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* ap,\n                           const lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_dsptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* ap,\n                           const lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_csptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* ap,\n                           const lapack_int* ipiv, lapack_complex_float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_zsptrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* ap,\n                           const lapack_int* ipiv, lapack_complex_double* b,\n                           lapack_int ldb );\n\nlapack_int LAPACKE_sstebz( char range, char order, lapack_int n, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           const float* d, const float* e, lapack_int* m,\n                           lapack_int* nsplit, float* w, lapack_int* iblock,\n                           lapack_int* isplit );\nlapack_int LAPACKE_dstebz( char range, char order, lapack_int n, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, const double* d, const double* e,\n                           lapack_int* m, lapack_int* nsplit, double* w,\n                           lapack_int* iblock, lapack_int* isplit );\n\nlapack_int LAPACKE_sstedc( int matrix_layout, char compz, lapack_int n, float* d,\n                           float* e, float* z, lapack_int ldz );\nlapack_int LAPACKE_dstedc( int matrix_layout, char compz, lapack_int n,\n                           double* d, double* e, double* z, lapack_int ldz );\nlapack_int LAPACKE_cstedc( int matrix_layout, char compz, lapack_int n, float* d,\n                           float* e, lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zstedc( int matrix_layout, char compz, lapack_int n,\n                           double* d, double* e, lapack_complex_double* z,\n                           lapack_int ldz );\n\nlapack_int LAPACKE_sstegr( int matrix_layout, char jobz, char range,\n                           lapack_int n, float* d, float* e, float vl, float vu,\n                           lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, float* z, lapack_int ldz,\n                           lapack_int* isuppz );\nlapack_int LAPACKE_dstegr( int matrix_layout, char jobz, char range,\n                           lapack_int n, double* d, double* e, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w, double* z,\n                           lapack_int ldz, lapack_int* isuppz );\nlapack_int LAPACKE_cstegr( int matrix_layout, char jobz, char range,\n                           lapack_int n, float* d, float* e, float vl, float vu,\n                           lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, lapack_complex_float* z,\n                           lapack_int ldz, lapack_int* isuppz );\nlapack_int LAPACKE_zstegr( int matrix_layout, char jobz, char range,\n                           lapack_int n, double* d, double* e, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w,\n                           lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* isuppz );\n\nlapack_int LAPACKE_sstein( int matrix_layout, lapack_int n, const float* d,\n                           const float* e, lapack_int m, const float* w,\n                           const lapack_int* iblock, const lapack_int* isplit,\n                           float* z, lapack_int ldz, lapack_int* ifailv );\nlapack_int LAPACKE_dstein( int matrix_layout, lapack_int n, const double* d,\n                           const double* e, lapack_int m, const double* w,\n                           const lapack_int* iblock, const lapack_int* isplit,\n                           double* z, lapack_int ldz, lapack_int* ifailv );\nlapack_int LAPACKE_cstein( int matrix_layout, lapack_int n, const float* d,\n                           const float* e, lapack_int m, const float* w,\n                           const lapack_int* iblock, const lapack_int* isplit,\n                           lapack_complex_float* z, lapack_int ldz,\n                           lapack_int* ifailv );\nlapack_int LAPACKE_zstein( int matrix_layout, lapack_int n, const double* d,\n                           const double* e, lapack_int m, const double* w,\n                           const lapack_int* iblock, const lapack_int* isplit,\n                           lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* ifailv );\n\nlapack_int LAPACKE_sstemr( int matrix_layout, char jobz, char range,\n                           lapack_int n, float* d, float* e, float vl, float vu,\n                           lapack_int il, lapack_int iu, lapack_int* m,\n                           float* w, float* z, lapack_int ldz, lapack_int nzc,\n                           lapack_int* isuppz, lapack_logical* tryrac );\nlapack_int LAPACKE_dstemr( int matrix_layout, char jobz, char range,\n                           lapack_int n, double* d, double* e, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           lapack_int* m, double* w, double* z, lapack_int ldz,\n                           lapack_int nzc, lapack_int* isuppz,\n                           lapack_logical* tryrac );\nlapack_int LAPACKE_cstemr( int matrix_layout, char jobz, char range,\n                           lapack_int n, float* d, float* e, float vl, float vu,\n                           lapack_int il, lapack_int iu, lapack_int* m,\n                           float* w, lapack_complex_float* z, lapack_int ldz,\n                           lapack_int nzc, lapack_int* isuppz,\n                           lapack_logical* tryrac );\nlapack_int LAPACKE_zstemr( int matrix_layout, char jobz, char range,\n                           lapack_int n, double* d, double* e, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           lapack_int* m, double* w, lapack_complex_double* z,\n                           lapack_int ldz, lapack_int nzc, lapack_int* isuppz,\n                           lapack_logical* tryrac );\n\nlapack_int LAPACKE_ssteqr( int matrix_layout, char compz, lapack_int n, float* d,\n                           float* e, float* z, lapack_int ldz );\nlapack_int LAPACKE_dsteqr( int matrix_layout, char compz, lapack_int n,\n                           double* d, double* e, double* z, lapack_int ldz );\nlapack_int LAPACKE_csteqr( int matrix_layout, char compz, lapack_int n, float* d,\n                           float* e, lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zsteqr( int matrix_layout, char compz, lapack_int n,\n                           double* d, double* e, lapack_complex_double* z,\n                           lapack_int ldz );\n\nlapack_int LAPACKE_ssterf( lapack_int n, float* d, float* e );\nlapack_int LAPACKE_dsterf( lapack_int n, double* d, double* e );\n\nlapack_int LAPACKE_sstev( int matrix_layout, char jobz, lapack_int n, float* d,\n                          float* e, float* z, lapack_int ldz );\nlapack_int LAPACKE_dstev( int matrix_layout, char jobz, lapack_int n, double* d,\n                          double* e, double* z, lapack_int ldz );\n\nlapack_int LAPACKE_sstevd( int matrix_layout, char jobz, lapack_int n, float* d,\n                           float* e, float* z, lapack_int ldz );\nlapack_int LAPACKE_dstevd( int matrix_layout, char jobz, lapack_int n, double* d,\n                           double* e, double* z, lapack_int ldz );\n\nlapack_int LAPACKE_sstevr( int matrix_layout, char jobz, char range,\n                           lapack_int n, float* d, float* e, float vl, float vu,\n                           lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, float* z, lapack_int ldz,\n                           lapack_int* isuppz );\nlapack_int LAPACKE_dstevr( int matrix_layout, char jobz, char range,\n                           lapack_int n, double* d, double* e, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w, double* z,\n                           lapack_int ldz, lapack_int* isuppz );\n\nlapack_int LAPACKE_sstevx( int matrix_layout, char jobz, char range,\n                           lapack_int n, float* d, float* e, float vl, float vu,\n                           lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, float* z, lapack_int ldz,\n                           lapack_int* ifail );\nlapack_int LAPACKE_dstevx( int matrix_layout, char jobz, char range,\n                           lapack_int n, double* d, double* e, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w, double* z,\n                           lapack_int ldz, lapack_int* ifail );\n\nlapack_int LAPACKE_ssycon( int matrix_layout, char uplo, lapack_int n,\n                           const float* a, lapack_int lda,\n                           const lapack_int* ipiv, float anorm, float* rcond );\nlapack_int LAPACKE_dsycon( int matrix_layout, char uplo, lapack_int n,\n                           const double* a, lapack_int lda,\n                           const lapack_int* ipiv, double anorm,\n                           double* rcond );\nlapack_int LAPACKE_csycon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_int* ipiv, float anorm, float* rcond );\nlapack_int LAPACKE_zsycon( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_int* ipiv, double anorm,\n                           double* rcond );\n\nlapack_int LAPACKE_ssyequb( int matrix_layout, char uplo, lapack_int n,\n                            const float* a, lapack_int lda, float* s,\n                            float* scond, float* amax );\nlapack_int LAPACKE_dsyequb( int matrix_layout, char uplo, lapack_int n,\n                            const double* a, lapack_int lda, double* s,\n                            double* scond, double* amax );\nlapack_int LAPACKE_csyequb( int matrix_layout, char uplo, lapack_int n,\n                            const lapack_complex_float* a, lapack_int lda,\n                            float* s, float* scond, float* amax );\nlapack_int LAPACKE_zsyequb( int matrix_layout, char uplo, lapack_int n,\n                            const lapack_complex_double* a, lapack_int lda,\n                            double* s, double* scond, double* amax );\n\nlapack_int LAPACKE_ssyev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          float* a, lapack_int lda, float* w );\nlapack_int LAPACKE_dsyev( int matrix_layout, char jobz, char uplo, lapack_int n,\n                          double* a, lapack_int lda, double* w );\n\nlapack_int LAPACKE_ssyevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           float* a, lapack_int lda, float* w );\nlapack_int LAPACKE_dsyevd( int matrix_layout, char jobz, char uplo, lapack_int n,\n                           double* a, lapack_int lda, double* w );\n\nlapack_int LAPACKE_ssyevr( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, float* a, lapack_int lda, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, float* z, lapack_int ldz,\n                           lapack_int* isuppz );\nlapack_int LAPACKE_dsyevr( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, double* a, lapack_int lda, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w, double* z,\n                           lapack_int ldz, lapack_int* isuppz );\n\nlapack_int LAPACKE_ssyevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, float* a, lapack_int lda, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, float* z, lapack_int ldz,\n                           lapack_int* ifail );\nlapack_int LAPACKE_dsyevx( int matrix_layout, char jobz, char range, char uplo,\n                           lapack_int n, double* a, lapack_int lda, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w, double* z,\n                           lapack_int ldz, lapack_int* ifail );\n\nlapack_int LAPACKE_ssygst( int matrix_layout, lapack_int itype, char uplo,\n                           lapack_int n, float* a, lapack_int lda,\n                           const float* b, lapack_int ldb );\nlapack_int LAPACKE_dsygst( int matrix_layout, lapack_int itype, char uplo,\n                           lapack_int n, double* a, lapack_int lda,\n                           const double* b, lapack_int ldb );\n\nlapack_int LAPACKE_ssygv( int matrix_layout, lapack_int itype, char jobz,\n                          char uplo, lapack_int n, float* a, lapack_int lda,\n                          float* b, lapack_int ldb, float* w );\nlapack_int LAPACKE_dsygv( int matrix_layout, lapack_int itype, char jobz,\n                          char uplo, lapack_int n, double* a, lapack_int lda,\n                          double* b, lapack_int ldb, double* w );\n\nlapack_int LAPACKE_ssygvd( int matrix_layout, lapack_int itype, char jobz,\n                           char uplo, lapack_int n, float* a, lapack_int lda,\n                           float* b, lapack_int ldb, float* w );\nlapack_int LAPACKE_dsygvd( int matrix_layout, lapack_int itype, char jobz,\n                           char uplo, lapack_int n, double* a, lapack_int lda,\n                           double* b, lapack_int ldb, double* w );\n\nlapack_int LAPACKE_ssygvx( int matrix_layout, lapack_int itype, char jobz,\n                           char range, char uplo, lapack_int n, float* a,\n                           lapack_int lda, float* b, lapack_int ldb, float vl,\n                           float vu, lapack_int il, lapack_int iu, float abstol,\n                           lapack_int* m, float* w, float* z, lapack_int ldz,\n                           lapack_int* ifail );\nlapack_int LAPACKE_dsygvx( int matrix_layout, lapack_int itype, char jobz,\n                           char range, char uplo, lapack_int n, double* a,\n                           lapack_int lda, double* b, lapack_int ldb, double vl,\n                           double vu, lapack_int il, lapack_int iu,\n                           double abstol, lapack_int* m, double* w, double* z,\n                           lapack_int ldz, lapack_int* ifail );\n\nlapack_int LAPACKE_ssyrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* a, lapack_int lda,\n                           const float* af, lapack_int ldaf,\n                           const lapack_int* ipiv, const float* b,\n                           lapack_int ldb, float* x, lapack_int ldx,\n                           float* ferr, float* berr );\nlapack_int LAPACKE_dsyrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* a, lapack_int lda,\n                           const double* af, lapack_int ldaf,\n                           const lapack_int* ipiv, const double* b,\n                           lapack_int ldb, double* x, lapack_int ldx,\n                           double* ferr, double* berr );\nlapack_int LAPACKE_csyrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* af,\n                           lapack_int ldaf, const lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_zsyrfs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* af,\n                           lapack_int ldaf, const lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_ssysv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, float* a, lapack_int lda,\n                          lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_dsysv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, double* a, lapack_int lda,\n                          lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_csysv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_float* a,\n                          lapack_int lda, lapack_int* ipiv,\n                          lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zsysv( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_double* a,\n                          lapack_int lda, lapack_int* ipiv,\n                          lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_ssysvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* a, lapack_int lda,\n                           float* af, lapack_int ldaf, lapack_int* ipiv,\n                           const float* b, lapack_int ldb, float* x,\n                           lapack_int ldx, float* rcond, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_dsysvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* a, lapack_int lda,\n                           double* af, lapack_int ldaf, lapack_int* ipiv,\n                           const double* b, lapack_int ldb, double* x,\n                           lapack_int ldx, double* rcond, double* ferr,\n                           double* berr );\nlapack_int LAPACKE_csysvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* af,\n                           lapack_int ldaf, lapack_int* ipiv,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* x, lapack_int ldx,\n                           float* rcond, float* ferr, float* berr );\nlapack_int LAPACKE_zsysvx( int matrix_layout, char fact, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* af,\n                           lapack_int ldaf, lapack_int* ipiv,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* x, lapack_int ldx,\n                           double* rcond, double* ferr, double* berr );\n\nlapack_int LAPACKE_ssytrd( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda, float* d, float* e, float* tau );\nlapack_int LAPACKE_dsytrd( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda, double* d, double* e, double* tau );\n\nlapack_int LAPACKE_ssytrf( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_dsytrf( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_csytrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_zsytrf( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ipiv );\n\nlapack_int LAPACKE_ssytri( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda, const lapack_int* ipiv );\nlapack_int LAPACKE_dsytri( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda, const lapack_int* ipiv );\nlapack_int LAPACKE_csytri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           const lapack_int* ipiv );\nlapack_int LAPACKE_zsytri( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           const lapack_int* ipiv );\n\nlapack_int LAPACKE_ssytrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* a, lapack_int lda,\n                           const lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_dsytrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* a, lapack_int lda,\n                           const lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_csytrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zsytrs( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_stbcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, lapack_int kd, const float* ab,\n                           lapack_int ldab, float* rcond );\nlapack_int LAPACKE_dtbcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, lapack_int kd, const double* ab,\n                           lapack_int ldab, double* rcond );\nlapack_int LAPACKE_ctbcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, lapack_int kd,\n                           const lapack_complex_float* ab, lapack_int ldab,\n                           float* rcond );\nlapack_int LAPACKE_ztbcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, lapack_int kd,\n                           const lapack_complex_double* ab, lapack_int ldab,\n                           double* rcond );\n\nlapack_int LAPACKE_stbrfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int kd, lapack_int nrhs,\n                           const float* ab, lapack_int ldab, const float* b,\n                           lapack_int ldb, const float* x, lapack_int ldx,\n                           float* ferr, float* berr );\nlapack_int LAPACKE_dtbrfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int kd, lapack_int nrhs,\n                           const double* ab, lapack_int ldab, const double* b,\n                           lapack_int ldb, const double* x, lapack_int ldx,\n                           double* ferr, double* berr );\nlapack_int LAPACKE_ctbrfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int kd, lapack_int nrhs,\n                           const lapack_complex_float* ab, lapack_int ldab,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           const lapack_complex_float* x, lapack_int ldx,\n                           float* ferr, float* berr );\nlapack_int LAPACKE_ztbrfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int kd, lapack_int nrhs,\n                           const lapack_complex_double* ab, lapack_int ldab,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           const lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_stbtrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int kd, lapack_int nrhs,\n                           const float* ab, lapack_int ldab, float* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_dtbtrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int kd, lapack_int nrhs,\n                           const double* ab, lapack_int ldab, double* b,\n                           lapack_int ldb );\nlapack_int LAPACKE_ctbtrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int kd, lapack_int nrhs,\n                           const lapack_complex_float* ab, lapack_int ldab,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_ztbtrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int kd, lapack_int nrhs,\n                           const lapack_complex_double* ab, lapack_int ldab,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_stfsm( int matrix_layout, char transr, char side, char uplo,\n                          char trans, char diag, lapack_int m, lapack_int n,\n                          float alpha, const float* a, float* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_dtfsm( int matrix_layout, char transr, char side, char uplo,\n                          char trans, char diag, lapack_int m, lapack_int n,\n                          double alpha, const double* a, double* b,\n                          lapack_int ldb );\nlapack_int LAPACKE_ctfsm( int matrix_layout, char transr, char side, char uplo,\n                          char trans, char diag, lapack_int m, lapack_int n,\n                          lapack_complex_float alpha,\n                          const lapack_complex_float* a,\n                          lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_ztfsm( int matrix_layout, char transr, char side, char uplo,\n                          char trans, char diag, lapack_int m, lapack_int n,\n                          lapack_complex_double alpha,\n                          const lapack_complex_double* a,\n                          lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_stftri( int matrix_layout, char transr, char uplo, char diag,\n                           lapack_int n, float* a );\nlapack_int LAPACKE_dtftri( int matrix_layout, char transr, char uplo, char diag,\n                           lapack_int n, double* a );\nlapack_int LAPACKE_ctftri( int matrix_layout, char transr, char uplo, char diag,\n                           lapack_int n, lapack_complex_float* a );\nlapack_int LAPACKE_ztftri( int matrix_layout, char transr, char uplo, char diag,\n                           lapack_int n, lapack_complex_double* a );\n\nlapack_int LAPACKE_stfttp( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const float* arf, float* ap );\nlapack_int LAPACKE_dtfttp( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const double* arf, double* ap );\nlapack_int LAPACKE_ctfttp( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const lapack_complex_float* arf,\n                           lapack_complex_float* ap );\nlapack_int LAPACKE_ztfttp( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const lapack_complex_double* arf,\n                           lapack_complex_double* ap );\n\nlapack_int LAPACKE_stfttr( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const float* arf, float* a,\n                           lapack_int lda );\nlapack_int LAPACKE_dtfttr( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const double* arf, double* a,\n                           lapack_int lda );\nlapack_int LAPACKE_ctfttr( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const lapack_complex_float* arf,\n                           lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_ztfttr( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const lapack_complex_double* arf,\n                           lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_stgevc( int matrix_layout, char side, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const float* s, lapack_int lds, const float* p,\n                           lapack_int ldp, float* vl, lapack_int ldvl,\n                           float* vr, lapack_int ldvr, lapack_int mm,\n                           lapack_int* m );\nlapack_int LAPACKE_dtgevc( int matrix_layout, char side, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const double* s, lapack_int lds, const double* p,\n                           lapack_int ldp, double* vl, lapack_int ldvl,\n                           double* vr, lapack_int ldvr, lapack_int mm,\n                           lapack_int* m );\nlapack_int LAPACKE_ctgevc( int matrix_layout, char side, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const lapack_complex_float* s, lapack_int lds,\n                           const lapack_complex_float* p, lapack_int ldp,\n                           lapack_complex_float* vl, lapack_int ldvl,\n                           lapack_complex_float* vr, lapack_int ldvr,\n                           lapack_int mm, lapack_int* m );\nlapack_int LAPACKE_ztgevc( int matrix_layout, char side, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const lapack_complex_double* s, lapack_int lds,\n                           const lapack_complex_double* p, lapack_int ldp,\n                           lapack_complex_double* vl, lapack_int ldvl,\n                           lapack_complex_double* vr, lapack_int ldvr,\n                           lapack_int mm, lapack_int* m );\n\nlapack_int LAPACKE_stgexc( int matrix_layout, lapack_logical wantq,\n                           lapack_logical wantz, lapack_int n, float* a,\n                           lapack_int lda, float* b, lapack_int ldb, float* q,\n                           lapack_int ldq, float* z, lapack_int ldz,\n                           lapack_int* ifst, lapack_int* ilst );\nlapack_int LAPACKE_dtgexc( int matrix_layout, lapack_logical wantq,\n                           lapack_logical wantz, lapack_int n, double* a,\n                           lapack_int lda, double* b, lapack_int ldb, double* q,\n                           lapack_int ldq, double* z, lapack_int ldz,\n                           lapack_int* ifst, lapack_int* ilst );\nlapack_int LAPACKE_ctgexc( int matrix_layout, lapack_logical wantq,\n                           lapack_logical wantz, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* q, lapack_int ldq,\n                           lapack_complex_float* z, lapack_int ldz,\n                           lapack_int ifst, lapack_int ilst );\nlapack_int LAPACKE_ztgexc( int matrix_layout, lapack_logical wantq,\n                           lapack_logical wantz, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_complex_double* z, lapack_int ldz,\n                           lapack_int ifst, lapack_int ilst );\n\nlapack_int LAPACKE_stgsen( int matrix_layout, lapack_int ijob,\n                           lapack_logical wantq, lapack_logical wantz,\n                           const lapack_logical* select, lapack_int n, float* a,\n                           lapack_int lda, float* b, lapack_int ldb,\n                           float* alphar, float* alphai, float* beta, float* q,\n                           lapack_int ldq, float* z, lapack_int ldz,\n                           lapack_int* m, float* pl, float* pr, float* dif );\nlapack_int LAPACKE_dtgsen( int matrix_layout, lapack_int ijob,\n                           lapack_logical wantq, lapack_logical wantz,\n                           const lapack_logical* select, lapack_int n,\n                           double* a, lapack_int lda, double* b, lapack_int ldb,\n                           double* alphar, double* alphai, double* beta,\n                           double* q, lapack_int ldq, double* z, lapack_int ldz,\n                           lapack_int* m, double* pl, double* pr, double* dif );\nlapack_int LAPACKE_ctgsen( int matrix_layout, lapack_int ijob,\n                           lapack_logical wantq, lapack_logical wantz,\n                           const lapack_logical* select, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* alpha,\n                           lapack_complex_float* beta, lapack_complex_float* q,\n                           lapack_int ldq, lapack_complex_float* z,\n                           lapack_int ldz, lapack_int* m, float* pl, float* pr,\n                           float* dif );\nlapack_int LAPACKE_ztgsen( int matrix_layout, lapack_int ijob,\n                           lapack_logical wantq, lapack_logical wantz,\n                           const lapack_logical* select, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* alpha,\n                           lapack_complex_double* beta,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_complex_double* z, lapack_int ldz,\n                           lapack_int* m, double* pl, double* pr, double* dif );\n\nlapack_int LAPACKE_stgsja( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int p, lapack_int n,\n                           lapack_int k, lapack_int l, float* a, lapack_int lda,\n                           float* b, lapack_int ldb, float tola, float tolb,\n                           float* alpha, float* beta, float* u, lapack_int ldu,\n                           float* v, lapack_int ldv, float* q, lapack_int ldq,\n                           lapack_int* ncycle );\nlapack_int LAPACKE_dtgsja( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int p, lapack_int n,\n                           lapack_int k, lapack_int l, double* a,\n                           lapack_int lda, double* b, lapack_int ldb,\n                           double tola, double tolb, double* alpha,\n                           double* beta, double* u, lapack_int ldu, double* v,\n                           lapack_int ldv, double* q, lapack_int ldq,\n                           lapack_int* ncycle );\nlapack_int LAPACKE_ctgsja( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int p, lapack_int n,\n                           lapack_int k, lapack_int l, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* b,\n                           lapack_int ldb, float tola, float tolb, float* alpha,\n                           float* beta, lapack_complex_float* u, lapack_int ldu,\n                           lapack_complex_float* v, lapack_int ldv,\n                           lapack_complex_float* q, lapack_int ldq,\n                           lapack_int* ncycle );\nlapack_int LAPACKE_ztgsja( int matrix_layout, char jobu, char jobv, char jobq,\n                           lapack_int m, lapack_int p, lapack_int n,\n                           lapack_int k, lapack_int l, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* b,\n                           lapack_int ldb, double tola, double tolb,\n                           double* alpha, double* beta,\n                           lapack_complex_double* u, lapack_int ldu,\n                           lapack_complex_double* v, lapack_int ldv,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_int* ncycle );\n\nlapack_int LAPACKE_stgsna( int matrix_layout, char job, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const float* a, lapack_int lda, const float* b,\n                           lapack_int ldb, const float* vl, lapack_int ldvl,\n                           const float* vr, lapack_int ldvr, float* s,\n                           float* dif, lapack_int mm, lapack_int* m );\nlapack_int LAPACKE_dtgsna( int matrix_layout, char job, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const double* a, lapack_int lda, const double* b,\n                           lapack_int ldb, const double* vl, lapack_int ldvl,\n                           const double* vr, lapack_int ldvr, double* s,\n                           double* dif, lapack_int mm, lapack_int* m );\nlapack_int LAPACKE_ctgsna( int matrix_layout, char job, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           const lapack_complex_float* vl, lapack_int ldvl,\n                           const lapack_complex_float* vr, lapack_int ldvr,\n                           float* s, float* dif, lapack_int mm, lapack_int* m );\nlapack_int LAPACKE_ztgsna( int matrix_layout, char job, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           const lapack_complex_double* vl, lapack_int ldvl,\n                           const lapack_complex_double* vr, lapack_int ldvr,\n                           double* s, double* dif, lapack_int mm,\n                           lapack_int* m );\n\nlapack_int LAPACKE_stgsyl( int matrix_layout, char trans, lapack_int ijob,\n                           lapack_int m, lapack_int n, const float* a,\n                           lapack_int lda, const float* b, lapack_int ldb,\n                           float* c, lapack_int ldc, const float* d,\n                           lapack_int ldd, const float* e, lapack_int lde,\n                           float* f, lapack_int ldf, float* scale, float* dif );\nlapack_int LAPACKE_dtgsyl( int matrix_layout, char trans, lapack_int ijob,\n                           lapack_int m, lapack_int n, const double* a,\n                           lapack_int lda, const double* b, lapack_int ldb,\n                           double* c, lapack_int ldc, const double* d,\n                           lapack_int ldd, const double* e, lapack_int lde,\n                           double* f, lapack_int ldf, double* scale,\n                           double* dif );\nlapack_int LAPACKE_ctgsyl( int matrix_layout, char trans, lapack_int ijob,\n                           lapack_int m, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* c, lapack_int ldc,\n                           const lapack_complex_float* d, lapack_int ldd,\n                           const lapack_complex_float* e, lapack_int lde,\n                           lapack_complex_float* f, lapack_int ldf,\n                           float* scale, float* dif );\nlapack_int LAPACKE_ztgsyl( int matrix_layout, char trans, lapack_int ijob,\n                           lapack_int m, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* c, lapack_int ldc,\n                           const lapack_complex_double* d, lapack_int ldd,\n                           const lapack_complex_double* e, lapack_int lde,\n                           lapack_complex_double* f, lapack_int ldf,\n                           double* scale, double* dif );\n\nlapack_int LAPACKE_stpcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, const float* ap, float* rcond );\nlapack_int LAPACKE_dtpcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, const double* ap, double* rcond );\nlapack_int LAPACKE_ctpcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, const lapack_complex_float* ap,\n                           float* rcond );\nlapack_int LAPACKE_ztpcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, const lapack_complex_double* ap,\n                           double* rcond );\n\nlapack_int LAPACKE_stprfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs, const float* ap,\n                           const float* b, lapack_int ldb, const float* x,\n                           lapack_int ldx, float* ferr, float* berr );\nlapack_int LAPACKE_dtprfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs, const double* ap,\n                           const double* b, lapack_int ldb, const double* x,\n                           lapack_int ldx, double* ferr, double* berr );\nlapack_int LAPACKE_ctprfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_float* ap,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           const lapack_complex_float* x, lapack_int ldx,\n                           float* ferr, float* berr );\nlapack_int LAPACKE_ztprfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_double* ap,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           const lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_stptri( int matrix_layout, char uplo, char diag, lapack_int n,\n                           float* ap );\nlapack_int LAPACKE_dtptri( int matrix_layout, char uplo, char diag, lapack_int n,\n                           double* ap );\nlapack_int LAPACKE_ctptri( int matrix_layout, char uplo, char diag, lapack_int n,\n                           lapack_complex_float* ap );\nlapack_int LAPACKE_ztptri( int matrix_layout, char uplo, char diag, lapack_int n,\n                           lapack_complex_double* ap );\n\nlapack_int LAPACKE_stptrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs, const float* ap,\n                           float* b, lapack_int ldb );\nlapack_int LAPACKE_dtptrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs, const double* ap,\n                           double* b, lapack_int ldb );\nlapack_int LAPACKE_ctptrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_float* ap,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_ztptrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_double* ap,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_stpttf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const float* ap, float* arf );\nlapack_int LAPACKE_dtpttf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const double* ap, double* arf );\nlapack_int LAPACKE_ctpttf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const lapack_complex_float* ap,\n                           lapack_complex_float* arf );\nlapack_int LAPACKE_ztpttf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const lapack_complex_double* ap,\n                           lapack_complex_double* arf );\n\nlapack_int LAPACKE_stpttr( int matrix_layout, char uplo, lapack_int n,\n                           const float* ap, float* a, lapack_int lda );\nlapack_int LAPACKE_dtpttr( int matrix_layout, char uplo, lapack_int n,\n                           const double* ap, double* a, lapack_int lda );\nlapack_int LAPACKE_ctpttr( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* ap,\n                           lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_ztpttr( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* ap,\n                           lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_strcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, const float* a, lapack_int lda,\n                           float* rcond );\nlapack_int LAPACKE_dtrcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, const double* a, lapack_int lda,\n                           double* rcond );\nlapack_int LAPACKE_ctrcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, const lapack_complex_float* a,\n                           lapack_int lda, float* rcond );\nlapack_int LAPACKE_ztrcon( int matrix_layout, char norm, char uplo, char diag,\n                           lapack_int n, const lapack_complex_double* a,\n                           lapack_int lda, double* rcond );\n\nlapack_int LAPACKE_strevc( int matrix_layout, char side, char howmny,\n                           lapack_logical* select, lapack_int n, const float* t,\n                           lapack_int ldt, float* vl, lapack_int ldvl,\n                           float* vr, lapack_int ldvr, lapack_int mm,\n                           lapack_int* m );\nlapack_int LAPACKE_dtrevc( int matrix_layout, char side, char howmny,\n                           lapack_logical* select, lapack_int n,\n                           const double* t, lapack_int ldt, double* vl,\n                           lapack_int ldvl, double* vr, lapack_int ldvr,\n                           lapack_int mm, lapack_int* m );\nlapack_int LAPACKE_ctrevc( int matrix_layout, char side, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           lapack_complex_float* t, lapack_int ldt,\n                           lapack_complex_float* vl, lapack_int ldvl,\n                           lapack_complex_float* vr, lapack_int ldvr,\n                           lapack_int mm, lapack_int* m );\nlapack_int LAPACKE_ztrevc( int matrix_layout, char side, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           lapack_complex_double* t, lapack_int ldt,\n                           lapack_complex_double* vl, lapack_int ldvl,\n                           lapack_complex_double* vr, lapack_int ldvr,\n                           lapack_int mm, lapack_int* m );\n\nlapack_int LAPACKE_strexc( int matrix_layout, char compq, lapack_int n, float* t,\n                           lapack_int ldt, float* q, lapack_int ldq,\n                           lapack_int* ifst, lapack_int* ilst );\nlapack_int LAPACKE_dtrexc( int matrix_layout, char compq, lapack_int n,\n                           double* t, lapack_int ldt, double* q, lapack_int ldq,\n                           lapack_int* ifst, lapack_int* ilst );\nlapack_int LAPACKE_ctrexc( int matrix_layout, char compq, lapack_int n,\n                           lapack_complex_float* t, lapack_int ldt,\n                           lapack_complex_float* q, lapack_int ldq,\n                           lapack_int ifst, lapack_int ilst );\nlapack_int LAPACKE_ztrexc( int matrix_layout, char compq, lapack_int n,\n                           lapack_complex_double* t, lapack_int ldt,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_int ifst, lapack_int ilst );\n\nlapack_int LAPACKE_strrfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs, const float* a,\n                           lapack_int lda, const float* b, lapack_int ldb,\n                           const float* x, lapack_int ldx, float* ferr,\n                           float* berr );\nlapack_int LAPACKE_dtrrfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs, const double* a,\n                           lapack_int lda, const double* b, lapack_int ldb,\n                           const double* x, lapack_int ldx, double* ferr,\n                           double* berr );\nlapack_int LAPACKE_ctrrfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           const lapack_complex_float* x, lapack_int ldx,\n                           float* ferr, float* berr );\nlapack_int LAPACKE_ztrrfs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           const lapack_complex_double* x, lapack_int ldx,\n                           double* ferr, double* berr );\n\nlapack_int LAPACKE_strsen( int matrix_layout, char job, char compq,\n                           const lapack_logical* select, lapack_int n, float* t,\n                           lapack_int ldt, float* q, lapack_int ldq, float* wr,\n                           float* wi, lapack_int* m, float* s, float* sep );\nlapack_int LAPACKE_dtrsen( int matrix_layout, char job, char compq,\n                           const lapack_logical* select, lapack_int n,\n                           double* t, lapack_int ldt, double* q, lapack_int ldq,\n                           double* wr, double* wi, lapack_int* m, double* s,\n                           double* sep );\nlapack_int LAPACKE_ctrsen( int matrix_layout, char job, char compq,\n                           const lapack_logical* select, lapack_int n,\n                           lapack_complex_float* t, lapack_int ldt,\n                           lapack_complex_float* q, lapack_int ldq,\n                           lapack_complex_float* w, lapack_int* m, float* s,\n                           float* sep );\nlapack_int LAPACKE_ztrsen( int matrix_layout, char job, char compq,\n                           const lapack_logical* select, lapack_int n,\n                           lapack_complex_double* t, lapack_int ldt,\n                           lapack_complex_double* q, lapack_int ldq,\n                           lapack_complex_double* w, lapack_int* m, double* s,\n                           double* sep );\n\nlapack_int LAPACKE_strsna( int matrix_layout, char job, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const float* t, lapack_int ldt, const float* vl,\n                           lapack_int ldvl, const float* vr, lapack_int ldvr,\n                           float* s, float* sep, lapack_int mm, lapack_int* m );\nlapack_int LAPACKE_dtrsna( int matrix_layout, char job, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const double* t, lapack_int ldt, const double* vl,\n                           lapack_int ldvl, const double* vr, lapack_int ldvr,\n                           double* s, double* sep, lapack_int mm,\n                           lapack_int* m );\nlapack_int LAPACKE_ctrsna( int matrix_layout, char job, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const lapack_complex_float* t, lapack_int ldt,\n                           const lapack_complex_float* vl, lapack_int ldvl,\n                           const lapack_complex_float* vr, lapack_int ldvr,\n                           float* s, float* sep, lapack_int mm, lapack_int* m );\nlapack_int LAPACKE_ztrsna( int matrix_layout, char job, char howmny,\n                           const lapack_logical* select, lapack_int n,\n                           const lapack_complex_double* t, lapack_int ldt,\n                           const lapack_complex_double* vl, lapack_int ldvl,\n                           const lapack_complex_double* vr, lapack_int ldvr,\n                           double* s, double* sep, lapack_int mm,\n                           lapack_int* m );\n\nlapack_int LAPACKE_strsyl( int matrix_layout, char trana, char tranb,\n                           lapack_int isgn, lapack_int m, lapack_int n,\n                           const float* a, lapack_int lda, const float* b,\n                           lapack_int ldb, float* c, lapack_int ldc,\n                           float* scale );\nlapack_int LAPACKE_dtrsyl( int matrix_layout, char trana, char tranb,\n                           lapack_int isgn, lapack_int m, lapack_int n,\n                           const double* a, lapack_int lda, const double* b,\n                           lapack_int ldb, double* c, lapack_int ldc,\n                           double* scale );\nlapack_int LAPACKE_ctrsyl( int matrix_layout, char trana, char tranb,\n                           lapack_int isgn, lapack_int m, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* c, lapack_int ldc,\n                           float* scale );\nlapack_int LAPACKE_ztrsyl( int matrix_layout, char trana, char tranb,\n                           lapack_int isgn, lapack_int m, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* c, lapack_int ldc,\n                           double* scale );\n\nlapack_int LAPACKE_strtri( int matrix_layout, char uplo, char diag, lapack_int n,\n                           float* a, lapack_int lda );\nlapack_int LAPACKE_dtrtri( int matrix_layout, char uplo, char diag, lapack_int n,\n                           double* a, lapack_int lda );\nlapack_int LAPACKE_ctrtri( int matrix_layout, char uplo, char diag, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_ztrtri( int matrix_layout, char uplo, char diag, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_strtrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs, const float* a,\n                           lapack_int lda, float* b, lapack_int ldb );\nlapack_int LAPACKE_dtrtrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs, const double* a,\n                           lapack_int lda, double* b, lapack_int ldb );\nlapack_int LAPACKE_ctrtrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_ztrtrs( int matrix_layout, char uplo, char trans, char diag,\n                           lapack_int n, lapack_int nrhs,\n                           const lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_strttf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const float* a, lapack_int lda,\n                           float* arf );\nlapack_int LAPACKE_dtrttf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const double* a, lapack_int lda,\n                           double* arf );\nlapack_int LAPACKE_ctrttf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* arf );\nlapack_int LAPACKE_ztrttf( int matrix_layout, char transr, char uplo,\n                           lapack_int n, const lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* arf );\n\nlapack_int LAPACKE_strttp( int matrix_layout, char uplo, lapack_int n,\n                           const float* a, lapack_int lda, float* ap );\nlapack_int LAPACKE_dtrttp( int matrix_layout, char uplo, lapack_int n,\n                           const double* a, lapack_int lda, double* ap );\nlapack_int LAPACKE_ctrttp( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* ap );\nlapack_int LAPACKE_ztrttp( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* ap );\n\nlapack_int LAPACKE_stzrzf( int matrix_layout, lapack_int m, lapack_int n,\n                           float* a, lapack_int lda, float* tau );\nlapack_int LAPACKE_dtzrzf( int matrix_layout, lapack_int m, lapack_int n,\n                           double* a, lapack_int lda, double* tau );\nlapack_int LAPACKE_ctzrzf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* tau );\nlapack_int LAPACKE_ztzrzf( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* tau );\n\nlapack_int LAPACKE_cungbr( int matrix_layout, char vect, lapack_int m,\n                           lapack_int n, lapack_int k, lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* tau );\nlapack_int LAPACKE_zungbr( int matrix_layout, char vect, lapack_int m,\n                           lapack_int n, lapack_int k, lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* tau );\n\nlapack_int LAPACKE_cunghr( int matrix_layout, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* tau );\nlapack_int LAPACKE_zunghr( int matrix_layout, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* tau );\n\nlapack_int LAPACKE_cunglq( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* tau );\nlapack_int LAPACKE_zunglq( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* tau );\n\nlapack_int LAPACKE_cungql( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* tau );\nlapack_int LAPACKE_zungql( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* tau );\n\nlapack_int LAPACKE_cungqr( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* tau );\nlapack_int LAPACKE_zungqr( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* tau );\n\nlapack_int LAPACKE_cungrq( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* tau );\nlapack_int LAPACKE_zungrq( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* tau );\n\nlapack_int LAPACKE_cungtr( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* tau );\nlapack_int LAPACKE_zungtr( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* tau );\n\nlapack_int LAPACKE_cunmbr( int matrix_layout, char vect, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* tau,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zunmbr( int matrix_layout, char vect, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* tau,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_cunmhr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* tau,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zunmhr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int ilo,\n                           lapack_int ihi, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* tau,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_cunmlq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* tau,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zunmlq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* tau,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_cunmql( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* tau,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zunmql( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* tau,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_cunmqr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* tau,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zunmqr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* tau,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_cunmrq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* tau,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zunmrq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* tau,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_cunmrz( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           lapack_int l, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_complex_float* tau,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zunmrz( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           lapack_int l, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_complex_double* tau,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_cunmtr( int matrix_layout, char side, char uplo, char trans,\n                           lapack_int m, lapack_int n,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* tau,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zunmtr( int matrix_layout, char side, char uplo, char trans,\n                           lapack_int m, lapack_int n,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* tau,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_cupgtr( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_float* ap,\n                           const lapack_complex_float* tau,\n                           lapack_complex_float* q, lapack_int ldq );\nlapack_int LAPACKE_zupgtr( int matrix_layout, char uplo, lapack_int n,\n                           const lapack_complex_double* ap,\n                           const lapack_complex_double* tau,\n                           lapack_complex_double* q, lapack_int ldq );\n\nlapack_int LAPACKE_cupmtr( int matrix_layout, char side, char uplo, char trans,\n                           lapack_int m, lapack_int n,\n                           const lapack_complex_float* ap,\n                           const lapack_complex_float* tau,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zupmtr( int matrix_layout, char side, char uplo, char trans,\n                           lapack_int m, lapack_int n,\n                           const lapack_complex_double* ap,\n                           const lapack_complex_double* tau,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sbdsdc_work( int matrix_layout, char uplo, char compq,\n                                lapack_int n, float* d, float* e, float* u,\n                                lapack_int ldu, float* vt, lapack_int ldvt,\n                                float* q, lapack_int* iq, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dbdsdc_work( int matrix_layout, char uplo, char compq,\n                                lapack_int n, double* d, double* e, double* u,\n                                lapack_int ldu, double* vt, lapack_int ldvt,\n                                double* q, lapack_int* iq, double* work,\n                                lapack_int* iwork );\n\nlapack_int LAPACKE_sbdsvdx_work( int matrix_layout, char uplo, char jobz, char range,\n                                 lapack_int n, float* d, float* e,\n                                 float vl, float vu,\n                                 lapack_int il, lapack_int iu, lapack_int* ns,\n                                 float* s, float* z, lapack_int ldz,\n                                 float* work, lapack_int* iwork );\nlapack_int LAPACKE_dbdsvdx_work( int matrix_layout, char uplo, char jobz, char range,\n                                 lapack_int n, double* d, double* e,\n                                 double vl, double vu,\n                                 lapack_int il, lapack_int iu, lapack_int* ns,\n                                 double* s, double* z, lapack_int ldz,\n                                 double* work, lapack_int* iwork );\n\nlapack_int LAPACKE_sbdsqr_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int ncvt, lapack_int nru, lapack_int ncc,\n                                float* d, float* e, float* vt, lapack_int ldvt,\n                                float* u, lapack_int ldu, float* c,\n                                lapack_int ldc, float* work );\nlapack_int LAPACKE_dbdsqr_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int ncvt, lapack_int nru, lapack_int ncc,\n                                double* d, double* e, double* vt,\n                                lapack_int ldvt, double* u, lapack_int ldu,\n                                double* c, lapack_int ldc, double* work );\nlapack_int LAPACKE_cbdsqr_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int ncvt, lapack_int nru, lapack_int ncc,\n                                float* d, float* e, lapack_complex_float* vt,\n                                lapack_int ldvt, lapack_complex_float* u,\n                                lapack_int ldu, lapack_complex_float* c,\n                                lapack_int ldc, float* work );\nlapack_int LAPACKE_zbdsqr_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int ncvt, lapack_int nru, lapack_int ncc,\n                                double* d, double* e, lapack_complex_double* vt,\n                                lapack_int ldvt, lapack_complex_double* u,\n                                lapack_int ldu, lapack_complex_double* c,\n                                lapack_int ldc, double* work );\n\nlapack_int LAPACKE_sdisna_work( char job, lapack_int m, lapack_int n,\n                                const float* d, float* sep );\nlapack_int LAPACKE_ddisna_work( char job, lapack_int m, lapack_int n,\n                                const double* d, double* sep );\n\nlapack_int LAPACKE_sgbbrd_work( int matrix_layout, char vect, lapack_int m,\n                                lapack_int n, lapack_int ncc, lapack_int kl,\n                                lapack_int ku, float* ab, lapack_int ldab,\n                                float* d, float* e, float* q, lapack_int ldq,\n                                float* pt, lapack_int ldpt, float* c,\n                                lapack_int ldc, float* work );\nlapack_int LAPACKE_dgbbrd_work( int matrix_layout, char vect, lapack_int m,\n                                lapack_int n, lapack_int ncc, lapack_int kl,\n                                lapack_int ku, double* ab, lapack_int ldab,\n                                double* d, double* e, double* q, lapack_int ldq,\n                                double* pt, lapack_int ldpt, double* c,\n                                lapack_int ldc, double* work );\nlapack_int LAPACKE_cgbbrd_work( int matrix_layout, char vect, lapack_int m,\n                                lapack_int n, lapack_int ncc, lapack_int kl,\n                                lapack_int ku, lapack_complex_float* ab,\n                                lapack_int ldab, float* d, float* e,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_complex_float* pt, lapack_int ldpt,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zgbbrd_work( int matrix_layout, char vect, lapack_int m,\n                                lapack_int n, lapack_int ncc, lapack_int kl,\n                                lapack_int ku, lapack_complex_double* ab,\n                                lapack_int ldab, double* d, double* e,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_complex_double* pt, lapack_int ldpt,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sgbcon_work( int matrix_layout, char norm, lapack_int n,\n                                lapack_int kl, lapack_int ku, const float* ab,\n                                lapack_int ldab, const lapack_int* ipiv,\n                                float anorm, float* rcond, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dgbcon_work( int matrix_layout, char norm, lapack_int n,\n                                lapack_int kl, lapack_int ku, const double* ab,\n                                lapack_int ldab, const lapack_int* ipiv,\n                                double anorm, double* rcond, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cgbcon_work( int matrix_layout, char norm, lapack_int n,\n                                lapack_int kl, lapack_int ku,\n                                const lapack_complex_float* ab, lapack_int ldab,\n                                const lapack_int* ipiv, float anorm,\n                                float* rcond, lapack_complex_float* work,\n                                float* rwork );\nlapack_int LAPACKE_zgbcon_work( int matrix_layout, char norm, lapack_int n,\n                                lapack_int kl, lapack_int ku,\n                                const lapack_complex_double* ab,\n                                lapack_int ldab, const lapack_int* ipiv,\n                                double anorm, double* rcond,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sgbequ_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int kl, lapack_int ku, const float* ab,\n                                lapack_int ldab, float* r, float* c,\n                                float* rowcnd, float* colcnd, float* amax );\nlapack_int LAPACKE_dgbequ_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int kl, lapack_int ku, const double* ab,\n                                lapack_int ldab, double* r, double* c,\n                                double* rowcnd, double* colcnd, double* amax );\nlapack_int LAPACKE_cgbequ_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int kl, lapack_int ku,\n                                const lapack_complex_float* ab, lapack_int ldab,\n                                float* r, float* c, float* rowcnd,\n                                float* colcnd, float* amax );\nlapack_int LAPACKE_zgbequ_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int kl, lapack_int ku,\n                                const lapack_complex_double* ab,\n                                lapack_int ldab, double* r, double* c,\n                                double* rowcnd, double* colcnd, double* amax );\n\nlapack_int LAPACKE_sgbequb_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_int kl, lapack_int ku, const float* ab,\n                                 lapack_int ldab, float* r, float* c,\n                                 float* rowcnd, float* colcnd, float* amax );\nlapack_int LAPACKE_dgbequb_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_int kl, lapack_int ku, const double* ab,\n                                 lapack_int ldab, double* r, double* c,\n                                 double* rowcnd, double* colcnd, double* amax );\nlapack_int LAPACKE_cgbequb_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_int kl, lapack_int ku,\n                                 const lapack_complex_float* ab,\n                                 lapack_int ldab, float* r, float* c,\n                                 float* rowcnd, float* colcnd, float* amax );\nlapack_int LAPACKE_zgbequb_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_int kl, lapack_int ku,\n                                 const lapack_complex_double* ab,\n                                 lapack_int ldab, double* r, double* c,\n                                 double* rowcnd, double* colcnd, double* amax );\n\nlapack_int LAPACKE_sgbrfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int kl, lapack_int ku, lapack_int nrhs,\n                                const float* ab, lapack_int ldab,\n                                const float* afb, lapack_int ldafb,\n                                const lapack_int* ipiv, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* ferr, float* berr, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dgbrfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int kl, lapack_int ku, lapack_int nrhs,\n                                const double* ab, lapack_int ldab,\n                                const double* afb, lapack_int ldafb,\n                                const lapack_int* ipiv, const double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* ferr, double* berr, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cgbrfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int kl, lapack_int ku, lapack_int nrhs,\n                                const lapack_complex_float* ab, lapack_int ldab,\n                                const lapack_complex_float* afb,\n                                lapack_int ldafb, const lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zgbrfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int kl, lapack_int ku, lapack_int nrhs,\n                                const lapack_complex_double* ab,\n                                lapack_int ldab,\n                                const lapack_complex_double* afb,\n                                lapack_int ldafb, const lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sgbsv_work( int matrix_layout, lapack_int n, lapack_int kl,\n                               lapack_int ku, lapack_int nrhs, float* ab,\n                               lapack_int ldab, lapack_int* ipiv, float* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_dgbsv_work( int matrix_layout, lapack_int n, lapack_int kl,\n                               lapack_int ku, lapack_int nrhs, double* ab,\n                               lapack_int ldab, lapack_int* ipiv, double* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_cgbsv_work( int matrix_layout, lapack_int n, lapack_int kl,\n                               lapack_int ku, lapack_int nrhs,\n                               lapack_complex_float* ab, lapack_int ldab,\n                               lapack_int* ipiv, lapack_complex_float* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_zgbsv_work( int matrix_layout, lapack_int n, lapack_int kl,\n                               lapack_int ku, lapack_int nrhs,\n                               lapack_complex_double* ab, lapack_int ldab,\n                               lapack_int* ipiv, lapack_complex_double* b,\n                               lapack_int ldb );\n\nlapack_int LAPACKE_sgbsvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int kl, lapack_int ku,\n                                lapack_int nrhs, float* ab, lapack_int ldab,\n                                float* afb, lapack_int ldafb, lapack_int* ipiv,\n                                char* equed, float* r, float* c, float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dgbsvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int kl, lapack_int ku,\n                                lapack_int nrhs, double* ab, lapack_int ldab,\n                                double* afb, lapack_int ldafb, lapack_int* ipiv,\n                                char* equed, double* r, double* c, double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cgbsvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int kl, lapack_int ku,\n                                lapack_int nrhs, lapack_complex_float* ab,\n                                lapack_int ldab, lapack_complex_float* afb,\n                                lapack_int ldafb, lapack_int* ipiv, char* equed,\n                                float* r, float* c, lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* x,\n                                lapack_int ldx, float* rcond, float* ferr,\n                                float* berr, lapack_complex_float* work,\n                                float* rwork );\nlapack_int LAPACKE_zgbsvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int kl, lapack_int ku,\n                                lapack_int nrhs, lapack_complex_double* ab,\n                                lapack_int ldab, lapack_complex_double* afb,\n                                lapack_int ldafb, lapack_int* ipiv, char* equed,\n                                double* r, double* c, lapack_complex_double* b,\n                                lapack_int ldb, lapack_complex_double* x,\n                                lapack_int ldx, double* rcond, double* ferr,\n                                double* berr, lapack_complex_double* work,\n                                double* rwork );\n\nlapack_int LAPACKE_sgbtrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int kl, lapack_int ku, float* ab,\n                                lapack_int ldab, lapack_int* ipiv );\nlapack_int LAPACKE_dgbtrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int kl, lapack_int ku, double* ab,\n                                lapack_int ldab, lapack_int* ipiv );\nlapack_int LAPACKE_cgbtrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int kl, lapack_int ku,\n                                lapack_complex_float* ab, lapack_int ldab,\n                                lapack_int* ipiv );\nlapack_int LAPACKE_zgbtrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int kl, lapack_int ku,\n                                lapack_complex_double* ab, lapack_int ldab,\n                                lapack_int* ipiv );\n\nlapack_int LAPACKE_sgbtrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int kl, lapack_int ku, lapack_int nrhs,\n                                const float* ab, lapack_int ldab,\n                                const lapack_int* ipiv, float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_dgbtrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int kl, lapack_int ku, lapack_int nrhs,\n                                const double* ab, lapack_int ldab,\n                                const lapack_int* ipiv, double* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_cgbtrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int kl, lapack_int ku, lapack_int nrhs,\n                                const lapack_complex_float* ab, lapack_int ldab,\n                                const lapack_int* ipiv, lapack_complex_float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_zgbtrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int kl, lapack_int ku, lapack_int nrhs,\n                                const lapack_complex_double* ab,\n                                lapack_int ldab, const lapack_int* ipiv,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sgebak_work( int matrix_layout, char job, char side,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                const float* scale, lapack_int m, float* v,\n                                lapack_int ldv );\nlapack_int LAPACKE_dgebak_work( int matrix_layout, char job, char side,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                const double* scale, lapack_int m, double* v,\n                                lapack_int ldv );\nlapack_int LAPACKE_cgebak_work( int matrix_layout, char job, char side,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                const float* scale, lapack_int m,\n                                lapack_complex_float* v, lapack_int ldv );\nlapack_int LAPACKE_zgebak_work( int matrix_layout, char job, char side,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                const double* scale, lapack_int m,\n                                lapack_complex_double* v, lapack_int ldv );\n\nlapack_int LAPACKE_sgebal_work( int matrix_layout, char job, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* ilo,\n                                lapack_int* ihi, float* scale );\nlapack_int LAPACKE_dgebal_work( int matrix_layout, char job, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* ilo,\n                                lapack_int* ihi, double* scale );\nlapack_int LAPACKE_cgebal_work( int matrix_layout, char job, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* ilo, lapack_int* ihi,\n                                float* scale );\nlapack_int LAPACKE_zgebal_work( int matrix_layout, char job, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ilo, lapack_int* ihi,\n                                double* scale );\n\nlapack_int LAPACKE_sgebrd_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, float* d, float* e,\n                                float* tauq, float* taup, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dgebrd_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, double* d, double* e,\n                                double* tauq, double* taup, double* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_cgebrd_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                float* d, float* e, lapack_complex_float* tauq,\n                                lapack_complex_float* taup,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgebrd_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                double* d, double* e,\n                                lapack_complex_double* tauq,\n                                lapack_complex_double* taup,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgecon_work( int matrix_layout, char norm, lapack_int n,\n                                const float* a, lapack_int lda, float anorm,\n                                float* rcond, float* work, lapack_int* iwork );\nlapack_int LAPACKE_dgecon_work( int matrix_layout, char norm, lapack_int n,\n                                const double* a, lapack_int lda, double anorm,\n                                double* rcond, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cgecon_work( int matrix_layout, char norm, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                float anorm, float* rcond,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zgecon_work( int matrix_layout, char norm, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                double anorm, double* rcond,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sgeequ_work( int matrix_layout, lapack_int m, lapack_int n,\n                                const float* a, lapack_int lda, float* r,\n                                float* c, float* rowcnd, float* colcnd,\n                                float* amax );\nlapack_int LAPACKE_dgeequ_work( int matrix_layout, lapack_int m, lapack_int n,\n                                const double* a, lapack_int lda, double* r,\n                                double* c, double* rowcnd, double* colcnd,\n                                double* amax );\nlapack_int LAPACKE_cgeequ_work( int matrix_layout, lapack_int m, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                float* r, float* c, float* rowcnd,\n                                float* colcnd, float* amax );\nlapack_int LAPACKE_zgeequ_work( int matrix_layout, lapack_int m, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                double* r, double* c, double* rowcnd,\n                                double* colcnd, double* amax );\n\nlapack_int LAPACKE_sgeequb_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 const float* a, lapack_int lda, float* r,\n                                 float* c, float* rowcnd, float* colcnd,\n                                 float* amax );\nlapack_int LAPACKE_dgeequb_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 const double* a, lapack_int lda, double* r,\n                                 double* c, double* rowcnd, double* colcnd,\n                                 double* amax );\nlapack_int LAPACKE_cgeequb_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 const lapack_complex_float* a, lapack_int lda,\n                                 float* r, float* c, float* rowcnd,\n                                 float* colcnd, float* amax );\nlapack_int LAPACKE_zgeequb_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 const lapack_complex_double* a, lapack_int lda,\n                                 double* r, double* c, double* rowcnd,\n                                 double* colcnd, double* amax );\n\nlapack_int LAPACKE_sgees_work( int matrix_layout, char jobvs, char sort,\n                               LAPACK_S_SELECT2 select, lapack_int n, float* a,\n                               lapack_int lda, lapack_int* sdim, float* wr,\n                               float* wi, float* vs, lapack_int ldvs,\n                               float* work, lapack_int lwork,\n                               lapack_logical* bwork );\nlapack_int LAPACKE_dgees_work( int matrix_layout, char jobvs, char sort,\n                               LAPACK_D_SELECT2 select, lapack_int n, double* a,\n                               lapack_int lda, lapack_int* sdim, double* wr,\n                               double* wi, double* vs, lapack_int ldvs,\n                               double* work, lapack_int lwork,\n                               lapack_logical* bwork );\nlapack_int LAPACKE_cgees_work( int matrix_layout, char jobvs, char sort,\n                               LAPACK_C_SELECT1 select, lapack_int n,\n                               lapack_complex_float* a, lapack_int lda,\n                               lapack_int* sdim, lapack_complex_float* w,\n                               lapack_complex_float* vs, lapack_int ldvs,\n                               lapack_complex_float* work, lapack_int lwork,\n                               float* rwork, lapack_logical* bwork );\nlapack_int LAPACKE_zgees_work( int matrix_layout, char jobvs, char sort,\n                               LAPACK_Z_SELECT1 select, lapack_int n,\n                               lapack_complex_double* a, lapack_int lda,\n                               lapack_int* sdim, lapack_complex_double* w,\n                               lapack_complex_double* vs, lapack_int ldvs,\n                               lapack_complex_double* work, lapack_int lwork,\n                               double* rwork, lapack_logical* bwork );\n\nlapack_int LAPACKE_sgeesx_work( int matrix_layout, char jobvs, char sort,\n                                LAPACK_S_SELECT2 select, char sense,\n                                lapack_int n, float* a, lapack_int lda,\n                                lapack_int* sdim, float* wr, float* wi,\n                                float* vs, lapack_int ldvs, float* rconde,\n                                float* rcondv, float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork,\n                                lapack_logical* bwork );\nlapack_int LAPACKE_dgeesx_work( int matrix_layout, char jobvs, char sort,\n                                LAPACK_D_SELECT2 select, char sense,\n                                lapack_int n, double* a, lapack_int lda,\n                                lapack_int* sdim, double* wr, double* wi,\n                                double* vs, lapack_int ldvs, double* rconde,\n                                double* rcondv, double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork,\n                                lapack_logical* bwork );\nlapack_int LAPACKE_cgeesx_work( int matrix_layout, char jobvs, char sort,\n                                LAPACK_C_SELECT1 select, char sense,\n                                lapack_int n, lapack_complex_float* a,\n                                lapack_int lda, lapack_int* sdim,\n                                lapack_complex_float* w,\n                                lapack_complex_float* vs, lapack_int ldvs,\n                                float* rconde, float* rcondv,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_logical* bwork );\nlapack_int LAPACKE_zgeesx_work( int matrix_layout, char jobvs, char sort,\n                                LAPACK_Z_SELECT1 select, char sense,\n                                lapack_int n, lapack_complex_double* a,\n                                lapack_int lda, lapack_int* sdim,\n                                lapack_complex_double* w,\n                                lapack_complex_double* vs, lapack_int ldvs,\n                                double* rconde, double* rcondv,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_logical* bwork );\n\nlapack_int LAPACKE_sgeev_work( int matrix_layout, char jobvl, char jobvr,\n                               lapack_int n, float* a, lapack_int lda,\n                               float* wr, float* wi, float* vl, lapack_int ldvl,\n                               float* vr, lapack_int ldvr, float* work,\n                               lapack_int lwork );\nlapack_int LAPACKE_dgeev_work( int matrix_layout, char jobvl, char jobvr,\n                               lapack_int n, double* a, lapack_int lda,\n                               double* wr, double* wi, double* vl,\n                               lapack_int ldvl, double* vr, lapack_int ldvr,\n                               double* work, lapack_int lwork );\nlapack_int LAPACKE_cgeev_work( int matrix_layout, char jobvl, char jobvr,\n                               lapack_int n, lapack_complex_float* a,\n                               lapack_int lda, lapack_complex_float* w,\n                               lapack_complex_float* vl, lapack_int ldvl,\n                               lapack_complex_float* vr, lapack_int ldvr,\n                               lapack_complex_float* work, lapack_int lwork,\n                               float* rwork );\nlapack_int LAPACKE_zgeev_work( int matrix_layout, char jobvl, char jobvr,\n                               lapack_int n, lapack_complex_double* a,\n                               lapack_int lda, lapack_complex_double* w,\n                               lapack_complex_double* vl, lapack_int ldvl,\n                               lapack_complex_double* vr, lapack_int ldvr,\n                               lapack_complex_double* work, lapack_int lwork,\n                               double* rwork );\n\nlapack_int LAPACKE_sgeevx_work( int matrix_layout, char balanc, char jobvl,\n                                char jobvr, char sense, lapack_int n, float* a,\n                                lapack_int lda, float* wr, float* wi, float* vl,\n                                lapack_int ldvl, float* vr, lapack_int ldvr,\n                                lapack_int* ilo, lapack_int* ihi, float* scale,\n                                float* abnrm, float* rconde, float* rcondv,\n                                float* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dgeevx_work( int matrix_layout, char balanc, char jobvl,\n                                char jobvr, char sense, lapack_int n, double* a,\n                                lapack_int lda, double* wr, double* wi,\n                                double* vl, lapack_int ldvl, double* vr,\n                                lapack_int ldvr, lapack_int* ilo,\n                                lapack_int* ihi, double* scale, double* abnrm,\n                                double* rconde, double* rcondv, double* work,\n                                lapack_int lwork, lapack_int* iwork );\nlapack_int LAPACKE_cgeevx_work( int matrix_layout, char balanc, char jobvl,\n                                char jobvr, char sense, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* w,\n                                lapack_complex_float* vl, lapack_int ldvl,\n                                lapack_complex_float* vr, lapack_int ldvr,\n                                lapack_int* ilo, lapack_int* ihi, float* scale,\n                                float* abnrm, float* rconde, float* rcondv,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork );\nlapack_int LAPACKE_zgeevx_work( int matrix_layout, char balanc, char jobvl,\n                                char jobvr, char sense, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* w,\n                                lapack_complex_double* vl, lapack_int ldvl,\n                                lapack_complex_double* vr, lapack_int ldvr,\n                                lapack_int* ilo, lapack_int* ihi, double* scale,\n                                double* abnrm, double* rconde, double* rcondv,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork );\n\nlapack_int LAPACKE_sgehrd_work( int matrix_layout, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, float* a, lapack_int lda,\n                                float* tau, float* work, lapack_int lwork );\nlapack_int LAPACKE_dgehrd_work( int matrix_layout, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, double* a, lapack_int lda,\n                                double* tau, double* work, lapack_int lwork );\nlapack_int LAPACKE_cgehrd_work( int matrix_layout, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgehrd_work( int matrix_layout, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgejsv_work( int matrix_layout, char joba, char jobu,\n                                char jobv, char jobr, char jobt, char jobp,\n                                lapack_int m, lapack_int n, float* a,\n                                lapack_int lda, float* sva, float* u,\n                                lapack_int ldu, float* v, lapack_int ldv,\n                                float* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dgejsv_work( int matrix_layout, char joba, char jobu,\n                                char jobv, char jobr, char jobt, char jobp,\n                                lapack_int m, lapack_int n, double* a,\n                                lapack_int lda, double* sva, double* u,\n                                lapack_int ldu, double* v, lapack_int ldv,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cgejsv_work( int matrix_layout, char joba, char jobu,\n                                char jobv, char jobr, char jobt, char jobp,\n                                lapack_int m, lapack_int n, lapack_complex_float* a,\n                                lapack_int lda, float* sva, lapack_complex_float* u,\n                                lapack_int ldu, lapack_complex_float* v, lapack_int ldv,\n                                lapack_complex_float* cwork, lapack_int lwork,\n                                float* work, lapack_int lrwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_zgejsv_work( int matrix_layout, char joba, char jobu,\n                                char jobv, char jobr, char jobt, char jobp,\n                                lapack_int m, lapack_int n, lapack_complex_double* a,\n                                lapack_int lda, double* sva, lapack_complex_double* u,\n                                lapack_int ldu, lapack_complex_double* v, lapack_int ldv,\n                                lapack_complex_double* cwork, lapack_int lwork,\n                                double* work, lapack_int lrwork,\n                                lapack_int* iwork );\n\nlapack_int LAPACKE_sgelq2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, float* tau,\n                                float* work );\nlapack_int LAPACKE_dgelq2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, double* tau,\n                                double* work );\nlapack_int LAPACKE_cgelq2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* tau,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zgelq2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* tau,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_sgelqf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, float* tau,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dgelqf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, double* tau,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgelqf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgelqf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgels_work( int matrix_layout, char trans, lapack_int m,\n                               lapack_int n, lapack_int nrhs, float* a,\n                               lapack_int lda, float* b, lapack_int ldb,\n                               float* work, lapack_int lwork );\nlapack_int LAPACKE_dgels_work( int matrix_layout, char trans, lapack_int m,\n                               lapack_int n, lapack_int nrhs, double* a,\n                               lapack_int lda, double* b, lapack_int ldb,\n                               double* work, lapack_int lwork );\nlapack_int LAPACKE_cgels_work( int matrix_layout, char trans, lapack_int m,\n                               lapack_int n, lapack_int nrhs,\n                               lapack_complex_float* a, lapack_int lda,\n                               lapack_complex_float* b, lapack_int ldb,\n                               lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgels_work( int matrix_layout, char trans, lapack_int m,\n                               lapack_int n, lapack_int nrhs,\n                               lapack_complex_double* a, lapack_int lda,\n                               lapack_complex_double* b, lapack_int ldb,\n                               lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgelsd_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, float* a, lapack_int lda,\n                                float* b, lapack_int ldb, float* s, float rcond,\n                                lapack_int* rank, float* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dgelsd_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, double* a, lapack_int lda,\n                                double* b, lapack_int ldb, double* s,\n                                double rcond, lapack_int* rank, double* work,\n                                lapack_int lwork, lapack_int* iwork );\nlapack_int LAPACKE_cgelsd_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* b,\n                                lapack_int ldb, float* s, float rcond,\n                                lapack_int* rank, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_zgelsd_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb, double* s, double rcond,\n                                lapack_int* rank, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork,\n                                lapack_int* iwork );\n\nlapack_int LAPACKE_sgelss_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, float* a, lapack_int lda,\n                                float* b, lapack_int ldb, float* s, float rcond,\n                                lapack_int* rank, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dgelss_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, double* a, lapack_int lda,\n                                double* b, lapack_int ldb, double* s,\n                                double rcond, lapack_int* rank, double* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_cgelss_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* b,\n                                lapack_int ldb, float* s, float rcond,\n                                lapack_int* rank, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork );\nlapack_int LAPACKE_zgelss_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb, double* s, double rcond,\n                                lapack_int* rank, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork );\n\nlapack_int LAPACKE_sgelsy_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, float* a, lapack_int lda,\n                                float* b, lapack_int ldb, lapack_int* jpvt,\n                                float rcond, lapack_int* rank, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dgelsy_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, double* a, lapack_int lda,\n                                double* b, lapack_int ldb, lapack_int* jpvt,\n                                double rcond, lapack_int* rank, double* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_cgelsy_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* b,\n                                lapack_int ldb, lapack_int* jpvt, float rcond,\n                                lapack_int* rank, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork );\nlapack_int LAPACKE_zgelsy_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nrhs, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb, lapack_int* jpvt, double rcond,\n                                lapack_int* rank, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork );\n\nlapack_int LAPACKE_sgeqlf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, float* tau,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dgeqlf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, double* tau,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgeqlf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgeqlf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgeqp3_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* jpvt,\n                                float* tau, float* work, lapack_int lwork );\nlapack_int LAPACKE_dgeqp3_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* jpvt,\n                                double* tau, double* work, lapack_int lwork );\nlapack_int LAPACKE_cgeqp3_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* jpvt, lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork );\nlapack_int LAPACKE_zgeqp3_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* jpvt, lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork );\n\nlapack_int LAPACKE_sgeqpf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* jpvt,\n                                float* tau, float* work );\nlapack_int LAPACKE_dgeqpf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* jpvt,\n                                double* tau, double* work );\nlapack_int LAPACKE_cgeqpf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* jpvt, lapack_complex_float* tau,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zgeqpf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* jpvt, lapack_complex_double* tau,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sgeqr2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, float* tau,\n                                float* work );\nlapack_int LAPACKE_dgeqr2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, double* tau,\n                                double* work );\nlapack_int LAPACKE_cgeqr2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* tau,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zgeqr2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* tau,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_sgeqrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, float* tau,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dgeqrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, double* tau,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgeqrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgeqrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgeqrfp_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 float* a, lapack_int lda, float* tau,\n                                 float* work, lapack_int lwork );\nlapack_int LAPACKE_dgeqrfp_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 double* a, lapack_int lda, double* tau,\n                                 double* work, lapack_int lwork );\nlapack_int LAPACKE_cgeqrfp_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_complex_float* a, lapack_int lda,\n                                 lapack_complex_float* tau,\n                                 lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgeqrfp_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_complex_double* a, lapack_int lda,\n                                 lapack_complex_double* tau,\n                                 lapack_complex_double* work,\n                                 lapack_int lwork );\n\nlapack_int LAPACKE_sgerfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const float* a, lapack_int lda,\n                                const float* af, lapack_int ldaf,\n                                const lapack_int* ipiv, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* ferr, float* berr, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dgerfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const double* a,\n                                lapack_int lda, const double* af,\n                                lapack_int ldaf, const lapack_int* ipiv,\n                                const double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* ferr, double* berr,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cgerfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* af,\n                                lapack_int ldaf, const lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zgerfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, const lapack_complex_double* af,\n                                lapack_int ldaf, const lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sgerqf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, float* tau,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dgerqf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, double* tau,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgerqf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgerqf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgesdd_work( int matrix_layout, char jobz, lapack_int m,\n                                lapack_int n, float* a, lapack_int lda,\n                                float* s, float* u, lapack_int ldu, float* vt,\n                                lapack_int ldvt, float* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dgesdd_work( int matrix_layout, char jobz, lapack_int m,\n                                lapack_int n, double* a, lapack_int lda,\n                                double* s, double* u, lapack_int ldu,\n                                double* vt, lapack_int ldvt, double* work,\n                                lapack_int lwork, lapack_int* iwork );\nlapack_int LAPACKE_cgesdd_work( int matrix_layout, char jobz, lapack_int m,\n                                lapack_int n, lapack_complex_float* a,\n                                lapack_int lda, float* s,\n                                lapack_complex_float* u, lapack_int ldu,\n                                lapack_complex_float* vt, lapack_int ldvt,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_int* iwork );\nlapack_int LAPACKE_zgesdd_work( int matrix_layout, char jobz, lapack_int m,\n                                lapack_int n, lapack_complex_double* a,\n                                lapack_int lda, double* s,\n                                lapack_complex_double* u, lapack_int ldu,\n                                lapack_complex_double* vt, lapack_int ldvt,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_int* iwork );\n\nlapack_int LAPACKE_sgesv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               float* a, lapack_int lda, lapack_int* ipiv,\n                               float* b, lapack_int ldb );\nlapack_int LAPACKE_dgesv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               double* a, lapack_int lda, lapack_int* ipiv,\n                               double* b, lapack_int ldb );\nlapack_int LAPACKE_cgesv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               lapack_complex_float* a, lapack_int lda,\n                               lapack_int* ipiv, lapack_complex_float* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_zgesv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               lapack_complex_double* a, lapack_int lda,\n                               lapack_int* ipiv, lapack_complex_double* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_dsgesv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                                double* a, lapack_int lda, lapack_int* ipiv,\n                                double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* work, float* swork,\n                                lapack_int* iter );\nlapack_int LAPACKE_zcgesv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_double* b,\n                                lapack_int ldb, lapack_complex_double* x,\n                                lapack_int ldx, lapack_complex_double* work,\n                                lapack_complex_float* swork, double* rwork,\n                                lapack_int* iter );\n\nlapack_int LAPACKE_sgesvd_work( int matrix_layout, char jobu, char jobvt,\n                                lapack_int m, lapack_int n, float* a,\n                                lapack_int lda, float* s, float* u,\n                                lapack_int ldu, float* vt, lapack_int ldvt,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dgesvd_work( int matrix_layout, char jobu, char jobvt,\n                                lapack_int m, lapack_int n, double* a,\n                                lapack_int lda, double* s, double* u,\n                                lapack_int ldu, double* vt, lapack_int ldvt,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgesvd_work( int matrix_layout, char jobu, char jobvt,\n                                lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                float* s, lapack_complex_float* u,\n                                lapack_int ldu, lapack_complex_float* vt,\n                                lapack_int ldvt, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork );\nlapack_int LAPACKE_zgesvd_work( int matrix_layout, char jobu, char jobvt,\n                                lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                double* s, lapack_complex_double* u,\n                                lapack_int ldu, lapack_complex_double* vt,\n                                lapack_int ldvt, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork );\n\nlapack_int LAPACKE_sgesvdx_work( int matrix_layout, char jobu, char jobvt, char range,\n                           \t\tlapack_int m, lapack_int n, float* a,\n                          \t\tlapack_int lda, float vl, float vu,\n                           \t\tlapack_int il, lapack_int iu, lapack_int* ns,\n                           \t\tfloat* s, float* u, lapack_int ldu,\n                           \t\tfloat* vt, lapack_int ldvt,\n                                float* work, lapack_int lwork, lapack_int* iwork );\nlapack_int LAPACKE_dgesvdx_work( int matrix_layout, char jobu, char jobvt, char range,\n                           \t\tlapack_int m, lapack_int n, double* a,\n                          \t\tlapack_int lda, double vl, double vu,\n                           \t\tlapack_int il, lapack_int iu, lapack_int* ns,\n                           \t\tdouble* s, double* u, lapack_int ldu,\n                           \t\tdouble* vt, lapack_int ldvt,\n                                double* work, lapack_int lwork, lapack_int* iwork );\nlapack_int LAPACKE_cgesvdx_work( int matrix_layout, char jobu, char jobvt, char range,\n                           \t\tlapack_int m, lapack_int n, lapack_complex_float* a,\n                          \t\tlapack_int lda, float vl, float vu,\n                           \t\tlapack_int il, lapack_int iu, lapack_int* ns,\n                           \t\tfloat* s, lapack_complex_float* u, lapack_int ldu,\n                           \t\tlapack_complex_float* vt, lapack_int ldvt,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_int* iwork );\nlapack_int LAPACKE_zgesvdx_work( int matrix_layout, char jobu, char jobvt, char range,\n                           \t\tlapack_int m, lapack_int n, lapack_complex_double* a,\n                          \t\tlapack_int lda, double vl, double vu,\n                           \t\tlapack_int il, lapack_int iu, lapack_int* ns,\n                           \t\tdouble* s, lapack_complex_double* u, lapack_int ldu,\n                           \t\tlapack_complex_double* vt, lapack_int ldvt,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_int* iwork );\n                           \nlapack_int LAPACKE_sgesvj_work( int matrix_layout, char joba, char jobu,\n                                char jobv, lapack_int m, lapack_int n, float* a,\n                                lapack_int lda, float* sva, lapack_int mv,\n                                float* v, lapack_int ldv, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dgesvj_work( int matrix_layout, char joba, char jobu,\n                                char jobv, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, double* sva,\n                                lapack_int mv, double* v, lapack_int ldv,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgesvj_work( int matrix_layout, char joba, char jobu,\n                                char jobv, lapack_int m, lapack_int n, lapack_complex_float* a,\n                                lapack_int lda, float* sva, lapack_int mv,\n                                lapack_complex_float* v, lapack_int ldv,\n                                lapack_complex_float* cwork, lapack_int lwork,\n \t\t\t\t\t\t\t\tfloat* rwork,lapack_int lrwork );\nlapack_int LAPACKE_zgesvj_work( int matrix_layout, char joba, char jobu,\n                                char jobv, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda, double* sva,\n                                lapack_int mv, lapack_complex_double* v, lapack_int ldv,\n                                lapack_complex_double* cwork, lapack_int lwork,\n                                double* rwork, lapack_int lrwork );\n\nlapack_int LAPACKE_sgesvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int nrhs, float* a,\n                                lapack_int lda, float* af, lapack_int ldaf,\n                                lapack_int* ipiv, char* equed, float* r,\n                                float* c, float* b, lapack_int ldb, float* x,\n                                lapack_int ldx, float* rcond, float* ferr,\n                                float* berr, float* work, lapack_int* iwork );\nlapack_int LAPACKE_dgesvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int nrhs, double* a,\n                                lapack_int lda, double* af, lapack_int ldaf,\n                                lapack_int* ipiv, char* equed, double* r,\n                                double* c, double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* rcond, double* ferr,\n                                double* berr, double* work, lapack_int* iwork );\nlapack_int LAPACKE_cgesvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int nrhs,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* af, lapack_int ldaf,\n                                lapack_int* ipiv, char* equed, float* r,\n                                float* c, lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* x,\n                                lapack_int ldx, float* rcond, float* ferr,\n                                float* berr, lapack_complex_float* work,\n                                float* rwork );\nlapack_int LAPACKE_zgesvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int nrhs,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* af, lapack_int ldaf,\n                                lapack_int* ipiv, char* equed, double* r,\n                                double* c, lapack_complex_double* b,\n                                lapack_int ldb, lapack_complex_double* x,\n                                lapack_int ldx, double* rcond, double* ferr,\n                                double* berr, lapack_complex_double* work,\n                                double* rwork );\n\nlapack_int LAPACKE_sgetf2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_dgetf2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_cgetf2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* ipiv );\nlapack_int LAPACKE_zgetf2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ipiv );\n\nlapack_int LAPACKE_sgetrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_dgetrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_cgetrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* ipiv );\nlapack_int LAPACKE_zgetrf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ipiv );\n\nlapack_int LAPACKE_sgetrf2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_dgetrf2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_cgetrf2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* ipiv );\nlapack_int LAPACKE_zgetrf2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ipiv );\n\nlapack_int LAPACKE_sgetri_work( int matrix_layout, lapack_int n, float* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dgetri_work( int matrix_layout, lapack_int n, double* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgetri_work( int matrix_layout, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                const lapack_int* ipiv,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgetri_work( int matrix_layout, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                const lapack_int* ipiv,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgetrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const float* a, lapack_int lda,\n                                const lapack_int* ipiv, float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_dgetrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const double* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                double* b, lapack_int ldb );\nlapack_int LAPACKE_cgetrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zgetrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sggbak_work( int matrix_layout, char job, char side,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                const float* lscale, const float* rscale,\n                                lapack_int m, float* v, lapack_int ldv );\nlapack_int LAPACKE_dggbak_work( int matrix_layout, char job, char side,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                const double* lscale, const double* rscale,\n                                lapack_int m, double* v, lapack_int ldv );\nlapack_int LAPACKE_cggbak_work( int matrix_layout, char job, char side,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                const float* lscale, const float* rscale,\n                                lapack_int m, lapack_complex_float* v,\n                                lapack_int ldv );\nlapack_int LAPACKE_zggbak_work( int matrix_layout, char job, char side,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                const double* lscale, const double* rscale,\n                                lapack_int m, lapack_complex_double* v,\n                                lapack_int ldv );\n\nlapack_int LAPACKE_sggbal_work( int matrix_layout, char job, lapack_int n,\n                                float* a, lapack_int lda, float* b,\n                                lapack_int ldb, lapack_int* ilo,\n                                lapack_int* ihi, float* lscale, float* rscale,\n                                float* work );\nlapack_int LAPACKE_dggbal_work( int matrix_layout, char job, lapack_int n,\n                                double* a, lapack_int lda, double* b,\n                                lapack_int ldb, lapack_int* ilo,\n                                lapack_int* ihi, double* lscale, double* rscale,\n                                double* work );\nlapack_int LAPACKE_cggbal_work( int matrix_layout, char job, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_int* ilo, lapack_int* ihi, float* lscale,\n                                float* rscale, float* work );\nlapack_int LAPACKE_zggbal_work( int matrix_layout, char job, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_int* ilo, lapack_int* ihi,\n                                double* lscale, double* rscale, double* work );\n\nlapack_int LAPACKE_sgges_work( int matrix_layout, char jobvsl, char jobvsr,\n                               char sort, LAPACK_S_SELECT3 selctg, lapack_int n,\n                               float* a, lapack_int lda, float* b,\n                               lapack_int ldb, lapack_int* sdim, float* alphar,\n                               float* alphai, float* beta, float* vsl,\n                               lapack_int ldvsl, float* vsr, lapack_int ldvsr,\n                               float* work, lapack_int lwork,\n                               lapack_logical* bwork );\nlapack_int LAPACKE_dgges_work( int matrix_layout, char jobvsl, char jobvsr,\n                               char sort, LAPACK_D_SELECT3 selctg, lapack_int n,\n                               double* a, lapack_int lda, double* b,\n                               lapack_int ldb, lapack_int* sdim, double* alphar,\n                               double* alphai, double* beta, double* vsl,\n                               lapack_int ldvsl, double* vsr, lapack_int ldvsr,\n                               double* work, lapack_int lwork,\n                               lapack_logical* bwork );\nlapack_int LAPACKE_cgges_work( int matrix_layout, char jobvsl, char jobvsr,\n                               char sort, LAPACK_C_SELECT2 selctg, lapack_int n,\n                               lapack_complex_float* a, lapack_int lda,\n                               lapack_complex_float* b, lapack_int ldb,\n                               lapack_int* sdim, lapack_complex_float* alpha,\n                               lapack_complex_float* beta,\n                               lapack_complex_float* vsl, lapack_int ldvsl,\n                               lapack_complex_float* vsr, lapack_int ldvsr,\n                               lapack_complex_float* work, lapack_int lwork,\n                               float* rwork, lapack_logical* bwork );\nlapack_int LAPACKE_zgges_work( int matrix_layout, char jobvsl, char jobvsr,\n                               char sort, LAPACK_Z_SELECT2 selctg, lapack_int n,\n                               lapack_complex_double* a, lapack_int lda,\n                               lapack_complex_double* b, lapack_int ldb,\n                               lapack_int* sdim, lapack_complex_double* alpha,\n                               lapack_complex_double* beta,\n                               lapack_complex_double* vsl, lapack_int ldvsl,\n                               lapack_complex_double* vsr, lapack_int ldvsr,\n                               lapack_complex_double* work, lapack_int lwork,\n                               double* rwork, lapack_logical* bwork );\n\nlapack_int LAPACKE_sgges3_work( int matrix_layout, char jobvsl, char jobvsr,\n                                char sort, LAPACK_S_SELECT3 selctg,\n                                lapack_int n,\n                                float* a, lapack_int lda,\n                                float* b, lapack_int ldb, lapack_int* sdim,\n                                float* alphar, float* alphai, float* beta,\n                                float* vsl, lapack_int ldvsl,\n                                float* vsr, lapack_int ldvsr,\n                                float* work, lapack_int lwork,\n                                lapack_logical* bwork );\nlapack_int LAPACKE_dgges3_work( int matrix_layout, char jobvsl, char jobvsr,\n                                char sort, LAPACK_D_SELECT3 selctg,\n                                lapack_int n,\n                                double* a, lapack_int lda,\n                                double* b, lapack_int ldb, lapack_int* sdim,\n                                double* alphar, double* alphai, double* beta,\n                                double* vsl, lapack_int ldvsl,\n                                double* vsr, lapack_int ldvsr,\n                                double* work, lapack_int lwork,\n                                lapack_logical* bwork );\nlapack_int LAPACKE_cgges3_work( int matrix_layout, char jobvsl, char jobvsr,\n                                char sort, LAPACK_C_SELECT2 selctg,\n                                lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_int* sdim, lapack_complex_float* alpha,\n                                lapack_complex_float* beta,\n                                lapack_complex_float* vsl, lapack_int ldvsl,\n                                lapack_complex_float* vsr, lapack_int ldvsr,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_logical* bwork );\nlapack_int LAPACKE_zgges3_work( int matrix_layout, char jobvsl, char jobvsr,\n                                char sort, LAPACK_Z_SELECT2 selctg,\n                                lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_int* sdim, lapack_complex_double* alpha,\n                                lapack_complex_double* beta,\n                                lapack_complex_double* vsl, lapack_int ldvsl,\n                                lapack_complex_double* vsr, lapack_int ldvsr,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_logical* bwork );\n\nlapack_int LAPACKE_sggesx_work( int matrix_layout, char jobvsl, char jobvsr,\n                                char sort, LAPACK_S_SELECT3 selctg, char sense,\n                                lapack_int n, float* a, lapack_int lda,\n                                float* b, lapack_int ldb, lapack_int* sdim,\n                                float* alphar, float* alphai, float* beta,\n                                float* vsl, lapack_int ldvsl, float* vsr,\n                                lapack_int ldvsr, float* rconde, float* rcondv,\n                                float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork,\n                                lapack_logical* bwork );\nlapack_int LAPACKE_dggesx_work( int matrix_layout, char jobvsl, char jobvsr,\n                                char sort, LAPACK_D_SELECT3 selctg, char sense,\n                                lapack_int n, double* a, lapack_int lda,\n                                double* b, lapack_int ldb, lapack_int* sdim,\n                                double* alphar, double* alphai, double* beta,\n                                double* vsl, lapack_int ldvsl, double* vsr,\n                                lapack_int ldvsr, double* rconde,\n                                double* rcondv, double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork,\n                                lapack_logical* bwork );\nlapack_int LAPACKE_cggesx_work( int matrix_layout, char jobvsl, char jobvsr,\n                                char sort, LAPACK_C_SELECT2 selctg, char sense,\n                                lapack_int n, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* b,\n                                lapack_int ldb, lapack_int* sdim,\n                                lapack_complex_float* alpha,\n                                lapack_complex_float* beta,\n                                lapack_complex_float* vsl, lapack_int ldvsl,\n                                lapack_complex_float* vsr, lapack_int ldvsr,\n                                float* rconde, float* rcondv,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_int* iwork,\n                                lapack_int liwork, lapack_logical* bwork );\nlapack_int LAPACKE_zggesx_work( int matrix_layout, char jobvsl, char jobvsr,\n                                char sort, LAPACK_Z_SELECT2 selctg, char sense,\n                                lapack_int n, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb, lapack_int* sdim,\n                                lapack_complex_double* alpha,\n                                lapack_complex_double* beta,\n                                lapack_complex_double* vsl, lapack_int ldvsl,\n                                lapack_complex_double* vsr, lapack_int ldvsr,\n                                double* rconde, double* rcondv,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_int* iwork,\n                                lapack_int liwork, lapack_logical* bwork );\n\nlapack_int LAPACKE_sggev_work( int matrix_layout, char jobvl, char jobvr,\n                               lapack_int n, float* a, lapack_int lda, float* b,\n                               lapack_int ldb, float* alphar, float* alphai,\n                               float* beta, float* vl, lapack_int ldvl,\n                               float* vr, lapack_int ldvr, float* work,\n                               lapack_int lwork );\nlapack_int LAPACKE_dggev_work( int matrix_layout, char jobvl, char jobvr,\n                               lapack_int n, double* a, lapack_int lda,\n                               double* b, lapack_int ldb, double* alphar,\n                               double* alphai, double* beta, double* vl,\n                               lapack_int ldvl, double* vr, lapack_int ldvr,\n                               double* work, lapack_int lwork );\nlapack_int LAPACKE_cggev_work( int matrix_layout, char jobvl, char jobvr,\n                               lapack_int n, lapack_complex_float* a,\n                               lapack_int lda, lapack_complex_float* b,\n                               lapack_int ldb, lapack_complex_float* alpha,\n                               lapack_complex_float* beta,\n                               lapack_complex_float* vl, lapack_int ldvl,\n                               lapack_complex_float* vr, lapack_int ldvr,\n                               lapack_complex_float* work, lapack_int lwork,\n                               float* rwork );\nlapack_int LAPACKE_zggev_work( int matrix_layout, char jobvl, char jobvr,\n                               lapack_int n, lapack_complex_double* a,\n                               lapack_int lda, lapack_complex_double* b,\n                               lapack_int ldb, lapack_complex_double* alpha,\n                               lapack_complex_double* beta,\n                               lapack_complex_double* vl, lapack_int ldvl,\n                               lapack_complex_double* vr, lapack_int ldvr,\n                               lapack_complex_double* work, lapack_int lwork,\n                               double* rwork );\n\nlapack_int LAPACKE_sggev3_work( int matrix_layout, char jobvl, char jobvr,\n                                lapack_int n,\n                                float* a, lapack_int lda,\n                                float* b, lapack_int ldb,\n                                float* alphar, float* alphai, float* beta,\n                                float* vl, lapack_int ldvl,\n                                float* vr, lapack_int ldvr,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dggev3_work( int matrix_layout, char jobvl, char jobvr,\n                                lapack_int n,\n                                double* a, lapack_int lda,\n                                double* b, lapack_int ldb,\n                                double* alphar, double* alphai, double* beta,\n                                double* vl, lapack_int ldvl,\n                                double* vr, lapack_int ldvr,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cggev3_work( int matrix_layout, char jobvl, char jobvr,\n                                lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* alpha,\n                                lapack_complex_float* beta,\n                                lapack_complex_float* vl, lapack_int ldvl,\n                                lapack_complex_float* vr, lapack_int ldvr,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork );\nlapack_int LAPACKE_zggev3_work( int matrix_layout, char jobvl, char jobvr,\n                                lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* alpha,\n                                lapack_complex_double* beta,\n                                lapack_complex_double* vl, lapack_int ldvl,\n                                lapack_complex_double* vr, lapack_int ldvr,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork );\n\nlapack_int LAPACKE_sggevx_work( int matrix_layout, char balanc, char jobvl,\n                                char jobvr, char sense, lapack_int n, float* a,\n                                lapack_int lda, float* b, lapack_int ldb,\n                                float* alphar, float* alphai, float* beta,\n                                float* vl, lapack_int ldvl, float* vr,\n                                lapack_int ldvr, lapack_int* ilo,\n                                lapack_int* ihi, float* lscale, float* rscale,\n                                float* abnrm, float* bbnrm, float* rconde,\n                                float* rcondv, float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_logical* bwork );\nlapack_int LAPACKE_dggevx_work( int matrix_layout, char balanc, char jobvl,\n                                char jobvr, char sense, lapack_int n, double* a,\n                                lapack_int lda, double* b, lapack_int ldb,\n                                double* alphar, double* alphai, double* beta,\n                                double* vl, lapack_int ldvl, double* vr,\n                                lapack_int ldvr, lapack_int* ilo,\n                                lapack_int* ihi, double* lscale, double* rscale,\n                                double* abnrm, double* bbnrm, double* rconde,\n                                double* rcondv, double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_logical* bwork );\nlapack_int LAPACKE_cggevx_work( int matrix_layout, char balanc, char jobvl,\n                                char jobvr, char sense, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* alpha,\n                                lapack_complex_float* beta,\n                                lapack_complex_float* vl, lapack_int ldvl,\n                                lapack_complex_float* vr, lapack_int ldvr,\n                                lapack_int* ilo, lapack_int* ihi, float* lscale,\n                                float* rscale, float* abnrm, float* bbnrm,\n                                float* rconde, float* rcondv,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_int* iwork,\n                                lapack_logical* bwork );\nlapack_int LAPACKE_zggevx_work( int matrix_layout, char balanc, char jobvl,\n                                char jobvr, char sense, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* alpha,\n                                lapack_complex_double* beta,\n                                lapack_complex_double* vl, lapack_int ldvl,\n                                lapack_complex_double* vr, lapack_int ldvr,\n                                lapack_int* ilo, lapack_int* ihi,\n                                double* lscale, double* rscale, double* abnrm,\n                                double* bbnrm, double* rconde, double* rcondv,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_int* iwork,\n                                lapack_logical* bwork );\n\nlapack_int LAPACKE_sggglm_work( int matrix_layout, lapack_int n, lapack_int m,\n                                lapack_int p, float* a, lapack_int lda,\n                                float* b, lapack_int ldb, float* d, float* x,\n                                float* y, float* work, lapack_int lwork );\nlapack_int LAPACKE_dggglm_work( int matrix_layout, lapack_int n, lapack_int m,\n                                lapack_int p, double* a, lapack_int lda,\n                                double* b, lapack_int ldb, double* d, double* x,\n                                double* y, double* work, lapack_int lwork );\nlapack_int LAPACKE_cggglm_work( int matrix_layout, lapack_int n, lapack_int m,\n                                lapack_int p, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* d,\n                                lapack_complex_float* x,\n                                lapack_complex_float* y,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zggglm_work( int matrix_layout, lapack_int n, lapack_int m,\n                                lapack_int p, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb, lapack_complex_double* d,\n                                lapack_complex_double* x,\n                                lapack_complex_double* y,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgghrd_work( int matrix_layout, char compq, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                float* a, lapack_int lda, float* b,\n                                lapack_int ldb, float* q, lapack_int ldq,\n                                float* z, lapack_int ldz );\nlapack_int LAPACKE_dgghrd_work( int matrix_layout, char compq, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                double* a, lapack_int lda, double* b,\n                                lapack_int ldb, double* q, lapack_int ldq,\n                                double* z, lapack_int ldz );\nlapack_int LAPACKE_cgghrd_work( int matrix_layout, char compq, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_complex_float* z, lapack_int ldz );\nlapack_int LAPACKE_zgghrd_work( int matrix_layout, char compq, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_complex_double* z, lapack_int ldz );\n\nlapack_int LAPACKE_sgghd3_work( int matrix_layout, char compq, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                float* a, lapack_int lda,\n                                float* b, lapack_int ldb,\n                                float* q, lapack_int ldq,\n                                float* z, lapack_int ldz,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dgghd3_work( int matrix_layout, char compq, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                double* a, lapack_int lda,\n                                double* b, lapack_int ldb,\n                                double* q, lapack_int ldq,\n                                double* z, lapack_int ldz,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgghd3_work( int matrix_layout, char compq, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgghd3_work( int matrix_layout, char compq, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_complex_double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_sgglse_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int p, float* a, lapack_int lda,\n                                float* b, lapack_int ldb, float* c, float* d,\n                                float* x, float* work, lapack_int lwork );\nlapack_int LAPACKE_dgglse_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int p, double* a, lapack_int lda,\n                                double* b, lapack_int ldb, double* c, double* d,\n                                double* x, double* work, lapack_int lwork );\nlapack_int LAPACKE_cgglse_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int p, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* c,\n                                lapack_complex_float* d,\n                                lapack_complex_float* x,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgglse_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int p, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb, lapack_complex_double* c,\n                                lapack_complex_double* d,\n                                lapack_complex_double* x,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sggqrf_work( int matrix_layout, lapack_int n, lapack_int m,\n                                lapack_int p, float* a, lapack_int lda,\n                                float* taua, float* b, lapack_int ldb,\n                                float* taub, float* work, lapack_int lwork );\nlapack_int LAPACKE_dggqrf_work( int matrix_layout, lapack_int n, lapack_int m,\n                                lapack_int p, double* a, lapack_int lda,\n                                double* taua, double* b, lapack_int ldb,\n                                double* taub, double* work, lapack_int lwork );\nlapack_int LAPACKE_cggqrf_work( int matrix_layout, lapack_int n, lapack_int m,\n                                lapack_int p, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* taua,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* taub,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zggqrf_work( int matrix_layout, lapack_int n, lapack_int m,\n                                lapack_int p, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* taua,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* taub,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sggrqf_work( int matrix_layout, lapack_int m, lapack_int p,\n                                lapack_int n, float* a, lapack_int lda,\n                                float* taua, float* b, lapack_int ldb,\n                                float* taub, float* work, lapack_int lwork );\nlapack_int LAPACKE_dggrqf_work( int matrix_layout, lapack_int m, lapack_int p,\n                                lapack_int n, double* a, lapack_int lda,\n                                double* taua, double* b, lapack_int ldb,\n                                double* taub, double* work, lapack_int lwork );\nlapack_int LAPACKE_cggrqf_work( int matrix_layout, lapack_int m, lapack_int p,\n                                lapack_int n, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* taua,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* taub,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zggrqf_work( int matrix_layout, lapack_int m, lapack_int p,\n                                lapack_int n, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* taua,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* taub,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sggsvd_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int n,\n                                lapack_int p, lapack_int* k, lapack_int* l,\n                                float* a, lapack_int lda, float* b,\n                                lapack_int ldb, float* alpha, float* beta,\n                                float* u, lapack_int ldu, float* v,\n                                lapack_int ldv, float* q, lapack_int ldq,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dggsvd_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int n,\n                                lapack_int p, lapack_int* k, lapack_int* l,\n                                double* a, lapack_int lda, double* b,\n                                lapack_int ldb, double* alpha, double* beta,\n                                double* u, lapack_int ldu, double* v,\n                                lapack_int ldv, double* q, lapack_int ldq,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cggsvd_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int n,\n                                lapack_int p, lapack_int* k, lapack_int* l,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                float* alpha, float* beta,\n                                lapack_complex_float* u, lapack_int ldu,\n                                lapack_complex_float* v, lapack_int ldv,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_complex_float* work, float* rwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_zggsvd_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int n,\n                                lapack_int p, lapack_int* k, lapack_int* l,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                double* alpha, double* beta,\n                                lapack_complex_double* u, lapack_int ldu,\n                                lapack_complex_double* v, lapack_int ldv,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_complex_double* work, double* rwork,\n                                lapack_int* iwork );\n\nlapack_int LAPACKE_sggsvd3_work( int matrix_layout, char jobu, char jobv,\n                                 char jobq, lapack_int m, lapack_int n,\n                                 lapack_int p, lapack_int* k, lapack_int* l,\n                                 float* a, lapack_int lda, float* b,\n                                 lapack_int ldb, float* alpha, float* beta,\n                                 float* u, lapack_int ldu, float* v,\n                                 lapack_int ldv, float* q, lapack_int ldq,\n                                 float* work, lapack_int lwork,\n                                 lapack_int* iwork );\nlapack_int LAPACKE_dggsvd3_work( int matrix_layout, char jobu, char jobv,\n                                 char jobq, lapack_int m, lapack_int n,\n                                 lapack_int p, lapack_int* k, lapack_int* l,\n                                 double* a, lapack_int lda, double* b,\n                                 lapack_int ldb, double* alpha, double* beta,\n                                 double* u, lapack_int ldu, double* v,\n                                 lapack_int ldv, double* q, lapack_int ldq,\n                                 double* work, lapack_int lwork,\n                                 lapack_int* iwork );\nlapack_int LAPACKE_cggsvd3_work( int matrix_layout, char jobu, char jobv,\n                                 char jobq, lapack_int m, lapack_int n,\n                                 lapack_int p, lapack_int* k, lapack_int* l,\n                                 lapack_complex_float* a, lapack_int lda,\n                                 lapack_complex_float* b, lapack_int ldb,\n                                 float* alpha, float* beta,\n                                 lapack_complex_float* u, lapack_int ldu,\n                                 lapack_complex_float* v, lapack_int ldv,\n                                 lapack_complex_float* q, lapack_int ldq,\n                                 lapack_complex_float* work, lapack_int lwork,\n                                 float* rwork, lapack_int* iwork );\nlapack_int LAPACKE_zggsvd3_work( int matrix_layout, char jobu, char jobv,\n                                 char jobq, lapack_int m, lapack_int n,\n                                 lapack_int p, lapack_int* k, lapack_int* l,\n                                 lapack_complex_double* a, lapack_int lda,\n                                 lapack_complex_double* b, lapack_int ldb,\n                                 double* alpha, double* beta,\n                                 lapack_complex_double* u, lapack_int ldu,\n                                 lapack_complex_double* v, lapack_int ldv,\n                                 lapack_complex_double* q, lapack_int ldq,\n                                 lapack_complex_double* work, lapack_int lwork,\n                                 double* rwork, lapack_int* iwork );\n\nlapack_int LAPACKE_sggsvp_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int p,\n                                lapack_int n, float* a, lapack_int lda,\n                                float* b, lapack_int ldb, float tola,\n                                float tolb, lapack_int* k, lapack_int* l,\n                                float* u, lapack_int ldu, float* v,\n                                lapack_int ldv, float* q, lapack_int ldq,\n                                lapack_int* iwork, float* tau, float* work );\nlapack_int LAPACKE_dggsvp_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int p,\n                                lapack_int n, double* a, lapack_int lda,\n                                double* b, lapack_int ldb, double tola,\n                                double tolb, lapack_int* k, lapack_int* l,\n                                double* u, lapack_int ldu, double* v,\n                                lapack_int ldv, double* q, lapack_int ldq,\n                                lapack_int* iwork, double* tau, double* work );\nlapack_int LAPACKE_cggsvp_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int p,\n                                lapack_int n, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* b,\n                                lapack_int ldb, float tola, float tolb,\n                                lapack_int* k, lapack_int* l,\n                                lapack_complex_float* u, lapack_int ldu,\n                                lapack_complex_float* v, lapack_int ldv,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_int* iwork, float* rwork,\n                                lapack_complex_float* tau,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zggsvp_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int p,\n                                lapack_int n, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb, double tola, double tolb,\n                                lapack_int* k, lapack_int* l,\n                                lapack_complex_double* u, lapack_int ldu,\n                                lapack_complex_double* v, lapack_int ldv,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_int* iwork, double* rwork,\n                                lapack_complex_double* tau,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_sggsvp3_work( int matrix_layout, char jobu, char jobv,\n                                 char jobq, lapack_int m, lapack_int p,\n                                 lapack_int n, float* a, lapack_int lda,\n                                 float* b, lapack_int ldb, float tola,\n                                 float tolb, lapack_int* k, lapack_int* l,\n                                 float* u, lapack_int ldu, float* v,\n                                 lapack_int ldv, float* q, lapack_int ldq,\n                                 lapack_int* iwork, float* tau,\n                                 float* work, lapack_int lwork );\nlapack_int LAPACKE_dggsvp3_work( int matrix_layout, char jobu, char jobv,\n                                 char jobq, lapack_int m, lapack_int p,\n                                 lapack_int n, double* a, lapack_int lda,\n                                 double* b, lapack_int ldb, double tola,\n                                 double tolb, lapack_int* k, lapack_int* l,\n                                 double* u, lapack_int ldu, double* v,\n                                 lapack_int ldv, double* q, lapack_int ldq,\n                                 lapack_int* iwork, double* tau, double* work,\n                                 lapack_int lwork );\nlapack_int LAPACKE_cggsvp3_work( int matrix_layout, char jobu, char jobv,\n                                 char jobq, lapack_int m, lapack_int p,\n                                 lapack_int n, lapack_complex_float* a,\n                                 lapack_int lda, lapack_complex_float* b,\n                                 lapack_int ldb, float tola, float tolb,\n                                 lapack_int* k, lapack_int* l,\n                                 lapack_complex_float* u, lapack_int ldu,\n                                 lapack_complex_float* v, lapack_int ldv,\n                                 lapack_complex_float* q, lapack_int ldq,\n                                 lapack_int* iwork, float* rwork,\n                                 lapack_complex_float* tau,\n                                 lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zggsvp3_work( int matrix_layout, char jobu, char jobv,\n                                 char jobq, lapack_int m, lapack_int p,\n                                 lapack_int n, lapack_complex_double* a,\n                                 lapack_int lda, lapack_complex_double* b,\n                                 lapack_int ldb, double tola, double tolb,\n                                 lapack_int* k, lapack_int* l,\n                                 lapack_complex_double* u, lapack_int ldu,\n                                 lapack_complex_double* v, lapack_int ldv,\n                                 lapack_complex_double* q, lapack_int ldq,\n                                 lapack_int* iwork, double* rwork,\n                                 lapack_complex_double* tau,\n                                 lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgtcon_work( char norm, lapack_int n, const float* dl,\n                                const float* d, const float* du,\n                                const float* du2, const lapack_int* ipiv,\n                                float anorm, float* rcond, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dgtcon_work( char norm, lapack_int n, const double* dl,\n                                const double* d, const double* du,\n                                const double* du2, const lapack_int* ipiv,\n                                double anorm, double* rcond, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cgtcon_work( char norm, lapack_int n,\n                                const lapack_complex_float* dl,\n                                const lapack_complex_float* d,\n                                const lapack_complex_float* du,\n                                const lapack_complex_float* du2,\n                                const lapack_int* ipiv, float anorm,\n                                float* rcond, lapack_complex_float* work );\nlapack_int LAPACKE_zgtcon_work( char norm, lapack_int n,\n                                const lapack_complex_double* dl,\n                                const lapack_complex_double* d,\n                                const lapack_complex_double* du,\n                                const lapack_complex_double* du2,\n                                const lapack_int* ipiv, double anorm,\n                                double* rcond, lapack_complex_double* work );\n\nlapack_int LAPACKE_sgtrfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const float* dl,\n                                const float* d, const float* du,\n                                const float* dlf, const float* df,\n                                const float* duf, const float* du2,\n                                const lapack_int* ipiv, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* ferr, float* berr, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dgtrfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const double* dl,\n                                const double* d, const double* du,\n                                const double* dlf, const double* df,\n                                const double* duf, const double* du2,\n                                const lapack_int* ipiv, const double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* ferr, double* berr, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cgtrfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* dl,\n                                const lapack_complex_float* d,\n                                const lapack_complex_float* du,\n                                const lapack_complex_float* dlf,\n                                const lapack_complex_float* df,\n                                const lapack_complex_float* duf,\n                                const lapack_complex_float* du2,\n                                const lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zgtrfs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs,\n                                const lapack_complex_double* dl,\n                                const lapack_complex_double* d,\n                                const lapack_complex_double* du,\n                                const lapack_complex_double* dlf,\n                                const lapack_complex_double* df,\n                                const lapack_complex_double* duf,\n                                const lapack_complex_double* du2,\n                                const lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sgtsv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               float* dl, float* d, float* du, float* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_dgtsv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               double* dl, double* d, double* du, double* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_cgtsv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               lapack_complex_float* dl,\n                               lapack_complex_float* d,\n                               lapack_complex_float* du,\n                               lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zgtsv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               lapack_complex_double* dl,\n                               lapack_complex_double* d,\n                               lapack_complex_double* du,\n                               lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sgtsvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int nrhs, const float* dl,\n                                const float* d, const float* du, float* dlf,\n                                float* df, float* duf, float* du2,\n                                lapack_int* ipiv, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dgtsvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int nrhs, const double* dl,\n                                const double* d, const double* du, double* dlf,\n                                double* df, double* duf, double* du2,\n                                lapack_int* ipiv, const double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cgtsvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* dl,\n                                const lapack_complex_float* d,\n                                const lapack_complex_float* du,\n                                lapack_complex_float* dlf,\n                                lapack_complex_float* df,\n                                lapack_complex_float* duf,\n                                lapack_complex_float* du2, lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zgtsvx_work( int matrix_layout, char fact, char trans,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* dl,\n                                const lapack_complex_double* d,\n                                const lapack_complex_double* du,\n                                lapack_complex_double* dlf,\n                                lapack_complex_double* df,\n                                lapack_complex_double* duf,\n                                lapack_complex_double* du2, lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sgttrf_work( lapack_int n, float* dl, float* d, float* du,\n                                float* du2, lapack_int* ipiv );\nlapack_int LAPACKE_dgttrf_work( lapack_int n, double* dl, double* d, double* du,\n                                double* du2, lapack_int* ipiv );\nlapack_int LAPACKE_cgttrf_work( lapack_int n, lapack_complex_float* dl,\n                                lapack_complex_float* d,\n                                lapack_complex_float* du,\n                                lapack_complex_float* du2, lapack_int* ipiv );\nlapack_int LAPACKE_zgttrf_work( lapack_int n, lapack_complex_double* dl,\n                                lapack_complex_double* d,\n                                lapack_complex_double* du,\n                                lapack_complex_double* du2, lapack_int* ipiv );\n\nlapack_int LAPACKE_sgttrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const float* dl,\n                                const float* d, const float* du,\n                                const float* du2, const lapack_int* ipiv,\n                                float* b, lapack_int ldb );\nlapack_int LAPACKE_dgttrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const double* dl,\n                                const double* d, const double* du,\n                                const double* du2, const lapack_int* ipiv,\n                                double* b, lapack_int ldb );\nlapack_int LAPACKE_cgttrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* dl,\n                                const lapack_complex_float* d,\n                                const lapack_complex_float* du,\n                                const lapack_complex_float* du2,\n                                const lapack_int* ipiv, lapack_complex_float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_zgttrs_work( int matrix_layout, char trans, lapack_int n,\n                                lapack_int nrhs,\n                                const lapack_complex_double* dl,\n                                const lapack_complex_double* d,\n                                const lapack_complex_double* du,\n                                const lapack_complex_double* du2,\n                                const lapack_int* ipiv,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_chbev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_int kd,\n                               lapack_complex_float* ab, lapack_int ldab,\n                               float* w, lapack_complex_float* z,\n                               lapack_int ldz, lapack_complex_float* work,\n                               float* rwork );\nlapack_int LAPACKE_zhbev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_int kd,\n                               lapack_complex_double* ab, lapack_int ldab,\n                               double* w, lapack_complex_double* z,\n                               lapack_int ldz, lapack_complex_double* work,\n                               double* rwork );\n\nlapack_int LAPACKE_chbevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_int kd,\n                                lapack_complex_float* ab, lapack_int ldab,\n                                float* w, lapack_complex_float* z,\n                                lapack_int ldz, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_zhbevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_int kd,\n                                lapack_complex_double* ab, lapack_int ldab,\n                                double* w, lapack_complex_double* z,\n                                lapack_int ldz, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\n\nlapack_int LAPACKE_chbevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, lapack_int kd,\n                                lapack_complex_float* ab, lapack_int ldab,\n                                lapack_complex_float* q, lapack_int ldq,\n                                float vl, float vu, lapack_int il,\n                                lapack_int iu, float abstol, lapack_int* m,\n                                float* w, lapack_complex_float* z,\n                                lapack_int ldz, lapack_complex_float* work,\n                                float* rwork, lapack_int* iwork,\n                                lapack_int* ifail );\nlapack_int LAPACKE_zhbevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, lapack_int kd,\n                                lapack_complex_double* ab, lapack_int ldab,\n                                lapack_complex_double* q, lapack_int ldq,\n                                double vl, double vu, lapack_int il,\n                                lapack_int iu, double abstol, lapack_int* m,\n                                double* w, lapack_complex_double* z,\n                                lapack_int ldz, lapack_complex_double* work,\n                                double* rwork, lapack_int* iwork,\n                                lapack_int* ifail );\n\nlapack_int LAPACKE_chbgst_work( int matrix_layout, char vect, char uplo,\n                                lapack_int n, lapack_int ka, lapack_int kb,\n                                lapack_complex_float* ab, lapack_int ldab,\n                                const lapack_complex_float* bb, lapack_int ldbb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zhbgst_work( int matrix_layout, char vect, char uplo,\n                                lapack_int n, lapack_int ka, lapack_int kb,\n                                lapack_complex_double* ab, lapack_int ldab,\n                                const lapack_complex_double* bb,\n                                lapack_int ldbb, lapack_complex_double* x,\n                                lapack_int ldx, lapack_complex_double* work,\n                                double* rwork );\n\nlapack_int LAPACKE_chbgv_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_int ka, lapack_int kb,\n                               lapack_complex_float* ab, lapack_int ldab,\n                               lapack_complex_float* bb, lapack_int ldbb,\n                               float* w, lapack_complex_float* z,\n                               lapack_int ldz, lapack_complex_float* work,\n                               float* rwork );\nlapack_int LAPACKE_zhbgv_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_int ka, lapack_int kb,\n                               lapack_complex_double* ab, lapack_int ldab,\n                               lapack_complex_double* bb, lapack_int ldbb,\n                               double* w, lapack_complex_double* z,\n                               lapack_int ldz, lapack_complex_double* work,\n                               double* rwork );\n\nlapack_int LAPACKE_chbgvd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_int ka, lapack_int kb,\n                                lapack_complex_float* ab, lapack_int ldab,\n                                lapack_complex_float* bb, lapack_int ldbb,\n                                float* w, lapack_complex_float* z,\n                                lapack_int ldz, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_zhbgvd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_int ka, lapack_int kb,\n                                lapack_complex_double* ab, lapack_int ldab,\n                                lapack_complex_double* bb, lapack_int ldbb,\n                                double* w, lapack_complex_double* z,\n                                lapack_int ldz, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\n\nlapack_int LAPACKE_chbgvx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, lapack_int ka,\n                                lapack_int kb, lapack_complex_float* ab,\n                                lapack_int ldab, lapack_complex_float* bb,\n                                lapack_int ldbb, lapack_complex_float* q,\n                                lapack_int ldq, float vl, float vu,\n                                lapack_int il, lapack_int iu, float abstol,\n                                lapack_int* m, float* w,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_complex_float* work, float* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\nlapack_int LAPACKE_zhbgvx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, lapack_int ka,\n                                lapack_int kb, lapack_complex_double* ab,\n                                lapack_int ldab, lapack_complex_double* bb,\n                                lapack_int ldbb, lapack_complex_double* q,\n                                lapack_int ldq, double vl, double vu,\n                                lapack_int il, lapack_int iu, double abstol,\n                                lapack_int* m, double* w,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_complex_double* work, double* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_chbtrd_work( int matrix_layout, char vect, char uplo,\n                                lapack_int n, lapack_int kd,\n                                lapack_complex_float* ab, lapack_int ldab,\n                                float* d, float* e, lapack_complex_float* q,\n                                lapack_int ldq, lapack_complex_float* work );\nlapack_int LAPACKE_zhbtrd_work( int matrix_layout, char vect, char uplo,\n                                lapack_int n, lapack_int kd,\n                                lapack_complex_double* ab, lapack_int ldab,\n                                double* d, double* e, lapack_complex_double* q,\n                                lapack_int ldq, lapack_complex_double* work );\n\nlapack_int LAPACKE_checon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_int* ipiv, float anorm,\n                                float* rcond, lapack_complex_float* work );\nlapack_int LAPACKE_zhecon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_int* ipiv, double anorm,\n                                double* rcond, lapack_complex_double* work );\n\nlapack_int LAPACKE_cheequb_work( int matrix_layout, char uplo, lapack_int n,\n                                 const lapack_complex_float* a, lapack_int lda,\n                                 float* s, float* scond, float* amax,\n                                 lapack_complex_float* work );\nlapack_int LAPACKE_zheequb_work( int matrix_layout, char uplo, lapack_int n,\n                                 const lapack_complex_double* a, lapack_int lda,\n                                 double* s, double* scond, double* amax,\n                                 lapack_complex_double* work );\n\nlapack_int LAPACKE_cheev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_complex_float* a,\n                               lapack_int lda, float* w,\n                               lapack_complex_float* work, lapack_int lwork,\n                               float* rwork );\nlapack_int LAPACKE_zheev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_complex_double* a,\n                               lapack_int lda, double* w,\n                               lapack_complex_double* work, lapack_int lwork,\n                               double* rwork );\n\nlapack_int LAPACKE_cheevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_complex_float* a,\n                                lapack_int lda, float* w,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_int lrwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_zheevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_complex_double* a,\n                                lapack_int lda, double* w,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_int lrwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_cheevr_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                float vl, float vu, lapack_int il,\n                                lapack_int iu, float abstol, lapack_int* m,\n                                float* w, lapack_complex_float* z,\n                                lapack_int ldz, lapack_int* isuppz,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_int lrwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_zheevr_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                double vl, double vu, lapack_int il,\n                                lapack_int iu, double abstol, lapack_int* m,\n                                double* w, lapack_complex_double* z,\n                                lapack_int ldz, lapack_int* isuppz,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_int lrwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_cheevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                float vl, float vu, lapack_int il,\n                                lapack_int iu, float abstol, lapack_int* m,\n                                float* w, lapack_complex_float* z,\n                                lapack_int ldz, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\nlapack_int LAPACKE_zheevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                double vl, double vu, lapack_int il,\n                                lapack_int iu, double abstol, lapack_int* m,\n                                double* w, lapack_complex_double* z,\n                                lapack_int ldz, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_chegst_work( int matrix_layout, lapack_int itype, char uplo,\n                                lapack_int n, lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_zhegst_work( int matrix_layout, lapack_int itype, char uplo,\n                                lapack_int n, lapack_complex_double* a,\n                                lapack_int lda, const lapack_complex_double* b,\n                                lapack_int ldb );\n\nlapack_int LAPACKE_chegv_work( int matrix_layout, lapack_int itype, char jobz,\n                               char uplo, lapack_int n, lapack_complex_float* a,\n                               lapack_int lda, lapack_complex_float* b,\n                               lapack_int ldb, float* w,\n                               lapack_complex_float* work, lapack_int lwork,\n                               float* rwork );\nlapack_int LAPACKE_zhegv_work( int matrix_layout, lapack_int itype, char jobz,\n                               char uplo, lapack_int n,\n                               lapack_complex_double* a, lapack_int lda,\n                               lapack_complex_double* b, lapack_int ldb,\n                               double* w, lapack_complex_double* work,\n                               lapack_int lwork, double* rwork );\n\nlapack_int LAPACKE_chegvd_work( int matrix_layout, lapack_int itype, char jobz,\n                                char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                float* w, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_zhegvd_work( int matrix_layout, lapack_int itype, char jobz,\n                                char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                double* w, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\n\nlapack_int LAPACKE_chegvx_work( int matrix_layout, lapack_int itype, char jobz,\n                                char range, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                float vl, float vu, lapack_int il,\n                                lapack_int iu, float abstol, lapack_int* m,\n                                float* w, lapack_complex_float* z,\n                                lapack_int ldz, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\nlapack_int LAPACKE_zhegvx_work( int matrix_layout, lapack_int itype, char jobz,\n                                char range, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                double vl, double vu, lapack_int il,\n                                lapack_int iu, double abstol, lapack_int* m,\n                                double* w, lapack_complex_double* z,\n                                lapack_int ldz, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_cherfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* af,\n                                lapack_int ldaf, const lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zherfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, const lapack_complex_double* af,\n                                lapack_int ldaf, const lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_chesv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_float* a,\n                               lapack_int lda, lapack_int* ipiv,\n                               lapack_complex_float* b, lapack_int ldb,\n                               lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zhesv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_double* a,\n                               lapack_int lda, lapack_int* ipiv,\n                               lapack_complex_double* b, lapack_int ldb,\n                               lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_chesvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* af, lapack_int ldaf,\n                                lapack_int* ipiv, const lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* x,\n                                lapack_int ldx, float* rcond, float* ferr,\n                                float* berr, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork );\nlapack_int LAPACKE_zhesvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* af, lapack_int ldaf,\n                                lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork );\n\nlapack_int LAPACKE_chetrd_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                float* d, float* e, lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zhetrd_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                double* d, double* e,\n                                lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_chetrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_zhetrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_chetri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                const lapack_int* ipiv,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zhetri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                const lapack_int* ipiv,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_chetrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zhetrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_chfrk_work( int matrix_layout, char transr, char uplo,\n                               char trans, lapack_int n, lapack_int k,\n                               float alpha, const lapack_complex_float* a,\n                               lapack_int lda, float beta,\n                               lapack_complex_float* c );\nlapack_int LAPACKE_zhfrk_work( int matrix_layout, char transr, char uplo,\n                               char trans, lapack_int n, lapack_int k,\n                               double alpha, const lapack_complex_double* a,\n                               lapack_int lda, double beta,\n                               lapack_complex_double* c );\n\nlapack_int LAPACKE_shgeqz_work( int matrix_layout, char job, char compq,\n                                char compz, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, float* h, lapack_int ldh,\n                                float* t, lapack_int ldt, float* alphar,\n                                float* alphai, float* beta, float* q,\n                                lapack_int ldq, float* z, lapack_int ldz,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dhgeqz_work( int matrix_layout, char job, char compq,\n                                char compz, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, double* h, lapack_int ldh,\n                                double* t, lapack_int ldt, double* alphar,\n                                double* alphai, double* beta, double* q,\n                                lapack_int ldq, double* z, lapack_int ldz,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_chgeqz_work( int matrix_layout, char job, char compq,\n                                char compz, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, lapack_complex_float* h,\n                                lapack_int ldh, lapack_complex_float* t,\n                                lapack_int ldt, lapack_complex_float* alpha,\n                                lapack_complex_float* beta,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork );\nlapack_int LAPACKE_zhgeqz_work( int matrix_layout, char job, char compq,\n                                char compz, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, lapack_complex_double* h,\n                                lapack_int ldh, lapack_complex_double* t,\n                                lapack_int ldt, lapack_complex_double* alpha,\n                                lapack_complex_double* beta,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork );\n\nlapack_int LAPACKE_chpcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* ap,\n                                const lapack_int* ipiv, float anorm,\n                                float* rcond, lapack_complex_float* work );\nlapack_int LAPACKE_zhpcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* ap,\n                                const lapack_int* ipiv, double anorm,\n                                double* rcond, lapack_complex_double* work );\n\nlapack_int LAPACKE_chpev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_complex_float* ap, float* w,\n                               lapack_complex_float* z, lapack_int ldz,\n                               lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zhpev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_complex_double* ap,\n                               double* w, lapack_complex_double* z,\n                               lapack_int ldz, lapack_complex_double* work,\n                               double* rwork );\n\nlapack_int LAPACKE_chpevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_complex_float* ap,\n                                float* w, lapack_complex_float* z,\n                                lapack_int ldz, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_zhpevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_complex_double* ap,\n                                double* w, lapack_complex_double* z,\n                                lapack_int ldz, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\n\nlapack_int LAPACKE_chpevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n,\n                                lapack_complex_float* ap, float vl, float vu,\n                                lapack_int il, lapack_int iu, float abstol,\n                                lapack_int* m, float* w,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_complex_float* work, float* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\nlapack_int LAPACKE_zhpevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n,\n                                lapack_complex_double* ap, double vl, double vu,\n                                lapack_int il, lapack_int iu, double abstol,\n                                lapack_int* m, double* w,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_complex_double* work, double* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_chpgst_work( int matrix_layout, lapack_int itype, char uplo,\n                                lapack_int n, lapack_complex_float* ap,\n                                const lapack_complex_float* bp );\nlapack_int LAPACKE_zhpgst_work( int matrix_layout, lapack_int itype, char uplo,\n                                lapack_int n, lapack_complex_double* ap,\n                                const lapack_complex_double* bp );\n\nlapack_int LAPACKE_chpgv_work( int matrix_layout, lapack_int itype, char jobz,\n                               char uplo, lapack_int n,\n                               lapack_complex_float* ap,\n                               lapack_complex_float* bp, float* w,\n                               lapack_complex_float* z, lapack_int ldz,\n                               lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zhpgv_work( int matrix_layout, lapack_int itype, char jobz,\n                               char uplo, lapack_int n,\n                               lapack_complex_double* ap,\n                               lapack_complex_double* bp, double* w,\n                               lapack_complex_double* z, lapack_int ldz,\n                               lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_chpgvd_work( int matrix_layout, lapack_int itype, char jobz,\n                                char uplo, lapack_int n,\n                                lapack_complex_float* ap,\n                                lapack_complex_float* bp, float* w,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_int lrwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_zhpgvd_work( int matrix_layout, lapack_int itype, char jobz,\n                                char uplo, lapack_int n,\n                                lapack_complex_double* ap,\n                                lapack_complex_double* bp, double* w,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_int lrwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_chpgvx_work( int matrix_layout, lapack_int itype, char jobz,\n                                char range, char uplo, lapack_int n,\n                                lapack_complex_float* ap,\n                                lapack_complex_float* bp, float vl, float vu,\n                                lapack_int il, lapack_int iu, float abstol,\n                                lapack_int* m, float* w,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_complex_float* work, float* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\nlapack_int LAPACKE_zhpgvx_work( int matrix_layout, lapack_int itype, char jobz,\n                                char range, char uplo, lapack_int n,\n                                lapack_complex_double* ap,\n                                lapack_complex_double* bp, double vl, double vu,\n                                lapack_int il, lapack_int iu, double abstol,\n                                lapack_int* m, double* w,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_complex_double* work, double* rwork,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_chprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* ap,\n                                const lapack_complex_float* afp,\n                                const lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zhprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                const lapack_complex_double* afp,\n                                const lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_chpsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_float* ap,\n                               lapack_int* ipiv, lapack_complex_float* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_zhpsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_double* ap,\n                               lapack_int* ipiv, lapack_complex_double* b,\n                               lapack_int ldb );\n\nlapack_int LAPACKE_chpsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* ap,\n                                lapack_complex_float* afp, lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zhpsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                lapack_complex_double* afp, lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_chptrd_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* ap, float* d, float* e,\n                                lapack_complex_float* tau );\nlapack_int LAPACKE_zhptrd_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* ap, double* d, double* e,\n                                lapack_complex_double* tau );\n\nlapack_int LAPACKE_chptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* ap, lapack_int* ipiv );\nlapack_int LAPACKE_zhptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* ap, lapack_int* ipiv );\n\nlapack_int LAPACKE_chptri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* ap,\n                                const lapack_int* ipiv,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zhptri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* ap,\n                                const lapack_int* ipiv,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_chptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* ap,\n                                const lapack_int* ipiv, lapack_complex_float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_zhptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                const lapack_int* ipiv,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_shsein_work( int matrix_layout, char job, char eigsrc,\n                                char initv, lapack_logical* select,\n                                lapack_int n, const float* h, lapack_int ldh,\n                                float* wr, const float* wi, float* vl,\n                                lapack_int ldvl, float* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m, float* work,\n                                lapack_int* ifaill, lapack_int* ifailr );\nlapack_int LAPACKE_dhsein_work( int matrix_layout, char job, char eigsrc,\n                                char initv, lapack_logical* select,\n                                lapack_int n, const double* h, lapack_int ldh,\n                                double* wr, const double* wi, double* vl,\n                                lapack_int ldvl, double* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m, double* work,\n                                lapack_int* ifaill, lapack_int* ifailr );\nlapack_int LAPACKE_chsein_work( int matrix_layout, char job, char eigsrc,\n                                char initv, const lapack_logical* select,\n                                lapack_int n, const lapack_complex_float* h,\n                                lapack_int ldh, lapack_complex_float* w,\n                                lapack_complex_float* vl, lapack_int ldvl,\n                                lapack_complex_float* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m,\n                                lapack_complex_float* work, float* rwork,\n                                lapack_int* ifaill, lapack_int* ifailr );\nlapack_int LAPACKE_zhsein_work( int matrix_layout, char job, char eigsrc,\n                                char initv, const lapack_logical* select,\n                                lapack_int n, const lapack_complex_double* h,\n                                lapack_int ldh, lapack_complex_double* w,\n                                lapack_complex_double* vl, lapack_int ldvl,\n                                lapack_complex_double* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m,\n                                lapack_complex_double* work, double* rwork,\n                                lapack_int* ifaill, lapack_int* ifailr );\n\nlapack_int LAPACKE_shseqr_work( int matrix_layout, char job, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                float* h, lapack_int ldh, float* wr, float* wi,\n                                float* z, lapack_int ldz, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dhseqr_work( int matrix_layout, char job, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                double* h, lapack_int ldh, double* wr,\n                                double* wi, double* z, lapack_int ldz,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_chseqr_work( int matrix_layout, char job, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                lapack_complex_float* h, lapack_int ldh,\n                                lapack_complex_float* w,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zhseqr_work( int matrix_layout, char job, char compz,\n                                lapack_int n, lapack_int ilo, lapack_int ihi,\n                                lapack_complex_double* h, lapack_int ldh,\n                                lapack_complex_double* w,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_clacgv_work( lapack_int n, lapack_complex_float* x,\n                                lapack_int incx );\nlapack_int LAPACKE_zlacgv_work( lapack_int n, lapack_complex_double* x,\n                                lapack_int incx );\n\nlapack_int LAPACKE_slacn2_work( lapack_int n, float* v, float* x,\n                                lapack_int* isgn, float* est, lapack_int* kase,\n                                lapack_int* isave );\nlapack_int LAPACKE_dlacn2_work( lapack_int n, double* v, double* x,\n                                lapack_int* isgn, double* est, lapack_int* kase,\n                                lapack_int* isave );\nlapack_int LAPACKE_clacn2_work( lapack_int n, lapack_complex_float* v,\n                                lapack_complex_float* x,\n                                float* est, lapack_int* kase,\n                                lapack_int* isave );\nlapack_int LAPACKE_zlacn2_work( lapack_int n, lapack_complex_double* v,\n                                lapack_complex_double* x,\n                                double* est, lapack_int* kase,\n                                lapack_int* isave );\n\nlapack_int LAPACKE_slacpy_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, const float* a, lapack_int lda,\n                                float* b, lapack_int ldb );\nlapack_int LAPACKE_dlacpy_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, const double* a, lapack_int lda,\n                                double* b, lapack_int ldb );\nlapack_int LAPACKE_clacpy_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, const lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_zlacpy_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, const lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb );\n\nlapack_int LAPACKE_clacp2_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, const float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zlacp2_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, const double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_zlag2c_work( int matrix_layout, lapack_int m, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_float* sa, lapack_int ldsa );\n\nlapack_int LAPACKE_slag2d_work( int matrix_layout, lapack_int m, lapack_int n,\n                                const float* sa, lapack_int ldsa, double* a,\n                                lapack_int lda );\n\nlapack_int LAPACKE_dlag2s_work( int matrix_layout, lapack_int m, lapack_int n,\n                                const double* a, lapack_int lda, float* sa,\n                                lapack_int ldsa );\n\nlapack_int LAPACKE_clag2z_work( int matrix_layout, lapack_int m, lapack_int n,\n                                const lapack_complex_float* sa, lapack_int ldsa,\n                                lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_slapmr_work( int matrix_layout, lapack_logical forwrd,\n                                lapack_int m, lapack_int n, float* x,\n                                lapack_int ldx, lapack_int* k );\nlapack_int LAPACKE_dlapmr_work( int matrix_layout, lapack_logical forwrd,\n                                lapack_int m, lapack_int n, double* x,\n                                lapack_int ldx, lapack_int* k );\nlapack_int LAPACKE_clapmr_work( int matrix_layout, lapack_logical forwrd,\n                                lapack_int m, lapack_int n,\n                                lapack_complex_float* x, lapack_int ldx,\n                                lapack_int* k );\nlapack_int LAPACKE_zlapmr_work( int matrix_layout, lapack_logical forwrd,\n                                lapack_int m, lapack_int n,\n                                lapack_complex_double* x, lapack_int ldx,\n                                lapack_int* k );\n\nlapack_int LAPACKE_slapmt_work( int matrix_layout, lapack_logical forwrd,\n                                lapack_int m, lapack_int n, float* x,\n                                lapack_int ldx, lapack_int* k );\nlapack_int LAPACKE_dlapmt_work( int matrix_layout, lapack_logical forwrd,\n                                lapack_int m, lapack_int n, double* x,\n                                lapack_int ldx, lapack_int* k );\nlapack_int LAPACKE_clapmt_work( int matrix_layout, lapack_logical forwrd,\n                                lapack_int m, lapack_int n,\n                                lapack_complex_float* x, lapack_int ldx,\n                                lapack_int* k );\nlapack_int LAPACKE_zlapmt_work( int matrix_layout, lapack_logical forwrd,\n                                lapack_int m, lapack_int n,\n                                lapack_complex_double* x, lapack_int ldx,\n                                lapack_int* k );\n\nlapack_int LAPACKE_slartgp_work( float f, float g, float* cs, float* sn,\n                                 float* r );\nlapack_int LAPACKE_dlartgp_work( double f, double g, double* cs, double* sn,\n                                 double* r );\n\nlapack_int LAPACKE_slartgs_work( float x, float y, float sigma, float* cs,\n                                 float* sn );\nlapack_int LAPACKE_dlartgs_work( double x, double y, double sigma, double* cs,\n                                 double* sn );\n\nfloat LAPACKE_slapy2_work( float x, float y );\ndouble LAPACKE_dlapy2_work( double x, double y );\n\nfloat LAPACKE_slapy3_work( float x, float y, float z );\ndouble LAPACKE_dlapy3_work( double x, double y, double z );\n\nfloat LAPACKE_slamch_work( char cmach );\ndouble LAPACKE_dlamch_work( char cmach );\n\nfloat LAPACKE_slange_work( int matrix_layout, char norm, lapack_int m,\n                                lapack_int n, const float* a, lapack_int lda,\n                                float* work );\ndouble LAPACKE_dlange_work( int matrix_layout, char norm, lapack_int m,\n                                lapack_int n, const double* a, lapack_int lda,\n                                double* work );\nfloat LAPACKE_clange_work( int matrix_layout, char norm, lapack_int m,\n                                lapack_int n, const lapack_complex_float* a,\n                                lapack_int lda, float* work );\ndouble LAPACKE_zlange_work( int matrix_layout, char norm, lapack_int m,\n                                lapack_int n, const lapack_complex_double* a,\n                                lapack_int lda, double* work );\n\nfloat LAPACKE_clanhe_work( int matrix_layout, char norm, char uplo,\n                                lapack_int n, const lapack_complex_float* a,\n                                lapack_int lda, float* work );\ndouble LAPACKE_zlanhe_work( int matrix_layout, char norm, char uplo,\n                                lapack_int n, const lapack_complex_double* a,\n                                lapack_int lda, double* work );\n\nfloat LAPACKE_slansy_work( int matrix_layout, char norm, char uplo,\n                                lapack_int n, const float* a, lapack_int lda,\n                                float* work );\ndouble LAPACKE_dlansy_work( int matrix_layout, char norm, char uplo,\n                                lapack_int n, const double* a, lapack_int lda,\n                                double* work );\nfloat LAPACKE_clansy_work( int matrix_layout, char norm, char uplo,\n                                lapack_int n, const lapack_complex_float* a,\n                                lapack_int lda, float* work );\ndouble LAPACKE_zlansy_work( int matrix_layout, char norm, char uplo,\n                                lapack_int n, const lapack_complex_double* a,\n                                lapack_int lda, double* work );\n\nfloat LAPACKE_slantr_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int m, lapack_int n, const float* a,\n                                lapack_int lda, float* work );\ndouble LAPACKE_dlantr_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int m, lapack_int n,\n                                const double* a, lapack_int lda, double* work );\nfloat LAPACKE_clantr_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int m, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                float* work );\ndouble LAPACKE_zlantr_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int m, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                double* work );\n\nlapack_int LAPACKE_slarfb_work( int matrix_layout, char side, char trans,\n                                char direct, char storev, lapack_int m,\n                                lapack_int n, lapack_int k, const float* v,\n                                lapack_int ldv, const float* t, lapack_int ldt,\n                                float* c, lapack_int ldc, float* work,\n                                lapack_int ldwork );\nlapack_int LAPACKE_dlarfb_work( int matrix_layout, char side, char trans,\n                                char direct, char storev, lapack_int m,\n                                lapack_int n, lapack_int k, const double* v,\n                                lapack_int ldv, const double* t, lapack_int ldt,\n                                double* c, lapack_int ldc, double* work,\n                                lapack_int ldwork );\nlapack_int LAPACKE_clarfb_work( int matrix_layout, char side, char trans,\n                                char direct, char storev, lapack_int m,\n                                lapack_int n, lapack_int k,\n                                const lapack_complex_float* v, lapack_int ldv,\n                                const lapack_complex_float* t, lapack_int ldt,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int ldwork );\nlapack_int LAPACKE_zlarfb_work( int matrix_layout, char side, char trans,\n                                char direct, char storev, lapack_int m,\n                                lapack_int n, lapack_int k,\n                                const lapack_complex_double* v, lapack_int ldv,\n                                const lapack_complex_double* t, lapack_int ldt,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work,\n                                lapack_int ldwork );\n\nlapack_int LAPACKE_slarfg_work( lapack_int n, float* alpha, float* x,\n                                lapack_int incx, float* tau );\nlapack_int LAPACKE_dlarfg_work( lapack_int n, double* alpha, double* x,\n                                lapack_int incx, double* tau );\nlapack_int LAPACKE_clarfg_work( lapack_int n, lapack_complex_float* alpha,\n                                lapack_complex_float* x, lapack_int incx,\n                                lapack_complex_float* tau );\nlapack_int LAPACKE_zlarfg_work( lapack_int n, lapack_complex_double* alpha,\n                                lapack_complex_double* x, lapack_int incx,\n                                lapack_complex_double* tau );\n\nlapack_int LAPACKE_slarft_work( int matrix_layout, char direct, char storev,\n                                lapack_int n, lapack_int k, const float* v,\n                                lapack_int ldv, const float* tau, float* t,\n                                lapack_int ldt );\nlapack_int LAPACKE_dlarft_work( int matrix_layout, char direct, char storev,\n                                lapack_int n, lapack_int k, const double* v,\n                                lapack_int ldv, const double* tau, double* t,\n                                lapack_int ldt );\nlapack_int LAPACKE_clarft_work( int matrix_layout, char direct, char storev,\n                                lapack_int n, lapack_int k,\n                                const lapack_complex_float* v, lapack_int ldv,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* t, lapack_int ldt );\nlapack_int LAPACKE_zlarft_work( int matrix_layout, char direct, char storev,\n                                lapack_int n, lapack_int k,\n                                const lapack_complex_double* v, lapack_int ldv,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* t, lapack_int ldt );\n\nlapack_int LAPACKE_slarfx_work( int matrix_layout, char side, lapack_int m,\n                                lapack_int n, const float* v, float tau,\n                                float* c, lapack_int ldc, float* work );\nlapack_int LAPACKE_dlarfx_work( int matrix_layout, char side, lapack_int m,\n                                lapack_int n, const double* v, double tau,\n                                double* c, lapack_int ldc, double* work );\nlapack_int LAPACKE_clarfx_work( int matrix_layout, char side, lapack_int m,\n                                lapack_int n, const lapack_complex_float* v,\n                                lapack_complex_float tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zlarfx_work( int matrix_layout, char side, lapack_int m,\n                                lapack_int n, const lapack_complex_double* v,\n                                lapack_complex_double tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_slarnv_work( lapack_int idist, lapack_int* iseed,\n                                lapack_int n, float* x );\nlapack_int LAPACKE_dlarnv_work( lapack_int idist, lapack_int* iseed,\n                                lapack_int n, double* x );\nlapack_int LAPACKE_clarnv_work( lapack_int idist, lapack_int* iseed,\n                                lapack_int n, lapack_complex_float* x );\nlapack_int LAPACKE_zlarnv_work( lapack_int idist, lapack_int* iseed,\n                                lapack_int n, lapack_complex_double* x );\n\n\nlapack_int LAPACKE_slascl_work( int matrix_layout, char type, lapack_int kl,\n                           lapack_int ku, float cfrom, float cto, \n                           lapack_int m, lapack_int n, float* a, \n                           lapack_int lda );\nlapack_int LAPACKE_dlascl_work( int matrix_layout, char type, lapack_int kl,\n                           lapack_int ku, double cfrom, double cto, \n                           lapack_int m, lapack_int n, double* a, \n                           lapack_int lda );\nlapack_int LAPACKE_clascl_work( int matrix_layout, char type, lapack_int kl,\n                           lapack_int ku, float cfrom, float cto, \n                           lapack_int m, lapack_int n, lapack_complex_float* a, \n                           lapack_int lda );\nlapack_int LAPACKE_zlascl_work( int matrix_layout, char type, lapack_int kl,\n                           lapack_int ku, double cfrom, double cto, \n                           lapack_int m, lapack_int n, lapack_complex_double* a, \n                           lapack_int lda );\n                          \nlapack_int LAPACKE_slaset_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, float alpha, float beta, float* a,\n                                lapack_int lda );\nlapack_int LAPACKE_dlaset_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, double alpha, double beta,\n                                double* a, lapack_int lda );\nlapack_int LAPACKE_claset_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, lapack_complex_float alpha,\n                                lapack_complex_float beta,\n                                lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_zlaset_work( int matrix_layout, char uplo, lapack_int m,\n                                lapack_int n, lapack_complex_double alpha,\n                                lapack_complex_double beta,\n                                lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_slasrt_work( char id, lapack_int n, float* d );\nlapack_int LAPACKE_dlasrt_work( char id, lapack_int n, double* d );\n\nlapack_int LAPACKE_slaswp_work( int matrix_layout, lapack_int n, float* a,\n                                lapack_int lda, lapack_int k1, lapack_int k2,\n                                const lapack_int* ipiv, lapack_int incx );\nlapack_int LAPACKE_dlaswp_work( int matrix_layout, lapack_int n, double* a,\n                                lapack_int lda, lapack_int k1, lapack_int k2,\n                                const lapack_int* ipiv, lapack_int incx );\nlapack_int LAPACKE_claswp_work( int matrix_layout, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int k1, lapack_int k2,\n                                const lapack_int* ipiv, lapack_int incx );\nlapack_int LAPACKE_zlaswp_work( int matrix_layout, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int k1, lapack_int k2,\n                                const lapack_int* ipiv, lapack_int incx );\n\nlapack_int LAPACKE_slauum_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda );\nlapack_int LAPACKE_dlauum_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda );\nlapack_int LAPACKE_clauum_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_zlauum_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_sopgtr_work( int matrix_layout, char uplo, lapack_int n,\n                                const float* ap, const float* tau, float* q,\n                                lapack_int ldq, float* work );\nlapack_int LAPACKE_dopgtr_work( int matrix_layout, char uplo, lapack_int n,\n                                const double* ap, const double* tau, double* q,\n                                lapack_int ldq, double* work );\n\nlapack_int LAPACKE_sopmtr_work( int matrix_layout, char side, char uplo,\n                                char trans, lapack_int m, lapack_int n,\n                                const float* ap, const float* tau, float* c,\n                                lapack_int ldc, float* work );\nlapack_int LAPACKE_dopmtr_work( int matrix_layout, char side, char uplo,\n                                char trans, lapack_int m, lapack_int n,\n                                const double* ap, const double* tau, double* c,\n                                lapack_int ldc, double* work );\n\nlapack_int LAPACKE_sorgbr_work( int matrix_layout, char vect, lapack_int m,\n                                lapack_int n, lapack_int k, float* a,\n                                lapack_int lda, const float* tau, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dorgbr_work( int matrix_layout, char vect, lapack_int m,\n                                lapack_int n, lapack_int k, double* a,\n                                lapack_int lda, const double* tau, double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_sorghr_work( int matrix_layout, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, float* a, lapack_int lda,\n                                const float* tau, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dorghr_work( int matrix_layout, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, double* a, lapack_int lda,\n                                const double* tau, double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_sorglq_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, float* a, lapack_int lda,\n                                const float* tau, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dorglq_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, double* a, lapack_int lda,\n                                const double* tau, double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_sorgql_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, float* a, lapack_int lda,\n                                const float* tau, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dorgql_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, double* a, lapack_int lda,\n                                const double* tau, double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_sorgqr_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, float* a, lapack_int lda,\n                                const float* tau, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dorgqr_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, double* a, lapack_int lda,\n                                const double* tau, double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_sorgrq_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, float* a, lapack_int lda,\n                                const float* tau, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dorgrq_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, double* a, lapack_int lda,\n                                const double* tau, double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_sorgtr_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda, const float* tau,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dorgtr_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda, const double* tau,\n                                double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sormbr_work( int matrix_layout, char vect, char side,\n                                char trans, lapack_int m, lapack_int n,\n                                lapack_int k, const float* a, lapack_int lda,\n                                const float* tau, float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dormbr_work( int matrix_layout, char vect, char side,\n                                char trans, lapack_int m, lapack_int n,\n                                lapack_int k, const double* a, lapack_int lda,\n                                const double* tau, double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sormhr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, const float* a, lapack_int lda,\n                                const float* tau, float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dormhr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, const double* a, lapack_int lda,\n                                const double* tau, double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sormlq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const float* a, lapack_int lda,\n                                const float* tau, float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dormlq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const double* a, lapack_int lda,\n                                const double* tau, double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sormql_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const float* a, lapack_int lda,\n                                const float* tau, float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dormql_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const double* a, lapack_int lda,\n                                const double* tau, double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sormqr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const float* a, lapack_int lda,\n                                const float* tau, float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dormqr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const double* a, lapack_int lda,\n                                const double* tau, double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sormrq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const float* a, lapack_int lda,\n                                const float* tau, float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dormrq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const double* a, lapack_int lda,\n                                const double* tau, double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sormrz_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                lapack_int l, const float* a, lapack_int lda,\n                                const float* tau, float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dormrz_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                lapack_int l, const double* a, lapack_int lda,\n                                const double* tau, double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sormtr_work( int matrix_layout, char side, char uplo,\n                                char trans, lapack_int m, lapack_int n,\n                                const float* a, lapack_int lda,\n                                const float* tau, float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dormtr_work( int matrix_layout, char side, char uplo,\n                                char trans, lapack_int m, lapack_int n,\n                                const double* a, lapack_int lda,\n                                const double* tau, double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\n\nlapack_int LAPACKE_spbcon_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, const float* ab, lapack_int ldab,\n                                float anorm, float* rcond, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dpbcon_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, const double* ab,\n                                lapack_int ldab, double anorm, double* rcond,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cpbcon_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, const lapack_complex_float* ab,\n                                lapack_int ldab, float anorm, float* rcond,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zpbcon_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, const lapack_complex_double* ab,\n                                lapack_int ldab, double anorm, double* rcond,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_spbequ_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, const float* ab, lapack_int ldab,\n                                float* s, float* scond, float* amax );\nlapack_int LAPACKE_dpbequ_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, const double* ab,\n                                lapack_int ldab, double* s, double* scond,\n                                double* amax );\nlapack_int LAPACKE_cpbequ_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, const lapack_complex_float* ab,\n                                lapack_int ldab, float* s, float* scond,\n                                float* amax );\nlapack_int LAPACKE_zpbequ_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, const lapack_complex_double* ab,\n                                lapack_int ldab, double* s, double* scond,\n                                double* amax );\n\nlapack_int LAPACKE_spbrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_int nrhs, const float* ab,\n                                lapack_int ldab, const float* afb,\n                                lapack_int ldafb, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* ferr, float* berr, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dpbrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_int nrhs,\n                                const double* ab, lapack_int ldab,\n                                const double* afb, lapack_int ldafb,\n                                const double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* ferr, double* berr,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cpbrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_int nrhs,\n                                const lapack_complex_float* ab, lapack_int ldab,\n                                const lapack_complex_float* afb,\n                                lapack_int ldafb, const lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* x,\n                                lapack_int ldx, float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zpbrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_int nrhs,\n                                const lapack_complex_double* ab,\n                                lapack_int ldab,\n                                const lapack_complex_double* afb,\n                                lapack_int ldafb,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_spbstf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kb, float* bb, lapack_int ldbb );\nlapack_int LAPACKE_dpbstf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kb, double* bb, lapack_int ldbb );\nlapack_int LAPACKE_cpbstf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kb, lapack_complex_float* bb,\n                                lapack_int ldbb );\nlapack_int LAPACKE_zpbstf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kb, lapack_complex_double* bb,\n                                lapack_int ldbb );\n\nlapack_int LAPACKE_spbsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int kd, lapack_int nrhs, float* ab,\n                               lapack_int ldab, float* b, lapack_int ldb );\nlapack_int LAPACKE_dpbsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int kd, lapack_int nrhs, double* ab,\n                               lapack_int ldab, double* b, lapack_int ldb );\nlapack_int LAPACKE_cpbsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int kd, lapack_int nrhs,\n                               lapack_complex_float* ab, lapack_int ldab,\n                               lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpbsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int kd, lapack_int nrhs,\n                               lapack_complex_double* ab, lapack_int ldab,\n                               lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_spbsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int kd, lapack_int nrhs,\n                                float* ab, lapack_int ldab, float* afb,\n                                lapack_int ldafb, char* equed, float* s,\n                                float* b, lapack_int ldb, float* x,\n                                lapack_int ldx, float* rcond, float* ferr,\n                                float* berr, float* work, lapack_int* iwork );\nlapack_int LAPACKE_dpbsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int kd, lapack_int nrhs,\n                                double* ab, lapack_int ldab, double* afb,\n                                lapack_int ldafb, char* equed, double* s,\n                                double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* rcond, double* ferr,\n                                double* berr, double* work, lapack_int* iwork );\nlapack_int LAPACKE_cpbsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int kd, lapack_int nrhs,\n                                lapack_complex_float* ab, lapack_int ldab,\n                                lapack_complex_float* afb, lapack_int ldafb,\n                                char* equed, float* s, lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* x,\n                                lapack_int ldx, float* rcond, float* ferr,\n                                float* berr, lapack_complex_float* work,\n                                float* rwork );\nlapack_int LAPACKE_zpbsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int kd, lapack_int nrhs,\n                                lapack_complex_double* ab, lapack_int ldab,\n                                lapack_complex_double* afb, lapack_int ldafb,\n                                char* equed, double* s,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_spbtrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, float* ab, lapack_int ldab );\nlapack_int LAPACKE_dpbtrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, double* ab, lapack_int ldab );\nlapack_int LAPACKE_cpbtrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_complex_float* ab,\n                                lapack_int ldab );\nlapack_int LAPACKE_zpbtrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_complex_double* ab,\n                                lapack_int ldab );\n\nlapack_int LAPACKE_spbtrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_int nrhs, const float* ab,\n                                lapack_int ldab, float* b, lapack_int ldb );\nlapack_int LAPACKE_dpbtrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_int nrhs,\n                                const double* ab, lapack_int ldab, double* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_cpbtrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_int nrhs,\n                                const lapack_complex_float* ab, lapack_int ldab,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpbtrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int kd, lapack_int nrhs,\n                                const lapack_complex_double* ab,\n                                lapack_int ldab, lapack_complex_double* b,\n                                lapack_int ldb );\n\nlapack_int LAPACKE_spftrf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, float* a );\nlapack_int LAPACKE_dpftrf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, double* a );\nlapack_int LAPACKE_cpftrf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, lapack_complex_float* a );\nlapack_int LAPACKE_zpftrf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, lapack_complex_double* a );\n\nlapack_int LAPACKE_spftri_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, float* a );\nlapack_int LAPACKE_dpftri_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, double* a );\nlapack_int LAPACKE_cpftri_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, lapack_complex_float* a );\nlapack_int LAPACKE_zpftri_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, lapack_complex_double* a );\n\nlapack_int LAPACKE_spftrs_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, lapack_int nrhs, const float* a,\n                                float* b, lapack_int ldb );\nlapack_int LAPACKE_dpftrs_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, lapack_int nrhs, const double* a,\n                                double* b, lapack_int ldb );\nlapack_int LAPACKE_cpftrs_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* a,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpftrs_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* a,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_spocon_work( int matrix_layout, char uplo, lapack_int n,\n                                const float* a, lapack_int lda, float anorm,\n                                float* rcond, float* work, lapack_int* iwork );\nlapack_int LAPACKE_dpocon_work( int matrix_layout, char uplo, lapack_int n,\n                                const double* a, lapack_int lda, double anorm,\n                                double* rcond, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cpocon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                float anorm, float* rcond,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zpocon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                double anorm, double* rcond,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_spoequ_work( int matrix_layout, lapack_int n, const float* a,\n                                lapack_int lda, float* s, float* scond,\n                                float* amax );\nlapack_int LAPACKE_dpoequ_work( int matrix_layout, lapack_int n, const double* a,\n                                lapack_int lda, double* s, double* scond,\n                                double* amax );\nlapack_int LAPACKE_cpoequ_work( int matrix_layout, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                float* s, float* scond, float* amax );\nlapack_int LAPACKE_zpoequ_work( int matrix_layout, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                double* s, double* scond, double* amax );\n\nlapack_int LAPACKE_spoequb_work( int matrix_layout, lapack_int n, const float* a,\n                                 lapack_int lda, float* s, float* scond,\n                                 float* amax );\nlapack_int LAPACKE_dpoequb_work( int matrix_layout, lapack_int n,\n                                 const double* a, lapack_int lda, double* s,\n                                 double* scond, double* amax );\nlapack_int LAPACKE_cpoequb_work( int matrix_layout, lapack_int n,\n                                 const lapack_complex_float* a, lapack_int lda,\n                                 float* s, float* scond, float* amax );\nlapack_int LAPACKE_zpoequb_work( int matrix_layout, lapack_int n,\n                                 const lapack_complex_double* a, lapack_int lda,\n                                 double* s, double* scond, double* amax );\n\nlapack_int LAPACKE_sporfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* a, lapack_int lda,\n                                const float* af, lapack_int ldaf,\n                                const float* b, lapack_int ldb, float* x,\n                                lapack_int ldx, float* ferr, float* berr,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dporfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* a,\n                                lapack_int lda, const double* af,\n                                lapack_int ldaf, const double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* ferr, double* berr, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cporfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* af,\n                                lapack_int ldaf, const lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* x,\n                                lapack_int ldx, float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zporfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, const lapack_complex_double* af,\n                                lapack_int ldaf, const lapack_complex_double* b,\n                                lapack_int ldb, lapack_complex_double* x,\n                                lapack_int ldx, double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sposv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, float* a, lapack_int lda,\n                               float* b, lapack_int ldb );\nlapack_int LAPACKE_dposv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, double* a, lapack_int lda,\n                               double* b, lapack_int ldb );\nlapack_int LAPACKE_cposv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_float* a,\n                               lapack_int lda, lapack_complex_float* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_zposv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_double* a,\n                               lapack_int lda, lapack_complex_double* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_dsposv_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, double* a, lapack_int lda,\n                                double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* work, float* swork,\n                                lapack_int* iter );\nlapack_int LAPACKE_zcposv_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb, lapack_complex_double* x,\n                                lapack_int ldx, lapack_complex_double* work,\n                                lapack_complex_float* swork, double* rwork,\n                                lapack_int* iter );\n\nlapack_int LAPACKE_sposvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs, float* a,\n                                lapack_int lda, float* af, lapack_int ldaf,\n                                char* equed, float* s, float* b, lapack_int ldb,\n                                float* x, lapack_int ldx, float* rcond,\n                                float* ferr, float* berr, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dposvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs, double* a,\n                                lapack_int lda, double* af, lapack_int ldaf,\n                                char* equed, double* s, double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cposvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* af, lapack_int ldaf,\n                                char* equed, float* s, lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* x,\n                                lapack_int ldx, float* rcond, float* ferr,\n                                float* berr, lapack_complex_float* work,\n                                float* rwork );\nlapack_int LAPACKE_zposvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* af, lapack_int ldaf,\n                                char* equed, double* s,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_spotrf2_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda );\nlapack_int LAPACKE_dpotrf2_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda );\nlapack_int LAPACKE_cpotrf2_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_zpotrf2_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_spotrf_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda );\nlapack_int LAPACKE_dpotrf_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda );\nlapack_int LAPACKE_cpotrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_zpotrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_spotri_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda );\nlapack_int LAPACKE_dpotri_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda );\nlapack_int LAPACKE_cpotri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_zpotri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_spotrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* a, lapack_int lda,\n                                float* b, lapack_int ldb );\nlapack_int LAPACKE_dpotrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* a,\n                                lapack_int lda, double* b, lapack_int ldb );\nlapack_int LAPACKE_cpotrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_zpotrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* b,\n                                lapack_int ldb );\n\nlapack_int LAPACKE_sppcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const float* ap, float anorm, float* rcond,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dppcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const double* ap, double anorm, double* rcond,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cppcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* ap, float anorm,\n                                float* rcond, lapack_complex_float* work,\n                                float* rwork );\nlapack_int LAPACKE_zppcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* ap, double anorm,\n                                double* rcond, lapack_complex_double* work,\n                                double* rwork );\n\nlapack_int LAPACKE_sppequ_work( int matrix_layout, char uplo, lapack_int n,\n                                const float* ap, float* s, float* scond,\n                                float* amax );\nlapack_int LAPACKE_dppequ_work( int matrix_layout, char uplo, lapack_int n,\n                                const double* ap, double* s, double* scond,\n                                double* amax );\nlapack_int LAPACKE_cppequ_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* ap, float* s,\n                                float* scond, float* amax );\nlapack_int LAPACKE_zppequ_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* ap, double* s,\n                                double* scond, double* amax );\n\nlapack_int LAPACKE_spprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* ap,\n                                const float* afp, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* ferr, float* berr, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dpprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* ap,\n                                const double* afp, const double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* ferr, double* berr, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cpprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* ap,\n                                const lapack_complex_float* afp,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zpprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                const lapack_complex_double* afp,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sppsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, float* ap, float* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_dppsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, double* ap, double* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_cppsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_float* ap,\n                               lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zppsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_double* ap,\n                               lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sppsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs, float* ap,\n                                float* afp, char* equed, float* s, float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dppsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs, double* ap,\n                                double* afp, char* equed, double* s, double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cppsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                lapack_complex_float* ap,\n                                lapack_complex_float* afp, char* equed,\n                                float* s, lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* x,\n                                lapack_int ldx, float* rcond, float* ferr,\n                                float* berr, lapack_complex_float* work,\n                                float* rwork );\nlapack_int LAPACKE_zppsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                lapack_complex_double* ap,\n                                lapack_complex_double* afp, char* equed,\n                                double* s, lapack_complex_double* b,\n                                lapack_int ldb, lapack_complex_double* x,\n                                lapack_int ldx, double* rcond, double* ferr,\n                                double* berr, lapack_complex_double* work,\n                                double* rwork );\n\nlapack_int LAPACKE_spptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                float* ap );\nlapack_int LAPACKE_dpptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                double* ap );\nlapack_int LAPACKE_cpptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* ap );\nlapack_int LAPACKE_zpptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* ap );\n\nlapack_int LAPACKE_spptri_work( int matrix_layout, char uplo, lapack_int n,\n                                float* ap );\nlapack_int LAPACKE_dpptri_work( int matrix_layout, char uplo, lapack_int n,\n                                double* ap );\nlapack_int LAPACKE_cpptri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* ap );\nlapack_int LAPACKE_zpptri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* ap );\n\nlapack_int LAPACKE_spptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* ap, float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_dpptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* ap, double* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_cpptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* ap,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_spstrf_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* piv,\n                                lapack_int* rank, float tol, float* work );\nlapack_int LAPACKE_dpstrf_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* piv,\n                                lapack_int* rank, double tol, double* work );\nlapack_int LAPACKE_cpstrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* piv, lapack_int* rank, float tol,\n                                float* work );\nlapack_int LAPACKE_zpstrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* piv, lapack_int* rank, double tol,\n                                double* work );\n\nlapack_int LAPACKE_sptcon_work( lapack_int n, const float* d, const float* e,\n                                float anorm, float* rcond, float* work );\nlapack_int LAPACKE_dptcon_work( lapack_int n, const double* d, const double* e,\n                                double anorm, double* rcond, double* work );\nlapack_int LAPACKE_cptcon_work( lapack_int n, const float* d,\n                                const lapack_complex_float* e, float anorm,\n                                float* rcond, float* work );\nlapack_int LAPACKE_zptcon_work( lapack_int n, const double* d,\n                                const lapack_complex_double* e, double anorm,\n                                double* rcond, double* work );\n\nlapack_int LAPACKE_spteqr_work( int matrix_layout, char compz, lapack_int n,\n                                float* d, float* e, float* z, lapack_int ldz,\n                                float* work );\nlapack_int LAPACKE_dpteqr_work( int matrix_layout, char compz, lapack_int n,\n                                double* d, double* e, double* z, lapack_int ldz,\n                                double* work );\nlapack_int LAPACKE_cpteqr_work( int matrix_layout, char compz, lapack_int n,\n                                float* d, float* e, lapack_complex_float* z,\n                                lapack_int ldz, float* work );\nlapack_int LAPACKE_zpteqr_work( int matrix_layout, char compz, lapack_int n,\n                                double* d, double* e, lapack_complex_double* z,\n                                lapack_int ldz, double* work );\n\nlapack_int LAPACKE_sptrfs_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                                const float* d, const float* e, const float* df,\n                                const float* ef, const float* b, lapack_int ldb,\n                                float* x, lapack_int ldx, float* ferr,\n                                float* berr, float* work );\nlapack_int LAPACKE_dptrfs_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                                const double* d, const double* e,\n                                const double* df, const double* ef,\n                                const double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* ferr, double* berr,\n                                double* work );\nlapack_int LAPACKE_cptrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* d,\n                                const lapack_complex_float* e, const float* df,\n                                const lapack_complex_float* ef,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zptrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* d,\n                                const lapack_complex_double* e,\n                                const double* df,\n                                const lapack_complex_double* ef,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sptsv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               float* d, float* e, float* b, lapack_int ldb );\nlapack_int LAPACKE_dptsv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               double* d, double* e, double* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_cptsv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               float* d, lapack_complex_float* e,\n                               lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zptsv_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                               double* d, lapack_complex_double* e,\n                               lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sptsvx_work( int matrix_layout, char fact, lapack_int n,\n                                lapack_int nrhs, const float* d, const float* e,\n                                float* df, float* ef, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                float* work );\nlapack_int LAPACKE_dptsvx_work( int matrix_layout, char fact, lapack_int n,\n                                lapack_int nrhs, const double* d,\n                                const double* e, double* df, double* ef,\n                                const double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* rcond, double* ferr,\n                                double* berr, double* work );\nlapack_int LAPACKE_cptsvx_work( int matrix_layout, char fact, lapack_int n,\n                                lapack_int nrhs, const float* d,\n                                const lapack_complex_float* e, float* df,\n                                lapack_complex_float* ef,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zptsvx_work( int matrix_layout, char fact, lapack_int n,\n                                lapack_int nrhs, const double* d,\n                                const lapack_complex_double* e, double* df,\n                                lapack_complex_double* ef,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_spttrf_work( lapack_int n, float* d, float* e );\nlapack_int LAPACKE_dpttrf_work( lapack_int n, double* d, double* e );\nlapack_int LAPACKE_cpttrf_work( lapack_int n, float* d,\n                                lapack_complex_float* e );\nlapack_int LAPACKE_zpttrf_work( lapack_int n, double* d,\n                                lapack_complex_double* e );\n\nlapack_int LAPACKE_spttrs_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                                const float* d, const float* e, float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_dpttrs_work( int matrix_layout, lapack_int n, lapack_int nrhs,\n                                const double* d, const double* e, double* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_cpttrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* d,\n                                const lapack_complex_float* e,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zpttrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* d,\n                                const lapack_complex_double* e,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_ssbev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_int kd, float* ab,\n                               lapack_int ldab, float* w, float* z,\n                               lapack_int ldz, float* work );\nlapack_int LAPACKE_dsbev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_int kd, double* ab,\n                               lapack_int ldab, double* w, double* z,\n                               lapack_int ldz, double* work );\n\nlapack_int LAPACKE_ssbevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_int kd, float* ab,\n                                lapack_int ldab, float* w, float* z,\n                                lapack_int ldz, float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_dsbevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_int kd, double* ab,\n                                lapack_int ldab, double* w, double* z,\n                                lapack_int ldz, double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_ssbevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, lapack_int kd,\n                                float* ab, lapack_int ldab, float* q,\n                                lapack_int ldq, float vl, float vu,\n                                lapack_int il, lapack_int iu, float abstol,\n                                lapack_int* m, float* w, float* z,\n                                lapack_int ldz, float* work, lapack_int* iwork,\n                                lapack_int* ifail );\nlapack_int LAPACKE_dsbevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, lapack_int kd,\n                                double* ab, lapack_int ldab, double* q,\n                                lapack_int ldq, double vl, double vu,\n                                lapack_int il, lapack_int iu, double abstol,\n                                lapack_int* m, double* w, double* z,\n                                lapack_int ldz, double* work,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_ssbgst_work( int matrix_layout, char vect, char uplo,\n                                lapack_int n, lapack_int ka, lapack_int kb,\n                                float* ab, lapack_int ldab, const float* bb,\n                                lapack_int ldbb, float* x, lapack_int ldx,\n                                float* work );\nlapack_int LAPACKE_dsbgst_work( int matrix_layout, char vect, char uplo,\n                                lapack_int n, lapack_int ka, lapack_int kb,\n                                double* ab, lapack_int ldab, const double* bb,\n                                lapack_int ldbb, double* x, lapack_int ldx,\n                                double* work );\n\nlapack_int LAPACKE_ssbgv_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_int ka, lapack_int kb,\n                               float* ab, lapack_int ldab, float* bb,\n                               lapack_int ldbb, float* w, float* z,\n                               lapack_int ldz, float* work );\nlapack_int LAPACKE_dsbgv_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, lapack_int ka, lapack_int kb,\n                               double* ab, lapack_int ldab, double* bb,\n                               lapack_int ldbb, double* w, double* z,\n                               lapack_int ldz, double* work );\n\nlapack_int LAPACKE_ssbgvd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_int ka, lapack_int kb,\n                                float* ab, lapack_int ldab, float* bb,\n                                lapack_int ldbb, float* w, float* z,\n                                lapack_int ldz, float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_dsbgvd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, lapack_int ka, lapack_int kb,\n                                double* ab, lapack_int ldab, double* bb,\n                                lapack_int ldbb, double* w, double* z,\n                                lapack_int ldz, double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_ssbgvx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, lapack_int ka,\n                                lapack_int kb, float* ab, lapack_int ldab,\n                                float* bb, lapack_int ldbb, float* q,\n                                lapack_int ldq, float vl, float vu,\n                                lapack_int il, lapack_int iu, float abstol,\n                                lapack_int* m, float* w, float* z,\n                                lapack_int ldz, float* work, lapack_int* iwork,\n                                lapack_int* ifail );\nlapack_int LAPACKE_dsbgvx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, lapack_int ka,\n                                lapack_int kb, double* ab, lapack_int ldab,\n                                double* bb, lapack_int ldbb, double* q,\n                                lapack_int ldq, double vl, double vu,\n                                lapack_int il, lapack_int iu, double abstol,\n                                lapack_int* m, double* w, double* z,\n                                lapack_int ldz, double* work, lapack_int* iwork,\n                                lapack_int* ifail );\n\nlapack_int LAPACKE_ssbtrd_work( int matrix_layout, char vect, char uplo,\n                                lapack_int n, lapack_int kd, float* ab,\n                                lapack_int ldab, float* d, float* e, float* q,\n                                lapack_int ldq, float* work );\nlapack_int LAPACKE_dsbtrd_work( int matrix_layout, char vect, char uplo,\n                                lapack_int n, lapack_int kd, double* ab,\n                                lapack_int ldab, double* d, double* e,\n                                double* q, lapack_int ldq, double* work );\n\nlapack_int LAPACKE_ssfrk_work( int matrix_layout, char transr, char uplo,\n                               char trans, lapack_int n, lapack_int k,\n                               float alpha, const float* a, lapack_int lda,\n                               float beta, float* c );\nlapack_int LAPACKE_dsfrk_work( int matrix_layout, char transr, char uplo,\n                               char trans, lapack_int n, lapack_int k,\n                               double alpha, const double* a, lapack_int lda,\n                               double beta, double* c );\n\nlapack_int LAPACKE_sspcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const float* ap, const lapack_int* ipiv,\n                                float anorm, float* rcond, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dspcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const double* ap, const lapack_int* ipiv,\n                                double anorm, double* rcond, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cspcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* ap,\n                                const lapack_int* ipiv, float anorm,\n                                float* rcond, lapack_complex_float* work );\nlapack_int LAPACKE_zspcon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* ap,\n                                const lapack_int* ipiv, double anorm,\n                                double* rcond, lapack_complex_double* work );\n\nlapack_int LAPACKE_sspev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, float* ap, float* w, float* z,\n                               lapack_int ldz, float* work );\nlapack_int LAPACKE_dspev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, double* ap, double* w, double* z,\n                               lapack_int ldz, double* work );\n\nlapack_int LAPACKE_sspevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, float* ap, float* w, float* z,\n                                lapack_int ldz, float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_dspevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, double* ap, double* w, double* z,\n                                lapack_int ldz, double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_sspevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, float* ap, float vl,\n                                float vu, lapack_int il, lapack_int iu,\n                                float abstol, lapack_int* m, float* w, float* z,\n                                lapack_int ldz, float* work, lapack_int* iwork,\n                                lapack_int* ifail );\nlapack_int LAPACKE_dspevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, double* ap, double vl,\n                                double vu, lapack_int il, lapack_int iu,\n                                double abstol, lapack_int* m, double* w,\n                                double* z, lapack_int ldz, double* work,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_sspgst_work( int matrix_layout, lapack_int itype, char uplo,\n                                lapack_int n, float* ap, const float* bp );\nlapack_int LAPACKE_dspgst_work( int matrix_layout, lapack_int itype, char uplo,\n                                lapack_int n, double* ap, const double* bp );\n\nlapack_int LAPACKE_sspgv_work( int matrix_layout, lapack_int itype, char jobz,\n                               char uplo, lapack_int n, float* ap, float* bp,\n                               float* w, float* z, lapack_int ldz,\n                               float* work );\nlapack_int LAPACKE_dspgv_work( int matrix_layout, lapack_int itype, char jobz,\n                               char uplo, lapack_int n, double* ap, double* bp,\n                               double* w, double* z, lapack_int ldz,\n                               double* work );\n\nlapack_int LAPACKE_sspgvd_work( int matrix_layout, lapack_int itype, char jobz,\n                                char uplo, lapack_int n, float* ap, float* bp,\n                                float* w, float* z, lapack_int ldz, float* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_dspgvd_work( int matrix_layout, lapack_int itype, char jobz,\n                                char uplo, lapack_int n, double* ap, double* bp,\n                                double* w, double* z, lapack_int ldz,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_sspgvx_work( int matrix_layout, lapack_int itype, char jobz,\n                                char range, char uplo, lapack_int n, float* ap,\n                                float* bp, float vl, float vu, lapack_int il,\n                                lapack_int iu, float abstol, lapack_int* m,\n                                float* w, float* z, lapack_int ldz, float* work,\n                                lapack_int* iwork, lapack_int* ifail );\nlapack_int LAPACKE_dspgvx_work( int matrix_layout, lapack_int itype, char jobz,\n                                char range, char uplo, lapack_int n, double* ap,\n                                double* bp, double vl, double vu, lapack_int il,\n                                lapack_int iu, double abstol, lapack_int* m,\n                                double* w, double* z, lapack_int ldz,\n                                double* work, lapack_int* iwork,\n                                lapack_int* ifail );\n\nlapack_int LAPACKE_ssprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* ap,\n                                const float* afp, const lapack_int* ipiv,\n                                const float* b, lapack_int ldb, float* x,\n                                lapack_int ldx, float* ferr, float* berr,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dsprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* ap,\n                                const double* afp, const lapack_int* ipiv,\n                                const double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* ferr, double* berr,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_csprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* ap,\n                                const lapack_complex_float* afp,\n                                const lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zsprfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                const lapack_complex_double* afp,\n                                const lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_sspsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, float* ap, lapack_int* ipiv,\n                               float* b, lapack_int ldb );\nlapack_int LAPACKE_dspsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, double* ap, lapack_int* ipiv,\n                               double* b, lapack_int ldb );\nlapack_int LAPACKE_cspsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_float* ap,\n                               lapack_int* ipiv, lapack_complex_float* b,\n                               lapack_int ldb );\nlapack_int LAPACKE_zspsv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_double* ap,\n                               lapack_int* ipiv, lapack_complex_double* b,\n                               lapack_int ldb );\n\nlapack_int LAPACKE_sspsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs, const float* ap,\n                                float* afp, lapack_int* ipiv, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dspsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs, const double* ap,\n                                double* afp, lapack_int* ipiv, const double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_cspsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* ap,\n                                lapack_complex_float* afp, lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zspsvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                lapack_complex_double* afp, lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_ssptrd_work( int matrix_layout, char uplo, lapack_int n,\n                                float* ap, float* d, float* e, float* tau );\nlapack_int LAPACKE_dsptrd_work( int matrix_layout, char uplo, lapack_int n,\n                                double* ap, double* d, double* e, double* tau );\n\nlapack_int LAPACKE_ssptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                float* ap, lapack_int* ipiv );\nlapack_int LAPACKE_dsptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                double* ap, lapack_int* ipiv );\nlapack_int LAPACKE_csptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* ap, lapack_int* ipiv );\nlapack_int LAPACKE_zsptrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* ap, lapack_int* ipiv );\n\nlapack_int LAPACKE_ssptri_work( int matrix_layout, char uplo, lapack_int n,\n                                float* ap, const lapack_int* ipiv,\n                                float* work );\nlapack_int LAPACKE_dsptri_work( int matrix_layout, char uplo, lapack_int n,\n                                double* ap, const lapack_int* ipiv,\n                                double* work );\nlapack_int LAPACKE_csptri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* ap,\n                                const lapack_int* ipiv,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zsptri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* ap,\n                                const lapack_int* ipiv,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_ssptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* ap,\n                                const lapack_int* ipiv, float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_dsptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* ap,\n                                const lapack_int* ipiv, double* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_csptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* ap,\n                                const lapack_int* ipiv, lapack_complex_float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_zsptrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                const lapack_int* ipiv,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sstebz_work( char range, char order, lapack_int n, float vl,\n                                float vu, lapack_int il, lapack_int iu,\n                                float abstol, const float* d, const float* e,\n                                lapack_int* m, lapack_int* nsplit, float* w,\n                                lapack_int* iblock, lapack_int* isplit,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dstebz_work( char range, char order, lapack_int n, double vl,\n                                double vu, lapack_int il, lapack_int iu,\n                                double abstol, const double* d, const double* e,\n                                lapack_int* m, lapack_int* nsplit, double* w,\n                                lapack_int* iblock, lapack_int* isplit,\n                                double* work, lapack_int* iwork );\n\nlapack_int LAPACKE_sstedc_work( int matrix_layout, char compz, lapack_int n,\n                                float* d, float* e, float* z, lapack_int ldz,\n                                float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_dstedc_work( int matrix_layout, char compz, lapack_int n,\n                                double* d, double* e, double* z, lapack_int ldz,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_cstedc_work( int matrix_layout, char compz, lapack_int n,\n                                float* d, float* e, lapack_complex_float* z,\n                                lapack_int ldz, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_zstedc_work( int matrix_layout, char compz, lapack_int n,\n                                double* d, double* e, lapack_complex_double* z,\n                                lapack_int ldz, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork,\n                                lapack_int lrwork, lapack_int* iwork,\n                                lapack_int liwork );\n\nlapack_int LAPACKE_sstegr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, float* d, float* e, float vl,\n                                float vu, lapack_int il, lapack_int iu,\n                                float abstol, lapack_int* m, float* w, float* z,\n                                lapack_int ldz, lapack_int* isuppz, float* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_dstegr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, double* d, double* e, double vl,\n                                double vu, lapack_int il, lapack_int iu,\n                                double abstol, lapack_int* m, double* w,\n                                double* z, lapack_int ldz, lapack_int* isuppz,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_cstegr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, float* d, float* e, float vl,\n                                float vu, lapack_int il, lapack_int iu,\n                                float abstol, lapack_int* m, float* w,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_int* isuppz, float* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_zstegr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, double* d, double* e, double vl,\n                                double vu, lapack_int il, lapack_int iu,\n                                double abstol, lapack_int* m, double* w,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_int* isuppz, double* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\n\nlapack_int LAPACKE_sstein_work( int matrix_layout, lapack_int n, const float* d,\n                                const float* e, lapack_int m, const float* w,\n                                const lapack_int* iblock,\n                                const lapack_int* isplit, float* z,\n                                lapack_int ldz, float* work, lapack_int* iwork,\n                                lapack_int* ifailv );\nlapack_int LAPACKE_dstein_work( int matrix_layout, lapack_int n, const double* d,\n                                const double* e, lapack_int m, const double* w,\n                                const lapack_int* iblock,\n                                const lapack_int* isplit, double* z,\n                                lapack_int ldz, double* work, lapack_int* iwork,\n                                lapack_int* ifailv );\nlapack_int LAPACKE_cstein_work( int matrix_layout, lapack_int n, const float* d,\n                                const float* e, lapack_int m, const float* w,\n                                const lapack_int* iblock,\n                                const lapack_int* isplit,\n                                lapack_complex_float* z, lapack_int ldz,\n                                float* work, lapack_int* iwork,\n                                lapack_int* ifailv );\nlapack_int LAPACKE_zstein_work( int matrix_layout, lapack_int n, const double* d,\n                                const double* e, lapack_int m, const double* w,\n                                const lapack_int* iblock,\n                                const lapack_int* isplit,\n                                lapack_complex_double* z, lapack_int ldz,\n                                double* work, lapack_int* iwork,\n                                lapack_int* ifailv );\n\nlapack_int LAPACKE_sstemr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, float* d, float* e, float vl,\n                                float vu, lapack_int il, lapack_int iu,\n                                lapack_int* m, float* w, float* z,\n                                lapack_int ldz, lapack_int nzc,\n                                lapack_int* isuppz, lapack_logical* tryrac,\n                                float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_dstemr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, double* d, double* e, double vl,\n                                double vu, lapack_int il, lapack_int iu,\n                                lapack_int* m, double* w, double* z,\n                                lapack_int ldz, lapack_int nzc,\n                                lapack_int* isuppz, lapack_logical* tryrac,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_cstemr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, float* d, float* e, float vl,\n                                float vu, lapack_int il, lapack_int iu,\n                                lapack_int* m, float* w,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_int nzc, lapack_int* isuppz,\n                                lapack_logical* tryrac, float* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_zstemr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, double* d, double* e, double vl,\n                                double vu, lapack_int il, lapack_int iu,\n                                lapack_int* m, double* w,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_int nzc, lapack_int* isuppz,\n                                lapack_logical* tryrac, double* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\n\nlapack_int LAPACKE_ssteqr_work( int matrix_layout, char compz, lapack_int n,\n                                float* d, float* e, float* z, lapack_int ldz,\n                                float* work );\nlapack_int LAPACKE_dsteqr_work( int matrix_layout, char compz, lapack_int n,\n                                double* d, double* e, double* z, lapack_int ldz,\n                                double* work );\nlapack_int LAPACKE_csteqr_work( int matrix_layout, char compz, lapack_int n,\n                                float* d, float* e, lapack_complex_float* z,\n                                lapack_int ldz, float* work );\nlapack_int LAPACKE_zsteqr_work( int matrix_layout, char compz, lapack_int n,\n                                double* d, double* e, lapack_complex_double* z,\n                                lapack_int ldz, double* work );\n\nlapack_int LAPACKE_ssterf_work( lapack_int n, float* d, float* e );\nlapack_int LAPACKE_dsterf_work( lapack_int n, double* d, double* e );\n\nlapack_int LAPACKE_sstev_work( int matrix_layout, char jobz, lapack_int n,\n                               float* d, float* e, float* z, lapack_int ldz,\n                               float* work );\nlapack_int LAPACKE_dstev_work( int matrix_layout, char jobz, lapack_int n,\n                               double* d, double* e, double* z, lapack_int ldz,\n                               double* work );\n\nlapack_int LAPACKE_sstevd_work( int matrix_layout, char jobz, lapack_int n,\n                                float* d, float* e, float* z, lapack_int ldz,\n                                float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_dstevd_work( int matrix_layout, char jobz, lapack_int n,\n                                double* d, double* e, double* z, lapack_int ldz,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_sstevr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, float* d, float* e, float vl,\n                                float vu, lapack_int il, lapack_int iu,\n                                float abstol, lapack_int* m, float* w, float* z,\n                                lapack_int ldz, lapack_int* isuppz, float* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_dstevr_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, double* d, double* e, double vl,\n                                double vu, lapack_int il, lapack_int iu,\n                                double abstol, lapack_int* m, double* w,\n                                double* z, lapack_int ldz, lapack_int* isuppz,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_sstevx_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, float* d, float* e, float vl,\n                                float vu, lapack_int il, lapack_int iu,\n                                float abstol, lapack_int* m, float* w, float* z,\n                                lapack_int ldz, float* work, lapack_int* iwork,\n                                lapack_int* ifail );\nlapack_int LAPACKE_dstevx_work( int matrix_layout, char jobz, char range,\n                                lapack_int n, double* d, double* e, double vl,\n                                double vu, lapack_int il, lapack_int iu,\n                                double abstol, lapack_int* m, double* w,\n                                double* z, lapack_int ldz, double* work,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_ssycon_work( int matrix_layout, char uplo, lapack_int n,\n                                const float* a, lapack_int lda,\n                                const lapack_int* ipiv, float anorm,\n                                float* rcond, float* work, lapack_int* iwork );\nlapack_int LAPACKE_dsycon_work( int matrix_layout, char uplo, lapack_int n,\n                                const double* a, lapack_int lda,\n                                const lapack_int* ipiv, double anorm,\n                                double* rcond, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_csycon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_int* ipiv, float anorm,\n                                float* rcond, lapack_complex_float* work );\nlapack_int LAPACKE_zsycon_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_int* ipiv, double anorm,\n                                double* rcond, lapack_complex_double* work );\n\nlapack_int LAPACKE_ssyequb_work( int matrix_layout, char uplo, lapack_int n,\n                                 const float* a, lapack_int lda, float* s,\n                                 float* scond, float* amax, float* work );\nlapack_int LAPACKE_dsyequb_work( int matrix_layout, char uplo, lapack_int n,\n                                 const double* a, lapack_int lda, double* s,\n                                 double* scond, double* amax, double* work );\nlapack_int LAPACKE_csyequb_work( int matrix_layout, char uplo, lapack_int n,\n                                 const lapack_complex_float* a, lapack_int lda,\n                                 float* s, float* scond, float* amax,\n                                 lapack_complex_float* work );\nlapack_int LAPACKE_zsyequb_work( int matrix_layout, char uplo, lapack_int n,\n                                 const lapack_complex_double* a, lapack_int lda,\n                                 double* s, double* scond, double* amax,\n                                 lapack_complex_double* work );\n\nlapack_int LAPACKE_ssyev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, float* a, lapack_int lda, float* w,\n                               float* work, lapack_int lwork );\nlapack_int LAPACKE_dsyev_work( int matrix_layout, char jobz, char uplo,\n                               lapack_int n, double* a, lapack_int lda,\n                               double* w, double* work, lapack_int lwork );\n\nlapack_int LAPACKE_ssyevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, float* a, lapack_int lda,\n                                float* w, float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_dsyevd_work( int matrix_layout, char jobz, char uplo,\n                                lapack_int n, double* a, lapack_int lda,\n                                double* w, double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_ssyevr_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, float* a,\n                                lapack_int lda, float vl, float vu,\n                                lapack_int il, lapack_int iu, float abstol,\n                                lapack_int* m, float* w, float* z,\n                                lapack_int ldz, lapack_int* isuppz, float* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_dsyevr_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, double* a,\n                                lapack_int lda, double vl, double vu,\n                                lapack_int il, lapack_int iu, double abstol,\n                                lapack_int* m, double* w, double* z,\n                                lapack_int ldz, lapack_int* isuppz,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_ssyevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, float* a,\n                                lapack_int lda, float vl, float vu,\n                                lapack_int il, lapack_int iu, float abstol,\n                                lapack_int* m, float* w, float* z,\n                                lapack_int ldz, float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int* ifail );\nlapack_int LAPACKE_dsyevx_work( int matrix_layout, char jobz, char range,\n                                char uplo, lapack_int n, double* a,\n                                lapack_int lda, double vl, double vu,\n                                lapack_int il, lapack_int iu, double abstol,\n                                lapack_int* m, double* w, double* z,\n                                lapack_int ldz, double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_ssygst_work( int matrix_layout, lapack_int itype, char uplo,\n                                lapack_int n, float* a, lapack_int lda,\n                                const float* b, lapack_int ldb );\nlapack_int LAPACKE_dsygst_work( int matrix_layout, lapack_int itype, char uplo,\n                                lapack_int n, double* a, lapack_int lda,\n                                const double* b, lapack_int ldb );\n\nlapack_int LAPACKE_ssygv_work( int matrix_layout, lapack_int itype, char jobz,\n                               char uplo, lapack_int n, float* a,\n                               lapack_int lda, float* b, lapack_int ldb,\n                               float* w, float* work, lapack_int lwork );\nlapack_int LAPACKE_dsygv_work( int matrix_layout, lapack_int itype, char jobz,\n                               char uplo, lapack_int n, double* a,\n                               lapack_int lda, double* b, lapack_int ldb,\n                               double* w, double* work, lapack_int lwork );\n\nlapack_int LAPACKE_ssygvd_work( int matrix_layout, lapack_int itype, char jobz,\n                                char uplo, lapack_int n, float* a,\n                                lapack_int lda, float* b, lapack_int ldb,\n                                float* w, float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_dsygvd_work( int matrix_layout, lapack_int itype, char jobz,\n                                char uplo, lapack_int n, double* a,\n                                lapack_int lda, double* b, lapack_int ldb,\n                                double* w, double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\n\nlapack_int LAPACKE_ssygvx_work( int matrix_layout, lapack_int itype, char jobz,\n                                char range, char uplo, lapack_int n, float* a,\n                                lapack_int lda, float* b, lapack_int ldb,\n                                float vl, float vu, lapack_int il,\n                                lapack_int iu, float abstol, lapack_int* m,\n                                float* w, float* z, lapack_int ldz, float* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int* ifail );\nlapack_int LAPACKE_dsygvx_work( int matrix_layout, lapack_int itype, char jobz,\n                                char range, char uplo, lapack_int n, double* a,\n                                lapack_int lda, double* b, lapack_int ldb,\n                                double vl, double vu, lapack_int il,\n                                lapack_int iu, double abstol, lapack_int* m,\n                                double* w, double* z, lapack_int ldz,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int* ifail );\n\nlapack_int LAPACKE_ssyrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* a, lapack_int lda,\n                                const float* af, lapack_int ldaf,\n                                const lapack_int* ipiv, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* ferr, float* berr, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dsyrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* a,\n                                lapack_int lda, const double* af,\n                                lapack_int ldaf, const lapack_int* ipiv,\n                                const double* b, lapack_int ldb, double* x,\n                                lapack_int ldx, double* ferr, double* berr,\n                                double* work, lapack_int* iwork );\nlapack_int LAPACKE_csyrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* af,\n                                lapack_int ldaf, const lapack_int* ipiv,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_zsyrfs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, const lapack_complex_double* af,\n                                lapack_int ldaf, const lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_ssysv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, float* a, lapack_int lda,\n                               lapack_int* ipiv, float* b, lapack_int ldb,\n                               float* work, lapack_int lwork );\nlapack_int LAPACKE_dsysv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, double* a, lapack_int lda,\n                               lapack_int* ipiv, double* b, lapack_int ldb,\n                               double* work, lapack_int lwork );\nlapack_int LAPACKE_csysv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_float* a,\n                               lapack_int lda, lapack_int* ipiv,\n                               lapack_complex_float* b, lapack_int ldb,\n                               lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zsysv_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_double* a,\n                               lapack_int lda, lapack_int* ipiv,\n                               lapack_complex_double* b, lapack_int ldb,\n                               lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_ssysvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs, const float* a,\n                                lapack_int lda, float* af, lapack_int ldaf,\n                                lapack_int* ipiv, const float* b,\n                                lapack_int ldb, float* x, lapack_int ldx,\n                                float* rcond, float* ferr, float* berr,\n                                float* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dsysvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs, const double* a,\n                                lapack_int lda, double* af, lapack_int ldaf,\n                                lapack_int* ipiv, const double* b,\n                                lapack_int ldb, double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_csysvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* af, lapack_int ldaf,\n                                lapack_int* ipiv, const lapack_complex_float* b,\n                                lapack_int ldb, lapack_complex_float* x,\n                                lapack_int ldx, float* rcond, float* ferr,\n                                float* berr, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork );\nlapack_int LAPACKE_zsysvx_work( int matrix_layout, char fact, char uplo,\n                                lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* af, lapack_int ldaf,\n                                lapack_int* ipiv,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* x, lapack_int ldx,\n                                double* rcond, double* ferr, double* berr,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork );\n\nlapack_int LAPACKE_ssytrd_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda, float* d, float* e,\n                                float* tau, float* work, lapack_int lwork );\nlapack_int LAPACKE_dsytrd_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda, double* d, double* e,\n                                double* tau, double* work, lapack_int lwork );\n\nlapack_int LAPACKE_ssytrf_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* ipiv,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dsytrf_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* ipiv,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_csytrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_zsytrf_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_ssytri_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda,\n                                const lapack_int* ipiv, float* work );\nlapack_int LAPACKE_dsytri_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda,\n                                const lapack_int* ipiv, double* work );\nlapack_int LAPACKE_csytri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                const lapack_int* ipiv,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zsytri_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                const lapack_int* ipiv,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_ssytrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* a, lapack_int lda,\n                                const lapack_int* ipiv, float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_dsytrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                double* b, lapack_int ldb );\nlapack_int LAPACKE_csytrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zsytrs_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_stbcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n, lapack_int kd,\n                                const float* ab, lapack_int ldab, float* rcond,\n                                float* work, lapack_int* iwork );\nlapack_int LAPACKE_dtbcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n, lapack_int kd,\n                                const double* ab, lapack_int ldab,\n                                double* rcond, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_ctbcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n, lapack_int kd,\n                                const lapack_complex_float* ab, lapack_int ldab,\n                                float* rcond, lapack_complex_float* work,\n                                float* rwork );\nlapack_int LAPACKE_ztbcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n, lapack_int kd,\n                                const lapack_complex_double* ab,\n                                lapack_int ldab, double* rcond,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_stbrfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int kd,\n                                lapack_int nrhs, const float* ab,\n                                lapack_int ldab, const float* b, lapack_int ldb,\n                                const float* x, lapack_int ldx, float* ferr,\n                                float* berr, float* work, lapack_int* iwork );\nlapack_int LAPACKE_dtbrfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int kd,\n                                lapack_int nrhs, const double* ab,\n                                lapack_int ldab, const double* b,\n                                lapack_int ldb, const double* x, lapack_int ldx,\n                                double* ferr, double* berr, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_ctbrfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int kd,\n                                lapack_int nrhs, const lapack_complex_float* ab,\n                                lapack_int ldab, const lapack_complex_float* b,\n                                lapack_int ldb, const lapack_complex_float* x,\n                                lapack_int ldx, float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_ztbrfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int kd,\n                                lapack_int nrhs,\n                                const lapack_complex_double* ab,\n                                lapack_int ldab, const lapack_complex_double* b,\n                                lapack_int ldb, const lapack_complex_double* x,\n                                lapack_int ldx, double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_stbtrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int kd,\n                                lapack_int nrhs, const float* ab,\n                                lapack_int ldab, float* b, lapack_int ldb );\nlapack_int LAPACKE_dtbtrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int kd,\n                                lapack_int nrhs, const double* ab,\n                                lapack_int ldab, double* b, lapack_int ldb );\nlapack_int LAPACKE_ctbtrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int kd,\n                                lapack_int nrhs, const lapack_complex_float* ab,\n                                lapack_int ldab, lapack_complex_float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_ztbtrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int kd,\n                                lapack_int nrhs,\n                                const lapack_complex_double* ab,\n                                lapack_int ldab, lapack_complex_double* b,\n                                lapack_int ldb );\n\nlapack_int LAPACKE_stfsm_work( int matrix_layout, char transr, char side,\n                               char uplo, char trans, char diag, lapack_int m,\n                               lapack_int n, float alpha, const float* a,\n                               float* b, lapack_int ldb );\nlapack_int LAPACKE_dtfsm_work( int matrix_layout, char transr, char side,\n                               char uplo, char trans, char diag, lapack_int m,\n                               lapack_int n, double alpha, const double* a,\n                               double* b, lapack_int ldb );\nlapack_int LAPACKE_ctfsm_work( int matrix_layout, char transr, char side,\n                               char uplo, char trans, char diag, lapack_int m,\n                               lapack_int n, lapack_complex_float alpha,\n                               const lapack_complex_float* a,\n                               lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_ztfsm_work( int matrix_layout, char transr, char side,\n                               char uplo, char trans, char diag, lapack_int m,\n                               lapack_int n, lapack_complex_double alpha,\n                               const lapack_complex_double* a,\n                               lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_stftri_work( int matrix_layout, char transr, char uplo,\n                                char diag, lapack_int n, float* a );\nlapack_int LAPACKE_dtftri_work( int matrix_layout, char transr, char uplo,\n                                char diag, lapack_int n, double* a );\nlapack_int LAPACKE_ctftri_work( int matrix_layout, char transr, char uplo,\n                                char diag, lapack_int n,\n                                lapack_complex_float* a );\nlapack_int LAPACKE_ztftri_work( int matrix_layout, char transr, char uplo,\n                                char diag, lapack_int n,\n                                lapack_complex_double* a );\n\nlapack_int LAPACKE_stfttp_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const float* arf, float* ap );\nlapack_int LAPACKE_dtfttp_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const double* arf, double* ap );\nlapack_int LAPACKE_ctfttp_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const lapack_complex_float* arf,\n                                lapack_complex_float* ap );\nlapack_int LAPACKE_ztfttp_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const lapack_complex_double* arf,\n                                lapack_complex_double* ap );\n\nlapack_int LAPACKE_stfttr_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const float* arf, float* a,\n                                lapack_int lda );\nlapack_int LAPACKE_dtfttr_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const double* arf, double* a,\n                                lapack_int lda );\nlapack_int LAPACKE_ctfttr_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const lapack_complex_float* arf,\n                                lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_ztfttr_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const lapack_complex_double* arf,\n                                lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_stgevc_work( int matrix_layout, char side, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const float* s, lapack_int lds, const float* p,\n                                lapack_int ldp, float* vl, lapack_int ldvl,\n                                float* vr, lapack_int ldvr, lapack_int mm,\n                                lapack_int* m, float* work );\nlapack_int LAPACKE_dtgevc_work( int matrix_layout, char side, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const double* s, lapack_int lds,\n                                const double* p, lapack_int ldp, double* vl,\n                                lapack_int ldvl, double* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m, double* work );\nlapack_int LAPACKE_ctgevc_work( int matrix_layout, char side, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const lapack_complex_float* s, lapack_int lds,\n                                const lapack_complex_float* p, lapack_int ldp,\n                                lapack_complex_float* vl, lapack_int ldvl,\n                                lapack_complex_float* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_ztgevc_work( int matrix_layout, char side, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const lapack_complex_double* s, lapack_int lds,\n                                const lapack_complex_double* p, lapack_int ldp,\n                                lapack_complex_double* vl, lapack_int ldvl,\n                                lapack_complex_double* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_stgexc_work( int matrix_layout, lapack_logical wantq,\n                                lapack_logical wantz, lapack_int n, float* a,\n                                lapack_int lda, float* b, lapack_int ldb,\n                                float* q, lapack_int ldq, float* z,\n                                lapack_int ldz, lapack_int* ifst,\n                                lapack_int* ilst, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dtgexc_work( int matrix_layout, lapack_logical wantq,\n                                lapack_logical wantz, lapack_int n, double* a,\n                                lapack_int lda, double* b, lapack_int ldb,\n                                double* q, lapack_int ldq, double* z,\n                                lapack_int ldz, lapack_int* ifst,\n                                lapack_int* ilst, double* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_ctgexc_work( int matrix_layout, lapack_logical wantq,\n                                lapack_logical wantz, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_int ifst, lapack_int ilst );\nlapack_int LAPACKE_ztgexc_work( int matrix_layout, lapack_logical wantq,\n                                lapack_logical wantz, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_int ifst, lapack_int ilst );\n\nlapack_int LAPACKE_stgsen_work( int matrix_layout, lapack_int ijob,\n                                lapack_logical wantq, lapack_logical wantz,\n                                const lapack_logical* select, lapack_int n,\n                                float* a, lapack_int lda, float* b,\n                                lapack_int ldb, float* alphar, float* alphai,\n                                float* beta, float* q, lapack_int ldq, float* z,\n                                lapack_int ldz, lapack_int* m, float* pl,\n                                float* pr, float* dif, float* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\nlapack_int LAPACKE_dtgsen_work( int matrix_layout, lapack_int ijob,\n                                lapack_logical wantq, lapack_logical wantz,\n                                const lapack_logical* select, lapack_int n,\n                                double* a, lapack_int lda, double* b,\n                                lapack_int ldb, double* alphar, double* alphai,\n                                double* beta, double* q, lapack_int ldq,\n                                double* z, lapack_int ldz, lapack_int* m,\n                                double* pl, double* pr, double* dif,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_ctgsen_work( int matrix_layout, lapack_int ijob,\n                                lapack_logical wantq, lapack_logical wantz,\n                                const lapack_logical* select, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* alpha,\n                                lapack_complex_float* beta,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_complex_float* z, lapack_int ldz,\n                                lapack_int* m, float* pl, float* pr, float* dif,\n                                lapack_complex_float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_ztgsen_work( int matrix_layout, lapack_int ijob,\n                                lapack_logical wantq, lapack_logical wantz,\n                                const lapack_logical* select, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* alpha,\n                                lapack_complex_double* beta,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_complex_double* z, lapack_int ldz,\n                                lapack_int* m, double* pl, double* pr,\n                                double* dif, lapack_complex_double* work,\n                                lapack_int lwork, lapack_int* iwork,\n                                lapack_int liwork );\n\nlapack_int LAPACKE_stgsja_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int p,\n                                lapack_int n, lapack_int k, lapack_int l,\n                                float* a, lapack_int lda, float* b,\n                                lapack_int ldb, float tola, float tolb,\n                                float* alpha, float* beta, float* u,\n                                lapack_int ldu, float* v, lapack_int ldv,\n                                float* q, lapack_int ldq, float* work,\n                                lapack_int* ncycle );\nlapack_int LAPACKE_dtgsja_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int p,\n                                lapack_int n, lapack_int k, lapack_int l,\n                                double* a, lapack_int lda, double* b,\n                                lapack_int ldb, double tola, double tolb,\n                                double* alpha, double* beta, double* u,\n                                lapack_int ldu, double* v, lapack_int ldv,\n                                double* q, lapack_int ldq, double* work,\n                                lapack_int* ncycle );\nlapack_int LAPACKE_ctgsja_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int p,\n                                lapack_int n, lapack_int k, lapack_int l,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                float tola, float tolb, float* alpha,\n                                float* beta, lapack_complex_float* u,\n                                lapack_int ldu, lapack_complex_float* v,\n                                lapack_int ldv, lapack_complex_float* q,\n                                lapack_int ldq, lapack_complex_float* work,\n                                lapack_int* ncycle );\nlapack_int LAPACKE_ztgsja_work( int matrix_layout, char jobu, char jobv,\n                                char jobq, lapack_int m, lapack_int p,\n                                lapack_int n, lapack_int k, lapack_int l,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                double tola, double tolb, double* alpha,\n                                double* beta, lapack_complex_double* u,\n                                lapack_int ldu, lapack_complex_double* v,\n                                lapack_int ldv, lapack_complex_double* q,\n                                lapack_int ldq, lapack_complex_double* work,\n                                lapack_int* ncycle );\n\nlapack_int LAPACKE_stgsna_work( int matrix_layout, char job, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const float* a, lapack_int lda, const float* b,\n                                lapack_int ldb, const float* vl,\n                                lapack_int ldvl, const float* vr,\n                                lapack_int ldvr, float* s, float* dif,\n                                lapack_int mm, lapack_int* m, float* work,\n                                lapack_int lwork, lapack_int* iwork );\nlapack_int LAPACKE_dtgsna_work( int matrix_layout, char job, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const double* a, lapack_int lda,\n                                const double* b, lapack_int ldb,\n                                const double* vl, lapack_int ldvl,\n                                const double* vr, lapack_int ldvr, double* s,\n                                double* dif, lapack_int mm, lapack_int* m,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_ctgsna_work( int matrix_layout, char job, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                const lapack_complex_float* vl, lapack_int ldvl,\n                                const lapack_complex_float* vr, lapack_int ldvr,\n                                float* s, float* dif, lapack_int mm,\n                                lapack_int* m, lapack_complex_float* work,\n                                lapack_int lwork, lapack_int* iwork );\nlapack_int LAPACKE_ztgsna_work( int matrix_layout, char job, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                const lapack_complex_double* vl,\n                                lapack_int ldvl,\n                                const lapack_complex_double* vr,\n                                lapack_int ldvr, double* s, double* dif,\n                                lapack_int mm, lapack_int* m,\n                                lapack_complex_double* work, lapack_int lwork,\n                                lapack_int* iwork );\n\nlapack_int LAPACKE_stgsyl_work( int matrix_layout, char trans, lapack_int ijob,\n                                lapack_int m, lapack_int n, const float* a,\n                                lapack_int lda, const float* b, lapack_int ldb,\n                                float* c, lapack_int ldc, const float* d,\n                                lapack_int ldd, const float* e, lapack_int lde,\n                                float* f, lapack_int ldf, float* scale,\n                                float* dif, float* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dtgsyl_work( int matrix_layout, char trans, lapack_int ijob,\n                                lapack_int m, lapack_int n, const double* a,\n                                lapack_int lda, const double* b, lapack_int ldb,\n                                double* c, lapack_int ldc, const double* d,\n                                lapack_int ldd, const double* e, lapack_int lde,\n                                double* f, lapack_int ldf, double* scale,\n                                double* dif, double* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_ctgsyl_work( int matrix_layout, char trans, lapack_int ijob,\n                                lapack_int m, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* c, lapack_int ldc,\n                                const lapack_complex_float* d, lapack_int ldd,\n                                const lapack_complex_float* e, lapack_int lde,\n                                lapack_complex_float* f, lapack_int ldf,\n                                float* scale, float* dif,\n                                lapack_complex_float* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_ztgsyl_work( int matrix_layout, char trans, lapack_int ijob,\n                                lapack_int m, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* c, lapack_int ldc,\n                                const lapack_complex_double* d, lapack_int ldd,\n                                const lapack_complex_double* e, lapack_int lde,\n                                lapack_complex_double* f, lapack_int ldf,\n                                double* scale, double* dif,\n                                lapack_complex_double* work, lapack_int lwork,\n                                lapack_int* iwork );\n\nlapack_int LAPACKE_stpcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n, const float* ap,\n                                float* rcond, float* work, lapack_int* iwork );\nlapack_int LAPACKE_dtpcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n, const double* ap,\n                                double* rcond, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_ctpcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n,\n                                const lapack_complex_float* ap, float* rcond,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_ztpcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n,\n                                const lapack_complex_double* ap, double* rcond,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_stprfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const float* ap, const float* b, lapack_int ldb,\n                                const float* x, lapack_int ldx, float* ferr,\n                                float* berr, float* work, lapack_int* iwork );\nlapack_int LAPACKE_dtprfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const double* ap, const double* b,\n                                lapack_int ldb, const double* x, lapack_int ldx,\n                                double* ferr, double* berr, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_ctprfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* ap,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                const lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_ztprfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                const lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_stptri_work( int matrix_layout, char uplo, char diag,\n                                lapack_int n, float* ap );\nlapack_int LAPACKE_dtptri_work( int matrix_layout, char uplo, char diag,\n                                lapack_int n, double* ap );\nlapack_int LAPACKE_ctptri_work( int matrix_layout, char uplo, char diag,\n                                lapack_int n, lapack_complex_float* ap );\nlapack_int LAPACKE_ztptri_work( int matrix_layout, char uplo, char diag,\n                                lapack_int n, lapack_complex_double* ap );\n\nlapack_int LAPACKE_stptrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const float* ap, float* b, lapack_int ldb );\nlapack_int LAPACKE_dtptrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const double* ap, double* b, lapack_int ldb );\nlapack_int LAPACKE_ctptrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* ap,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_ztptrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* ap,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_stpttf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const float* ap, float* arf );\nlapack_int LAPACKE_dtpttf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const double* ap, double* arf );\nlapack_int LAPACKE_ctpttf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const lapack_complex_float* ap,\n                                lapack_complex_float* arf );\nlapack_int LAPACKE_ztpttf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const lapack_complex_double* ap,\n                                lapack_complex_double* arf );\n\nlapack_int LAPACKE_stpttr_work( int matrix_layout, char uplo, lapack_int n,\n                                const float* ap, float* a, lapack_int lda );\nlapack_int LAPACKE_dtpttr_work( int matrix_layout, char uplo, lapack_int n,\n                                const double* ap, double* a, lapack_int lda );\nlapack_int LAPACKE_ctpttr_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* ap,\n                                lapack_complex_float* a, lapack_int lda );\nlapack_int LAPACKE_ztpttr_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* ap,\n                                lapack_complex_double* a, lapack_int lda );\n\nlapack_int LAPACKE_strcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n, const float* a,\n                                lapack_int lda, float* rcond, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dtrcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n, const double* a,\n                                lapack_int lda, double* rcond, double* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_ctrcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                float* rcond, lapack_complex_float* work,\n                                float* rwork );\nlapack_int LAPACKE_ztrcon_work( int matrix_layout, char norm, char uplo,\n                                char diag, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                double* rcond, lapack_complex_double* work,\n                                double* rwork );\n\nlapack_int LAPACKE_strevc_work( int matrix_layout, char side, char howmny,\n                                lapack_logical* select, lapack_int n,\n                                const float* t, lapack_int ldt, float* vl,\n                                lapack_int ldvl, float* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m, float* work );\nlapack_int LAPACKE_dtrevc_work( int matrix_layout, char side, char howmny,\n                                lapack_logical* select, lapack_int n,\n                                const double* t, lapack_int ldt, double* vl,\n                                lapack_int ldvl, double* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m, double* work );\nlapack_int LAPACKE_ctrevc_work( int matrix_layout, char side, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                lapack_complex_float* t, lapack_int ldt,\n                                lapack_complex_float* vl, lapack_int ldvl,\n                                lapack_complex_float* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_ztrevc_work( int matrix_layout, char side, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                lapack_complex_double* t, lapack_int ldt,\n                                lapack_complex_double* vl, lapack_int ldvl,\n                                lapack_complex_double* vr, lapack_int ldvr,\n                                lapack_int mm, lapack_int* m,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_strexc_work( int matrix_layout, char compq, lapack_int n,\n                                float* t, lapack_int ldt, float* q,\n                                lapack_int ldq, lapack_int* ifst,\n                                lapack_int* ilst, float* work );\nlapack_int LAPACKE_dtrexc_work( int matrix_layout, char compq, lapack_int n,\n                                double* t, lapack_int ldt, double* q,\n                                lapack_int ldq, lapack_int* ifst,\n                                lapack_int* ilst, double* work );\nlapack_int LAPACKE_ctrexc_work( int matrix_layout, char compq, lapack_int n,\n                                lapack_complex_float* t, lapack_int ldt,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_int ifst, lapack_int ilst );\nlapack_int LAPACKE_ztrexc_work( int matrix_layout, char compq, lapack_int n,\n                                lapack_complex_double* t, lapack_int ldt,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_int ifst, lapack_int ilst );\n\nlapack_int LAPACKE_strrfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const float* a, lapack_int lda, const float* b,\n                                lapack_int ldb, const float* x, lapack_int ldx,\n                                float* ferr, float* berr, float* work,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dtrrfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const double* a, lapack_int lda,\n                                const double* b, lapack_int ldb,\n                                const double* x, lapack_int ldx, double* ferr,\n                                double* berr, double* work, lapack_int* iwork );\nlapack_int LAPACKE_ctrrfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                const lapack_complex_float* x, lapack_int ldx,\n                                float* ferr, float* berr,\n                                lapack_complex_float* work, float* rwork );\nlapack_int LAPACKE_ztrrfs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                const lapack_complex_double* x, lapack_int ldx,\n                                double* ferr, double* berr,\n                                lapack_complex_double* work, double* rwork );\n\nlapack_int LAPACKE_strsen_work( int matrix_layout, char job, char compq,\n                                const lapack_logical* select, lapack_int n,\n                                float* t, lapack_int ldt, float* q,\n                                lapack_int ldq, float* wr, float* wi,\n                                lapack_int* m, float* s, float* sep,\n                                float* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_dtrsen_work( int matrix_layout, char job, char compq,\n                                const lapack_logical* select, lapack_int n,\n                                double* t, lapack_int ldt, double* q,\n                                lapack_int ldq, double* wr, double* wi,\n                                lapack_int* m, double* s, double* sep,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork, lapack_int liwork );\nlapack_int LAPACKE_ctrsen_work( int matrix_layout, char job, char compq,\n                                const lapack_logical* select, lapack_int n,\n                                lapack_complex_float* t, lapack_int ldt,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_complex_float* w, lapack_int* m,\n                                float* s, float* sep,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_ztrsen_work( int matrix_layout, char job, char compq,\n                                const lapack_logical* select, lapack_int n,\n                                lapack_complex_double* t, lapack_int ldt,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_complex_double* w, lapack_int* m,\n                                double* s, double* sep,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_strsna_work( int matrix_layout, char job, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const float* t, lapack_int ldt, const float* vl,\n                                lapack_int ldvl, const float* vr,\n                                lapack_int ldvr, float* s, float* sep,\n                                lapack_int mm, lapack_int* m, float* work,\n                                lapack_int ldwork, lapack_int* iwork );\nlapack_int LAPACKE_dtrsna_work( int matrix_layout, char job, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const double* t, lapack_int ldt,\n                                const double* vl, lapack_int ldvl,\n                                const double* vr, lapack_int ldvr, double* s,\n                                double* sep, lapack_int mm, lapack_int* m,\n                                double* work, lapack_int ldwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_ctrsna_work( int matrix_layout, char job, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const lapack_complex_float* t, lapack_int ldt,\n                                const lapack_complex_float* vl, lapack_int ldvl,\n                                const lapack_complex_float* vr, lapack_int ldvr,\n                                float* s, float* sep, lapack_int mm,\n                                lapack_int* m, lapack_complex_float* work,\n                                lapack_int ldwork, float* rwork );\nlapack_int LAPACKE_ztrsna_work( int matrix_layout, char job, char howmny,\n                                const lapack_logical* select, lapack_int n,\n                                const lapack_complex_double* t, lapack_int ldt,\n                                const lapack_complex_double* vl,\n                                lapack_int ldvl,\n                                const lapack_complex_double* vr,\n                                lapack_int ldvr, double* s, double* sep,\n                                lapack_int mm, lapack_int* m,\n                                lapack_complex_double* work, lapack_int ldwork,\n                                double* rwork );\n\nlapack_int LAPACKE_strsyl_work( int matrix_layout, char trana, char tranb,\n                                lapack_int isgn, lapack_int m, lapack_int n,\n                                const float* a, lapack_int lda, const float* b,\n                                lapack_int ldb, float* c, lapack_int ldc,\n                                float* scale );\nlapack_int LAPACKE_dtrsyl_work( int matrix_layout, char trana, char tranb,\n                                lapack_int isgn, lapack_int m, lapack_int n,\n                                const double* a, lapack_int lda,\n                                const double* b, lapack_int ldb, double* c,\n                                lapack_int ldc, double* scale );\nlapack_int LAPACKE_ctrsyl_work( int matrix_layout, char trana, char tranb,\n                                lapack_int isgn, lapack_int m, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* c, lapack_int ldc,\n                                float* scale );\nlapack_int LAPACKE_ztrsyl_work( int matrix_layout, char trana, char tranb,\n                                lapack_int isgn, lapack_int m, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* c, lapack_int ldc,\n                                double* scale );\n\nlapack_int LAPACKE_strtri_work( int matrix_layout, char uplo, char diag,\n                                lapack_int n, float* a, lapack_int lda );\nlapack_int LAPACKE_dtrtri_work( int matrix_layout, char uplo, char diag,\n                                lapack_int n, double* a, lapack_int lda );\nlapack_int LAPACKE_ctrtri_work( int matrix_layout, char uplo, char diag,\n                                lapack_int n, lapack_complex_float* a,\n                                lapack_int lda );\nlapack_int LAPACKE_ztrtri_work( int matrix_layout, char uplo, char diag,\n                                lapack_int n, lapack_complex_double* a,\n                                lapack_int lda );\n\nlapack_int LAPACKE_strtrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const float* a, lapack_int lda, float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_dtrtrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const double* a, lapack_int lda, double* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_ctrtrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_ztrtrs_work( int matrix_layout, char uplo, char trans,\n                                char diag, lapack_int n, lapack_int nrhs,\n                                const lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_strttf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const float* a, lapack_int lda,\n                                float* arf );\nlapack_int LAPACKE_dtrttf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const double* a, lapack_int lda,\n                                double* arf );\nlapack_int LAPACKE_ctrttf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* arf );\nlapack_int LAPACKE_ztrttf_work( int matrix_layout, char transr, char uplo,\n                                lapack_int n, const lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* arf );\n\nlapack_int LAPACKE_strttp_work( int matrix_layout, char uplo, lapack_int n,\n                                const float* a, lapack_int lda, float* ap );\nlapack_int LAPACKE_dtrttp_work( int matrix_layout, char uplo, lapack_int n,\n                                const double* a, lapack_int lda, double* ap );\nlapack_int LAPACKE_ctrttp_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* ap );\nlapack_int LAPACKE_ztrttp_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* ap );\n\nlapack_int LAPACKE_stzrzf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                float* a, lapack_int lda, float* tau,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dtzrzf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                double* a, lapack_int lda, double* tau,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_ctzrzf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_ztzrzf_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cungbr_work( int matrix_layout, char vect, lapack_int m,\n                                lapack_int n, lapack_int k,\n                                lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zungbr_work( int matrix_layout, char vect, lapack_int m,\n                                lapack_int n, lapack_int k,\n                                lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunghr_work( int matrix_layout, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunghr_work( int matrix_layout, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, lapack_complex_double* a,\n                                lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunglq_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunglq_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, lapack_complex_double* a,\n                                lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cungql_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zungql_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, lapack_complex_double* a,\n                                lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cungqr_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zungqr_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, lapack_complex_double* a,\n                                lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cungrq_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zungrq_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int k, lapack_complex_double* a,\n                                lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cungtr_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zungtr_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunmbr_work( int matrix_layout, char vect, char side,\n                                char trans, lapack_int m, lapack_int n,\n                                lapack_int k, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunmbr_work( int matrix_layout, char vect, char side,\n                                char trans, lapack_int m, lapack_int n,\n                                lapack_int k, const lapack_complex_double* a,\n                                lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunmhr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunmhr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int ilo,\n                                lapack_int ihi, const lapack_complex_double* a,\n                                lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunmlq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunmlq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunmql_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunmql_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunmqr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunmqr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunmrq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunmrq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunmrz_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                lapack_int l, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_complex_float* tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunmrz_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                lapack_int l, const lapack_complex_double* a,\n                                lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cunmtr_work( int matrix_layout, char side, char uplo,\n                                char trans, lapack_int m, lapack_int n,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zunmtr_work( int matrix_layout, char side, char uplo,\n                                char trans, lapack_int m, lapack_int n,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_cupgtr_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_float* ap,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* q, lapack_int ldq,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zupgtr_work( int matrix_layout, char uplo, lapack_int n,\n                                const lapack_complex_double* ap,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* q, lapack_int ldq,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_cupmtr_work( int matrix_layout, char side, char uplo,\n                                char trans, lapack_int m, lapack_int n,\n                                const lapack_complex_float* ap,\n                                const lapack_complex_float* tau,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_zupmtr_work( int matrix_layout, char side, char uplo,\n                                char trans, lapack_int m, lapack_int n,\n                                const lapack_complex_double* ap,\n                                const lapack_complex_double* tau,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work );\n\n\nlapack_int LAPACKE_slapmr( int matrix_layout, lapack_logical forwrd,\n                           lapack_int m, lapack_int n, float* x, lapack_int ldx,\n                           lapack_int* k );\nlapack_int LAPACKE_dlapmr( int matrix_layout, lapack_logical forwrd,\n                           lapack_int m, lapack_int n, double* x,\n                           lapack_int ldx, lapack_int* k );\nlapack_int LAPACKE_clapmr( int matrix_layout, lapack_logical forwrd,\n                           lapack_int m, lapack_int n, lapack_complex_float* x,\n                           lapack_int ldx, lapack_int* k );\nlapack_int LAPACKE_zlapmr( int matrix_layout, lapack_logical forwrd,\n                           lapack_int m, lapack_int n, lapack_complex_double* x,\n                           lapack_int ldx, lapack_int* k );\n\nlapack_int LAPACKE_slapmt( int matrix_layout, lapack_logical forwrd,\n                           lapack_int m, lapack_int n, float* x, lapack_int ldx,\n                           lapack_int* k );\nlapack_int LAPACKE_dlapmt( int matrix_layout, lapack_logical forwrd,\n                           lapack_int m, lapack_int n, double* x,\n                           lapack_int ldx, lapack_int* k );\nlapack_int LAPACKE_clapmt( int matrix_layout, lapack_logical forwrd,\n                           lapack_int m, lapack_int n, lapack_complex_float* x,\n                           lapack_int ldx, lapack_int* k );\nlapack_int LAPACKE_zlapmt( int matrix_layout, lapack_logical forwrd,\n                           lapack_int m, lapack_int n, lapack_complex_double* x,\n                           lapack_int ldx, lapack_int* k );\n\nfloat LAPACKE_slapy2( float x, float y );\ndouble LAPACKE_dlapy2( double x, double y );\n\nfloat LAPACKE_slapy3( float x, float y, float z );\ndouble LAPACKE_dlapy3( double x, double y, double z );\n\nlapack_int LAPACKE_slartgp( float f, float g, float* cs, float* sn, float* r );\nlapack_int LAPACKE_dlartgp( double f, double g, double* cs, double* sn,\n                            double* r );\n\nlapack_int LAPACKE_slartgs( float x, float y, float sigma, float* cs,\n                            float* sn );\nlapack_int LAPACKE_dlartgs( double x, double y, double sigma, double* cs,\n                            double* sn );\n\n\n/* LAPACK 3.3.0 */\nlapack_int LAPACKE_cbbcsd( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, char jobv2t, char trans, lapack_int m,\n                           lapack_int p, lapack_int q, float* theta, float* phi,\n                           lapack_complex_float* u1, lapack_int ldu1,\n                           lapack_complex_float* u2, lapack_int ldu2,\n                           lapack_complex_float* v1t, lapack_int ldv1t,\n                           lapack_complex_float* v2t, lapack_int ldv2t,\n                           float* b11d, float* b11e, float* b12d, float* b12e,\n                           float* b21d, float* b21e, float* b22d, float* b22e );\nlapack_int LAPACKE_cbbcsd_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, char jobv2t, char trans,\n                                lapack_int m, lapack_int p, lapack_int q,\n                                float* theta, float* phi,\n                                lapack_complex_float* u1, lapack_int ldu1,\n                                lapack_complex_float* u2, lapack_int ldu2,\n                                lapack_complex_float* v1t, lapack_int ldv1t,\n                                lapack_complex_float* v2t, lapack_int ldv2t,\n                                float* b11d, float* b11e, float* b12d,\n                                float* b12e, float* b21d, float* b21e,\n                                float* b22d, float* b22e, float* rwork,\n                                lapack_int lrwork );\nlapack_int LAPACKE_cheswapr( int matrix_layout, char uplo, lapack_int n,\n                             lapack_complex_float* a, lapack_int lda,\n                             lapack_int i1, lapack_int i2 );\nlapack_int LAPACKE_cheswapr_work( int matrix_layout, char uplo, lapack_int n,\n                                  lapack_complex_float* a, lapack_int lda,\n                                  lapack_int i1, lapack_int i2 );\nlapack_int LAPACKE_chetri2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_complex_float* a, lapack_int lda,\n                            const lapack_int* ipiv );\nlapack_int LAPACKE_chetri2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_complex_float* a, lapack_int lda,\n                                 const lapack_int* ipiv,\n                                 lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_chetri2x( int matrix_layout, char uplo, lapack_int n,\n                             lapack_complex_float* a, lapack_int lda,\n                             const lapack_int* ipiv, lapack_int nb );\nlapack_int LAPACKE_chetri2x_work( int matrix_layout, char uplo, lapack_int n,\n                                  lapack_complex_float* a, lapack_int lda,\n                                  const lapack_int* ipiv,\n                                  lapack_complex_float* work, lapack_int nb );\nlapack_int LAPACKE_chetrs2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_int nrhs, const lapack_complex_float* a,\n                            lapack_int lda, const lapack_int* ipiv,\n                            lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_chetrs2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_int nrhs, const lapack_complex_float* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 lapack_complex_float* b, lapack_int ldb,\n                                 lapack_complex_float* work );\nlapack_int LAPACKE_csyconv( int matrix_layout, char uplo, char way, lapack_int n,\n                            lapack_complex_float* a, lapack_int lda,\n                            const lapack_int* ipiv, lapack_complex_float* e  );\nlapack_int LAPACKE_csyconv_work( int matrix_layout, char uplo, char way,\n                                 lapack_int n, lapack_complex_float* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 lapack_complex_float* e );\nlapack_int LAPACKE_csyswapr( int matrix_layout, char uplo, lapack_int n,\n                             lapack_complex_float* a, lapack_int lda,\n                             lapack_int i1, lapack_int i2 );\nlapack_int LAPACKE_csyswapr_work( int matrix_layout, char uplo, lapack_int n,\n                                  lapack_complex_float* a, lapack_int lda,\n                                  lapack_int i1, lapack_int i2 );\nlapack_int LAPACKE_csytri2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_complex_float* a, lapack_int lda,\n                            const lapack_int* ipiv );\nlapack_int LAPACKE_csytri2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_complex_float* a, lapack_int lda,\n                                 const lapack_int* ipiv,\n                                 lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_csytri2x( int matrix_layout, char uplo, lapack_int n,\n                             lapack_complex_float* a, lapack_int lda,\n                             const lapack_int* ipiv, lapack_int nb );\nlapack_int LAPACKE_csytri2x_work( int matrix_layout, char uplo, lapack_int n,\n                                  lapack_complex_float* a, lapack_int lda,\n                                  const lapack_int* ipiv,\n                                  lapack_complex_float* work, lapack_int nb );\nlapack_int LAPACKE_csytrs2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_int nrhs, const lapack_complex_float* a,\n                            lapack_int lda, const lapack_int* ipiv,\n                            lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_csytrs2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_int nrhs, const lapack_complex_float* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 lapack_complex_float* b, lapack_int ldb,\n                                 lapack_complex_float* work );\nlapack_int LAPACKE_cunbdb( int matrix_layout, char trans, char signs,\n                           lapack_int m, lapack_int p, lapack_int q,\n                           lapack_complex_float* x11, lapack_int ldx11,\n                           lapack_complex_float* x12, lapack_int ldx12,\n                           lapack_complex_float* x21, lapack_int ldx21,\n                           lapack_complex_float* x22, lapack_int ldx22,\n                           float* theta, float* phi,\n                           lapack_complex_float* taup1,\n                           lapack_complex_float* taup2,\n                           lapack_complex_float* tauq1,\n                           lapack_complex_float* tauq2 );\nlapack_int LAPACKE_cunbdb_work( int matrix_layout, char trans, char signs,\n                                lapack_int m, lapack_int p, lapack_int q,\n                                lapack_complex_float* x11, lapack_int ldx11,\n                                lapack_complex_float* x12, lapack_int ldx12,\n                                lapack_complex_float* x21, lapack_int ldx21,\n                                lapack_complex_float* x22, lapack_int ldx22,\n                                float* theta, float* phi,\n                                lapack_complex_float* taup1,\n                                lapack_complex_float* taup2,\n                                lapack_complex_float* tauq1,\n                                lapack_complex_float* tauq2,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_cuncsd( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, char jobv2t, char trans, char signs,\n                           lapack_int m, lapack_int p, lapack_int q,\n                           lapack_complex_float* x11, lapack_int ldx11,\n                           lapack_complex_float* x12, lapack_int ldx12,\n                           lapack_complex_float* x21, lapack_int ldx21,\n                           lapack_complex_float* x22, lapack_int ldx22,\n                           float* theta, lapack_complex_float* u1,\n                           lapack_int ldu1, lapack_complex_float* u2,\n                           lapack_int ldu2, lapack_complex_float* v1t,\n                           lapack_int ldv1t, lapack_complex_float* v2t,\n                           lapack_int ldv2t );\nlapack_int LAPACKE_cuncsd_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, char jobv2t, char trans,\n                                char signs, lapack_int m, lapack_int p,\n                                lapack_int q, lapack_complex_float* x11,\n                                lapack_int ldx11, lapack_complex_float* x12,\n                                lapack_int ldx12, lapack_complex_float* x21,\n                                lapack_int ldx21, lapack_complex_float* x22,\n                                lapack_int ldx22, float* theta,\n                                lapack_complex_float* u1, lapack_int ldu1,\n                                lapack_complex_float* u2, lapack_int ldu2,\n                                lapack_complex_float* v1t, lapack_int ldv1t,\n                                lapack_complex_float* v2t, lapack_int ldv2t,\n                                lapack_complex_float* work, lapack_int lwork,\n                                float* rwork, lapack_int lrwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_cuncsd2by1( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, lapack_int m, lapack_int p, lapack_int q,\n                           lapack_complex_float* x11, lapack_int ldx11,\n                           lapack_complex_float* x21, lapack_int ldx21,\n                           float* theta, lapack_complex_float* u1,\n                           lapack_int ldu1, lapack_complex_float* u2,\n                           lapack_int ldu2, lapack_complex_float* v1t, lapack_int ldv1t );\nlapack_int LAPACKE_cuncsd2by1_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, lapack_int m, lapack_int p,\n                                lapack_int q, lapack_complex_float* x11, lapack_int ldx11,\n                                lapack_complex_float* x21, lapack_int ldx21,\n                                float* theta, lapack_complex_float* u1,\n                                lapack_int ldu1, lapack_complex_float* u2,\n                                lapack_int ldu2, lapack_complex_float* v1t,\n                                lapack_int ldv1t, lapack_complex_float* work,\n                                lapack_int lwork, float* rwork, lapack_int lrwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dbbcsd( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, char jobv2t, char trans, lapack_int m,\n                           lapack_int p, lapack_int q, double* theta,\n                           double* phi, double* u1, lapack_int ldu1, double* u2,\n                           lapack_int ldu2, double* v1t, lapack_int ldv1t,\n                           double* v2t, lapack_int ldv2t, double* b11d,\n                           double* b11e, double* b12d, double* b12e,\n                           double* b21d, double* b21e, double* b22d,\n                           double* b22e );\nlapack_int LAPACKE_dbbcsd_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, char jobv2t, char trans,\n                                lapack_int m, lapack_int p, lapack_int q,\n                                double* theta, double* phi, double* u1,\n                                lapack_int ldu1, double* u2, lapack_int ldu2,\n                                double* v1t, lapack_int ldv1t, double* v2t,\n                                lapack_int ldv2t, double* b11d, double* b11e,\n                                double* b12d, double* b12e, double* b21d,\n                                double* b21e, double* b22d, double* b22e,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_dorbdb( int matrix_layout, char trans, char signs,\n                           lapack_int m, lapack_int p, lapack_int q,\n                           double* x11, lapack_int ldx11, double* x12,\n                           lapack_int ldx12, double* x21, lapack_int ldx21,\n                           double* x22, lapack_int ldx22, double* theta,\n                           double* phi, double* taup1, double* taup2,\n                           double* tauq1, double* tauq2 );\nlapack_int LAPACKE_dorbdb_work( int matrix_layout, char trans, char signs,\n                                lapack_int m, lapack_int p, lapack_int q,\n                                double* x11, lapack_int ldx11, double* x12,\n                                lapack_int ldx12, double* x21, lapack_int ldx21,\n                                double* x22, lapack_int ldx22, double* theta,\n                                double* phi, double* taup1, double* taup2,\n                                double* tauq1, double* tauq2, double* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_dorcsd( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, char jobv2t, char trans, char signs,\n                           lapack_int m, lapack_int p, lapack_int q,\n                           double* x11, lapack_int ldx11, double* x12,\n                           lapack_int ldx12, double* x21, lapack_int ldx21,\n                           double* x22, lapack_int ldx22, double* theta,\n                           double* u1, lapack_int ldu1, double* u2,\n                           lapack_int ldu2, double* v1t, lapack_int ldv1t,\n                           double* v2t, lapack_int ldv2t );\nlapack_int LAPACKE_dorcsd_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, char jobv2t, char trans,\n                                char signs, lapack_int m, lapack_int p,\n                                lapack_int q, double* x11, lapack_int ldx11,\n                                double* x12, lapack_int ldx12, double* x21,\n                                lapack_int ldx21, double* x22, lapack_int ldx22,\n                                double* theta, double* u1, lapack_int ldu1,\n                                double* u2, lapack_int ldu2, double* v1t,\n                                lapack_int ldv1t, double* v2t, lapack_int ldv2t,\n                                double* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_dorcsd2by1( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, lapack_int m, lapack_int p, lapack_int q,\n                           double* x11, lapack_int ldx11, double* x21, lapack_int ldx21,\n                           double* theta, double* u1, lapack_int ldu1, double* u2,\n                           lapack_int ldu2, double* v1t, lapack_int ldv1t);\nlapack_int LAPACKE_dorcsd2by1_work( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, lapack_int m, lapack_int p, lapack_int q,\n                           double* x11, lapack_int ldx11, double* x21, lapack_int ldx21,\n                           double* theta, double* u1, lapack_int ldu1, double* u2,\n                           lapack_int ldu2, double* v1t, lapack_int ldv1t,\n                           double* work, lapack_int lwork, lapack_int* iwork );\nlapack_int LAPACKE_dsyconv( int matrix_layout, char uplo, char way, lapack_int n,\n                            double* a, lapack_int lda, const lapack_int* ipiv, double* e);\nlapack_int LAPACKE_dsyconv_work( int matrix_layout, char uplo, char way,\n                                 lapack_int n, double* a, lapack_int lda,\n                                 const lapack_int* ipiv, double* e );\nlapack_int LAPACKE_dsyswapr( int matrix_layout, char uplo, lapack_int n,\n                             double* a, lapack_int lda, lapack_int i1,\n                             lapack_int i2 );\nlapack_int LAPACKE_dsyswapr_work( int matrix_layout, char uplo, lapack_int n,\n                                  double* a, lapack_int lda, lapack_int i1,\n                                  lapack_int i2 );\nlapack_int LAPACKE_dsytri2( int matrix_layout, char uplo, lapack_int n,\n                            double* a, lapack_int lda, const lapack_int* ipiv );\nlapack_int LAPACKE_dsytri2_work( int matrix_layout, char uplo, lapack_int n,\n                                 double* a, lapack_int lda,\n                                 const lapack_int* ipiv,\n                                 double* work, lapack_int lwork );\nlapack_int LAPACKE_dsytri2x( int matrix_layout, char uplo, lapack_int n,\n                             double* a, lapack_int lda, const lapack_int* ipiv,\n                             lapack_int nb );\nlapack_int LAPACKE_dsytri2x_work( int matrix_layout, char uplo, lapack_int n,\n                                  double* a, lapack_int lda,\n                                  const lapack_int* ipiv, double* work,\n                                  lapack_int nb );\nlapack_int LAPACKE_dsytrs2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_int nrhs, const double* a, lapack_int lda,\n                            const lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_dsytrs2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_int nrhs, const double* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 double* b, lapack_int ldb, double* work );\nlapack_int LAPACKE_sbbcsd( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, char jobv2t, char trans, lapack_int m,\n                           lapack_int p, lapack_int q, float* theta, float* phi,\n                           float* u1, lapack_int ldu1, float* u2,\n                           lapack_int ldu2, float* v1t, lapack_int ldv1t,\n                           float* v2t, lapack_int ldv2t, float* b11d,\n                           float* b11e, float* b12d, float* b12e, float* b21d,\n                           float* b21e, float* b22d, float* b22e );\nlapack_int LAPACKE_sbbcsd_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, char jobv2t, char trans,\n                                lapack_int m, lapack_int p, lapack_int q,\n                                float* theta, float* phi, float* u1,\n                                lapack_int ldu1, float* u2, lapack_int ldu2,\n                                float* v1t, lapack_int ldv1t, float* v2t,\n                                lapack_int ldv2t, float* b11d, float* b11e,\n                                float* b12d, float* b12e, float* b21d,\n                                float* b21e, float* b22d, float* b22e,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_sorbdb( int matrix_layout, char trans, char signs,\n                           lapack_int m, lapack_int p, lapack_int q, float* x11,\n                           lapack_int ldx11, float* x12, lapack_int ldx12,\n                           float* x21, lapack_int ldx21, float* x22,\n                           lapack_int ldx22, float* theta, float* phi,\n                           float* taup1, float* taup2, float* tauq1,\n                           float* tauq2 );\nlapack_int LAPACKE_sorbdb_work( int matrix_layout, char trans, char signs,\n                                lapack_int m, lapack_int p, lapack_int q,\n                                float* x11, lapack_int ldx11, float* x12,\n                                lapack_int ldx12, float* x21, lapack_int ldx21,\n                                float* x22, lapack_int ldx22, float* theta,\n                                float* phi, float* taup1, float* taup2,\n                                float* tauq1, float* tauq2, float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_sorcsd( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, char jobv2t, char trans, char signs,\n                           lapack_int m, lapack_int p, lapack_int q, float* x11,\n                           lapack_int ldx11, float* x12, lapack_int ldx12,\n                           float* x21, lapack_int ldx21, float* x22,\n                           lapack_int ldx22, float* theta, float* u1,\n                           lapack_int ldu1, float* u2, lapack_int ldu2,\n                           float* v1t, lapack_int ldv1t, float* v2t,\n                           lapack_int ldv2t );\nlapack_int LAPACKE_sorcsd_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, char jobv2t, char trans,\n                                char signs, lapack_int m, lapack_int p,\n                                lapack_int q, float* x11, lapack_int ldx11,\n                                float* x12, lapack_int ldx12, float* x21,\n                                lapack_int ldx21, float* x22, lapack_int ldx22,\n                                float* theta, float* u1, lapack_int ldu1,\n                                float* u2, lapack_int ldu2, float* v1t,\n                                lapack_int ldv1t, float* v2t, lapack_int ldv2t,\n                                float* work, lapack_int lwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_sorcsd2by1( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, lapack_int m, lapack_int p, lapack_int q,\n                           float* x11, lapack_int ldx11, float* x21, lapack_int ldx21,\n                           float* theta, float* u1, lapack_int ldu1, float* u2,\n                           lapack_int ldu2, float* v1t, lapack_int ldv1t);\nlapack_int LAPACKE_sorcsd2by1_work( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, lapack_int m, lapack_int p, lapack_int q,\n                           float* x11, lapack_int ldx11, float* x21, lapack_int ldx21,\n                           float* theta, float* u1, lapack_int ldu1, float* u2,\n                           lapack_int ldu2, float* v1t, lapack_int ldv1t,\n                           float* work, lapack_int lwork, lapack_int* iwork );\nlapack_int LAPACKE_ssyconv( int matrix_layout, char uplo, char way, lapack_int n,\n                            float* a, lapack_int lda, const lapack_int* ipiv, float* e );\nlapack_int LAPACKE_ssyconv_work( int matrix_layout, char uplo, char way,\n                                 lapack_int n, float* a, lapack_int lda,\n                                 const lapack_int* ipiv, float* e );\nlapack_int LAPACKE_ssyswapr( int matrix_layout, char uplo, lapack_int n,\n                             float* a, lapack_int lda, lapack_int i1,\n                             lapack_int i2 );\nlapack_int LAPACKE_ssyswapr_work( int matrix_layout, char uplo, lapack_int n,\n                                  float* a, lapack_int lda, lapack_int i1,\n                                  lapack_int i2 );\nlapack_int LAPACKE_ssytri2( int matrix_layout, char uplo, lapack_int n, float* a,\n                            lapack_int lda, const lapack_int* ipiv );\nlapack_int LAPACKE_ssytri2_work( int matrix_layout, char uplo, lapack_int n,\n                                 float* a, lapack_int lda,\n                                 const lapack_int* ipiv,\n                                 float* work, lapack_int lwork );\nlapack_int LAPACKE_ssytri2x( int matrix_layout, char uplo, lapack_int n,\n                             float* a, lapack_int lda, const lapack_int* ipiv,\n                             lapack_int nb );\nlapack_int LAPACKE_ssytri2x_work( int matrix_layout, char uplo, lapack_int n,\n                                  float* a, lapack_int lda,\n                                  const lapack_int* ipiv, float* work,\n                                  lapack_int nb );\nlapack_int LAPACKE_ssytrs2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_int nrhs, const float* a, lapack_int lda,\n                            const lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_ssytrs2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_int nrhs, const float* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 float* b, lapack_int ldb, float* work );\nlapack_int LAPACKE_zbbcsd( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, char jobv2t, char trans, lapack_int m,\n                           lapack_int p, lapack_int q, double* theta,\n                           double* phi, lapack_complex_double* u1,\n                           lapack_int ldu1, lapack_complex_double* u2,\n                           lapack_int ldu2, lapack_complex_double* v1t,\n                           lapack_int ldv1t, lapack_complex_double* v2t,\n                           lapack_int ldv2t, double* b11d, double* b11e,\n                           double* b12d, double* b12e, double* b21d,\n                           double* b21e, double* b22d, double* b22e );\nlapack_int LAPACKE_zbbcsd_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, char jobv2t, char trans,\n                                lapack_int m, lapack_int p, lapack_int q,\n                                double* theta, double* phi,\n                                lapack_complex_double* u1, lapack_int ldu1,\n                                lapack_complex_double* u2, lapack_int ldu2,\n                                lapack_complex_double* v1t, lapack_int ldv1t,\n                                lapack_complex_double* v2t, lapack_int ldv2t,\n                                double* b11d, double* b11e, double* b12d,\n                                double* b12e, double* b21d, double* b21e,\n                                double* b22d, double* b22e, double* rwork,\n                                lapack_int lrwork );\nlapack_int LAPACKE_zheswapr( int matrix_layout, char uplo, lapack_int n,\n                             lapack_complex_double* a, lapack_int lda,\n                             lapack_int i1, lapack_int i2 );\nlapack_int LAPACKE_zheswapr_work( int matrix_layout, char uplo, lapack_int n,\n                                  lapack_complex_double* a, lapack_int lda,\n                                  lapack_int i1, lapack_int i2 );\nlapack_int LAPACKE_zhetri2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_complex_double* a, lapack_int lda,\n                            const lapack_int* ipiv );\nlapack_int LAPACKE_zhetri2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_complex_double* a, lapack_int lda,\n                                 const lapack_int* ipiv,\n                                 lapack_complex_double* work, lapack_int lwork );\nlapack_int LAPACKE_zhetri2x( int matrix_layout, char uplo, lapack_int n,\n                             lapack_complex_double* a, lapack_int lda,\n                             const lapack_int* ipiv, lapack_int nb );\nlapack_int LAPACKE_zhetri2x_work( int matrix_layout, char uplo, lapack_int n,\n                                  lapack_complex_double* a, lapack_int lda,\n                                  const lapack_int* ipiv,\n                                  lapack_complex_double* work, lapack_int nb );\nlapack_int LAPACKE_zhetrs2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_int nrhs, const lapack_complex_double* a,\n                            lapack_int lda, const lapack_int* ipiv,\n                            lapack_complex_double* b, lapack_int ldb );\nlapack_int LAPACKE_zhetrs2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_int nrhs, const lapack_complex_double* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 lapack_complex_double* b, lapack_int ldb,\n                                 lapack_complex_double* work );\nlapack_int LAPACKE_zsyconv( int matrix_layout, char uplo, char way, lapack_int n,\n                            lapack_complex_double* a, lapack_int lda,\n                            const lapack_int* ipiv, lapack_complex_double* e );\nlapack_int LAPACKE_zsyconv_work( int matrix_layout, char uplo, char way,\n                                 lapack_int n, lapack_complex_double* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 lapack_complex_double* e );\nlapack_int LAPACKE_zsyswapr( int matrix_layout, char uplo, lapack_int n,\n                             lapack_complex_double* a, lapack_int lda,\n                             lapack_int i1, lapack_int i2 );\nlapack_int LAPACKE_zsyswapr_work( int matrix_layout, char uplo, lapack_int n,\n                                  lapack_complex_double* a, lapack_int lda,\n                                  lapack_int i1, lapack_int i2 );\nlapack_int LAPACKE_zsytri2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_complex_double* a, lapack_int lda,\n                            const lapack_int* ipiv );\nlapack_int LAPACKE_zsytri2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_complex_double* a, lapack_int lda,\n                                 const lapack_int* ipiv,\n                                 lapack_complex_double* work, lapack_int lwork );\nlapack_int LAPACKE_zsytri2x( int matrix_layout, char uplo, lapack_int n,\n                             lapack_complex_double* a, lapack_int lda,\n                             const lapack_int* ipiv, lapack_int nb );\nlapack_int LAPACKE_zsytri2x_work( int matrix_layout, char uplo, lapack_int n,\n                                  lapack_complex_double* a, lapack_int lda,\n                                  const lapack_int* ipiv,\n                                  lapack_complex_double* work, lapack_int nb );\nlapack_int LAPACKE_zsytrs2( int matrix_layout, char uplo, lapack_int n,\n                            lapack_int nrhs, const lapack_complex_double* a,\n                            lapack_int lda, const lapack_int* ipiv,\n                            lapack_complex_double* b, lapack_int ldb );\nlapack_int LAPACKE_zsytrs2_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_int nrhs, const lapack_complex_double* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 lapack_complex_double* b, lapack_int ldb,\n                                 lapack_complex_double* work );\nlapack_int LAPACKE_zunbdb( int matrix_layout, char trans, char signs,\n                           lapack_int m, lapack_int p, lapack_int q,\n                           lapack_complex_double* x11, lapack_int ldx11,\n                           lapack_complex_double* x12, lapack_int ldx12,\n                           lapack_complex_double* x21, lapack_int ldx21,\n                           lapack_complex_double* x22, lapack_int ldx22,\n                           double* theta, double* phi,\n                           lapack_complex_double* taup1,\n                           lapack_complex_double* taup2,\n                           lapack_complex_double* tauq1,\n                           lapack_complex_double* tauq2 );\nlapack_int LAPACKE_zunbdb_work( int matrix_layout, char trans, char signs,\n                                lapack_int m, lapack_int p, lapack_int q,\n                                lapack_complex_double* x11, lapack_int ldx11,\n                                lapack_complex_double* x12, lapack_int ldx12,\n                                lapack_complex_double* x21, lapack_int ldx21,\n                                lapack_complex_double* x22, lapack_int ldx22,\n                                double* theta, double* phi,\n                                lapack_complex_double* taup1,\n                                lapack_complex_double* taup2,\n                                lapack_complex_double* tauq1,\n                                lapack_complex_double* tauq2,\n                                lapack_complex_double* work, lapack_int lwork );\nlapack_int LAPACKE_zuncsd( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, char jobv2t, char trans, char signs,\n                           lapack_int m, lapack_int p, lapack_int q,\n                           lapack_complex_double* x11, lapack_int ldx11,\n                           lapack_complex_double* x12, lapack_int ldx12,\n                           lapack_complex_double* x21, lapack_int ldx21,\n                           lapack_complex_double* x22, lapack_int ldx22,\n                           double* theta, lapack_complex_double* u1,\n                           lapack_int ldu1, lapack_complex_double* u2,\n                           lapack_int ldu2, lapack_complex_double* v1t,\n                           lapack_int ldv1t, lapack_complex_double* v2t,\n                           lapack_int ldv2t );\nlapack_int LAPACKE_zuncsd_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, char jobv2t, char trans,\n                                char signs, lapack_int m, lapack_int p,\n                                lapack_int q, lapack_complex_double* x11,\n                                lapack_int ldx11, lapack_complex_double* x12,\n                                lapack_int ldx12, lapack_complex_double* x21,\n                                lapack_int ldx21, lapack_complex_double* x22,\n                                lapack_int ldx22, double* theta,\n                                lapack_complex_double* u1, lapack_int ldu1,\n                                lapack_complex_double* u2, lapack_int ldu2,\n                                lapack_complex_double* v1t, lapack_int ldv1t,\n                                lapack_complex_double* v2t, lapack_int ldv2t,\n                                lapack_complex_double* work, lapack_int lwork,\n                                double* rwork, lapack_int lrwork,\n                                lapack_int* iwork );\nlapack_int LAPACKE_zuncsd2by1( int matrix_layout, char jobu1, char jobu2,\n                           char jobv1t, lapack_int m, lapack_int p, lapack_int q,\n                           lapack_complex_double* x11, lapack_int ldx11,\n                           lapack_complex_double* x21, lapack_int ldx21,\n                           double* theta, lapack_complex_double* u1,\n                           lapack_int ldu1, lapack_complex_double* u2,\n                           lapack_int ldu2, lapack_complex_double* v1t, lapack_int ldv1t );\nlapack_int LAPACKE_zuncsd2by1_work( int matrix_layout, char jobu1, char jobu2,\n                                char jobv1t, lapack_int m, lapack_int p,\n                                lapack_int q, lapack_complex_double* x11, lapack_int ldx11,\n                                lapack_complex_double* x21, lapack_int ldx21,\n                                double* theta, lapack_complex_double* u1,\n                                lapack_int ldu1, lapack_complex_double* u2,\n                                lapack_int ldu2, lapack_complex_double* v1t,\n                                lapack_int ldv1t, lapack_complex_double* work,\n                                lapack_int lwork, double* rwork, lapack_int lrwork,\n                                lapack_int* iwork );\n\n/* LAPACK 3.4.0 */\nlapack_int LAPACKE_sgemqrt( int matrix_layout, char side, char trans,\n                            lapack_int m, lapack_int n, lapack_int k,\n                            lapack_int nb, const float* v, lapack_int ldv,\n                            const float* t, lapack_int ldt, float* c,\n                            lapack_int ldc );\nlapack_int LAPACKE_dgemqrt( int matrix_layout, char side, char trans,\n                            lapack_int m, lapack_int n, lapack_int k,\n                            lapack_int nb, const double* v, lapack_int ldv,\n                            const double* t, lapack_int ldt, double* c,\n                            lapack_int ldc );\nlapack_int LAPACKE_cgemqrt( int matrix_layout, char side, char trans,\n                            lapack_int m, lapack_int n, lapack_int k,\n                            lapack_int nb, const lapack_complex_float* v,\n                            lapack_int ldv, const lapack_complex_float* t,\n                            lapack_int ldt, lapack_complex_float* c,\n                            lapack_int ldc );\nlapack_int LAPACKE_zgemqrt( int matrix_layout, char side, char trans,\n                            lapack_int m, lapack_int n, lapack_int k,\n                            lapack_int nb, const lapack_complex_double* v,\n                            lapack_int ldv, const lapack_complex_double* t,\n                            lapack_int ldt, lapack_complex_double* c,\n                            lapack_int ldc );\n\nlapack_int LAPACKE_sgeqrt( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nb, float* a, lapack_int lda, float* t,\n                           lapack_int ldt );\nlapack_int LAPACKE_dgeqrt( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nb, double* a, lapack_int lda, double* t,\n                           lapack_int ldt );\nlapack_int LAPACKE_cgeqrt( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nb, lapack_complex_float* a,\n                           lapack_int lda, lapack_complex_float* t,\n                           lapack_int ldt );\nlapack_int LAPACKE_zgeqrt( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int nb, lapack_complex_double* a,\n                           lapack_int lda, lapack_complex_double* t,\n                           lapack_int ldt );\n\nlapack_int LAPACKE_sgeqrt2( int matrix_layout, lapack_int m, lapack_int n,\n                            float* a, lapack_int lda, float* t,\n                            lapack_int ldt );\nlapack_int LAPACKE_dgeqrt2( int matrix_layout, lapack_int m, lapack_int n,\n                            double* a, lapack_int lda, double* t,\n                            lapack_int ldt );\nlapack_int LAPACKE_cgeqrt2( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_complex_float* a, lapack_int lda,\n                            lapack_complex_float* t, lapack_int ldt );\nlapack_int LAPACKE_zgeqrt2( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_complex_double* a, lapack_int lda,\n                            lapack_complex_double* t, lapack_int ldt );\n\nlapack_int LAPACKE_sgeqrt3( int matrix_layout, lapack_int m, lapack_int n,\n                            float* a, lapack_int lda, float* t,\n                            lapack_int ldt );\nlapack_int LAPACKE_dgeqrt3( int matrix_layout, lapack_int m, lapack_int n,\n                            double* a, lapack_int lda, double* t,\n                            lapack_int ldt );\nlapack_int LAPACKE_cgeqrt3( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_complex_float* a, lapack_int lda,\n                            lapack_complex_float* t, lapack_int ldt );\nlapack_int LAPACKE_zgeqrt3( int matrix_layout, lapack_int m, lapack_int n,\n                            lapack_complex_double* a, lapack_int lda,\n                            lapack_complex_double* t, lapack_int ldt );\n\nlapack_int LAPACKE_stpmqrt( int matrix_layout, char side, char trans,\n                            lapack_int m, lapack_int n, lapack_int k,\n                            lapack_int l, lapack_int nb, const float* v,\n                            lapack_int ldv, const float* t, lapack_int ldt,\n                            float* a, lapack_int lda, float* b,\n                            lapack_int ldb );\nlapack_int LAPACKE_dtpmqrt( int matrix_layout, char side, char trans,\n                            lapack_int m, lapack_int n, lapack_int k,\n                            lapack_int l, lapack_int nb, const double* v,\n                            lapack_int ldv, const double* t, lapack_int ldt,\n                            double* a, lapack_int lda, double* b,\n                            lapack_int ldb );\nlapack_int LAPACKE_ctpmqrt( int matrix_layout, char side, char trans,\n                            lapack_int m, lapack_int n, lapack_int k,\n                            lapack_int l, lapack_int nb,\n                            const lapack_complex_float* v, lapack_int ldv,\n                            const lapack_complex_float* t, lapack_int ldt,\n                            lapack_complex_float* a, lapack_int lda,\n                            lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_ztpmqrt( int matrix_layout, char side, char trans,\n                            lapack_int m, lapack_int n, lapack_int k,\n                            lapack_int l, lapack_int nb,\n                            const lapack_complex_double* v, lapack_int ldv,\n                            const lapack_complex_double* t, lapack_int ldt,\n                            lapack_complex_double* a, lapack_int lda,\n                            lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_stpqrt( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int l, lapack_int nb, float* a,\n                           lapack_int lda, float* b, lapack_int ldb, float* t,\n                           lapack_int ldt );\n\nlapack_int LAPACKE_dtpqrt( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int l, lapack_int nb, double* a,\n                           lapack_int lda, double* b, lapack_int ldb, double* t,\n                           lapack_int ldt );\nlapack_int LAPACKE_ctpqrt( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int l, lapack_int nb,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb,\n                           lapack_complex_float* t, lapack_int ldt );\nlapack_int LAPACKE_ztpqrt( int matrix_layout, lapack_int m, lapack_int n,\n                           lapack_int l, lapack_int nb,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb,\n                           lapack_complex_double* t, lapack_int ldt );\n\nlapack_int LAPACKE_stpqrt2( int matrix_layout,\n                            lapack_int m, lapack_int n, lapack_int l,\n                            float* a, lapack_int lda,\n                            float* b, lapack_int ldb,\n                            float* t, lapack_int ldt );\nlapack_int LAPACKE_dtpqrt2( int matrix_layout,\n                            lapack_int m, lapack_int n, lapack_int l,\n                            double* a, lapack_int lda,\n                            double* b, lapack_int ldb,\n                            double* t, lapack_int ldt );\nlapack_int LAPACKE_ctpqrt2( int matrix_layout,\n                            lapack_int m, lapack_int n, lapack_int l,\n                            lapack_complex_float* a, lapack_int lda,\n                            lapack_complex_float* b, lapack_int ldb,\n                            lapack_complex_float* t, lapack_int ldt );\nlapack_int LAPACKE_ztpqrt2( int matrix_layout,\n                            lapack_int m, lapack_int n, lapack_int l,\n                            lapack_complex_double* a, lapack_int lda,\n                            lapack_complex_double* b, lapack_int ldb,\n                            lapack_complex_double* t, lapack_int ldt );\n\nlapack_int LAPACKE_stprfb( int matrix_layout, char side, char trans, char direct,\n                           char storev, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_int l, const float* v,\n                           lapack_int ldv, const float* t, lapack_int ldt,\n                           float* a, lapack_int lda, float* b, lapack_int ldb );\nlapack_int LAPACKE_dtprfb( int matrix_layout, char side, char trans, char direct,\n                           char storev, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_int l, const double* v,\n                           lapack_int ldv, const double* t, lapack_int ldt,\n                           double* a, lapack_int lda, double* b, lapack_int ldb );\nlapack_int LAPACKE_ctprfb( int matrix_layout, char side, char trans, char direct,\n                           char storev, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_int l,\n                           const lapack_complex_float* v, lapack_int ldv,\n                           const lapack_complex_float* t, lapack_int ldt,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_ztprfb( int matrix_layout, char side, char trans, char direct,\n                           char storev, lapack_int m, lapack_int n,\n                           lapack_int k, lapack_int l,\n                           const lapack_complex_double* v, lapack_int ldv,\n                           const lapack_complex_double* t, lapack_int ldt,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sgemqrt_work( int matrix_layout, char side, char trans,\n                                 lapack_int m, lapack_int n, lapack_int k,\n                                 lapack_int nb, const float* v, lapack_int ldv,\n                                 const float* t, lapack_int ldt, float* c,\n                                 lapack_int ldc, float* work );\nlapack_int LAPACKE_dgemqrt_work( int matrix_layout, char side, char trans,\n                                 lapack_int m, lapack_int n, lapack_int k,\n                                 lapack_int nb, const double* v, lapack_int ldv,\n                                 const double* t, lapack_int ldt, double* c,\n                                 lapack_int ldc, double* work );\nlapack_int LAPACKE_cgemqrt_work( int matrix_layout, char side, char trans,\n                                 lapack_int m, lapack_int n, lapack_int k,\n                                 lapack_int nb, const lapack_complex_float* v,\n                                 lapack_int ldv, const lapack_complex_float* t,\n                                 lapack_int ldt, lapack_complex_float* c,\n                                 lapack_int ldc, lapack_complex_float* work );\nlapack_int LAPACKE_zgemqrt_work( int matrix_layout, char side, char trans,\n                                 lapack_int m, lapack_int n, lapack_int k,\n                                 lapack_int nb, const lapack_complex_double* v,\n                                 lapack_int ldv, const lapack_complex_double* t,\n                                 lapack_int ldt, lapack_complex_double* c,\n                                 lapack_int ldc, lapack_complex_double* work );\n\nlapack_int LAPACKE_sgeqrt_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nb, float* a, lapack_int lda,\n                                float* t, lapack_int ldt, float* work );\nlapack_int LAPACKE_dgeqrt_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nb, double* a, lapack_int lda,\n                                double* t, lapack_int ldt, double* work );\nlapack_int LAPACKE_cgeqrt_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nb, lapack_complex_float* a,\n                                lapack_int lda, lapack_complex_float* t,\n                                lapack_int ldt, lapack_complex_float* work );\nlapack_int LAPACKE_zgeqrt_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int nb, lapack_complex_double* a,\n                                lapack_int lda, lapack_complex_double* t,\n                                lapack_int ldt, lapack_complex_double* work );\n\nlapack_int LAPACKE_sgeqrt2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 float* a, lapack_int lda, float* t,\n                                 lapack_int ldt );\nlapack_int LAPACKE_dgeqrt2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 double* a, lapack_int lda, double* t,\n                                 lapack_int ldt );\nlapack_int LAPACKE_cgeqrt2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_complex_float* a, lapack_int lda,\n                                 lapack_complex_float* t, lapack_int ldt );\nlapack_int LAPACKE_zgeqrt2_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_complex_double* a, lapack_int lda,\n                                 lapack_complex_double* t, lapack_int ldt );\n\nlapack_int LAPACKE_sgeqrt3_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 float* a, lapack_int lda, float* t,\n                                 lapack_int ldt );\nlapack_int LAPACKE_dgeqrt3_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 double* a, lapack_int lda, double* t,\n                                 lapack_int ldt );\nlapack_int LAPACKE_cgeqrt3_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_complex_float* a, lapack_int lda,\n                                 lapack_complex_float* t, lapack_int ldt );\nlapack_int LAPACKE_zgeqrt3_work( int matrix_layout, lapack_int m, lapack_int n,\n                                 lapack_complex_double* a, lapack_int lda,\n                                 lapack_complex_double* t, lapack_int ldt );\n\nlapack_int LAPACKE_stpmqrt_work( int matrix_layout, char side, char trans,\n                                 lapack_int m, lapack_int n, lapack_int k,\n                                 lapack_int l, lapack_int nb, const float* v,\n                                 lapack_int ldv, const float* t, lapack_int ldt,\n                                 float* a, lapack_int lda, float* b,\n                                 lapack_int ldb, float* work );\nlapack_int LAPACKE_dtpmqrt_work( int matrix_layout, char side, char trans,\n                                 lapack_int m, lapack_int n, lapack_int k,\n                                 lapack_int l, lapack_int nb, const double* v,\n                                 lapack_int ldv, const double* t,\n                                 lapack_int ldt, double* a, lapack_int lda,\n                                 double* b, lapack_int ldb, double* work );\nlapack_int LAPACKE_ctpmqrt_work( int matrix_layout, char side, char trans,\n                                 lapack_int m, lapack_int n, lapack_int k,\n                                 lapack_int l, lapack_int nb,\n                                 const lapack_complex_float* v, lapack_int ldv,\n                                 const lapack_complex_float* t, lapack_int ldt,\n                                 lapack_complex_float* a, lapack_int lda,\n                                 lapack_complex_float* b, lapack_int ldb,\n                                 lapack_complex_float* work );\nlapack_int LAPACKE_ztpmqrt_work( int matrix_layout, char side, char trans,\n                                 lapack_int m, lapack_int n, lapack_int k,\n                                 lapack_int l, lapack_int nb,\n                                 const lapack_complex_double* v, lapack_int ldv,\n                                 const lapack_complex_double* t, lapack_int ldt,\n                                 lapack_complex_double* a, lapack_int lda,\n                                 lapack_complex_double* b, lapack_int ldb,\n                                 lapack_complex_double* work );\n\nlapack_int LAPACKE_stpqrt_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int l, lapack_int nb, float* a,\n                                lapack_int lda, float* b, lapack_int ldb,\n                                float* t, lapack_int ldt, float* work );\nlapack_int LAPACKE_dtpqrt_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int l, lapack_int nb, double* a,\n                                lapack_int lda, double* b, lapack_int ldb,\n                                double* t, lapack_int ldt, double* work );\nlapack_int LAPACKE_ctpqrt_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int l, lapack_int nb,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* t, lapack_int ldt,\n                                lapack_complex_float* work );\nlapack_int LAPACKE_ztpqrt_work( int matrix_layout, lapack_int m, lapack_int n,\n                                lapack_int l, lapack_int nb,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* t, lapack_int ldt,\n                                lapack_complex_double* work );\n\nlapack_int LAPACKE_stpqrt2_work( int matrix_layout,\n                                 lapack_int m, lapack_int n, lapack_int l,\n                                 float* a, lapack_int lda,\n                                 float* b, lapack_int ldb,\n                                 float* t, lapack_int ldt );\nlapack_int LAPACKE_dtpqrt2_work( int matrix_layout,\n                                 lapack_int m, lapack_int n, lapack_int l,\n                                 double* a, lapack_int lda,\n                                 double* b, lapack_int ldb,\n                                 double* t, lapack_int ldt );\nlapack_int LAPACKE_ctpqrt2_work( int matrix_layout,\n                                 lapack_int m, lapack_int n, lapack_int l,\n                                 lapack_complex_float* a, lapack_int lda,\n                                 lapack_complex_float* b, lapack_int ldb,\n                                 lapack_complex_float* t, lapack_int ldt );\nlapack_int LAPACKE_ztpqrt2_work( int matrix_layout,\n                                 lapack_int m, lapack_int n, lapack_int l,\n                                 lapack_complex_double* a, lapack_int lda,\n                                 lapack_complex_double* b, lapack_int ldb,\n                                 lapack_complex_double* t, lapack_int ldt );\n\nlapack_int LAPACKE_stprfb_work( int matrix_layout, char side, char trans,\n                                char direct, char storev, lapack_int m,\n                                lapack_int n, lapack_int k, lapack_int l,\n                                const float* v, lapack_int ldv, const float* t,\n                                lapack_int ldt, float* a, lapack_int lda,\n                                float* b, lapack_int ldb, float* work,\n                                lapack_int ldwork );\nlapack_int LAPACKE_dtprfb_work( int matrix_layout, char side, char trans,\n                                char direct, char storev, lapack_int m,\n                                lapack_int n, lapack_int k, lapack_int l,\n                                const double* v, lapack_int ldv,\n                                const double* t, lapack_int ldt, double* a,\n                                lapack_int lda, double* b, lapack_int ldb,\n                                double* work, lapack_int ldwork );\nlapack_int LAPACKE_ctprfb_work( int matrix_layout, char side, char trans,\n                                char direct, char storev, lapack_int m,\n                                lapack_int n, lapack_int k, lapack_int l,\n                                const lapack_complex_float* v, lapack_int ldv,\n                                const lapack_complex_float* t, lapack_int ldt,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_complex_float* b, lapack_int ldb,\n                                lapack_complex_float* work, lapack_int ldwork );\nlapack_int LAPACKE_ztprfb_work( int matrix_layout, char side, char trans,\n                                char direct, char storev, lapack_int m,\n                                lapack_int n, lapack_int k, lapack_int l,\n                                const lapack_complex_double* v, lapack_int ldv,\n                                const lapack_complex_double* t, lapack_int ldt,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_complex_double* b, lapack_int ldb,\n                                lapack_complex_double* work, lapack_int ldwork );\n/* LAPACK 3.X.X */\nlapack_int LAPACKE_ssysv_rook( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, float* a, lapack_int lda,\n                               lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_dsysv_rook( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, double* a, lapack_int lda,\n                               lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_csysv_rook( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_float* a,\n                               lapack_int lda, lapack_int* ipiv,\n                               lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zsysv_rook( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_double* a,\n                               lapack_int lda, lapack_int* ipiv,\n                               lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_ssytrf_rook( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_dsytrf_rook( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_csytrf_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_zsytrf_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ipiv );\n\nlapack_int LAPACKE_ssytrs_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* a, lapack_int lda,\n                           const lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_dsytrs_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const double* a, lapack_int lda,\n                           const lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_csytrs_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zsytrs_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_chetrf_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_zhetrf_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ipiv );\n\nlapack_int LAPACKE_chetrs_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_float* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zhetrs_rook( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const lapack_complex_double* a,\n                           lapack_int lda, const lapack_int* ipiv,\n                           lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_ssysv_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                    lapack_int nrhs, float* a, lapack_int lda,\n                                    lapack_int* ipiv, float* b, lapack_int ldb,\n                                    float* work, lapack_int lwork );\nlapack_int LAPACKE_dsysv_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                    lapack_int nrhs, double* a, lapack_int lda,\n                                    lapack_int* ipiv, double* b, lapack_int ldb,\n                                    double* work, lapack_int lwork );\nlapack_int LAPACKE_csysv_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                    lapack_int nrhs, lapack_complex_float* a,\n                                    lapack_int lda, lapack_int* ipiv,\n                                    lapack_complex_float* b, lapack_int ldb,\n                                    lapack_complex_float* work,\n                                    lapack_int lwork );\nlapack_int LAPACKE_zsysv_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                    lapack_int nrhs, lapack_complex_double* a,\n                                    lapack_int lda, lapack_int* ipiv,\n                                    lapack_complex_double* b, lapack_int ldb,\n                                    lapack_complex_double* work,\n                                    lapack_int lwork );\n\nlapack_int LAPACKE_ssytrf_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* ipiv,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dsytrf_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* ipiv,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_csytrf_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_zsytrf_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_ssytrs_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* a, lapack_int lda,\n                                const lapack_int* ipiv, float* b,\n                                lapack_int ldb );\nlapack_int LAPACKE_dsytrs_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const double* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                double* b, lapack_int ldb );\nlapack_int LAPACKE_csytrs_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zsytrs_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_chetrf_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_zhetrf_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_chetrs_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_float* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zhetrs_rook_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const lapack_complex_double* a,\n                                lapack_int lda, const lapack_int* ipiv,\n                                lapack_complex_double* b, lapack_int ldb );\n\n\nvoid LAPACKE_ilaver( lapack_int* vers_major,\n                     lapack_int* vers_minor,\n                     lapack_int* vers_patch );\n/* LAPACK 3.7.0 */\nlapack_int LAPACKE_ssysv_aa( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, float* a, lapack_int lda,\n                          lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_ssysv_aa_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, float* a, lapack_int lda,\n                               lapack_int* ipiv, float* b, lapack_int ldb,\n                               float* work, lapack_int lwork );\nlapack_int LAPACKE_dsysv_aa( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, double* a, lapack_int lda,\n                          lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_dsysv_aa_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, double* a, lapack_int lda,\n                               lapack_int* ipiv, double* b, lapack_int ldb,\n                               double* work, lapack_int lwork );\nlapack_int LAPACKE_chesv_aa( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_float* a,\n                          lapack_int lda, lapack_int* ipiv,\n                          lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_chesv_aa_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_float* a,\n                               lapack_int lda, lapack_int* ipiv,\n                               lapack_complex_float* b, lapack_int ldb,\n                               lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zhesv_aa( int matrix_layout, char uplo, lapack_int n,\n                          lapack_int nrhs, lapack_complex_double* a,\n                          lapack_int lda, lapack_int* ipiv,\n                          lapack_complex_double* b, lapack_int ldb );\nlapack_int LAPACKE_zhesv_aa_work( int matrix_layout, char uplo, lapack_int n,\n                               lapack_int nrhs, lapack_complex_double* a,\n                               lapack_int lda, lapack_int* ipiv,\n                               lapack_complex_double* b, lapack_int ldb,\n                               lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_ssytrf_aa( int matrix_layout, char uplo, lapack_int n, float* a,\n                           lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_dsytrf_aa( int matrix_layout, char uplo, lapack_int n, double* a,\n                           lapack_int lda, lapack_int* ipiv );\nlapack_int LAPACKE_chetrf_aa( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_float* a, lapack_int lda,\n                           lapack_int* ipiv );\nlapack_int LAPACKE_zhetrf_aa( int matrix_layout, char uplo, lapack_int n,\n                           lapack_complex_double* a, lapack_int lda,\n                           lapack_int* ipiv );\n\nlapack_int LAPACKE_ssytrf_aa_work( int matrix_layout, char uplo, lapack_int n,\n                                float* a, lapack_int lda, lapack_int* ipiv,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dsytrf_aa_work( int matrix_layout, char uplo, lapack_int n,\n                                double* a, lapack_int lda, lapack_int* ipiv,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_chetrf_aa_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_float* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_float* work,\n                                lapack_int lwork );\nlapack_int LAPACKE_zhetrf_aa_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_complex_double* a, lapack_int lda,\n                                lapack_int* ipiv, lapack_complex_double* work,\n                                lapack_int lwork );\n\nlapack_int LAPACKE_chetrs_aa( int matrix_layout, char uplo, lapack_int n,\n                            lapack_int nrhs, const lapack_complex_float* a,\n                            lapack_int lda, const lapack_int* ipiv,\n                            lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_chetrs_aa_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_int nrhs, const lapack_complex_float* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 lapack_complex_float* b, lapack_int ldb,\n                                 lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_dsytrs_aa( int matrix_layout, char uplo, lapack_int n,\n                            lapack_int nrhs, const double* a, lapack_int lda,\n                            const lapack_int* ipiv, double* b, lapack_int ldb );\nlapack_int LAPACKE_dsytrs_aa_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_int nrhs, const double* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 double* b, lapack_int ldb, double* work, lapack_int lwork );\nlapack_int LAPACKE_ssytrs_aa( int matrix_layout, char uplo, lapack_int n,\n                           lapack_int nrhs, const float* a, lapack_int lda,\n                           const lapack_int* ipiv, float* b, lapack_int ldb );\nlapack_int LAPACKE_ssytrs_aa_work( int matrix_layout, char uplo, lapack_int n,\n                                lapack_int nrhs, const float* a, lapack_int lda,\n                                const lapack_int* ipiv, float* b,\n                                lapack_int ldb, float* work, lapack_int lwork );\nlapack_int LAPACKE_zhetrs_aa( int matrix_layout, char uplo, lapack_int n,\n                            lapack_int nrhs, const lapack_complex_double* a,\n                            lapack_int lda, const lapack_int* ipiv,\n                            lapack_complex_double* b, lapack_int ldb );\nlapack_int LAPACKE_zhetrs_aa_work( int matrix_layout, char uplo, lapack_int n,\n                                 lapack_int nrhs, const lapack_complex_double* a,\n                                 lapack_int lda, const lapack_int* ipiv,\n                                 lapack_complex_double* b, lapack_int ldb,\n                                 lapack_complex_double* work,  lapack_int lwork);\n\nlapack_int LAPACKE_sgelq( int matrix_layout, lapack_int m, lapack_int n,\n                          float* a, lapack_int lda,\n                          float* t, lapack_int tsize );\nlapack_int LAPACKE_dgelq( int matrix_layout, lapack_int m, lapack_int n,\n                          double* a, lapack_int lda,\n                          double* t, lapack_int tsize );\nlapack_int LAPACKE_cgelq( int matrix_layout, lapack_int m, lapack_int n,\n                          lapack_complex_float* a, lapack_int lda,\n                          lapack_complex_float* t, lapack_int tsize );\nlapack_int LAPACKE_zgelq( int matrix_layout, lapack_int m, lapack_int n,\n                          lapack_complex_double* a, lapack_int lda,\n                          lapack_complex_double* t, lapack_int tsize );\n\nlapack_int LAPACKE_sgelq_work( int matrix_layout, lapack_int m, lapack_int n,\n                               float* a, lapack_int lda,\n                               float* t, lapack_int tsize,\n                               float* work, lapack_int lwork );\nlapack_int LAPACKE_dgelq_work( int matrix_layout, lapack_int m, lapack_int n,\n                               double* a, lapack_int lda,\n                               double* t, lapack_int tsize,\n                               double* work, lapack_int lwork );\nlapack_int LAPACKE_cgelq_work( int matrix_layout, lapack_int m, lapack_int n,\n                               lapack_complex_float* a, lapack_int lda,\n                               lapack_complex_float* t, lapack_int tsize,\n                               lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgelq_work( int matrix_layout, lapack_int m, lapack_int n,\n                               lapack_complex_double* a, lapack_int lda,\n                               lapack_complex_double* t, lapack_int tsize,\n                               lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgemlq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const float* a, lapack_int lda,\n                           const float* t, lapack_int tsize,\n                           float* c, lapack_int ldc );\nlapack_int LAPACKE_dgemlq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const double* a, lapack_int lda,\n                           const double* t, lapack_int tsize,\n                           double* c, lapack_int ldc );\nlapack_int LAPACKE_cgemlq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* t, lapack_int tsize,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zgemlq( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* t, lapack_int tsize,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sgemlq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const float* a, lapack_int lda,\n                                const float* t, lapack_int tsize,\n                                float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dgemlq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const double* a, lapack_int lda,\n                                const double* t, lapack_int tsize,\n                                double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgemlq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* t, lapack_int tsize,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgemlq_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* t, lapack_int tsize,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgeqr( int matrix_layout, lapack_int m, lapack_int n,\n                          float* a, lapack_int lda,\n                          float* t, lapack_int tsize );\nlapack_int LAPACKE_dgeqr( int matrix_layout, lapack_int m, lapack_int n,\n                          double* a, lapack_int lda,\n                          double* t, lapack_int tsize );\nlapack_int LAPACKE_cgeqr( int matrix_layout, lapack_int m, lapack_int n,\n                          lapack_complex_float* a, lapack_int lda,\n                          lapack_complex_float* t, lapack_int tsize );\nlapack_int LAPACKE_zgeqr( int matrix_layout, lapack_int m, lapack_int n,\n                          lapack_complex_double* a, lapack_int lda,\n                          lapack_complex_double* t, lapack_int tsize );\n\nlapack_int LAPACKE_sgeqr_work( int matrix_layout, lapack_int m, lapack_int n,\n                               float* a, lapack_int lda,\n                               float* t, lapack_int tsize,\n                               float* work, lapack_int lwork );\nlapack_int LAPACKE_dgeqr_work( int matrix_layout, lapack_int m, lapack_int n,\n                               double* a, lapack_int lda,\n                               double* t, lapack_int tsize,\n                               double* work, lapack_int lwork );\nlapack_int LAPACKE_cgeqr_work( int matrix_layout, lapack_int m, lapack_int n,\n                               lapack_complex_float* a, lapack_int lda,\n                               lapack_complex_float* t, lapack_int tsize,\n                               lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgeqr_work( int matrix_layout, lapack_int m, lapack_int n,\n                               lapack_complex_double* a, lapack_int lda,\n                               lapack_complex_double* t, lapack_int tsize,\n                               lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgemqr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const float* a, lapack_int lda,\n                           const float* t, lapack_int tsize,\n                           float* c, lapack_int ldc );\nlapack_int LAPACKE_dgemqr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const double* a, lapack_int lda,\n                           const double* t, lapack_int tsize,\n                           double* c, lapack_int ldc );\nlapack_int LAPACKE_cgemqr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_float* a, lapack_int lda,\n                           const lapack_complex_float* t, lapack_int tsize,\n                           lapack_complex_float* c, lapack_int ldc );\nlapack_int LAPACKE_zgemqr( int matrix_layout, char side, char trans,\n                           lapack_int m, lapack_int n, lapack_int k,\n                           const lapack_complex_double* a, lapack_int lda,\n                           const lapack_complex_double* t, lapack_int tsize,\n                           lapack_complex_double* c, lapack_int ldc );\n\nlapack_int LAPACKE_sgemqr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const float* a, lapack_int lda,\n                                const float* t, lapack_int tsize,\n                                float* c, lapack_int ldc,\n                                float* work, lapack_int lwork );\nlapack_int LAPACKE_dgemqr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const double* a, lapack_int lda,\n                                const double* t, lapack_int tsize,\n                                double* c, lapack_int ldc,\n                                double* work, lapack_int lwork );\nlapack_int LAPACKE_cgemqr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_float* a, lapack_int lda,\n                                const lapack_complex_float* t, lapack_int tsize,\n                                lapack_complex_float* c, lapack_int ldc,\n                                lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgemqr_work( int matrix_layout, char side, char trans,\n                                lapack_int m, lapack_int n, lapack_int k,\n                                const lapack_complex_double* a, lapack_int lda,\n                                const lapack_complex_double* t, lapack_int tsize,\n                                lapack_complex_double* c, lapack_int ldc,\n                                lapack_complex_double* work, lapack_int lwork );\n\nlapack_int LAPACKE_sgetsls( int matrix_layout, char trans, lapack_int m,\n                            lapack_int n, lapack_int nrhs, float* a,\n                            lapack_int lda, float* b, lapack_int ldb );\nlapack_int LAPACKE_dgetsls( int matrix_layout, char trans, lapack_int m,\n                            lapack_int n, lapack_int nrhs, double* a,\n                            lapack_int lda, double* b, lapack_int ldb );\nlapack_int LAPACKE_cgetsls( int matrix_layout, char trans, lapack_int m,\n                            lapack_int n, lapack_int nrhs,\n                            lapack_complex_float* a, lapack_int lda,\n                            lapack_complex_float* b, lapack_int ldb );\nlapack_int LAPACKE_zgetsls( int matrix_layout, char trans, lapack_int m,\n                            lapack_int n, lapack_int nrhs,\n                            lapack_complex_double* a, lapack_int lda,\n                            lapack_complex_double* b, lapack_int ldb );\n\nlapack_int LAPACKE_sgetsls_work( int matrix_layout, char trans, lapack_int m,\n                                 lapack_int n, lapack_int nrhs, float* a,\n                                 lapack_int lda, float* b, lapack_int ldb,\n                                 float* work, lapack_int lwork );\nlapack_int LAPACKE_dgetsls_work( int matrix_layout, char trans, lapack_int m,\n                                 lapack_int n, lapack_int nrhs, double* a,\n                                 lapack_int lda, double* b, lapack_int ldb,\n                                 double* work, lapack_int lwork );\nlapack_int LAPACKE_cgetsls_work( int matrix_layout, char trans, lapack_int m,\n                                 lapack_int n, lapack_int nrhs,\n                                 lapack_complex_float* a, lapack_int lda,\n                                 lapack_complex_float* b, lapack_int ldb,\n                                 lapack_complex_float* work, lapack_int lwork );\nlapack_int LAPACKE_zgetsls_work( int matrix_layout, char trans, lapack_int m,\n                                 lapack_int n, lapack_int nrhs,\n                                 lapack_complex_double* a, lapack_int lda,\n                                 lapack_complex_double* b, lapack_int ldb,\n                                 lapack_complex_double* work, lapack_int lwork );\n\n#if !defined(MW_HAVE_LAPACK_DECLS) && defined(mllapack_h)\n#error \"The files lapack.h and lapacke.h may not be simultaneously included because of conflicting declarations of LAPACK routines. Include at most one of these headers in each source file.\"\n#endif /* !defined(MW_HAVE_LAPACK_DECLS) && defined(mllapack_h) */\n#if !defined(MW_HAVE_LAPACK_DECLS) && !defined(mllapack_h)\n#define LAPACK_sgetrf LAPACK_GLOBAL(sgetrf,SGETRF)\n#define LAPACK_dgetrf LAPACK_GLOBAL(dgetrf,DGETRF)\n#define LAPACK_cgetrf LAPACK_GLOBAL(cgetrf,CGETRF)\n#define LAPACK_zgetrf LAPACK_GLOBAL(zgetrf,ZGETRF)\n#define LAPACK_sgetrf2 LAPACK_GLOBAL(sgetrf2,SGETRF2)\n#define LAPACK_dgetrf2 LAPACK_GLOBAL(dgetrf2,DGETRF2)\n#define LAPACK_cgetrf2 LAPACK_GLOBAL(cgetrf2,CGETRF2)\n#define LAPACK_zgetrf2 LAPACK_GLOBAL(zgetrf2,ZGETRF2)\n#define LAPACK_sgbtrf LAPACK_GLOBAL(sgbtrf,SGBTRF)\n#define LAPACK_dgbtrf LAPACK_GLOBAL(dgbtrf,DGBTRF)\n#define LAPACK_cgbtrf LAPACK_GLOBAL(cgbtrf,CGBTRF)\n#define LAPACK_zgbtrf LAPACK_GLOBAL(zgbtrf,ZGBTRF)\n#define LAPACK_sgttrf LAPACK_GLOBAL(sgttrf,SGTTRF)\n#define LAPACK_dgttrf LAPACK_GLOBAL(dgttrf,DGTTRF)\n#define LAPACK_cgttrf LAPACK_GLOBAL(cgttrf,CGTTRF)\n#define LAPACK_zgttrf LAPACK_GLOBAL(zgttrf,ZGTTRF)\n#define LAPACK_spotrf LAPACK_GLOBAL(spotrf,SPOTRF)\n#define LAPACK_dpotrf LAPACK_GLOBAL(dpotrf,DPOTRF)\n#define LAPACK_cpotrf LAPACK_GLOBAL(cpotrf,CPOTRF)\n#define LAPACK_zpotrf LAPACK_GLOBAL(zpotrf,ZPOTRF)\n#define LAPACK_spotrf2 LAPACK_GLOBAL(spotrf2,SPOTRF2)\n#define LAPACK_dpotrf2 LAPACK_GLOBAL(dpotrf2,DPOTRF2)\n#define LAPACK_cpotrf2 LAPACK_GLOBAL(cpotrf2,CPOTRF2)\n#define LAPACK_zpotrf2 LAPACK_GLOBAL(zpotrf2,ZPOTRF2)\n#define LAPACK_dpstrf LAPACK_GLOBAL(dpstrf,DPSTRF)\n#define LAPACK_spstrf LAPACK_GLOBAL(spstrf,SPSTRF)\n#define LAPACK_zpstrf LAPACK_GLOBAL(zpstrf,ZPSTRF)\n#define LAPACK_cpstrf LAPACK_GLOBAL(cpstrf,CPSTRF)\n#define LAPACK_dpftrf LAPACK_GLOBAL(dpftrf,DPFTRF)\n#define LAPACK_spftrf LAPACK_GLOBAL(spftrf,SPFTRF)\n#define LAPACK_zpftrf LAPACK_GLOBAL(zpftrf,ZPFTRF)\n#define LAPACK_cpftrf LAPACK_GLOBAL(cpftrf,CPFTRF)\n#define LAPACK_spptrf LAPACK_GLOBAL(spptrf,SPPTRF)\n#define LAPACK_dpptrf LAPACK_GLOBAL(dpptrf,DPPTRF)\n#define LAPACK_cpptrf LAPACK_GLOBAL(cpptrf,CPPTRF)\n#define LAPACK_zpptrf LAPACK_GLOBAL(zpptrf,ZPPTRF)\n#define LAPACK_spbtrf LAPACK_GLOBAL(spbtrf,SPBTRF)\n#define LAPACK_dpbtrf LAPACK_GLOBAL(dpbtrf,DPBTRF)\n#define LAPACK_cpbtrf LAPACK_GLOBAL(cpbtrf,CPBTRF)\n#define LAPACK_zpbtrf LAPACK_GLOBAL(zpbtrf,ZPBTRF)\n#define LAPACK_spttrf LAPACK_GLOBAL(spttrf,SPTTRF)\n#define LAPACK_dpttrf LAPACK_GLOBAL(dpttrf,DPTTRF)\n#define LAPACK_cpttrf LAPACK_GLOBAL(cpttrf,CPTTRF)\n#define LAPACK_zpttrf LAPACK_GLOBAL(zpttrf,ZPTTRF)\n#define LAPACK_ssytrf LAPACK_GLOBAL(ssytrf,SSYTRF)\n#define LAPACK_ssytrf_rook LAPACK_GLOBAL(ssytrf_rook,SSYTRF_ROOK)\n#define LAPACK_dsytrf LAPACK_GLOBAL(dsytrf,DSYTRF)\n#define LAPACK_dsytrf_rook LAPACK_GLOBAL(dsytrf_rook,DSYTRF_ROOK)\n#define LAPACK_csytrf LAPACK_GLOBAL(csytrf,CSYTRF)\n#define LAPACK_csytrf_rook LAPACK_GLOBAL(csytrf_rook,CSYTRF_ROOK)\n#define LAPACK_zsytrf LAPACK_GLOBAL(zsytrf,ZSYTRF)\n#define LAPACK_zsytrf_rook LAPACK_GLOBAL(zsytrf_rook,ZSYTRF_ROOK)\n#define LAPACK_chetrf LAPACK_GLOBAL(chetrf,CHETRF)\n#define LAPACK_chetrf_rook LAPACK_GLOBAL(chetrf_rook,CHETRF_ROOK)\n#define LAPACK_zhetrf LAPACK_GLOBAL(zhetrf,ZHETRF)\n#define LAPACK_zhetrf_rook LAPACK_GLOBAL(zhetrf_rook,ZHETRF_ROOK)\n#define LAPACK_ssptrf LAPACK_GLOBAL(ssptrf,SSPTRF)\n#define LAPACK_dsptrf LAPACK_GLOBAL(dsptrf,DSPTRF)\n#define LAPACK_csptrf LAPACK_GLOBAL(csptrf,CSPTRF)\n#define LAPACK_zsptrf LAPACK_GLOBAL(zsptrf,ZSPTRF)\n#define LAPACK_chptrf LAPACK_GLOBAL(chptrf,CHPTRF)\n#define LAPACK_zhptrf LAPACK_GLOBAL(zhptrf,ZHPTRF)\n#define LAPACK_sgetrs LAPACK_GLOBAL(sgetrs,SGETRS)\n#define LAPACK_dgetrs LAPACK_GLOBAL(dgetrs,DGETRS)\n#define LAPACK_cgetrs LAPACK_GLOBAL(cgetrs,CGETRS)\n#define LAPACK_zgetrs LAPACK_GLOBAL(zgetrs,ZGETRS)\n#define LAPACK_sgbtrs LAPACK_GLOBAL(sgbtrs,SGBTRS)\n#define LAPACK_dgbtrs LAPACK_GLOBAL(dgbtrs,DGBTRS)\n#define LAPACK_cgbtrs LAPACK_GLOBAL(cgbtrs,CGBTRS)\n#define LAPACK_zgbtrs LAPACK_GLOBAL(zgbtrs,ZGBTRS)\n#define LAPACK_sgttrs LAPACK_GLOBAL(sgttrs,SGTTRS)\n#define LAPACK_dgttrs LAPACK_GLOBAL(dgttrs,DGTTRS)\n#define LAPACK_cgttrs LAPACK_GLOBAL(cgttrs,CGTTRS)\n#define LAPACK_zgttrs LAPACK_GLOBAL(zgttrs,ZGTTRS)\n#define LAPACK_spotrs LAPACK_GLOBAL(spotrs,SPOTRS)\n#define LAPACK_dpotrs LAPACK_GLOBAL(dpotrs,DPOTRS)\n#define LAPACK_cpotrs LAPACK_GLOBAL(cpotrs,CPOTRS)\n#define LAPACK_zpotrs LAPACK_GLOBAL(zpotrs,ZPOTRS)\n#define LAPACK_dpftrs LAPACK_GLOBAL(dpftrs,DPFTRS)\n#define LAPACK_spftrs LAPACK_GLOBAL(spftrs,SPFTRS)\n#define LAPACK_zpftrs LAPACK_GLOBAL(zpftrs,ZPFTRS)\n#define LAPACK_cpftrs LAPACK_GLOBAL(cpftrs,CPFTRS)\n#define LAPACK_spptrs LAPACK_GLOBAL(spptrs,SPPTRS)\n#define LAPACK_dpptrs LAPACK_GLOBAL(dpptrs,DPPTRS)\n#define LAPACK_cpptrs LAPACK_GLOBAL(cpptrs,CPPTRS)\n#define LAPACK_zpptrs LAPACK_GLOBAL(zpptrs,ZPPTRS)\n#define LAPACK_spbtrs LAPACK_GLOBAL(spbtrs,SPBTRS)\n#define LAPACK_dpbtrs LAPACK_GLOBAL(dpbtrs,DPBTRS)\n#define LAPACK_cpbtrs LAPACK_GLOBAL(cpbtrs,CPBTRS)\n#define LAPACK_zpbtrs LAPACK_GLOBAL(zpbtrs,ZPBTRS)\n#define LAPACK_spttrs LAPACK_GLOBAL(spttrs,SPTTRS)\n#define LAPACK_dpttrs LAPACK_GLOBAL(dpttrs,DPTTRS)\n#define LAPACK_cpttrs LAPACK_GLOBAL(cpttrs,CPTTRS)\n#define LAPACK_zpttrs LAPACK_GLOBAL(zpttrs,ZPTTRS)\n#define LAPACK_ssytrs LAPACK_GLOBAL(ssytrs,SSYTRS)\n#define LAPACK_ssytrs_rook LAPACK_GLOBAL(ssytrs_rook,SSYTRS_ROOK)\n#define LAPACK_dsytrs LAPACK_GLOBAL(dsytrs,DSYTRS)\n#define LAPACK_dsytrs_rook LAPACK_GLOBAL(dsytrs_rook,DSYTRS_ROOK)\n#define LAPACK_csytrs LAPACK_GLOBAL(csytrs,CSYTRS)\n#define LAPACK_csytrs_rook LAPACK_GLOBAL(csytrs_rook,CSYTRS_ROOK)\n#define LAPACK_zsytrs LAPACK_GLOBAL(zsytrs,ZSYTRS)\n#define LAPACK_zsytrs_rook LAPACK_GLOBAL(zsytrs_rook,ZSYTRS_ROOK)\n#define LAPACK_chetrs LAPACK_GLOBAL(chetrs,CHETRS)\n#define LAPACK_chetrs_rook LAPACK_GLOBAL(chetrs_rook,CHETRS_ROOK)\n#define LAPACK_zhetrs LAPACK_GLOBAL(zhetrs,ZHETRS)\n#define LAPACK_zhetrs_rook LAPACK_GLOBAL(zhetrs_rook,ZHETRS_ROOK)\n#define LAPACK_ssptrs LAPACK_GLOBAL(ssptrs,SSPTRS)\n#define LAPACK_dsptrs LAPACK_GLOBAL(dsptrs,DSPTRS)\n#define LAPACK_csptrs LAPACK_GLOBAL(csptrs,CSPTRS)\n#define LAPACK_zsptrs LAPACK_GLOBAL(zsptrs,ZSPTRS)\n#define LAPACK_chptrs LAPACK_GLOBAL(chptrs,CHPTRS)\n#define LAPACK_zhptrs LAPACK_GLOBAL(zhptrs,ZHPTRS)\n#define LAPACK_strtrs LAPACK_GLOBAL(strtrs,STRTRS)\n#define LAPACK_dtrtrs LAPACK_GLOBAL(dtrtrs,DTRTRS)\n#define LAPACK_ctrtrs LAPACK_GLOBAL(ctrtrs,CTRTRS)\n#define LAPACK_ztrtrs LAPACK_GLOBAL(ztrtrs,ZTRTRS)\n#define LAPACK_stptrs LAPACK_GLOBAL(stptrs,STPTRS)\n#define LAPACK_dtptrs LAPACK_GLOBAL(dtptrs,DTPTRS)\n#define LAPACK_ctptrs LAPACK_GLOBAL(ctptrs,CTPTRS)\n#define LAPACK_ztptrs LAPACK_GLOBAL(ztptrs,ZTPTRS)\n#define LAPACK_stbtrs LAPACK_GLOBAL(stbtrs,STBTRS)\n#define LAPACK_dtbtrs LAPACK_GLOBAL(dtbtrs,DTBTRS)\n#define LAPACK_ctbtrs LAPACK_GLOBAL(ctbtrs,CTBTRS)\n#define LAPACK_ztbtrs LAPACK_GLOBAL(ztbtrs,ZTBTRS)\n#define LAPACK_sgecon LAPACK_GLOBAL(sgecon,SGECON)\n#define LAPACK_dgecon LAPACK_GLOBAL(dgecon,DGECON)\n#define LAPACK_cgecon LAPACK_GLOBAL(cgecon,CGECON)\n#define LAPACK_zgecon LAPACK_GLOBAL(zgecon,ZGECON)\n#define LAPACK_sgbcon LAPACK_GLOBAL(sgbcon,SGBCON)\n#define LAPACK_dgbcon LAPACK_GLOBAL(dgbcon,DGBCON)\n#define LAPACK_cgbcon LAPACK_GLOBAL(cgbcon,CGBCON)\n#define LAPACK_zgbcon LAPACK_GLOBAL(zgbcon,ZGBCON)\n#define LAPACK_sgtcon LAPACK_GLOBAL(sgtcon,SGTCON)\n#define LAPACK_dgtcon LAPACK_GLOBAL(dgtcon,DGTCON)\n#define LAPACK_cgtcon LAPACK_GLOBAL(cgtcon,CGTCON)\n#define LAPACK_zgtcon LAPACK_GLOBAL(zgtcon,ZGTCON)\n#define LAPACK_spocon LAPACK_GLOBAL(spocon,SPOCON)\n#define LAPACK_dpocon LAPACK_GLOBAL(dpocon,DPOCON)\n#define LAPACK_cpocon LAPACK_GLOBAL(cpocon,CPOCON)\n#define LAPACK_zpocon LAPACK_GLOBAL(zpocon,ZPOCON)\n#define LAPACK_sppcon LAPACK_GLOBAL(sppcon,SPPCON)\n#define LAPACK_dppcon LAPACK_GLOBAL(dppcon,DPPCON)\n#define LAPACK_cppcon LAPACK_GLOBAL(cppcon,CPPCON)\n#define LAPACK_zppcon LAPACK_GLOBAL(zppcon,ZPPCON)\n#define LAPACK_spbcon LAPACK_GLOBAL(spbcon,SPBCON)\n#define LAPACK_dpbcon LAPACK_GLOBAL(dpbcon,DPBCON)\n#define LAPACK_cpbcon LAPACK_GLOBAL(cpbcon,CPBCON)\n#define LAPACK_zpbcon LAPACK_GLOBAL(zpbcon,ZPBCON)\n#define LAPACK_sptcon LAPACK_GLOBAL(sptcon,SPTCON)\n#define LAPACK_dptcon LAPACK_GLOBAL(dptcon,DPTCON)\n#define LAPACK_cptcon LAPACK_GLOBAL(cptcon,CPTCON)\n#define LAPACK_zptcon LAPACK_GLOBAL(zptcon,ZPTCON)\n#define LAPACK_ssycon LAPACK_GLOBAL(ssycon,SSYCON)\n#define LAPACK_dsycon LAPACK_GLOBAL(dsycon,DSYCON)\n#define LAPACK_csycon LAPACK_GLOBAL(csycon,CSYCON)\n#define LAPACK_zsycon LAPACK_GLOBAL(zsycon,ZSYCON)\n#define LAPACK_checon LAPACK_GLOBAL(checon,CHECON)\n#define LAPACK_zhecon LAPACK_GLOBAL(zhecon,ZHECON)\n#define LAPACK_sspcon LAPACK_GLOBAL(sspcon,SSPCON)\n#define LAPACK_dspcon LAPACK_GLOBAL(dspcon,DSPCON)\n#define LAPACK_cspcon LAPACK_GLOBAL(cspcon,CSPCON)\n#define LAPACK_zspcon LAPACK_GLOBAL(zspcon,ZSPCON)\n#define LAPACK_chpcon LAPACK_GLOBAL(chpcon,CHPCON)\n#define LAPACK_zhpcon LAPACK_GLOBAL(zhpcon,ZHPCON)\n#define LAPACK_strcon LAPACK_GLOBAL(strcon,STRCON)\n#define LAPACK_dtrcon LAPACK_GLOBAL(dtrcon,DTRCON)\n#define LAPACK_ctrcon LAPACK_GLOBAL(ctrcon,CTRCON)\n#define LAPACK_ztrcon LAPACK_GLOBAL(ztrcon,ZTRCON)\n#define LAPACK_stpcon LAPACK_GLOBAL(stpcon,STPCON)\n#define LAPACK_dtpcon LAPACK_GLOBAL(dtpcon,DTPCON)\n#define LAPACK_ctpcon LAPACK_GLOBAL(ctpcon,CTPCON)\n#define LAPACK_ztpcon LAPACK_GLOBAL(ztpcon,ZTPCON)\n#define LAPACK_stbcon LAPACK_GLOBAL(stbcon,STBCON)\n#define LAPACK_dtbcon LAPACK_GLOBAL(dtbcon,DTBCON)\n#define LAPACK_ctbcon LAPACK_GLOBAL(ctbcon,CTBCON)\n#define LAPACK_ztbcon LAPACK_GLOBAL(ztbcon,ZTBCON)\n#define LAPACK_sgerfs LAPACK_GLOBAL(sgerfs,SGERFS)\n#define LAPACK_dgerfs LAPACK_GLOBAL(dgerfs,DGERFS)\n#define LAPACK_cgerfs LAPACK_GLOBAL(cgerfs,CGERFS)\n#define LAPACK_zgerfs LAPACK_GLOBAL(zgerfs,ZGERFS)\n#define LAPACK_sgbrfs LAPACK_GLOBAL(sgbrfs,SGBRFS)\n#define LAPACK_dgbrfs LAPACK_GLOBAL(dgbrfs,DGBRFS)\n#define LAPACK_cgbrfs LAPACK_GLOBAL(cgbrfs,CGBRFS)\n#define LAPACK_zgbrfs LAPACK_GLOBAL(zgbrfs,ZGBRFS)\n#define LAPACK_sgtrfs LAPACK_GLOBAL(sgtrfs,SGTRFS)\n#define LAPACK_dgtrfs LAPACK_GLOBAL(dgtrfs,DGTRFS)\n#define LAPACK_cgtrfs LAPACK_GLOBAL(cgtrfs,CGTRFS)\n#define LAPACK_zgtrfs LAPACK_GLOBAL(zgtrfs,ZGTRFS)\n#define LAPACK_sporfs LAPACK_GLOBAL(sporfs,SPORFS)\n#define LAPACK_dporfs LAPACK_GLOBAL(dporfs,DPORFS)\n#define LAPACK_cporfs LAPACK_GLOBAL(cporfs,CPORFS)\n#define LAPACK_zporfs LAPACK_GLOBAL(zporfs,ZPORFS)\n#define LAPACK_spprfs LAPACK_GLOBAL(spprfs,SPPRFS)\n#define LAPACK_dpprfs LAPACK_GLOBAL(dpprfs,DPPRFS)\n#define LAPACK_cpprfs LAPACK_GLOBAL(cpprfs,CPPRFS)\n#define LAPACK_zpprfs LAPACK_GLOBAL(zpprfs,ZPPRFS)\n#define LAPACK_spbrfs LAPACK_GLOBAL(spbrfs,SPBRFS)\n#define LAPACK_dpbrfs LAPACK_GLOBAL(dpbrfs,DPBRFS)\n#define LAPACK_cpbrfs LAPACK_GLOBAL(cpbrfs,CPBRFS)\n#define LAPACK_zpbrfs LAPACK_GLOBAL(zpbrfs,ZPBRFS)\n#define LAPACK_sptrfs LAPACK_GLOBAL(sptrfs,SPTRFS)\n#define LAPACK_dptrfs LAPACK_GLOBAL(dptrfs,DPTRFS)\n#define LAPACK_cptrfs LAPACK_GLOBAL(cptrfs,CPTRFS)\n#define LAPACK_zptrfs LAPACK_GLOBAL(zptrfs,ZPTRFS)\n#define LAPACK_ssyrfs LAPACK_GLOBAL(ssyrfs,SSYRFS)\n#define LAPACK_dsyrfs LAPACK_GLOBAL(dsyrfs,DSYRFS)\n#define LAPACK_csyrfs LAPACK_GLOBAL(csyrfs,CSYRFS)\n#define LAPACK_zsyrfs LAPACK_GLOBAL(zsyrfs,ZSYRFS)\n#define LAPACK_cherfs LAPACK_GLOBAL(cherfs,CHERFS)\n#define LAPACK_zherfs LAPACK_GLOBAL(zherfs,ZHERFS)\n#define LAPACK_ssprfs LAPACK_GLOBAL(ssprfs,SSPRFS)\n#define LAPACK_dsprfs LAPACK_GLOBAL(dsprfs,DSPRFS)\n#define LAPACK_csprfs LAPACK_GLOBAL(csprfs,CSPRFS)\n#define LAPACK_zsprfs LAPACK_GLOBAL(zsprfs,ZSPRFS)\n#define LAPACK_chprfs LAPACK_GLOBAL(chprfs,CHPRFS)\n#define LAPACK_zhprfs LAPACK_GLOBAL(zhprfs,ZHPRFS)\n#define LAPACK_strrfs LAPACK_GLOBAL(strrfs,STRRFS)\n#define LAPACK_dtrrfs LAPACK_GLOBAL(dtrrfs,DTRRFS)\n#define LAPACK_ctrrfs LAPACK_GLOBAL(ctrrfs,CTRRFS)\n#define LAPACK_ztrrfs LAPACK_GLOBAL(ztrrfs,ZTRRFS)\n#define LAPACK_stprfs LAPACK_GLOBAL(stprfs,STPRFS)\n#define LAPACK_dtprfs LAPACK_GLOBAL(dtprfs,DTPRFS)\n#define LAPACK_ctprfs LAPACK_GLOBAL(ctprfs,CTPRFS)\n#define LAPACK_ztprfs LAPACK_GLOBAL(ztprfs,ZTPRFS)\n#define LAPACK_stbrfs LAPACK_GLOBAL(stbrfs,STBRFS)\n#define LAPACK_dtbrfs LAPACK_GLOBAL(dtbrfs,DTBRFS)\n#define LAPACK_ctbrfs LAPACK_GLOBAL(ctbrfs,CTBRFS)\n#define LAPACK_ztbrfs LAPACK_GLOBAL(ztbrfs,ZTBRFS)\n#define LAPACK_sgetri LAPACK_GLOBAL(sgetri,SGETRI)\n#define LAPACK_dgetri LAPACK_GLOBAL(dgetri,DGETRI)\n#define LAPACK_cgetri LAPACK_GLOBAL(cgetri,CGETRI)\n#define LAPACK_zgetri LAPACK_GLOBAL(zgetri,ZGETRI)\n#define LAPACK_spotri LAPACK_GLOBAL(spotri,SPOTRI)\n#define LAPACK_dpotri LAPACK_GLOBAL(dpotri,DPOTRI)\n#define LAPACK_cpotri LAPACK_GLOBAL(cpotri,CPOTRI)\n#define LAPACK_zpotri LAPACK_GLOBAL(zpotri,ZPOTRI)\n#define LAPACK_dpftri LAPACK_GLOBAL(dpftri,DPFTRI)\n#define LAPACK_spftri LAPACK_GLOBAL(spftri,SPFTRI)\n#define LAPACK_zpftri LAPACK_GLOBAL(zpftri,ZPFTRI)\n#define LAPACK_cpftri LAPACK_GLOBAL(cpftri,CPFTRI)\n#define LAPACK_spptri LAPACK_GLOBAL(spptri,SPPTRI)\n#define LAPACK_dpptri LAPACK_GLOBAL(dpptri,DPPTRI)\n#define LAPACK_cpptri LAPACK_GLOBAL(cpptri,CPPTRI)\n#define LAPACK_zpptri LAPACK_GLOBAL(zpptri,ZPPTRI)\n#define LAPACK_ssytri LAPACK_GLOBAL(ssytri,SSYTRI)\n#define LAPACK_dsytri LAPACK_GLOBAL(dsytri,DSYTRI)\n#define LAPACK_csytri LAPACK_GLOBAL(csytri,CSYTRI)\n#define LAPACK_zsytri LAPACK_GLOBAL(zsytri,ZSYTRI)\n#define LAPACK_chetri LAPACK_GLOBAL(chetri,CHETRI)\n#define LAPACK_zhetri LAPACK_GLOBAL(zhetri,ZHETRI)\n#define LAPACK_ssptri LAPACK_GLOBAL(ssptri,SSPTRI)\n#define LAPACK_dsptri LAPACK_GLOBAL(dsptri,DSPTRI)\n#define LAPACK_csptri LAPACK_GLOBAL(csptri,CSPTRI)\n#define LAPACK_zsptri LAPACK_GLOBAL(zsptri,ZSPTRI)\n#define LAPACK_chptri LAPACK_GLOBAL(chptri,CHPTRI)\n#define LAPACK_zhptri LAPACK_GLOBAL(zhptri,ZHPTRI)\n#define LAPACK_strtri LAPACK_GLOBAL(strtri,STRTRI)\n#define LAPACK_dtrtri LAPACK_GLOBAL(dtrtri,DTRTRI)\n#define LAPACK_ctrtri LAPACK_GLOBAL(ctrtri,CTRTRI)\n#define LAPACK_ztrtri LAPACK_GLOBAL(ztrtri,ZTRTRI)\n#define LAPACK_dtftri LAPACK_GLOBAL(dtftri,DTFTRI)\n#define LAPACK_stftri LAPACK_GLOBAL(stftri,STFTRI)\n#define LAPACK_ztftri LAPACK_GLOBAL(ztftri,ZTFTRI)\n#define LAPACK_ctftri LAPACK_GLOBAL(ctftri,CTFTRI)\n#define LAPACK_stptri LAPACK_GLOBAL(stptri,STPTRI)\n#define LAPACK_dtptri LAPACK_GLOBAL(dtptri,DTPTRI)\n#define LAPACK_ctptri LAPACK_GLOBAL(ctptri,CTPTRI)\n#define LAPACK_ztptri LAPACK_GLOBAL(ztptri,ZTPTRI)\n#define LAPACK_sgeequ LAPACK_GLOBAL(sgeequ,SGEEQU)\n#define LAPACK_dgeequ LAPACK_GLOBAL(dgeequ,DGEEQU)\n#define LAPACK_cgeequ LAPACK_GLOBAL(cgeequ,CGEEQU)\n#define LAPACK_zgeequ LAPACK_GLOBAL(zgeequ,ZGEEQU)\n#define LAPACK_dgeequb LAPACK_GLOBAL(dgeequb,DGEEQUB)\n#define LAPACK_sgeequb LAPACK_GLOBAL(sgeequb,SGEEQUB)\n#define LAPACK_zgeequb LAPACK_GLOBAL(zgeequb,ZGEEQUB)\n#define LAPACK_cgeequb LAPACK_GLOBAL(cgeequb,CGEEQUB)\n#define LAPACK_sgbequ LAPACK_GLOBAL(sgbequ,SGBEQU)\n#define LAPACK_dgbequ LAPACK_GLOBAL(dgbequ,DGBEQU)\n#define LAPACK_cgbequ LAPACK_GLOBAL(cgbequ,CGBEQU)\n#define LAPACK_zgbequ LAPACK_GLOBAL(zgbequ,ZGBEQU)\n#define LAPACK_dgbequb LAPACK_GLOBAL(dgbequb,DGBEQUB)\n#define LAPACK_sgbequb LAPACK_GLOBAL(sgbequb,SGBEQUB)\n#define LAPACK_zgbequb LAPACK_GLOBAL(zgbequb,ZGBEQUB)\n#define LAPACK_cgbequb LAPACK_GLOBAL(cgbequb,CGBEQUB)\n#define LAPACK_spoequ LAPACK_GLOBAL(spoequ,SPOEQU)\n#define LAPACK_dpoequ LAPACK_GLOBAL(dpoequ,DPOEQU)\n#define LAPACK_cpoequ LAPACK_GLOBAL(cpoequ,CPOEQU)\n#define LAPACK_zpoequ LAPACK_GLOBAL(zpoequ,ZPOEQU)\n#define LAPACK_dpoequb LAPACK_GLOBAL(dpoequb,DPOEQUB)\n#define LAPACK_spoequb LAPACK_GLOBAL(spoequb,SPOEQUB)\n#define LAPACK_zpoequb LAPACK_GLOBAL(zpoequb,ZPOEQUB)\n#define LAPACK_cpoequb LAPACK_GLOBAL(cpoequb,CPOEQUB)\n#define LAPACK_sppequ LAPACK_GLOBAL(sppequ,SPPEQU)\n#define LAPACK_dppequ LAPACK_GLOBAL(dppequ,DPPEQU)\n#define LAPACK_cppequ LAPACK_GLOBAL(cppequ,CPPEQU)\n#define LAPACK_zppequ LAPACK_GLOBAL(zppequ,ZPPEQU)\n#define LAPACK_spbequ LAPACK_GLOBAL(spbequ,SPBEQU)\n#define LAPACK_dpbequ LAPACK_GLOBAL(dpbequ,DPBEQU)\n#define LAPACK_cpbequ LAPACK_GLOBAL(cpbequ,CPBEQU)\n#define LAPACK_zpbequ LAPACK_GLOBAL(zpbequ,ZPBEQU)\n#define LAPACK_dsyequb LAPACK_GLOBAL(dsyequb,DSYEQUB)\n#define LAPACK_ssyequb LAPACK_GLOBAL(ssyequb,SSYEQUB)\n#define LAPACK_zsyequb LAPACK_GLOBAL(zsyequb,ZSYEQUB)\n#define LAPACK_csyequb LAPACK_GLOBAL(csyequb,CSYEQUB)\n#define LAPACK_zheequb LAPACK_GLOBAL(zheequb,ZHEEQUB)\n#define LAPACK_cheequb LAPACK_GLOBAL(cheequb,CHEEQUB)\n#define LAPACK_sgesv LAPACK_GLOBAL(sgesv,SGESV)\n#define LAPACK_dgesv LAPACK_GLOBAL(dgesv,DGESV)\n#define LAPACK_cgesv LAPACK_GLOBAL(cgesv,CGESV)\n#define LAPACK_zgesv LAPACK_GLOBAL(zgesv,ZGESV)\n#define LAPACK_dsgesv LAPACK_GLOBAL(dsgesv,DSGESV)\n#define LAPACK_zcgesv LAPACK_GLOBAL(zcgesv,ZCGESV)\n#define LAPACK_sgesvx LAPACK_GLOBAL(sgesvx,SGESVX)\n#define LAPACK_dgesvx LAPACK_GLOBAL(dgesvx,DGESVX)\n#define LAPACK_cgesvx LAPACK_GLOBAL(cgesvx,CGESVX)\n#define LAPACK_zgesvx LAPACK_GLOBAL(zgesvx,ZGESVX)\n#define LAPACK_sgbsv LAPACK_GLOBAL(sgbsv,SGBSV)\n#define LAPACK_dgbsv LAPACK_GLOBAL(dgbsv,DGBSV)\n#define LAPACK_cgbsv LAPACK_GLOBAL(cgbsv,CGBSV)\n#define LAPACK_zgbsv LAPACK_GLOBAL(zgbsv,ZGBSV)\n#define LAPACK_sgbsvx LAPACK_GLOBAL(sgbsvx,SGBSVX)\n#define LAPACK_dgbsvx LAPACK_GLOBAL(dgbsvx,DGBSVX)\n#define LAPACK_cgbsvx LAPACK_GLOBAL(cgbsvx,CGBSVX)\n#define LAPACK_zgbsvx LAPACK_GLOBAL(zgbsvx,ZGBSVX)\n#define LAPACK_sgtsv LAPACK_GLOBAL(sgtsv,SGTSV)\n#define LAPACK_dgtsv LAPACK_GLOBAL(dgtsv,DGTSV)\n#define LAPACK_cgtsv LAPACK_GLOBAL(cgtsv,CGTSV)\n#define LAPACK_zgtsv LAPACK_GLOBAL(zgtsv,ZGTSV)\n#define LAPACK_sgtsvx LAPACK_GLOBAL(sgtsvx,SGTSVX)\n#define LAPACK_dgtsvx LAPACK_GLOBAL(dgtsvx,DGTSVX)\n#define LAPACK_cgtsvx LAPACK_GLOBAL(cgtsvx,CGTSVX)\n#define LAPACK_zgtsvx LAPACK_GLOBAL(zgtsvx,ZGTSVX)\n#define LAPACK_sposv LAPACK_GLOBAL(sposv,SPOSV)\n#define LAPACK_dposv LAPACK_GLOBAL(dposv,DPOSV)\n#define LAPACK_cposv LAPACK_GLOBAL(cposv,CPOSV)\n#define LAPACK_zposv LAPACK_GLOBAL(zposv,ZPOSV)\n#define LAPACK_dsposv LAPACK_GLOBAL(dsposv,DSPOSV)\n#define LAPACK_zcposv LAPACK_GLOBAL(zcposv,ZCPOSV)\n#define LAPACK_sposvx LAPACK_GLOBAL(sposvx,SPOSVX)\n#define LAPACK_dposvx LAPACK_GLOBAL(dposvx,DPOSVX)\n#define LAPACK_cposvx LAPACK_GLOBAL(cposvx,CPOSVX)\n#define LAPACK_zposvx LAPACK_GLOBAL(zposvx,ZPOSVX)\n#define LAPACK_sppsv LAPACK_GLOBAL(sppsv,SPPSV)\n#define LAPACK_dppsv LAPACK_GLOBAL(dppsv,DPPSV)\n#define LAPACK_cppsv LAPACK_GLOBAL(cppsv,CPPSV)\n#define LAPACK_zppsv LAPACK_GLOBAL(zppsv,ZPPSV)\n#define LAPACK_sppsvx LAPACK_GLOBAL(sppsvx,SPPSVX)\n#define LAPACK_dppsvx LAPACK_GLOBAL(dppsvx,DPPSVX)\n#define LAPACK_cppsvx LAPACK_GLOBAL(cppsvx,CPPSVX)\n#define LAPACK_zppsvx LAPACK_GLOBAL(zppsvx,ZPPSVX)\n#define LAPACK_spbsv LAPACK_GLOBAL(spbsv,SPBSV)\n#define LAPACK_dpbsv LAPACK_GLOBAL(dpbsv,DPBSV)\n#define LAPACK_cpbsv LAPACK_GLOBAL(cpbsv,CPBSV)\n#define LAPACK_zpbsv LAPACK_GLOBAL(zpbsv,ZPBSV)\n#define LAPACK_spbsvx LAPACK_GLOBAL(spbsvx,SPBSVX)\n#define LAPACK_dpbsvx LAPACK_GLOBAL(dpbsvx,DPBSVX)\n#define LAPACK_cpbsvx LAPACK_GLOBAL(cpbsvx,CPBSVX)\n#define LAPACK_zpbsvx LAPACK_GLOBAL(zpbsvx,ZPBSVX)\n#define LAPACK_sptsv LAPACK_GLOBAL(sptsv,SPTSV)\n#define LAPACK_dptsv LAPACK_GLOBAL(dptsv,DPTSV)\n#define LAPACK_cptsv LAPACK_GLOBAL(cptsv,CPTSV)\n#define LAPACK_zptsv LAPACK_GLOBAL(zptsv,ZPTSV)\n#define LAPACK_sptsvx LAPACK_GLOBAL(sptsvx,SPTSVX)\n#define LAPACK_dptsvx LAPACK_GLOBAL(dptsvx,DPTSVX)\n#define LAPACK_cptsvx LAPACK_GLOBAL(cptsvx,CPTSVX)\n#define LAPACK_zptsvx LAPACK_GLOBAL(zptsvx,ZPTSVX)\n#define LAPACK_ssysv LAPACK_GLOBAL(ssysv,SSYSV)\n#define LAPACK_dsysv LAPACK_GLOBAL(dsysv,DSYSV)\n#define LAPACK_csysv LAPACK_GLOBAL(csysv,CSYSV)\n#define LAPACK_zsysv LAPACK_GLOBAL(zsysv,ZSYSV)\n#define LAPACK_ssysvx LAPACK_GLOBAL(ssysvx,SSYSVX)\n#define LAPACK_dsysvx LAPACK_GLOBAL(dsysvx,DSYSVX)\n#define LAPACK_csysvx LAPACK_GLOBAL(csysvx,CSYSVX)\n#define LAPACK_zsysvx LAPACK_GLOBAL(zsysvx,ZSYSVX)\n#define LAPACK_chesv LAPACK_GLOBAL(chesv,CHESV)\n#define LAPACK_zhesv LAPACK_GLOBAL(zhesv,ZHESV)\n#define LAPACK_chesvx LAPACK_GLOBAL(chesvx,CHESVX)\n#define LAPACK_zhesvx LAPACK_GLOBAL(zhesvx,ZHESVX)\n#define LAPACK_sspsv LAPACK_GLOBAL(sspsv,SSPSV)\n#define LAPACK_dspsv LAPACK_GLOBAL(dspsv,DSPSV)\n#define LAPACK_cspsv LAPACK_GLOBAL(cspsv,CSPSV)\n#define LAPACK_zspsv LAPACK_GLOBAL(zspsv,ZSPSV)\n#define LAPACK_sspsvx LAPACK_GLOBAL(sspsvx,SSPSVX)\n#define LAPACK_dspsvx LAPACK_GLOBAL(dspsvx,DSPSVX)\n#define LAPACK_cspsvx LAPACK_GLOBAL(cspsvx,CSPSVX)\n#define LAPACK_zspsvx LAPACK_GLOBAL(zspsvx,ZSPSVX)\n#define LAPACK_chpsv LAPACK_GLOBAL(chpsv,CHPSV)\n#define LAPACK_zhpsv LAPACK_GLOBAL(zhpsv,ZHPSV)\n#define LAPACK_chpsvx LAPACK_GLOBAL(chpsvx,CHPSVX)\n#define LAPACK_zhpsvx LAPACK_GLOBAL(zhpsvx,ZHPSVX)\n#define LAPACK_sgeqrf LAPACK_GLOBAL(sgeqrf,SGEQRF)\n#define LAPACK_dgeqrf LAPACK_GLOBAL(dgeqrf,DGEQRF)\n#define LAPACK_cgeqrf LAPACK_GLOBAL(cgeqrf,CGEQRF)\n#define LAPACK_zgeqrf LAPACK_GLOBAL(zgeqrf,ZGEQRF)\n#define LAPACK_sgeqpf LAPACK_GLOBAL(sgeqpf,SGEQPF)\n#define LAPACK_dgeqpf LAPACK_GLOBAL(dgeqpf,DGEQPF)\n#define LAPACK_cgeqpf LAPACK_GLOBAL(cgeqpf,CGEQPF)\n#define LAPACK_zgeqpf LAPACK_GLOBAL(zgeqpf,ZGEQPF)\n#define LAPACK_sgeqp3 LAPACK_GLOBAL(sgeqp3,SGEQP3)\n#define LAPACK_dgeqp3 LAPACK_GLOBAL(dgeqp3,DGEQP3)\n#define LAPACK_cgeqp3 LAPACK_GLOBAL(cgeqp3,CGEQP3)\n#define LAPACK_zgeqp3 LAPACK_GLOBAL(zgeqp3,ZGEQP3)\n#define LAPACK_sorgqr LAPACK_GLOBAL(sorgqr,SORGQR)\n#define LAPACK_dorgqr LAPACK_GLOBAL(dorgqr,DORGQR)\n#define LAPACK_sormqr LAPACK_GLOBAL(sormqr,SORMQR)\n#define LAPACK_dormqr LAPACK_GLOBAL(dormqr,DORMQR)\n#define LAPACK_cungqr LAPACK_GLOBAL(cungqr,CUNGQR)\n#define LAPACK_zungqr LAPACK_GLOBAL(zungqr,ZUNGQR)\n#define LAPACK_cunmqr LAPACK_GLOBAL(cunmqr,CUNMQR)\n#define LAPACK_zunmqr LAPACK_GLOBAL(zunmqr,ZUNMQR)\n#define LAPACK_sgelqf LAPACK_GLOBAL(sgelqf,SGELQF)\n#define LAPACK_dgelqf LAPACK_GLOBAL(dgelqf,DGELQF)\n#define LAPACK_cgelqf LAPACK_GLOBAL(cgelqf,CGELQF)\n#define LAPACK_zgelqf LAPACK_GLOBAL(zgelqf,ZGELQF)\n#define LAPACK_sorglq LAPACK_GLOBAL(sorglq,SORGLQ)\n#define LAPACK_dorglq LAPACK_GLOBAL(dorglq,DORGLQ)\n#define LAPACK_sormlq LAPACK_GLOBAL(sormlq,SORMLQ)\n#define LAPACK_dormlq LAPACK_GLOBAL(dormlq,DORMLQ)\n#define LAPACK_cunglq LAPACK_GLOBAL(cunglq,CUNGLQ)\n#define LAPACK_zunglq LAPACK_GLOBAL(zunglq,ZUNGLQ)\n#define LAPACK_cunmlq LAPACK_GLOBAL(cunmlq,CUNMLQ)\n#define LAPACK_zunmlq LAPACK_GLOBAL(zunmlq,ZUNMLQ)\n#define LAPACK_sgeqlf LAPACK_GLOBAL(sgeqlf,SGEQLF)\n#define LAPACK_dgeqlf LAPACK_GLOBAL(dgeqlf,DGEQLF)\n#define LAPACK_cgeqlf LAPACK_GLOBAL(cgeqlf,CGEQLF)\n#define LAPACK_zgeqlf LAPACK_GLOBAL(zgeqlf,ZGEQLF)\n#define LAPACK_sorgql LAPACK_GLOBAL(sorgql,SORGQL)\n#define LAPACK_dorgql LAPACK_GLOBAL(dorgql,DORGQL)\n#define LAPACK_cungql LAPACK_GLOBAL(cungql,CUNGQL)\n#define LAPACK_zungql LAPACK_GLOBAL(zungql,ZUNGQL)\n#define LAPACK_sormql LAPACK_GLOBAL(sormql,SORMQL)\n#define LAPACK_dormql LAPACK_GLOBAL(dormql,DORMQL)\n#define LAPACK_cunmql LAPACK_GLOBAL(cunmql,CUNMQL)\n#define LAPACK_zunmql LAPACK_GLOBAL(zunmql,ZUNMQL)\n#define LAPACK_sgerqf LAPACK_GLOBAL(sgerqf,SGERQF)\n#define LAPACK_dgerqf LAPACK_GLOBAL(dgerqf,DGERQF)\n#define LAPACK_cgerqf LAPACK_GLOBAL(cgerqf,CGERQF)\n#define LAPACK_zgerqf LAPACK_GLOBAL(zgerqf,ZGERQF)\n#define LAPACK_sorgrq LAPACK_GLOBAL(sorgrq,SORGRQ)\n#define LAPACK_dorgrq LAPACK_GLOBAL(dorgrq,DORGRQ)\n#define LAPACK_cungrq LAPACK_GLOBAL(cungrq,CUNGRQ)\n#define LAPACK_zungrq LAPACK_GLOBAL(zungrq,ZUNGRQ)\n#define LAPACK_sormrq LAPACK_GLOBAL(sormrq,SORMRQ)\n#define LAPACK_dormrq LAPACK_GLOBAL(dormrq,DORMRQ)\n#define LAPACK_cunmrq LAPACK_GLOBAL(cunmrq,CUNMRQ)\n#define LAPACK_zunmrq LAPACK_GLOBAL(zunmrq,ZUNMRQ)\n#define LAPACK_stzrzf LAPACK_GLOBAL(stzrzf,STZRZF)\n#define LAPACK_dtzrzf LAPACK_GLOBAL(dtzrzf,DTZRZF)\n#define LAPACK_ctzrzf LAPACK_GLOBAL(ctzrzf,CTZRZF)\n#define LAPACK_ztzrzf LAPACK_GLOBAL(ztzrzf,ZTZRZF)\n#define LAPACK_sormrz LAPACK_GLOBAL(sormrz,SORMRZ)\n#define LAPACK_dormrz LAPACK_GLOBAL(dormrz,DORMRZ)\n#define LAPACK_cunmrz LAPACK_GLOBAL(cunmrz,CUNMRZ)\n#define LAPACK_zunmrz LAPACK_GLOBAL(zunmrz,ZUNMRZ)\n#define LAPACK_sggqrf LAPACK_GLOBAL(sggqrf,SGGQRF)\n#define LAPACK_dggqrf LAPACK_GLOBAL(dggqrf,DGGQRF)\n#define LAPACK_cggqrf LAPACK_GLOBAL(cggqrf,CGGQRF)\n#define LAPACK_zggqrf LAPACK_GLOBAL(zggqrf,ZGGQRF)\n#define LAPACK_sggrqf LAPACK_GLOBAL(sggrqf,SGGRQF)\n#define LAPACK_dggrqf LAPACK_GLOBAL(dggrqf,DGGRQF)\n#define LAPACK_cggrqf LAPACK_GLOBAL(cggrqf,CGGRQF)\n#define LAPACK_zggrqf LAPACK_GLOBAL(zggrqf,ZGGRQF)\n#define LAPACK_sgebrd LAPACK_GLOBAL(sgebrd,SGEBRD)\n#define LAPACK_dgebrd LAPACK_GLOBAL(dgebrd,DGEBRD)\n#define LAPACK_cgebrd LAPACK_GLOBAL(cgebrd,CGEBRD)\n#define LAPACK_zgebrd LAPACK_GLOBAL(zgebrd,ZGEBRD)\n#define LAPACK_sgbbrd LAPACK_GLOBAL(sgbbrd,SGBBRD)\n#define LAPACK_dgbbrd LAPACK_GLOBAL(dgbbrd,DGBBRD)\n#define LAPACK_cgbbrd LAPACK_GLOBAL(cgbbrd,CGBBRD)\n#define LAPACK_zgbbrd LAPACK_GLOBAL(zgbbrd,ZGBBRD)\n#define LAPACK_sorgbr LAPACK_GLOBAL(sorgbr,SORGBR)\n#define LAPACK_dorgbr LAPACK_GLOBAL(dorgbr,DORGBR)\n#define LAPACK_sormbr LAPACK_GLOBAL(sormbr,SORMBR)\n#define LAPACK_dormbr LAPACK_GLOBAL(dormbr,DORMBR)\n#define LAPACK_cungbr LAPACK_GLOBAL(cungbr,CUNGBR)\n#define LAPACK_zungbr LAPACK_GLOBAL(zungbr,ZUNGBR)\n#define LAPACK_cunmbr LAPACK_GLOBAL(cunmbr,CUNMBR)\n#define LAPACK_zunmbr LAPACK_GLOBAL(zunmbr,ZUNMBR)\n#define LAPACK_sbdsqr LAPACK_GLOBAL(sbdsqr,SBDSQR)\n#define LAPACK_dbdsqr LAPACK_GLOBAL(dbdsqr,DBDSQR)\n#define LAPACK_cbdsqr LAPACK_GLOBAL(cbdsqr,CBDSQR)\n#define LAPACK_zbdsqr LAPACK_GLOBAL(zbdsqr,ZBDSQR)\n#define LAPACK_sbdsdc LAPACK_GLOBAL(sbdsdc,SBDSDC)\n#define LAPACK_dbdsdc LAPACK_GLOBAL(dbdsdc,DBDSDC)\n#define LAPACK_sbdsvdx LAPACK_GLOBAL(sbdsvdx,SBDSVDX)\n#define LAPACK_dbdsvdx LAPACK_GLOBAL(dbdsvdx,DBDSVDX)\n#define LAPACK_ssytrd LAPACK_GLOBAL(ssytrd,SSYTRD)\n#define LAPACK_dsytrd LAPACK_GLOBAL(dsytrd,DSYTRD)\n#define LAPACK_sorgtr LAPACK_GLOBAL(sorgtr,SORGTR)\n#define LAPACK_dorgtr LAPACK_GLOBAL(dorgtr,DORGTR)\n#define LAPACK_sormtr LAPACK_GLOBAL(sormtr,SORMTR)\n#define LAPACK_dormtr LAPACK_GLOBAL(dormtr,DORMTR)\n#define LAPACK_chetrd LAPACK_GLOBAL(chetrd,CHETRD)\n#define LAPACK_zhetrd LAPACK_GLOBAL(zhetrd,ZHETRD)\n#define LAPACK_cungtr LAPACK_GLOBAL(cungtr,CUNGTR)\n#define LAPACK_zungtr LAPACK_GLOBAL(zungtr,ZUNGTR)\n#define LAPACK_cunmtr LAPACK_GLOBAL(cunmtr,CUNMTR)\n#define LAPACK_zunmtr LAPACK_GLOBAL(zunmtr,ZUNMTR)\n#define LAPACK_ssptrd LAPACK_GLOBAL(ssptrd,SSPTRD)\n#define LAPACK_dsptrd LAPACK_GLOBAL(dsptrd,DSPTRD)\n#define LAPACK_sopgtr LAPACK_GLOBAL(sopgtr,SOPGTR)\n#define LAPACK_dopgtr LAPACK_GLOBAL(dopgtr,DOPGTR)\n#define LAPACK_sopmtr LAPACK_GLOBAL(sopmtr,SOPMTR)\n#define LAPACK_dopmtr LAPACK_GLOBAL(dopmtr,DOPMTR)\n#define LAPACK_chptrd LAPACK_GLOBAL(chptrd,CHPTRD)\n#define LAPACK_zhptrd LAPACK_GLOBAL(zhptrd,ZHPTRD)\n#define LAPACK_cupgtr LAPACK_GLOBAL(cupgtr,CUPGTR)\n#define LAPACK_zupgtr LAPACK_GLOBAL(zupgtr,ZUPGTR)\n#define LAPACK_cupmtr LAPACK_GLOBAL(cupmtr,CUPMTR)\n#define LAPACK_zupmtr LAPACK_GLOBAL(zupmtr,ZUPMTR)\n#define LAPACK_ssbtrd LAPACK_GLOBAL(ssbtrd,SSBTRD)\n#define LAPACK_dsbtrd LAPACK_GLOBAL(dsbtrd,DSBTRD)\n#define LAPACK_chbtrd LAPACK_GLOBAL(chbtrd,CHBTRD)\n#define LAPACK_zhbtrd LAPACK_GLOBAL(zhbtrd,ZHBTRD)\n#define LAPACK_ssterf LAPACK_GLOBAL(ssterf,SSTERF)\n#define LAPACK_dsterf LAPACK_GLOBAL(dsterf,DSTERF)\n#define LAPACK_ssteqr LAPACK_GLOBAL(ssteqr,SSTEQR)\n#define LAPACK_dsteqr LAPACK_GLOBAL(dsteqr,DSTEQR)\n#define LAPACK_csteqr LAPACK_GLOBAL(csteqr,CSTEQR)\n#define LAPACK_zsteqr LAPACK_GLOBAL(zsteqr,ZSTEQR)\n#define LAPACK_sstemr LAPACK_GLOBAL(sstemr,SSTEMR)\n#define LAPACK_dstemr LAPACK_GLOBAL(dstemr,DSTEMR)\n#define LAPACK_cstemr LAPACK_GLOBAL(cstemr,CSTEMR)\n#define LAPACK_zstemr LAPACK_GLOBAL(zstemr,ZSTEMR)\n#define LAPACK_sstedc LAPACK_GLOBAL(sstedc,SSTEDC)\n#define LAPACK_dstedc LAPACK_GLOBAL(dstedc,DSTEDC)\n#define LAPACK_cstedc LAPACK_GLOBAL(cstedc,CSTEDC)\n#define LAPACK_zstedc LAPACK_GLOBAL(zstedc,ZSTEDC)\n#define LAPACK_sstegr LAPACK_GLOBAL(sstegr,SSTEGR)\n#define LAPACK_dstegr LAPACK_GLOBAL(dstegr,DSTEGR)\n#define LAPACK_cstegr LAPACK_GLOBAL(cstegr,CSTEGR)\n#define LAPACK_zstegr LAPACK_GLOBAL(zstegr,ZSTEGR)\n#define LAPACK_spteqr LAPACK_GLOBAL(spteqr,SPTEQR)\n#define LAPACK_dpteqr LAPACK_GLOBAL(dpteqr,DPTEQR)\n#define LAPACK_cpteqr LAPACK_GLOBAL(cpteqr,CPTEQR)\n#define LAPACK_zpteqr LAPACK_GLOBAL(zpteqr,ZPTEQR)\n#define LAPACK_sstebz LAPACK_GLOBAL(sstebz,SSTEBZ)\n#define LAPACK_dstebz LAPACK_GLOBAL(dstebz,DSTEBZ)\n#define LAPACK_sstein LAPACK_GLOBAL(sstein,SSTEIN)\n#define LAPACK_dstein LAPACK_GLOBAL(dstein,DSTEIN)\n#define LAPACK_cstein LAPACK_GLOBAL(cstein,CSTEIN)\n#define LAPACK_zstein LAPACK_GLOBAL(zstein,ZSTEIN)\n#define LAPACK_sdisna LAPACK_GLOBAL(sdisna,SDISNA)\n#define LAPACK_ddisna LAPACK_GLOBAL(ddisna,DDISNA)\n#define LAPACK_ssygst LAPACK_GLOBAL(ssygst,SSYGST)\n#define LAPACK_dsygst LAPACK_GLOBAL(dsygst,DSYGST)\n#define LAPACK_chegst LAPACK_GLOBAL(chegst,CHEGST)\n#define LAPACK_zhegst LAPACK_GLOBAL(zhegst,ZHEGST)\n#define LAPACK_sspgst LAPACK_GLOBAL(sspgst,SSPGST)\n#define LAPACK_dspgst LAPACK_GLOBAL(dspgst,DSPGST)\n#define LAPACK_chpgst LAPACK_GLOBAL(chpgst,CHPGST)\n#define LAPACK_zhpgst LAPACK_GLOBAL(zhpgst,ZHPGST)\n#define LAPACK_ssbgst LAPACK_GLOBAL(ssbgst,SSBGST)\n#define LAPACK_dsbgst LAPACK_GLOBAL(dsbgst,DSBGST)\n#define LAPACK_chbgst LAPACK_GLOBAL(chbgst,CHBGST)\n#define LAPACK_zhbgst LAPACK_GLOBAL(zhbgst,ZHBGST)\n#define LAPACK_spbstf LAPACK_GLOBAL(spbstf,SPBSTF)\n#define LAPACK_dpbstf LAPACK_GLOBAL(dpbstf,DPBSTF)\n#define LAPACK_cpbstf LAPACK_GLOBAL(cpbstf,CPBSTF)\n#define LAPACK_zpbstf LAPACK_GLOBAL(zpbstf,ZPBSTF)\n#define LAPACK_sgehrd LAPACK_GLOBAL(sgehrd,SGEHRD)\n#define LAPACK_dgehrd LAPACK_GLOBAL(dgehrd,DGEHRD)\n#define LAPACK_cgehrd LAPACK_GLOBAL(cgehrd,CGEHRD)\n#define LAPACK_zgehrd LAPACK_GLOBAL(zgehrd,ZGEHRD)\n#define LAPACK_sorghr LAPACK_GLOBAL(sorghr,SORGHR)\n#define LAPACK_dorghr LAPACK_GLOBAL(dorghr,DORGHR)\n#define LAPACK_sormhr LAPACK_GLOBAL(sormhr,SORMHR)\n#define LAPACK_dormhr LAPACK_GLOBAL(dormhr,DORMHR)\n#define LAPACK_cunghr LAPACK_GLOBAL(cunghr,CUNGHR)\n#define LAPACK_zunghr LAPACK_GLOBAL(zunghr,ZUNGHR)\n#define LAPACK_cunmhr LAPACK_GLOBAL(cunmhr,CUNMHR)\n#define LAPACK_zunmhr LAPACK_GLOBAL(zunmhr,ZUNMHR)\n#define LAPACK_sgebal LAPACK_GLOBAL(sgebal,SGEBAL)\n#define LAPACK_dgebal LAPACK_GLOBAL(dgebal,DGEBAL)\n#define LAPACK_cgebal LAPACK_GLOBAL(cgebal,CGEBAL)\n#define LAPACK_zgebal LAPACK_GLOBAL(zgebal,ZGEBAL)\n#define LAPACK_sgebak LAPACK_GLOBAL(sgebak,SGEBAK)\n#define LAPACK_dgebak LAPACK_GLOBAL(dgebak,DGEBAK)\n#define LAPACK_cgebak LAPACK_GLOBAL(cgebak,CGEBAK)\n#define LAPACK_zgebak LAPACK_GLOBAL(zgebak,ZGEBAK)\n#define LAPACK_shseqr LAPACK_GLOBAL(shseqr,SHSEQR)\n#define LAPACK_dhseqr LAPACK_GLOBAL(dhseqr,DHSEQR)\n#define LAPACK_chseqr LAPACK_GLOBAL(chseqr,CHSEQR)\n#define LAPACK_zhseqr LAPACK_GLOBAL(zhseqr,ZHSEQR)\n#define LAPACK_shsein LAPACK_GLOBAL(shsein,SHSEIN)\n#define LAPACK_dhsein LAPACK_GLOBAL(dhsein,DHSEIN)\n#define LAPACK_chsein LAPACK_GLOBAL(chsein,CHSEIN)\n#define LAPACK_zhsein LAPACK_GLOBAL(zhsein,ZHSEIN)\n#define LAPACK_strevc LAPACK_GLOBAL(strevc,STREVC)\n#define LAPACK_dtrevc LAPACK_GLOBAL(dtrevc,DTREVC)\n#define LAPACK_ctrevc LAPACK_GLOBAL(ctrevc,CTREVC)\n#define LAPACK_ztrevc LAPACK_GLOBAL(ztrevc,ZTREVC)\n#define LAPACK_strsna LAPACK_GLOBAL(strsna,STRSNA)\n#define LAPACK_dtrsna LAPACK_GLOBAL(dtrsna,DTRSNA)\n#define LAPACK_ctrsna LAPACK_GLOBAL(ctrsna,CTRSNA)\n#define LAPACK_ztrsna LAPACK_GLOBAL(ztrsna,ZTRSNA)\n#define LAPACK_strexc LAPACK_GLOBAL(strexc,STREXC)\n#define LAPACK_dtrexc LAPACK_GLOBAL(dtrexc,DTREXC)\n#define LAPACK_ctrexc LAPACK_GLOBAL(ctrexc,CTREXC)\n#define LAPACK_ztrexc LAPACK_GLOBAL(ztrexc,ZTREXC)\n#define LAPACK_strsen LAPACK_GLOBAL(strsen,STRSEN)\n#define LAPACK_dtrsen LAPACK_GLOBAL(dtrsen,DTRSEN)\n#define LAPACK_ctrsen LAPACK_GLOBAL(ctrsen,CTRSEN)\n#define LAPACK_ztrsen LAPACK_GLOBAL(ztrsen,ZTRSEN)\n#define LAPACK_strsyl LAPACK_GLOBAL(strsyl,STRSYL)\n#define LAPACK_dtrsyl LAPACK_GLOBAL(dtrsyl,DTRSYL)\n#define LAPACK_ctrsyl LAPACK_GLOBAL(ctrsyl,CTRSYL)\n#define LAPACK_ztrsyl LAPACK_GLOBAL(ztrsyl,ZTRSYL)\n#define LAPACK_sgghrd LAPACK_GLOBAL(sgghrd,SGGHRD)\n#define LAPACK_dgghrd LAPACK_GLOBAL(dgghrd,DGGHRD)\n#define LAPACK_cgghrd LAPACK_GLOBAL(cgghrd,CGGHRD)\n#define LAPACK_zgghrd LAPACK_GLOBAL(zgghrd,ZGGHRD)\n#define LAPACK_sgghd3 LAPACK_GLOBAL(sgghd3,SGGHD3)\n#define LAPACK_dgghd3 LAPACK_GLOBAL(dgghd3,DGGHD3)\n#define LAPACK_cgghd3 LAPACK_GLOBAL(cgghd3,CGGHD3)\n#define LAPACK_zgghd3 LAPACK_GLOBAL(zgghd3,ZGGHD3)\n#define LAPACK_sggbal LAPACK_GLOBAL(sggbal,SGGBAL)\n#define LAPACK_dggbal LAPACK_GLOBAL(dggbal,DGGBAL)\n#define LAPACK_cggbal LAPACK_GLOBAL(cggbal,CGGBAL)\n#define LAPACK_zggbal LAPACK_GLOBAL(zggbal,ZGGBAL)\n#define LAPACK_sggbak LAPACK_GLOBAL(sggbak,SGGBAK)\n#define LAPACK_dggbak LAPACK_GLOBAL(dggbak,DGGBAK)\n#define LAPACK_cggbak LAPACK_GLOBAL(cggbak,CGGBAK)\n#define LAPACK_zggbak LAPACK_GLOBAL(zggbak,ZGGBAK)\n#define LAPACK_shgeqz LAPACK_GLOBAL(shgeqz,SHGEQZ)\n#define LAPACK_dhgeqz LAPACK_GLOBAL(dhgeqz,DHGEQZ)\n#define LAPACK_chgeqz LAPACK_GLOBAL(chgeqz,CHGEQZ)\n#define LAPACK_zhgeqz LAPACK_GLOBAL(zhgeqz,ZHGEQZ)\n#define LAPACK_stgevc LAPACK_GLOBAL(stgevc,STGEVC)\n#define LAPACK_dtgevc LAPACK_GLOBAL(dtgevc,DTGEVC)\n#define LAPACK_ctgevc LAPACK_GLOBAL(ctgevc,CTGEVC)\n#define LAPACK_ztgevc LAPACK_GLOBAL(ztgevc,ZTGEVC)\n#define LAPACK_stgexc LAPACK_GLOBAL(stgexc,STGEXC)\n#define LAPACK_dtgexc LAPACK_GLOBAL(dtgexc,DTGEXC)\n#define LAPACK_ctgexc LAPACK_GLOBAL(ctgexc,CTGEXC)\n#define LAPACK_ztgexc LAPACK_GLOBAL(ztgexc,ZTGEXC)\n#define LAPACK_stgsen LAPACK_GLOBAL(stgsen,STGSEN)\n#define LAPACK_dtgsen LAPACK_GLOBAL(dtgsen,DTGSEN)\n#define LAPACK_ctgsen LAPACK_GLOBAL(ctgsen,CTGSEN)\n#define LAPACK_ztgsen LAPACK_GLOBAL(ztgsen,ZTGSEN)\n#define LAPACK_stgsyl LAPACK_GLOBAL(stgsyl,STGSYL)\n#define LAPACK_dtgsyl LAPACK_GLOBAL(dtgsyl,DTGSYL)\n#define LAPACK_ctgsyl LAPACK_GLOBAL(ctgsyl,CTGSYL)\n#define LAPACK_ztgsyl LAPACK_GLOBAL(ztgsyl,ZTGSYL)\n#define LAPACK_stgsna LAPACK_GLOBAL(stgsna,STGSNA)\n#define LAPACK_dtgsna LAPACK_GLOBAL(dtgsna,DTGSNA)\n#define LAPACK_ctgsna LAPACK_GLOBAL(ctgsna,CTGSNA)\n#define LAPACK_ztgsna LAPACK_GLOBAL(ztgsna,ZTGSNA)\n#define LAPACK_sggsvp LAPACK_GLOBAL(sggsvp,SGGSVP)\n#define LAPACK_dggsvp LAPACK_GLOBAL(dggsvp,DGGSVP)\n#define LAPACK_cggsvp LAPACK_GLOBAL(cggsvp,CGGSVP)\n#define LAPACK_zggsvp LAPACK_GLOBAL(zggsvp,ZGGSVP)\n#define LAPACK_sggsvp3 LAPACK_GLOBAL(sggsvp3,SGGSVP3)\n#define LAPACK_dggsvp3 LAPACK_GLOBAL(dggsvp3,DGGSVP3)\n#define LAPACK_cggsvp3 LAPACK_GLOBAL(cggsvp3,CGGSVP3)\n#define LAPACK_zggsvp3 LAPACK_GLOBAL(zggsvp3,ZGGSVP3)\n#define LAPACK_stgsja LAPACK_GLOBAL(stgsja,STGSJA)\n#define LAPACK_dtgsja LAPACK_GLOBAL(dtgsja,DTGSJA)\n#define LAPACK_ctgsja LAPACK_GLOBAL(ctgsja,CTGSJA)\n#define LAPACK_ztgsja LAPACK_GLOBAL(ztgsja,ZTGSJA)\n#define LAPACK_sgels LAPACK_GLOBAL(sgels,SGELS)\n#define LAPACK_dgels LAPACK_GLOBAL(dgels,DGELS)\n#define LAPACK_cgels LAPACK_GLOBAL(cgels,CGELS)\n#define LAPACK_zgels LAPACK_GLOBAL(zgels,ZGELS)\n#define LAPACK_sgelsy LAPACK_GLOBAL(sgelsy,SGELSY)\n#define LAPACK_dgelsy LAPACK_GLOBAL(dgelsy,DGELSY)\n#define LAPACK_cgelsy LAPACK_GLOBAL(cgelsy,CGELSY)\n#define LAPACK_zgelsy LAPACK_GLOBAL(zgelsy,ZGELSY)\n#define LAPACK_sgelss LAPACK_GLOBAL(sgelss,SGELSS)\n#define LAPACK_dgelss LAPACK_GLOBAL(dgelss,DGELSS)\n#define LAPACK_cgelss LAPACK_GLOBAL(cgelss,CGELSS)\n#define LAPACK_zgelss LAPACK_GLOBAL(zgelss,ZGELSS)\n#define LAPACK_sgelsd LAPACK_GLOBAL(sgelsd,SGELSD)\n#define LAPACK_dgelsd LAPACK_GLOBAL(dgelsd,DGELSD)\n#define LAPACK_cgelsd LAPACK_GLOBAL(cgelsd,CGELSD)\n#define LAPACK_zgelsd LAPACK_GLOBAL(zgelsd,ZGELSD)\n#define LAPACK_sgglse LAPACK_GLOBAL(sgglse,SGGLSE)\n#define LAPACK_dgglse LAPACK_GLOBAL(dgglse,DGGLSE)\n#define LAPACK_cgglse LAPACK_GLOBAL(cgglse,CGGLSE)\n#define LAPACK_zgglse LAPACK_GLOBAL(zgglse,ZGGLSE)\n#define LAPACK_sggglm LAPACK_GLOBAL(sggglm,SGGGLM)\n#define LAPACK_dggglm LAPACK_GLOBAL(dggglm,DGGGLM)\n#define LAPACK_cggglm LAPACK_GLOBAL(cggglm,CGGGLM)\n#define LAPACK_zggglm LAPACK_GLOBAL(zggglm,ZGGGLM)\n#define LAPACK_ssyev LAPACK_GLOBAL(ssyev,SSYEV)\n#define LAPACK_dsyev LAPACK_GLOBAL(dsyev,DSYEV)\n#define LAPACK_cheev LAPACK_GLOBAL(cheev,CHEEV)\n#define LAPACK_zheev LAPACK_GLOBAL(zheev,ZHEEV)\n#define LAPACK_ssyev_2stage LAPACK_GLOBAL(ssyev_2stage,SSYEV_2STAGE)\n#define LAPACK_dsyev_2stage LAPACK_GLOBAL(dsyev_2stage,DSYEV_2STAGE)\n#define LAPACK_cheev_2stage LAPACK_GLOBAL(cheev_2stage,CHEEV_2STAGE)\n#define LAPACK_zheev_2stage LAPACK_GLOBAL(zheev_2stage,ZHEEV_2STAGE)\n#define LAPACK_ssyevd LAPACK_GLOBAL(ssyevd,SSYEVD)\n#define LAPACK_dsyevd LAPACK_GLOBAL(dsyevd,DSYEVD)\n#define LAPACK_cheevd LAPACK_GLOBAL(cheevd,CHEEVD)\n#define LAPACK_zheevd LAPACK_GLOBAL(zheevd,ZHEEVD)\n#define LAPACK_ssyevd_2stage LAPACK_GLOBAL(ssyevd_2stage,SSYEVD_2STAGE)\n#define LAPACK_dsyevd_2stage LAPACK_GLOBAL(dsyevd_2stage,DSYEVD_2STAGE)\n#define LAPACK_cheevd_2stage LAPACK_GLOBAL(cheevd_2stage,CHEEVD_2STAGE)\n#define LAPACK_zheevd_2stage LAPACK_GLOBAL(zheevd_2stage,ZHEEVD_2STAGE)\n#define LAPACK_ssyevx LAPACK_GLOBAL(ssyevx,SSYEVX)\n#define LAPACK_dsyevx LAPACK_GLOBAL(dsyevx,DSYEVX)\n#define LAPACK_cheevx LAPACK_GLOBAL(cheevx,CHEEVX)\n#define LAPACK_zheevx LAPACK_GLOBAL(zheevx,ZHEEVX)\n#define LAPACK_ssyevx_2stage LAPACK_GLOBAL(ssyevx_2stage,SSYEVX_2STAGE)\n#define LAPACK_dsyevx_2stage LAPACK_GLOBAL(dsyevx_2stage,DSYEVX_2STAGE)\n#define LAPACK_cheevx_2stage LAPACK_GLOBAL(cheevx_2stage,CHEEVX_2STAGE)\n#define LAPACK_zheevx_2stage LAPACK_GLOBAL(zheevx_2stage,ZHEEVX_2STAGE)\n#define LAPACK_ssyevr LAPACK_GLOBAL(ssyevr,SSYEVR)\n#define LAPACK_dsyevr LAPACK_GLOBAL(dsyevr,DSYEVR)\n#define LAPACK_cheevr LAPACK_GLOBAL(cheevr,CHEEVR)\n#define LAPACK_zheevr LAPACK_GLOBAL(zheevr,ZHEEVR)\n#define LAPACK_ssyevr_2stage LAPACK_GLOBAL(ssyevr_2stage,SSYEVR_2STAGE)\n#define LAPACK_dsyevr_2stage LAPACK_GLOBAL(dsyevr_2stage,DSYEVR_2STAGE)\n#define LAPACK_cheevr_2stage LAPACK_GLOBAL(cheevr_2stage,CHEEVR_2STAGE)\n#define LAPACK_zheevr_2stage LAPACK_GLOBAL(zheevr_2stage,ZHEEVR_2STAGE)\n#define LAPACK_sspev LAPACK_GLOBAL(sspev,SSPEV)\n#define LAPACK_dspev LAPACK_GLOBAL(dspev,DSPEV)\n#define LAPACK_chpev LAPACK_GLOBAL(chpev,CHPEV)\n#define LAPACK_zhpev LAPACK_GLOBAL(zhpev,ZHPEV)\n#define LAPACK_sspevd LAPACK_GLOBAL(sspevd,SSPEVD)\n#define LAPACK_dspevd LAPACK_GLOBAL(dspevd,DSPEVD)\n#define LAPACK_chpevd LAPACK_GLOBAL(chpevd,CHPEVD)\n#define LAPACK_zhpevd LAPACK_GLOBAL(zhpevd,ZHPEVD)\n#define LAPACK_sspevx LAPACK_GLOBAL(sspevx,SSPEVX)\n#define LAPACK_dspevx LAPACK_GLOBAL(dspevx,DSPEVX)\n#define LAPACK_chpevx LAPACK_GLOBAL(chpevx,CHPEVX)\n#define LAPACK_zhpevx LAPACK_GLOBAL(zhpevx,ZHPEVX)\n#define LAPACK_ssbev LAPACK_GLOBAL(ssbev,SSBEV)\n#define LAPACK_dsbev LAPACK_GLOBAL(dsbev,DSBEV)\n#define LAPACK_chbev LAPACK_GLOBAL(chbev,CHBEV)\n#define LAPACK_zhbev LAPACK_GLOBAL(zhbev,ZHBEV)\n#define LAPACK_ssbev_2stage LAPACK_GLOBAL(ssbev_2stage,SSBEV_2STAGE)\n#define LAPACK_dsbev_2stage LAPACK_GLOBAL(dsbev_2stage,DSBEV_2STAGE)\n#define LAPACK_chbev_2stage LAPACK_GLOBAL(chbev_2stage,CHBEV_2STAGE)\n#define LAPACK_zhbev_2stage LAPACK_GLOBAL(zhbev_2stage,ZHBEV_2STAGE)\n#define LAPACK_ssbevd LAPACK_GLOBAL(ssbevd,SSBEVD)\n#define LAPACK_dsbevd LAPACK_GLOBAL(dsbevd,DSBEVD)\n#define LAPACK_chbevd LAPACK_GLOBAL(chbevd,CHBEVD)\n#define LAPACK_zhbevd LAPACK_GLOBAL(zhbevd,ZHBEVD)\n#define LAPACK_ssbevd_2stage LAPACK_GLOBAL(ssbevd_2stage,SSBEVD_2STAGE)\n#define LAPACK_dsbevd_2stage LAPACK_GLOBAL(dsbevd_2stage,DSBEVD_2STAGE)\n#define LAPACK_chbevd_2stage LAPACK_GLOBAL(chbevd_2stage,CHBEVD_2STAGE)\n#define LAPACK_zhbevd_2stage LAPACK_GLOBAL(zhbevd_2stage,ZHBEVD_2STAGE)\n#define LAPACK_ssbevx LAPACK_GLOBAL(ssbevx,SSBEVX)\n#define LAPACK_dsbevx LAPACK_GLOBAL(dsbevx,DSBEVX)\n#define LAPACK_chbevx LAPACK_GLOBAL(chbevx,CHBEVX)\n#define LAPACK_zhbevx LAPACK_GLOBAL(zhbevx,ZHBEVX)\n#define LAPACK_ssbevx_2stage LAPACK_GLOBAL(ssbevx_2stage,SSBEVX_2STAGE)\n#define LAPACK_dsbevx_2stage LAPACK_GLOBAL(dsbevx_2stage,DSBEVX_2STAGE)\n#define LAPACK_chbevx_2stage LAPACK_GLOBAL(chbevx_2stage,CHBEVX_2STAGE)\n#define LAPACK_zhbevx_2stage LAPACK_GLOBAL(zhbevx_2stage,ZHBEVX_2STAGE)\n#define LAPACK_sstev LAPACK_GLOBAL(sstev,SSTEV)\n#define LAPACK_dstev LAPACK_GLOBAL(dstev,DSTEV)\n#define LAPACK_sstevd LAPACK_GLOBAL(sstevd,SSTEVD)\n#define LAPACK_dstevd LAPACK_GLOBAL(dstevd,DSTEVD)\n#define LAPACK_sstevx LAPACK_GLOBAL(sstevx,SSTEVX)\n#define LAPACK_dstevx LAPACK_GLOBAL(dstevx,DSTEVX)\n#define LAPACK_sstevr LAPACK_GLOBAL(sstevr,SSTEVR)\n#define LAPACK_dstevr LAPACK_GLOBAL(dstevr,DSTEVR)\n#define LAPACK_sgees LAPACK_GLOBAL(sgees,SGEES)\n#define LAPACK_dgees LAPACK_GLOBAL(dgees,DGEES)\n#define LAPACK_cgees LAPACK_GLOBAL(cgees,CGEES)\n#define LAPACK_zgees LAPACK_GLOBAL(zgees,ZGEES)\n#define LAPACK_sgeesx LAPACK_GLOBAL(sgeesx,SGEESX)\n#define LAPACK_dgeesx LAPACK_GLOBAL(dgeesx,DGEESX)\n#define LAPACK_cgeesx LAPACK_GLOBAL(cgeesx,CGEESX)\n#define LAPACK_zgeesx LAPACK_GLOBAL(zgeesx,ZGEESX)\n#define LAPACK_sgeev LAPACK_GLOBAL(sgeev,SGEEV)\n#define LAPACK_dgeev LAPACK_GLOBAL(dgeev,DGEEV)\n#define LAPACK_cgeev LAPACK_GLOBAL(cgeev,CGEEV)\n#define LAPACK_zgeev LAPACK_GLOBAL(zgeev,ZGEEV)\n#define LAPACK_sgeevx LAPACK_GLOBAL(sgeevx,SGEEVX)\n#define LAPACK_dgeevx LAPACK_GLOBAL(dgeevx,DGEEVX)\n#define LAPACK_cgeevx LAPACK_GLOBAL(cgeevx,CGEEVX)\n#define LAPACK_zgeevx LAPACK_GLOBAL(zgeevx,ZGEEVX)\n#define LAPACK_sgesvd LAPACK_GLOBAL(sgesvd,SGESVD)\n#define LAPACK_dgesvd LAPACK_GLOBAL(dgesvd,DGESVD)\n#define LAPACK_cgesvd LAPACK_GLOBAL(cgesvd,CGESVD)\n#define LAPACK_zgesvd LAPACK_GLOBAL(zgesvd,ZGESVD)\n#define LAPACK_sgesvdx LAPACK_GLOBAL(sgesvdx,SGESVDX)\n#define LAPACK_dgesvdx LAPACK_GLOBAL(dgesvdx,DGESVDX)\n#define LAPACK_cgesvdx LAPACK_GLOBAL(cgesvdx,CGESVDX)\n#define LAPACK_zgesvdx LAPACK_GLOBAL(zgesvdx,ZGESVDX)\n#define LAPACK_sgesdd LAPACK_GLOBAL(sgesdd,SGESDD)\n#define LAPACK_dgesdd LAPACK_GLOBAL(dgesdd,DGESDD)\n#define LAPACK_cgesdd LAPACK_GLOBAL(cgesdd,CGESDD)\n#define LAPACK_zgesdd LAPACK_GLOBAL(zgesdd,ZGESDD)\n#define LAPACK_sgejsv LAPACK_GLOBAL(sgejsv,SGEJSV)\n#define LAPACK_dgejsv LAPACK_GLOBAL(dgejsv,DGEJSV)\n#define LAPACK_cgejsv LAPACK_GLOBAL(cgejsv,CGEJSV)\n#define LAPACK_zgejsv LAPACK_GLOBAL(zgejsv,ZGEJSV)\n#define LAPACK_sgesvj LAPACK_GLOBAL(sgesvj,SGESVJ)\n#define LAPACK_dgesvj LAPACK_GLOBAL(dgesvj,DGESVJ)\n#define LAPACK_cgesvj LAPACK_GLOBAL(cgesvj,CGESVJ)\n#define LAPACK_zgesvj LAPACK_GLOBAL(zgesvj,ZGESVJ)\n#define LAPACK_sggsvd LAPACK_GLOBAL(sggsvd,SGGSVD)\n#define LAPACK_dggsvd LAPACK_GLOBAL(dggsvd,DGGSVD)\n#define LAPACK_cggsvd LAPACK_GLOBAL(cggsvd,CGGSVD)\n#define LAPACK_zggsvd LAPACK_GLOBAL(zggsvd,ZGGSVD)\n#define LAPACK_ssygv LAPACK_GLOBAL(ssygv,SSYGV)\n#define LAPACK_dsygv LAPACK_GLOBAL(dsygv,DSYGV)\n#define LAPACK_chegv LAPACK_GLOBAL(chegv,CHEGV)\n#define LAPACK_zhegv LAPACK_GLOBAL(zhegv,ZHEGV)\n#define LAPACK_ssygv_2stage LAPACK_GLOBAL(ssygv_2stage,SSYGV_2STAGE)\n#define LAPACK_dsygv_2stage LAPACK_GLOBAL(dsygv_2stage,DSYGV_2STAGE)\n#define LAPACK_chegv_2stage LAPACK_GLOBAL(chegv_2stage,CHEGV_2STAGE)\n#define LAPACK_zhegv_2stage LAPACK_GLOBAL(zhegv_2stage,ZHEGV_2STAGE)\n#define LAPACK_ssygvd LAPACK_GLOBAL(ssygvd,SSYGVD)\n#define LAPACK_dsygvd LAPACK_GLOBAL(dsygvd,DSYGVD)\n#define LAPACK_chegvd LAPACK_GLOBAL(chegvd,CHEGVD)\n#define LAPACK_zhegvd LAPACK_GLOBAL(zhegvd,ZHEGVD)\n#define LAPACK_ssygvx LAPACK_GLOBAL(ssygvx,SSYGVX)\n#define LAPACK_dsygvx LAPACK_GLOBAL(dsygvx,DSYGVX)\n#define LAPACK_chegvx LAPACK_GLOBAL(chegvx,CHEGVX)\n#define LAPACK_zhegvx LAPACK_GLOBAL(zhegvx,ZHEGVX)\n#define LAPACK_sspgv LAPACK_GLOBAL(sspgv,SSPGV)\n#define LAPACK_dspgv LAPACK_GLOBAL(dspgv,DSPGV)\n#define LAPACK_chpgv LAPACK_GLOBAL(chpgv,CHPGV)\n#define LAPACK_zhpgv LAPACK_GLOBAL(zhpgv,ZHPGV)\n#define LAPACK_sspgvd LAPACK_GLOBAL(sspgvd,SSPGVD)\n#define LAPACK_dspgvd LAPACK_GLOBAL(dspgvd,DSPGVD)\n#define LAPACK_chpgvd LAPACK_GLOBAL(chpgvd,CHPGVD)\n#define LAPACK_zhpgvd LAPACK_GLOBAL(zhpgvd,ZHPGVD)\n#define LAPACK_sspgvx LAPACK_GLOBAL(sspgvx,SSPGVX)\n#define LAPACK_dspgvx LAPACK_GLOBAL(dspgvx,DSPGVX)\n#define LAPACK_chpgvx LAPACK_GLOBAL(chpgvx,CHPGVX)\n#define LAPACK_zhpgvx LAPACK_GLOBAL(zhpgvx,ZHPGVX)\n#define LAPACK_ssbgv LAPACK_GLOBAL(ssbgv,SSBGV)\n#define LAPACK_dsbgv LAPACK_GLOBAL(dsbgv,DSBGV)\n#define LAPACK_chbgv LAPACK_GLOBAL(chbgv,CHBGV)\n#define LAPACK_zhbgv LAPACK_GLOBAL(zhbgv,ZHBGV)\n#define LAPACK_ssbgvd LAPACK_GLOBAL(ssbgvd,SSBGVD)\n#define LAPACK_dsbgvd LAPACK_GLOBAL(dsbgvd,DSBGVD)\n#define LAPACK_chbgvd LAPACK_GLOBAL(chbgvd,CHBGVD)\n#define LAPACK_zhbgvd LAPACK_GLOBAL(zhbgvd,ZHBGVD)\n#define LAPACK_ssbgvx LAPACK_GLOBAL(ssbgvx,SSBGVX)\n#define LAPACK_dsbgvx LAPACK_GLOBAL(dsbgvx,DSBGVX)\n#define LAPACK_chbgvx LAPACK_GLOBAL(chbgvx,CHBGVX)\n#define LAPACK_zhbgvx LAPACK_GLOBAL(zhbgvx,ZHBGVX)\n#define LAPACK_sgges LAPACK_GLOBAL(sgges,SGGES)\n#define LAPACK_dgges LAPACK_GLOBAL(dgges,DGGES)\n#define LAPACK_cgges LAPACK_GLOBAL(cgges,CGGES)\n#define LAPACK_zgges LAPACK_GLOBAL(zgges,ZGGES)\n#define LAPACK_sgges3 LAPACK_GLOBAL(sgges3,SGGES3)\n#define LAPACK_dgges3 LAPACK_GLOBAL(dgges3,DGGES3)\n#define LAPACK_cgges3 LAPACK_GLOBAL(cgges3,CGGES3)\n#define LAPACK_zgges3 LAPACK_GLOBAL(zgges3,ZGGES3)\n#define LAPACK_sggesx LAPACK_GLOBAL(sggesx,SGGESX)\n#define LAPACK_dggesx LAPACK_GLOBAL(dggesx,DGGESX)\n#define LAPACK_cggesx LAPACK_GLOBAL(cggesx,CGGESX)\n#define LAPACK_zggesx LAPACK_GLOBAL(zggesx,ZGGESX)\n#define LAPACK_sggev LAPACK_GLOBAL(sggev,SGGEV)\n#define LAPACK_dggev LAPACK_GLOBAL(dggev,DGGEV)\n#define LAPACK_cggev LAPACK_GLOBAL(cggev,CGGEV)\n#define LAPACK_zggev LAPACK_GLOBAL(zggev,ZGGEV)\n#define LAPACK_sggev3 LAPACK_GLOBAL(sggev3,SGGEV3)\n#define LAPACK_dggev3 LAPACK_GLOBAL(dggev3,DGGEV3)\n#define LAPACK_cggev3 LAPACK_GLOBAL(cggev3,CGGEV3)\n#define LAPACK_zggev3 LAPACK_GLOBAL(zggev3,ZGGEV3)\n#define LAPACK_sggevx LAPACK_GLOBAL(sggevx,SGGEVX)\n#define LAPACK_dggevx LAPACK_GLOBAL(dggevx,DGGEVX)\n#define LAPACK_cggevx LAPACK_GLOBAL(cggevx,CGGEVX)\n#define LAPACK_zggevx LAPACK_GLOBAL(zggevx,ZGGEVX)\n#define LAPACK_dsfrk LAPACK_GLOBAL(dsfrk,DSFRK)\n#define LAPACK_ssfrk LAPACK_GLOBAL(ssfrk,SSFRK)\n#define LAPACK_zhfrk LAPACK_GLOBAL(zhfrk,ZHFRK)\n#define LAPACK_chfrk LAPACK_GLOBAL(chfrk,CHFRK)\n#define LAPACK_dtfsm LAPACK_GLOBAL(dtfsm,DTFSM)\n#define LAPACK_stfsm LAPACK_GLOBAL(stfsm,STFSM)\n#define LAPACK_ztfsm LAPACK_GLOBAL(ztfsm,ZTFSM)\n#define LAPACK_ctfsm LAPACK_GLOBAL(ctfsm,CTFSM)\n#define LAPACK_dtfttp LAPACK_GLOBAL(dtfttp,DTFTTP)\n#define LAPACK_stfttp LAPACK_GLOBAL(stfttp,STFTTP)\n#define LAPACK_ztfttp LAPACK_GLOBAL(ztfttp,ZTFTTP)\n#define LAPACK_ctfttp LAPACK_GLOBAL(ctfttp,CTFTTP)\n#define LAPACK_dtfttr LAPACK_GLOBAL(dtfttr,DTFTTR)\n#define LAPACK_stfttr LAPACK_GLOBAL(stfttr,STFTTR)\n#define LAPACK_ztfttr LAPACK_GLOBAL(ztfttr,ZTFTTR)\n#define LAPACK_ctfttr LAPACK_GLOBAL(ctfttr,CTFTTR)\n#define LAPACK_dtpttf LAPACK_GLOBAL(dtpttf,DTPTTF)\n#define LAPACK_stpttf LAPACK_GLOBAL(stpttf,STPTTF)\n#define LAPACK_ztpttf LAPACK_GLOBAL(ztpttf,ZTPTTF)\n#define LAPACK_ctpttf LAPACK_GLOBAL(ctpttf,CTPTTF)\n#define LAPACK_dtpttr LAPACK_GLOBAL(dtpttr,DTPTTR)\n#define LAPACK_stpttr LAPACK_GLOBAL(stpttr,STPTTR)\n#define LAPACK_ztpttr LAPACK_GLOBAL(ztpttr,ZTPTTR)\n#define LAPACK_ctpttr LAPACK_GLOBAL(ctpttr,CTPTTR)\n#define LAPACK_dtrttf LAPACK_GLOBAL(dtrttf,DTRTTF)\n#define LAPACK_strttf LAPACK_GLOBAL(strttf,STRTTF)\n#define LAPACK_ztrttf LAPACK_GLOBAL(ztrttf,ZTRTTF)\n#define LAPACK_ctrttf LAPACK_GLOBAL(ctrttf,CTRTTF)\n#define LAPACK_dtrttp LAPACK_GLOBAL(dtrttp,DTRTTP)\n#define LAPACK_strttp LAPACK_GLOBAL(strttp,STRTTP)\n#define LAPACK_ztrttp LAPACK_GLOBAL(ztrttp,ZTRTTP)\n#define LAPACK_ctrttp LAPACK_GLOBAL(ctrttp,CTRTTP)\n#define LAPACK_sgeqrfp LAPACK_GLOBAL(sgeqrfp,SGEQRFP)\n#define LAPACK_dgeqrfp LAPACK_GLOBAL(dgeqrfp,DGEQRFP)\n#define LAPACK_cgeqrfp LAPACK_GLOBAL(cgeqrfp,CGEQRFP)\n#define LAPACK_zgeqrfp LAPACK_GLOBAL(zgeqrfp,ZGEQRFP)\n#define LAPACK_clacgv LAPACK_GLOBAL(clacgv,CLACGV)\n#define LAPACK_zlacgv LAPACK_GLOBAL(zlacgv,ZLACGV)\n#define LAPACK_slarnv LAPACK_GLOBAL(slarnv,SLARNV)\n#define LAPACK_dlarnv LAPACK_GLOBAL(dlarnv,DLARNV)\n#define LAPACK_clarnv LAPACK_GLOBAL(clarnv,CLARNV)\n#define LAPACK_zlarnv LAPACK_GLOBAL(zlarnv,ZLARNV)\n#define LAPACK_sgeqr2 LAPACK_GLOBAL(sgeqr2,SGEQR2)\n#define LAPACK_dgeqr2 LAPACK_GLOBAL(dgeqr2,DGEQR2)\n#define LAPACK_cgeqr2 LAPACK_GLOBAL(cgeqr2,CGEQR2)\n#define LAPACK_zgeqr2 LAPACK_GLOBAL(zgeqr2,ZGEQR2)\n#define LAPACK_slacn2 LAPACK_GLOBAL(slacn2,SLACN2)\n#define LAPACK_dlacn2 LAPACK_GLOBAL(dlacn2,DLACN2)\n#define LAPACK_clacn2 LAPACK_GLOBAL(clacn2,CLACN2)\n#define LAPACK_zlacn2 LAPACK_GLOBAL(zlacn2,ZLACN2)\n#define LAPACK_slacpy LAPACK_GLOBAL(slacpy,SLACPY)\n#define LAPACK_dlacpy LAPACK_GLOBAL(dlacpy,DLACPY)\n#define LAPACK_clacpy LAPACK_GLOBAL(clacpy,CLACPY)\n#define LAPACK_zlacpy LAPACK_GLOBAL(zlacpy,ZLACPY)\n#define LAPACK_clacp2 LAPACK_GLOBAL(clacp2,CLACP2)\n#define LAPACK_zlacp2 LAPACK_GLOBAL(zlacp2,ZLACP2)\n#define LAPACK_sgetf2 LAPACK_GLOBAL(sgetf2,SGETF2)\n#define LAPACK_dgetf2 LAPACK_GLOBAL(dgetf2,DGETF2)\n#define LAPACK_cgetf2 LAPACK_GLOBAL(cgetf2,CGETF2)\n#define LAPACK_zgetf2 LAPACK_GLOBAL(zgetf2,ZGETF2)\n#define LAPACK_slaswp LAPACK_GLOBAL(slaswp,SLASWP)\n#define LAPACK_dlaswp LAPACK_GLOBAL(dlaswp,DLASWP)\n#define LAPACK_claswp LAPACK_GLOBAL(claswp,CLASWP)\n#define LAPACK_zlaswp LAPACK_GLOBAL(zlaswp,ZLASWP)\n#define LAPACK_slange LAPACK_GLOBAL(slange,SLANGE)\n#define LAPACK_dlange LAPACK_GLOBAL(dlange,DLANGE)\n#define LAPACK_clange LAPACK_GLOBAL(clange,CLANGE)\n#define LAPACK_zlange LAPACK_GLOBAL(zlange,ZLANGE)\n#define LAPACK_clanhe LAPACK_GLOBAL(clanhe,CLANHE)\n#define LAPACK_zlanhe LAPACK_GLOBAL(zlanhe,ZLANHE)\n#define LAPACK_slansy LAPACK_GLOBAL(slansy,SLANSY)\n#define LAPACK_dlansy LAPACK_GLOBAL(dlansy,DLANSY)\n#define LAPACK_clansy LAPACK_GLOBAL(clansy,CLANSY)\n#define LAPACK_zlansy LAPACK_GLOBAL(zlansy,ZLANSY)\n#define LAPACK_slantr LAPACK_GLOBAL(slantr,SLANTR)\n#define LAPACK_dlantr LAPACK_GLOBAL(dlantr,DLANTR)\n#define LAPACK_clantr LAPACK_GLOBAL(clantr,CLANTR)\n#define LAPACK_zlantr LAPACK_GLOBAL(zlantr,ZLANTR)\n#define LAPACK_slamch LAPACK_GLOBAL(slamch,SLAMCH)\n#define LAPACK_dlamch LAPACK_GLOBAL(dlamch,DLAMCH)\n#define LAPACK_sgelq2 LAPACK_GLOBAL(sgelq2,SGELQ2)\n#define LAPACK_dgelq2 LAPACK_GLOBAL(dgelq2,DGELQ2)\n#define LAPACK_cgelq2 LAPACK_GLOBAL(cgelq2,CGELQ2)\n#define LAPACK_zgelq2 LAPACK_GLOBAL(zgelq2,ZGELQ2)\n#define LAPACK_slarfb LAPACK_GLOBAL(slarfb,SLARFB)\n#define LAPACK_dlarfb LAPACK_GLOBAL(dlarfb,DLARFB)\n#define LAPACK_clarfb LAPACK_GLOBAL(clarfb,CLARFB)\n#define LAPACK_zlarfb LAPACK_GLOBAL(zlarfb,ZLARFB)\n#define LAPACK_slarfg LAPACK_GLOBAL(slarfg,SLARFG)\n#define LAPACK_dlarfg LAPACK_GLOBAL(dlarfg,DLARFG)\n#define LAPACK_clarfg LAPACK_GLOBAL(clarfg,CLARFG)\n#define LAPACK_zlarfg LAPACK_GLOBAL(zlarfg,ZLARFG)\n#define LAPACK_slarft LAPACK_GLOBAL(slarft,SLARFT)\n#define LAPACK_dlarft LAPACK_GLOBAL(dlarft,DLARFT)\n#define LAPACK_clarft LAPACK_GLOBAL(clarft,CLARFT)\n#define LAPACK_zlarft LAPACK_GLOBAL(zlarft,ZLARFT)\n#define LAPACK_slarfx LAPACK_GLOBAL(slarfx,SLARFX)\n#define LAPACK_dlarfx LAPACK_GLOBAL(dlarfx,DLARFX)\n#define LAPACK_clarfx LAPACK_GLOBAL(clarfx,CLARFX)\n#define LAPACK_zlarfx LAPACK_GLOBAL(zlarfx,ZLARFX)\n#define LAPACK_slag2d LAPACK_GLOBAL(slag2d,SLAG2D)\n#define LAPACK_dlag2s LAPACK_GLOBAL(dlag2s,DLAG2S)\n#define LAPACK_clag2z LAPACK_GLOBAL(clag2z,CLAG2Z)\n#define LAPACK_zlag2c LAPACK_GLOBAL(zlag2c,ZLAG2C)\n#define LAPACK_slauum LAPACK_GLOBAL(slauum,SLAUUM)\n#define LAPACK_dlauum LAPACK_GLOBAL(dlauum,DLAUUM)\n#define LAPACK_clauum LAPACK_GLOBAL(clauum,CLAUUM)\n#define LAPACK_zlauum LAPACK_GLOBAL(zlauum,ZLAUUM)\n#define LAPACK_slascl LAPACK_GLOBAL(slascl,SLASCL)\n#define LAPACK_dlascl LAPACK_GLOBAL(dlascl,DLASCL)\n#define LAPACK_clascl LAPACK_GLOBAL(clascl,CLASCL)\n#define LAPACK_zlascl LAPACK_GLOBAL(zlascl,ZLASCL)\n#define LAPACK_slaset LAPACK_GLOBAL(slaset,SLASET)\n#define LAPACK_dlaset LAPACK_GLOBAL(dlaset,DLASET)\n#define LAPACK_claset LAPACK_GLOBAL(claset,CLASET)\n#define LAPACK_zlaset LAPACK_GLOBAL(zlaset,ZLASET)\n#define LAPACK_slasrt LAPACK_GLOBAL(slasrt,SLASRT)\n#define LAPACK_dlasrt LAPACK_GLOBAL(dlasrt,DLASRT)\n#define LAPACK_slapmr LAPACK_GLOBAL(slapmr,SLAPMR)\n#define LAPACK_dlapmr LAPACK_GLOBAL(dlapmr,DLAPMR)\n#define LAPACK_clapmr LAPACK_GLOBAL(clapmr,CLAPMR)\n#define LAPACK_zlapmr LAPACK_GLOBAL(zlapmr,ZLAPMR)\n#define LAPACK_slapmt LAPACK_GLOBAL(slapmt,SLAPMT)\n#define LAPACK_dlapmt LAPACK_GLOBAL(dlapmt,DLAPMT)\n#define LAPACK_clapmt LAPACK_GLOBAL(clapmt,CLAPMT)\n#define LAPACK_zlapmt LAPACK_GLOBAL(zlapmt,ZLAPMT)\n#define LAPACK_slapy2 LAPACK_GLOBAL(slapy2,SLAPY2)\n#define LAPACK_dlapy2 LAPACK_GLOBAL(dlapy2,DLAPY2)\n#define LAPACK_slapy3 LAPACK_GLOBAL(slapy3,SLAPY3)\n#define LAPACK_dlapy3 LAPACK_GLOBAL(dlapy3,DLAPY3)\n#define LAPACK_slartgp LAPACK_GLOBAL(slartgp,SLARTGP)\n#define LAPACK_dlartgp LAPACK_GLOBAL(dlartgp,DLARTGP)\n#define LAPACK_slartgs LAPACK_GLOBAL(slartgs,SLARTGS)\n#define LAPACK_dlartgs LAPACK_GLOBAL(dlartgs,DLARTGS)\n/* LAPACK 3.3.0 */\n#define LAPACK_cbbcsd LAPACK_GLOBAL(cbbcsd,CBBCSD)\n#define LAPACK_cheswapr LAPACK_GLOBAL(cheswapr,CHESWAPR)\n#define LAPACK_chetri2 LAPACK_GLOBAL(chetri2,CHETRI2)\n#define LAPACK_chetri2x LAPACK_GLOBAL(chetri2x,CHETRI2X)\n#define LAPACK_chetrs2 LAPACK_GLOBAL(chetrs2,CHETRS2)\n#define LAPACK_csyconv LAPACK_GLOBAL(csyconv,CSYCONV)\n#define LAPACK_csyswapr LAPACK_GLOBAL(csyswapr,CSYSWAPR)\n#define LAPACK_csytri2 LAPACK_GLOBAL(csytri2,CSYTRI2)\n#define LAPACK_csytri2x LAPACK_GLOBAL(csytri2x,CSYTRI2X)\n#define LAPACK_csytrs2 LAPACK_GLOBAL(csytrs2,CSYTRS2)\n#define LAPACK_cunbdb LAPACK_GLOBAL(cunbdb,CUNBDB)\n#define LAPACK_cuncsd LAPACK_GLOBAL(cuncsd,CUNCSD)\n#define LAPACK_cuncsd2by1 LAPACK_GLOBAL(cuncsd2by1,CUNCSD2BY1)\n#define LAPACK_dbbcsd LAPACK_GLOBAL(dbbcsd,DBBCSD)\n#define LAPACK_dorbdb LAPACK_GLOBAL(dorbdb,DORBDB)\n#define LAPACK_dorcsd LAPACK_GLOBAL(dorcsd,DORCSD)\n#define LAPACK_dorcsd2by1 LAPACK_GLOBAL(dorcsd2by1,DORCSD2BY1)\n#define LAPACK_dsyconv LAPACK_GLOBAL(dsyconv,DSYCONV)\n#define LAPACK_dsyswapr LAPACK_GLOBAL(dsyswapr,DSYSWAPR)\n#define LAPACK_dsytri2 LAPACK_GLOBAL(dsytri2,DSYTRI2)\n#define LAPACK_dsytri2x LAPACK_GLOBAL(dsytri2x,DSYTRI2X)\n#define LAPACK_dsytrs2 LAPACK_GLOBAL(dsytrs2,DSYTRS2)\n#define LAPACK_sbbcsd LAPACK_GLOBAL(sbbcsd,SBBCSD)\n#define LAPACK_sorbdb LAPACK_GLOBAL(sorbdb,SORBDB)\n#define LAPACK_sorcsd LAPACK_GLOBAL(sorcsd,SORCSD)\n#define LAPACK_sorcsd2by1 LAPACK_GLOBAL(sorcsd2by1,SORCSD2BY1)\n#define LAPACK_ssyconv LAPACK_GLOBAL(ssyconv,SSYCONV)\n#define LAPACK_ssyswapr LAPACK_GLOBAL(ssyswapr,SSYSWAPR)\n#define LAPACK_ssytri2 LAPACK_GLOBAL(ssytri2,SSYTRI2)\n#define LAPACK_ssytri2x LAPACK_GLOBAL(ssytri2x,SSYTRI2X)\n#define LAPACK_ssytrs2 LAPACK_GLOBAL(ssytrs2,SSYTRS2)\n#define LAPACK_zbbcsd LAPACK_GLOBAL(zbbcsd,ZBBCSD)\n#define LAPACK_zheswapr LAPACK_GLOBAL(zheswapr,ZHESWAPR)\n#define LAPACK_zhetri2 LAPACK_GLOBAL(zhetri2,ZHETRI2)\n#define LAPACK_zhetri2x LAPACK_GLOBAL(zhetri2x,ZHETRI2X)\n#define LAPACK_zhetrs2 LAPACK_GLOBAL(zhetrs2,ZHETRS2)\n#define LAPACK_zsyconv LAPACK_GLOBAL(zsyconv,ZSYCONV)\n#define LAPACK_zsyswapr LAPACK_GLOBAL(zsyswapr,ZSYSWAPR)\n#define LAPACK_zsytri2 LAPACK_GLOBAL(zsytri2,ZSYTRI2)\n#define LAPACK_zsytri2x LAPACK_GLOBAL(zsytri2x,ZSYTRI2X)\n#define LAPACK_zsytrs2 LAPACK_GLOBAL(zsytrs2,ZSYTRS2)\n#define LAPACK_zunbdb LAPACK_GLOBAL(zunbdb,ZUNBDB)\n#define LAPACK_zuncsd LAPACK_GLOBAL(zuncsd,ZUNCSD)\n#define LAPACK_zuncsd2by1 LAPACK_GLOBAL(zuncsd2by1,ZUNCSD2BY1)\n/* LAPACK 3.4.0 */\n#define LAPACK_sgemqrt LAPACK_GLOBAL(sgemqrt,SGEMQRT)\n#define LAPACK_dgemqrt LAPACK_GLOBAL(dgemqrt,DGEMQRT)\n#define LAPACK_cgemqrt LAPACK_GLOBAL(cgemqrt,CGEMQRT)\n#define LAPACK_zgemqrt LAPACK_GLOBAL(zgemqrt,ZGEMQRT)\n#define LAPACK_sgeqrt LAPACK_GLOBAL(sgeqrt,SGEQRT)\n#define LAPACK_dgeqrt LAPACK_GLOBAL(dgeqrt,DGEQRT)\n#define LAPACK_cgeqrt LAPACK_GLOBAL(cgeqrt,CGEQRT)\n#define LAPACK_zgeqrt LAPACK_GLOBAL(zgeqrt,ZGEQRT)\n#define LAPACK_sgeqrt2 LAPACK_GLOBAL(sgeqrt2,SGEQRT2)\n#define LAPACK_dgeqrt2 LAPACK_GLOBAL(dgeqrt2,DGEQRT2)\n#define LAPACK_cgeqrt2 LAPACK_GLOBAL(cgeqrt2,CGEQRT2)\n#define LAPACK_zgeqrt2 LAPACK_GLOBAL(zgeqrt2,ZGEQRT2)\n#define LAPACK_sgeqrt3 LAPACK_GLOBAL(sgeqrt3,SGEQRT3)\n#define LAPACK_dgeqrt3 LAPACK_GLOBAL(dgeqrt3,DGEQRT3)\n#define LAPACK_cgeqrt3 LAPACK_GLOBAL(cgeqrt3,CGEQRT3)\n#define LAPACK_zgeqrt3 LAPACK_GLOBAL(zgeqrt3,ZGEQRT3)\n#define LAPACK_stpmqrt LAPACK_GLOBAL(stpmqrt,STPMQRT)\n#define LAPACK_dtpmqrt LAPACK_GLOBAL(dtpmqrt,DTPMQRT)\n#define LAPACK_ctpmqrt LAPACK_GLOBAL(ctpmqrt,CTPMQRT)\n#define LAPACK_ztpmqrt LAPACK_GLOBAL(ztpmqrt,ZTPMQRT)\n#define LAPACK_stpqrt LAPACK_GLOBAL(stpqrt,STPQRT)\n#define LAPACK_dtpqrt LAPACK_GLOBAL(dtpqrt,DTPQRT)\n#define LAPACK_ctpqrt LAPACK_GLOBAL(ctpqrt,CTPQRT)\n#define LAPACK_ztpqrt LAPACK_GLOBAL(ztpqrt,ZTPQRT)\n#define LAPACK_stpqrt2 LAPACK_GLOBAL(stpqrt2,STPQRT2)\n#define LAPACK_dtpqrt2 LAPACK_GLOBAL(dtpqrt2,DTPQRT2)\n#define LAPACK_ctpqrt2 LAPACK_GLOBAL(ctpqrt2,CTPQRT2)\n#define LAPACK_ztpqrt2 LAPACK_GLOBAL(ztpqrt2,ZTPQRT2)\n#define LAPACK_stprfb LAPACK_GLOBAL(stprfb,STPRFB)\n#define LAPACK_dtprfb LAPACK_GLOBAL(dtprfb,DTPRFB)\n#define LAPACK_ctprfb LAPACK_GLOBAL(ctprfb,CTPRFB)\n#define LAPACK_ztprfb LAPACK_GLOBAL(ztprfb,ZTPRFB)\n/* LAPACK 3.5.0 */\n#define LAPACK_ssysv_rook LAPACK_GLOBAL(ssysv_rook,SSYSV_ROOK)\n#define LAPACK_dsysv_rook LAPACK_GLOBAL(dsysv_rook,DSYSV_ROOK)\n#define LAPACK_csysv_rook LAPACK_GLOBAL(csysv_rook,CSYSV_ROOK)\n#define LAPACK_zsysv_rook LAPACK_GLOBAL(zsysv_rook,ZSYSV_ROOK)\n#define LAPACK_ilaver LAPACK_GLOBAL(ilaver,ILAVER)\n/* LAPACK 3.6.0 */\n#define LAPACK_sggsvd3 LAPACK_GLOBAL(sggsvd3,SGGSVD3)\n#define LAPACK_dggsvd3 LAPACK_GLOBAL(dggsvd3,DGGSVD3)\n#define LAPACK_cggsvd3 LAPACK_GLOBAL(cggsvd3,CGGSVD3)\n#define LAPACK_zggsvd3 LAPACK_GLOBAL(zggsvd3,ZGGSVD3)\n/* LAPACK 3.7.0 */\n#define LAPACK_ssysv_aa LAPACK_GLOBAL(ssysv_aa,SSYSV_AA)\n#define LAPACK_dsysv_aa LAPACK_GLOBAL(dsysv_aa,DSYSV_AA)\n#define LAPACK_chesv_aa LAPACK_GLOBAL(chesv_aa,CHESV_AA)\n#define LAPACK_zsysv_aa LAPACK_GLOBAL(zsysv_aa,ZSYSV_AA)\n#define LAPACK_csysv_aa LAPACK_GLOBAL(csysv_aa,CSYSV_AA)\n#define LAPACK_zhesv_aa LAPACK_GLOBAL(zhesv_aa,ZHESV_AA)\n#define LAPACK_ssytrs_aa LAPACK_GLOBAL(ssytrs_aa,SSYTRS_AA)\n#define LAPACK_dsytrs_aa LAPACK_GLOBAL(dsytrs_aa,DSYTRS_AA)\n#define LAPACK_csytrs_aa LAPACK_GLOBAL(csytrs_aa,CSYTRS_AA)\n#define LAPACK_zsytrs_aa LAPACK_GLOBAL(zsytrs_aa,ZSYTRS_AA)\n#define LAPACK_chetrs_aa LAPACK_GLOBAL(chetrs_aa,CHETRS_AA)\n#define LAPACK_zhetrs_aa LAPACK_GLOBAL(zhetrs_aa,ZHETRS_AA)\n#define LAPACK_ssytrf_aa LAPACK_GLOBAL(ssytrf_aa,SSYTRF_AA)\n#define LAPACK_dsytrf_aa LAPACK_GLOBAL(dsytrf_aa,DSYTRF_AA)\n#define LAPACK_csytrf_aa LAPACK_GLOBAL(csytrf_aa,CSYTRF_AA)\n#define LAPACK_zsytrf_aa LAPACK_GLOBAL(zsytrf_aa,ZSYTRF_AA)\n#define LAPACK_chetrf_aa LAPACK_GLOBAL(chetrf_aa,CHETRF_AA)\n#define LAPACK_zhetrf_aa LAPACK_GLOBAL(zhetrf_aa,ZHETRF_AA)\n\n#define LAPACK_ssysv_rk LAPACK_GLOBAL(ssysv_rk,SSYSV_RK)\n#define LAPACK_dsysv_rk LAPACK_GLOBAL(dsysv_rk,DSYSV_RK)\n#define LAPACK_chesv_rk LAPACK_GLOBAL(chesv_rk,CHESV_RK)\n#define LAPACK_zsysv_rk LAPACK_GLOBAL(zsysv_rk,ZSYSV_RK)\n#define LAPACK_csysv_rk LAPACK_GLOBAL(csysv_rk,CSYSV_RK)\n#define LAPACK_zhesv_rk LAPACK_GLOBAL(zhesv_rk,ZHESV_RK)\n#define LAPACK_ssytrf_rk LAPACK_GLOBAL(ssytrf_rk,SSYTRF_RK)\n#define LAPACK_dsytrf_rk LAPACK_GLOBAL(dsytrf_rk,DSYTRF_RK)\n#define LAPACK_csytrf_rk LAPACK_GLOBAL(csytrf_rk,CSYTRF_RK)\n#define LAPACK_zsytrf_rk LAPACK_GLOBAL(zsytrf_rk,ZSYTRF_RK)\n#define LAPACK_chetrf_rk LAPACK_GLOBAL(chetrf_rk,CHETRF_RK)\n#define LAPACK_zhetrf_rk LAPACK_GLOBAL(zhetrf_rk,ZHETRF_RK)\n#define LAPACK_ssytrs_3 LAPACK_GLOBAL(ssytrs_3,SSYTRS_3)\n#define LAPACK_dsytrs_3 LAPACK_GLOBAL(dsytrs_3,DSYTRS_3)\n#define LAPACK_csytrs_3 LAPACK_GLOBAL(csytrs_3,CSYTRS_3)\n#define LAPACK_zsytrs_3 LAPACK_GLOBAL(zsytrs_3,ZSYTRS_3)\n#define LAPACK_chetrs_3 LAPACK_GLOBAL(chetrs_3,CHETRS_3)\n#define LAPACK_zhetrs_3 LAPACK_GLOBAL(zhetrs_3,ZHETRS_3)\n#define LAPACK_ssytri_3 LAPACK_GLOBAL(ssytri_3,SSYTRI_3)\n#define LAPACK_dsytri_3 LAPACK_GLOBAL(dsytri_3,DSYTRI_3)\n#define LAPACK_csytri_3 LAPACK_GLOBAL(csytri_3,CSYTRI_3)\n#define LAPACK_zsytri_3 LAPACK_GLOBAL(zsytri_3,ZSYTRI_3)\n#define LAPACK_chetri_3 LAPACK_GLOBAL(chetri_3,CHETRI_3)\n#define LAPACK_zhetri_3 LAPACK_GLOBAL(zhetri_3,ZHETRI_3)\n#define LAPACK_ssycon_3 LAPACK_GLOBAL(ssycon_3,SSYCON_3)\n#define LAPACK_dsycon_3 LAPACK_GLOBAL(dsycon_3,DSYCON_3)\n#define LAPACK_csycon_3 LAPACK_GLOBAL(csycon_3,CSYCON_3)\n#define LAPACK_zsycon_3 LAPACK_GLOBAL(zsycon_3,ZSYCON_3)\n#define LAPACK_checon_3 LAPACK_GLOBAL(checon_3,CHECON_3)\n#define LAPACK_zhecon_3 LAPACK_GLOBAL(zhecon_3,ZHECON_3)\n#define LAPACK_sgelq LAPACK_GLOBAL(sgelq,SGELQ)\n#define LAPACK_dgelq LAPACK_GLOBAL(dgelq,DGELQ)\n#define LAPACK_cgelq LAPACK_GLOBAL(cgelq,CGELQ)\n#define LAPACK_zgelq LAPACK_GLOBAL(zgelq,ZGELQ)\n#define LAPACK_sgemlq LAPACK_GLOBAL(sgemlq,SGEMLQ)\n#define LAPACK_dgemlq LAPACK_GLOBAL(dgemlq,DGEMLQ)\n#define LAPACK_cgemlq LAPACK_GLOBAL(cgemlq,CGEMLQ)\n#define LAPACK_zgemlq LAPACK_GLOBAL(zgemlq,ZGEMLQ)\n#define LAPACK_sgeqr LAPACK_GLOBAL(sgeqr,SGEQR)\n#define LAPACK_dgeqr LAPACK_GLOBAL(dgeqr,DGEQR)\n#define LAPACK_cgeqr LAPACK_GLOBAL(cgeqr,CGEQR)\n#define LAPACK_zgeqr LAPACK_GLOBAL(zgeqr,ZGEQR)\n#define LAPACK_sgemqr LAPACK_GLOBAL(sgemqr,SGEMQR)\n#define LAPACK_dgemqr LAPACK_GLOBAL(dgemqr,DGEMQR)\n#define LAPACK_cgemqr LAPACK_GLOBAL(cgemqr,CGEMQR)\n#define LAPACK_zgemqr LAPACK_GLOBAL(zgemqr,ZGEMQR)\n#define LAPACK_sgetsls LAPACK_GLOBAL(sgetsls,SGETSLS)\n#define LAPACK_dgetsls LAPACK_GLOBAL(dgetsls,DGETSLS)\n#define LAPACK_cgetsls LAPACK_GLOBAL(cgetsls,CGETSLS)\n#define LAPACK_zgetsls LAPACK_GLOBAL(zgetsls,ZGETSLS)\n\n\nvoid LAPACK_sgetrf( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_dgetrf( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_cgetrf( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_zgetrf( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_sgetrf2( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_dgetrf2( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_cgetrf2( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_zgetrf2( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_sgbtrf( lapack_int* m, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, float* ab, lapack_int* ldab,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_dgbtrf( lapack_int* m, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, double* ab, lapack_int* ldab,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_cgbtrf( lapack_int* m, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, lapack_complex_float* ab, lapack_int* ldab,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_zgbtrf( lapack_int* m, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, lapack_complex_double* ab, lapack_int* ldab,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_sgttrf( lapack_int* n, float* dl, float* d, float* du, float* du2,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_dgttrf( lapack_int* n, double* dl, double* d, double* du,\n                    double* du2, lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_cgttrf( lapack_int* n, lapack_complex_float* dl,\n                    lapack_complex_float* d, lapack_complex_float* du,\n                    lapack_complex_float* du2, lapack_int* ipiv,\n                    lapack_int *info );\nvoid LAPACK_zgttrf( lapack_int* n, lapack_complex_double* dl,\n                    lapack_complex_double* d, lapack_complex_double* du,\n                    lapack_complex_double* du2, lapack_int* ipiv,\n                    lapack_int *info );\nvoid LAPACK_spotrf2( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_dpotrf2( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_cpotrf2( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_zpotrf2( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_spotrf( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_dpotrf( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_cpotrf( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_zpotrf( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_dpstrf( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* piv, lapack_int* rank, double* tol,\n                    double* work, lapack_int *info );\nvoid LAPACK_spstrf( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* piv, lapack_int* rank, float* tol, float* work,\n                    lapack_int *info );\nvoid LAPACK_zpstrf( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* piv, lapack_int* rank,\n                    double* tol, double* work, lapack_int *info );\nvoid LAPACK_cpstrf( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* piv, lapack_int* rank,\n                    float* tol, float* work, lapack_int *info );\nvoid LAPACK_dpftrf( char* transr, char* uplo, lapack_int* n, double* a,\n                    lapack_int *info );\nvoid LAPACK_spftrf( char* transr, char* uplo, lapack_int* n, float* a,\n                    lapack_int *info );\nvoid LAPACK_zpftrf( char* transr, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int *info );\nvoid LAPACK_cpftrf( char* transr, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int *info );\nvoid LAPACK_spptrf( char* uplo, lapack_int* n, float* ap, lapack_int *info );\nvoid LAPACK_dpptrf( char* uplo, lapack_int* n, double* ap, lapack_int *info );\nvoid LAPACK_cpptrf( char* uplo, lapack_int* n, lapack_complex_float* ap,\n                    lapack_int *info );\nvoid LAPACK_zpptrf( char* uplo, lapack_int* n, lapack_complex_double* ap,\n                    lapack_int *info );\nvoid LAPACK_spbtrf( char* uplo, lapack_int* n, lapack_int* kd, float* ab,\n                    lapack_int* ldab, lapack_int *info );\nvoid LAPACK_dpbtrf( char* uplo, lapack_int* n, lapack_int* kd, double* ab,\n                    lapack_int* ldab, lapack_int *info );\nvoid LAPACK_cpbtrf( char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_complex_float* ab, lapack_int* ldab,\n                    lapack_int *info );\nvoid LAPACK_zpbtrf( char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_complex_double* ab, lapack_int* ldab,\n                    lapack_int *info );\nvoid LAPACK_spttrf( lapack_int* n, float* d, float* e, lapack_int *info );\nvoid LAPACK_dpttrf( lapack_int* n, double* d, double* e, lapack_int *info );\nvoid LAPACK_cpttrf( lapack_int* n, float* d, lapack_complex_float* e,\n                    lapack_int *info );\nvoid LAPACK_zpttrf( lapack_int* n, double* d, lapack_complex_double* e,\n                    lapack_int *info );\nvoid LAPACK_ssytrf( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* ipiv, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dsytrf( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* ipiv, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_csytrf( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zsytrf( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_chetrf( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zhetrf( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_ssptrf( char* uplo, lapack_int* n, float* ap, lapack_int* ipiv,\n                    lapack_int *info );\nvoid LAPACK_dsptrf( char* uplo, lapack_int* n, double* ap, lapack_int* ipiv,\n                    lapack_int *info );\nvoid LAPACK_csptrf( char* uplo, lapack_int* n, lapack_complex_float* ap,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_zsptrf( char* uplo, lapack_int* n, lapack_complex_double* ap,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_chptrf( char* uplo, lapack_int* n, lapack_complex_float* ap,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_zhptrf( char* uplo, lapack_int* n, lapack_complex_double* ap,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_sgetrs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const float* a, lapack_int* lda, const lapack_int* ipiv,\n                    float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dgetrs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const double* a, lapack_int* lda, const lapack_int* ipiv,\n                    double* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_cgetrs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zgetrs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_sgbtrs( char* trans, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    lapack_int* nrhs, const float* ab, lapack_int* ldab,\n                    const lapack_int* ipiv, float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_dgbtrs( char* trans, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    lapack_int* nrhs, const double* ab, lapack_int* ldab,\n                    const lapack_int* ipiv, double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_cgbtrs( char* trans, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    lapack_int* nrhs, const lapack_complex_float* ab,\n                    lapack_int* ldab, const lapack_int* ipiv,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_zgbtrs( char* trans, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    lapack_int* nrhs, const lapack_complex_double* ab,\n                    lapack_int* ldab, const lapack_int* ipiv,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_sgttrs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const float* dl, const float* d, const float* du,\n                    const float* du2, const lapack_int* ipiv, float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dgttrs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const double* dl, const double* d, const double* du,\n                    const double* du2, const lapack_int* ipiv, double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_cgttrs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* dl,\n                    const lapack_complex_float* d,\n                    const lapack_complex_float* du,\n                    const lapack_complex_float* du2, const lapack_int* ipiv,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_zgttrs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* dl,\n                    const lapack_complex_double* d,\n                    const lapack_complex_double* du,\n                    const lapack_complex_double* du2, const lapack_int* ipiv,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_spotrs( char* uplo, lapack_int* n, lapack_int* nrhs, const float* a,\n                    lapack_int* lda, float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_dpotrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* a, lapack_int* lda, double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_cpotrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_zpotrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_dpftrs( char* transr, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* a, double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_spftrs( char* transr, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const float* a, float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_zpftrs( char* transr, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_cpftrs( char* transr, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_spptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const float* ap, float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_dpptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* ap, double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_cpptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* ap, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zpptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* ap, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_spbtrs( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                    const float* ab, lapack_int* ldab, float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dpbtrs( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                    const double* ab, lapack_int* ldab, double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_cpbtrs( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                    const lapack_complex_float* ab, lapack_int* ldab,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_zpbtrs( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                    const lapack_complex_double* ab, lapack_int* ldab,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_spttrs( lapack_int* n, lapack_int* nrhs, const float* d,\n                    const float* e, float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_dpttrs( lapack_int* n, lapack_int* nrhs, const double* d,\n                    const double* e, double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_cpttrs( char* uplo, lapack_int* n, lapack_int* nrhs, const float* d,\n                    const lapack_complex_float* e, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zpttrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* d, const lapack_complex_double* e,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_ssytrs( char* uplo, lapack_int* n, lapack_int* nrhs, const float* a,\n                    lapack_int* lda, const lapack_int* ipiv, float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dsytrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* a, lapack_int* lda, const lapack_int* ipiv,\n                    double* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_csytrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zsytrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_chetrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zhetrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_ssptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const float* ap, const lapack_int* ipiv, float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dsptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* ap, const lapack_int* ipiv, double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_csptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* ap, const lapack_int* ipiv,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_zsptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* ap, const lapack_int* ipiv,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_chptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* ap, const lapack_int* ipiv,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_zhptrs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* ap, const lapack_int* ipiv,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_strtrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const float* a, lapack_int* lda, float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dtrtrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const double* a, lapack_int* lda,\n                    double* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_ctrtrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_ztrtrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_stptrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const float* ap, float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dtptrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const double* ap, double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_ctptrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const lapack_complex_float* ap,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_ztptrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const lapack_complex_double* ap,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_stbtrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* kd, lapack_int* nrhs, const float* ab,\n                    lapack_int* ldab, float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_dtbtrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* kd, lapack_int* nrhs, const double* ab,\n                    lapack_int* ldab, double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_ctbtrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* kd, lapack_int* nrhs,\n                    const lapack_complex_float* ab, lapack_int* ldab,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_ztbtrs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* kd, lapack_int* nrhs,\n                    const lapack_complex_double* ab, lapack_int* ldab,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_sgecon( char* norm, lapack_int* n, const float* a, lapack_int* lda,\n                    float* anorm, float* rcond, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dgecon( char* norm, lapack_int* n, const double* a, lapack_int* lda,\n                    double* anorm, double* rcond, double* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgecon( char* norm, lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, float* anorm, float* rcond,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zgecon( char* norm, lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, double* anorm, double* rcond,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_sgbcon( char* norm, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    const float* ab, lapack_int* ldab, const lapack_int* ipiv,\n                    float* anorm, float* rcond, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dgbcon( char* norm, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    const double* ab, lapack_int* ldab, const lapack_int* ipiv,\n                    double* anorm, double* rcond, double* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgbcon( char* norm, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    const lapack_complex_float* ab, lapack_int* ldab,\n                    const lapack_int* ipiv, float* anorm, float* rcond,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zgbcon( char* norm, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    const lapack_complex_double* ab, lapack_int* ldab,\n                    const lapack_int* ipiv, double* anorm, double* rcond,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_sgtcon( char* norm, lapack_int* n, const float* dl, const float* d,\n                    const float* du, const float* du2, const lapack_int* ipiv,\n                    float* anorm, float* rcond, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dgtcon( char* norm, lapack_int* n, const double* dl,\n                    const double* d, const double* du, const double* du2,\n                    const lapack_int* ipiv, double* anorm, double* rcond,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgtcon( char* norm, lapack_int* n, const lapack_complex_float* dl,\n                    const lapack_complex_float* d,\n                    const lapack_complex_float* du,\n                    const lapack_complex_float* du2, const lapack_int* ipiv,\n                    float* anorm, float* rcond, lapack_complex_float* work,\n                    lapack_int *info );\nvoid LAPACK_zgtcon( char* norm, lapack_int* n, const lapack_complex_double* dl,\n                    const lapack_complex_double* d,\n                    const lapack_complex_double* du,\n                    const lapack_complex_double* du2, const lapack_int* ipiv,\n                    double* anorm, double* rcond, lapack_complex_double* work,\n                    lapack_int *info );\nvoid LAPACK_spocon( char* uplo, lapack_int* n, const float* a, lapack_int* lda,\n                    float* anorm, float* rcond, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dpocon( char* uplo, lapack_int* n, const double* a, lapack_int* lda,\n                    double* anorm, double* rcond, double* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cpocon( char* uplo, lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, float* anorm, float* rcond,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zpocon( char* uplo, lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, double* anorm, double* rcond,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_sppcon( char* uplo, lapack_int* n, const float* ap, float* anorm,\n                    float* rcond, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dppcon( char* uplo, lapack_int* n, const double* ap, double* anorm,\n                    double* rcond, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_cppcon( char* uplo, lapack_int* n, const lapack_complex_float* ap,\n                    float* anorm, float* rcond, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zppcon( char* uplo, lapack_int* n, const lapack_complex_double* ap,\n                    double* anorm, double* rcond, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_spbcon( char* uplo, lapack_int* n, lapack_int* kd, const float* ab,\n                    lapack_int* ldab, float* anorm, float* rcond, float* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dpbcon( char* uplo, lapack_int* n, lapack_int* kd, const double* ab,\n                    lapack_int* ldab, double* anorm, double* rcond,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cpbcon( char* uplo, lapack_int* n, lapack_int* kd,\n                    const lapack_complex_float* ab, lapack_int* ldab,\n                    float* anorm, float* rcond, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zpbcon( char* uplo, lapack_int* n, lapack_int* kd,\n                    const lapack_complex_double* ab, lapack_int* ldab,\n                    double* anorm, double* rcond, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sptcon( lapack_int* n, const float* d, const float* e, float* anorm,\n                    float* rcond, float* work, lapack_int *info );\nvoid LAPACK_dptcon( lapack_int* n, const double* d, const double* e,\n                    double* anorm, double* rcond, double* work,\n                    lapack_int *info );\nvoid LAPACK_cptcon( lapack_int* n, const float* d,\n                    const lapack_complex_float* e, float* anorm, float* rcond,\n                    float* work, lapack_int *info );\nvoid LAPACK_zptcon( lapack_int* n, const double* d,\n                    const lapack_complex_double* e, double* anorm,\n                    double* rcond, double* work, lapack_int *info );\nvoid LAPACK_ssycon( char* uplo, lapack_int* n, const float* a, lapack_int* lda,\n                    const lapack_int* ipiv, float* anorm, float* rcond,\n                    float* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dsycon( char* uplo, lapack_int* n, const double* a, lapack_int* lda,\n                    const lapack_int* ipiv, double* anorm, double* rcond,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_csycon( char* uplo, lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_int* ipiv, float* anorm,\n                    float* rcond, lapack_complex_float* work,\n                    lapack_int *info );\nvoid LAPACK_zsycon( char* uplo, lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_int* ipiv, double* anorm,\n                    double* rcond, lapack_complex_double* work,\n                    lapack_int *info );\nvoid LAPACK_checon( char* uplo, lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_int* ipiv, float* anorm,\n                    float* rcond, lapack_complex_float* work,\n                    lapack_int *info );\nvoid LAPACK_zhecon( char* uplo, lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_int* ipiv, double* anorm,\n                    double* rcond, lapack_complex_double* work,\n                    lapack_int *info );\nvoid LAPACK_sspcon( char* uplo, lapack_int* n, const float* ap,\n                    const lapack_int* ipiv, float* anorm, float* rcond,\n                    float* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dspcon( char* uplo, lapack_int* n, const double* ap,\n                    const lapack_int* ipiv, double* anorm, double* rcond,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cspcon( char* uplo, lapack_int* n, const lapack_complex_float* ap,\n                    const lapack_int* ipiv, float* anorm, float* rcond,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zspcon( char* uplo, lapack_int* n, const lapack_complex_double* ap,\n                    const lapack_int* ipiv, double* anorm, double* rcond,\n                    lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_chpcon( char* uplo, lapack_int* n, const lapack_complex_float* ap,\n                    const lapack_int* ipiv, float* anorm, float* rcond,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zhpcon( char* uplo, lapack_int* n, const lapack_complex_double* ap,\n                    const lapack_int* ipiv, double* anorm, double* rcond,\n                    lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_strcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    const float* a, lapack_int* lda, float* rcond, float* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dtrcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    const double* a, lapack_int* lda, double* rcond,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_ctrcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    float* rcond, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_ztrcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    double* rcond, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_stpcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    const float* ap, float* rcond, float* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dtpcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    const double* ap, double* rcond, double* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_ctpcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    const lapack_complex_float* ap, float* rcond,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_ztpcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    const lapack_complex_double* ap, double* rcond,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_stbcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    lapack_int* kd, const float* ab, lapack_int* ldab,\n                    float* rcond, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dtbcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    lapack_int* kd, const double* ab, lapack_int* ldab,\n                    double* rcond, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_ctbcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    lapack_int* kd, const lapack_complex_float* ab,\n                    lapack_int* ldab, float* rcond, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_ztbcon( char* norm, char* uplo, char* diag, lapack_int* n,\n                    lapack_int* kd, const lapack_complex_double* ab,\n                    lapack_int* ldab, double* rcond,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_sgerfs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const float* a, lapack_int* lda, const float* af,\n                    lapack_int* ldaf, const lapack_int* ipiv, const float* b,\n                    lapack_int* ldb, float* x, lapack_int* ldx, float* ferr,\n                    float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dgerfs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const double* a, lapack_int* lda, const double* af,\n                    lapack_int* ldaf, const lapack_int* ipiv, const double* b,\n                    lapack_int* ldb, double* x, lapack_int* ldx, double* ferr,\n                    double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_cgerfs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* af, lapack_int* ldaf,\n                    const lapack_int* ipiv, const lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* x, lapack_int* ldx,\n                    float* ferr, float* berr, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zgerfs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* af, lapack_int* ldaf,\n                    const lapack_int* ipiv, const lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sgbrfs( char* trans, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    lapack_int* nrhs, const float* ab, lapack_int* ldab,\n                    const float* afb, lapack_int* ldafb, const lapack_int* ipiv,\n                    const float* b, lapack_int* ldb, float* x, lapack_int* ldx,\n                    float* ferr, float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dgbrfs( char* trans, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    lapack_int* nrhs, const double* ab, lapack_int* ldab,\n                    const double* afb, lapack_int* ldafb,\n                    const lapack_int* ipiv, const double* b, lapack_int* ldb,\n                    double* x, lapack_int* ldx, double* ferr, double* berr,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgbrfs( char* trans, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    lapack_int* nrhs, const lapack_complex_float* ab,\n                    lapack_int* ldab, const lapack_complex_float* afb,\n                    lapack_int* ldafb, const lapack_int* ipiv,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zgbrfs( char* trans, lapack_int* n, lapack_int* kl, lapack_int* ku,\n                    lapack_int* nrhs, const lapack_complex_double* ab,\n                    lapack_int* ldab, const lapack_complex_double* afb,\n                    lapack_int* ldafb, const lapack_int* ipiv,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* ferr,\n                    double* berr, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_sgtrfs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const float* dl, const float* d, const float* du,\n                    const float* dlf, const float* df, const float* duf,\n                    const float* du2, const lapack_int* ipiv, const float* b,\n                    lapack_int* ldb, float* x, lapack_int* ldx, float* ferr,\n                    float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dgtrfs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const double* dl, const double* d, const double* du,\n                    const double* dlf, const double* df, const double* duf,\n                    const double* du2, const lapack_int* ipiv, const double* b,\n                    lapack_int* ldb, double* x, lapack_int* ldx, double* ferr,\n                    double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_cgtrfs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* dl,\n                    const lapack_complex_float* d,\n                    const lapack_complex_float* du,\n                    const lapack_complex_float* dlf,\n                    const lapack_complex_float* df,\n                    const lapack_complex_float* duf,\n                    const lapack_complex_float* du2, const lapack_int* ipiv,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zgtrfs( char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* dl,\n                    const lapack_complex_double* d,\n                    const lapack_complex_double* du,\n                    const lapack_complex_double* dlf,\n                    const lapack_complex_double* df,\n                    const lapack_complex_double* duf,\n                    const lapack_complex_double* du2, const lapack_int* ipiv,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* ferr,\n                    double* berr, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_sporfs( char* uplo, lapack_int* n, lapack_int* nrhs, const float* a,\n                    lapack_int* lda, const float* af, lapack_int* ldaf,\n                    const float* b, lapack_int* ldb, float* x, lapack_int* ldx,\n                    float* ferr, float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dporfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* a, lapack_int* lda, const double* af,\n                    lapack_int* ldaf, const double* b, lapack_int* ldb,\n                    double* x, lapack_int* ldx, double* ferr, double* berr,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cporfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* af, lapack_int* ldaf,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zporfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* af, lapack_int* ldaf,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* ferr,\n                    double* berr, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_spprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const float* ap, const float* afp, const float* b,\n                    lapack_int* ldb, float* x, lapack_int* ldx, float* ferr,\n                    float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dpprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* ap, const double* afp, const double* b,\n                    lapack_int* ldb, double* x, lapack_int* ldx, double* ferr,\n                    double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_cpprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* ap,\n                    const lapack_complex_float* afp,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zpprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* ap,\n                    const lapack_complex_double* afp,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* ferr,\n                    double* berr, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_spbrfs( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                    const float* ab, lapack_int* ldab, const float* afb,\n                    lapack_int* ldafb, const float* b, lapack_int* ldb,\n                    float* x, lapack_int* ldx, float* ferr, float* berr,\n                    float* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dpbrfs( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                    const double* ab, lapack_int* ldab, const double* afb,\n                    lapack_int* ldafb, const double* b, lapack_int* ldb,\n                    double* x, lapack_int* ldx, double* ferr, double* berr,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cpbrfs( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                    const lapack_complex_float* ab, lapack_int* ldab,\n                    const lapack_complex_float* afb, lapack_int* ldafb,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zpbrfs( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                    const lapack_complex_double* ab, lapack_int* ldab,\n                    const lapack_complex_double* afb, lapack_int* ldafb,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* ferr,\n                    double* berr, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_sptrfs( lapack_int* n, lapack_int* nrhs, const float* d,\n                    const float* e, const float* df, const float* ef,\n                    const float* b, lapack_int* ldb, float* x, lapack_int* ldx,\n                    float* ferr, float* berr, float* work, lapack_int *info );\nvoid LAPACK_dptrfs( lapack_int* n, lapack_int* nrhs, const double* d,\n                    const double* e, const double* df, const double* ef,\n                    const double* b, lapack_int* ldb, double* x,\n                    lapack_int* ldx, double* ferr, double* berr, double* work,\n                    lapack_int *info );\nvoid LAPACK_cptrfs( char* uplo, lapack_int* n, lapack_int* nrhs, const float* d,\n                    const lapack_complex_float* e, const float* df,\n                    const lapack_complex_float* ef,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zptrfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* d, const lapack_complex_double* e,\n                    const double* df, const lapack_complex_double* ef,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* ferr,\n                    double* berr, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_ssyrfs( char* uplo, lapack_int* n, lapack_int* nrhs, const float* a,\n                    lapack_int* lda, const float* af, lapack_int* ldaf,\n                    const lapack_int* ipiv, const float* b, lapack_int* ldb,\n                    float* x, lapack_int* ldx, float* ferr, float* berr,\n                    float* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dsyrfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* a, lapack_int* lda, const double* af,\n                    lapack_int* ldaf, const lapack_int* ipiv, const double* b,\n                    lapack_int* ldb, double* x, lapack_int* ldx, double* ferr,\n                    double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_csyrfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* af, lapack_int* ldaf,\n                    const lapack_int* ipiv, const lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* x, lapack_int* ldx,\n                    float* ferr, float* berr, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zsyrfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* af, lapack_int* ldaf,\n                    const lapack_int* ipiv, const lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_cherfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* af, lapack_int* ldaf,\n                    const lapack_int* ipiv, const lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* x, lapack_int* ldx,\n                    float* ferr, float* berr, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zherfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* af, lapack_int* ldaf,\n                    const lapack_int* ipiv, const lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_ssprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const float* ap, const float* afp, const lapack_int* ipiv,\n                    const float* b, lapack_int* ldb, float* x, lapack_int* ldx,\n                    float* ferr, float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dsprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* ap, const double* afp, const lapack_int* ipiv,\n                    const double* b, lapack_int* ldb, double* x,\n                    lapack_int* ldx, double* ferr, double* berr, double* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_csprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* ap,\n                    const lapack_complex_float* afp, const lapack_int* ipiv,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zsprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* ap,\n                    const lapack_complex_double* afp, const lapack_int* ipiv,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* ferr,\n                    double* berr, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_chprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* ap,\n                    const lapack_complex_float* afp, const lapack_int* ipiv,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zhprfs( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* ap,\n                    const lapack_complex_double* afp, const lapack_int* ipiv,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* ferr,\n                    double* berr, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_strrfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const float* a, lapack_int* lda,\n                    const float* b, lapack_int* ldb, const float* x,\n                    lapack_int* ldx, float* ferr, float* berr, float* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dtrrfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const double* a, lapack_int* lda,\n                    const double* b, lapack_int* ldb, const double* x,\n                    lapack_int* ldx, double* ferr, double* berr, double* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_ctrrfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* b,\n                    lapack_int* ldb, const lapack_complex_float* x,\n                    lapack_int* ldx, float* ferr, float* berr,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_ztrrfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* b,\n                    lapack_int* ldb, const lapack_complex_double* x,\n                    lapack_int* ldx, double* ferr, double* berr,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_stprfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const float* ap, const float* b,\n                    lapack_int* ldb, const float* x, lapack_int* ldx,\n                    float* ferr, float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dtprfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const double* ap, const double* b,\n                    lapack_int* ldb, const double* x, lapack_int* ldx,\n                    double* ferr, double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_ctprfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const lapack_complex_float* ap,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    const lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_ztprfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* nrhs, const lapack_complex_double* ap,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    const lapack_complex_double* x, lapack_int* ldx,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_stbrfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* kd, lapack_int* nrhs, const float* ab,\n                    lapack_int* ldab, const float* b, lapack_int* ldb,\n                    const float* x, lapack_int* ldx, float* ferr, float* berr,\n                    float* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dtbrfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* kd, lapack_int* nrhs, const double* ab,\n                    lapack_int* ldab, const double* b, lapack_int* ldb,\n                    const double* x, lapack_int* ldx, double* ferr,\n                    double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_ctbrfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* kd, lapack_int* nrhs,\n                    const lapack_complex_float* ab, lapack_int* ldab,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    const lapack_complex_float* x, lapack_int* ldx, float* ferr,\n                    float* berr, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_ztbrfs( char* uplo, char* trans, char* diag, lapack_int* n,\n                    lapack_int* kd, lapack_int* nrhs,\n                    const lapack_complex_double* ab, lapack_int* ldab,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    const lapack_complex_double* x, lapack_int* ldx,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sgetri( lapack_int* n, float* a, lapack_int* lda,\n                    const lapack_int* ipiv, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dgetri( lapack_int* n, double* a, lapack_int* lda,\n                    const lapack_int* ipiv, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cgetri( lapack_int* n, lapack_complex_float* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zgetri( lapack_int* n, lapack_complex_double* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_spotri( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_dpotri( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_cpotri( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_zpotri( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_dpftri( char* transr, char* uplo, lapack_int* n, double* a,\n                    lapack_int *info );\nvoid LAPACK_spftri( char* transr, char* uplo, lapack_int* n, float* a,\n                    lapack_int *info );\nvoid LAPACK_zpftri( char* transr, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int *info );\nvoid LAPACK_cpftri( char* transr, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int *info );\nvoid LAPACK_spptri( char* uplo, lapack_int* n, float* ap, lapack_int *info );\nvoid LAPACK_dpptri( char* uplo, lapack_int* n, double* ap, lapack_int *info );\nvoid LAPACK_cpptri( char* uplo, lapack_int* n, lapack_complex_float* ap,\n                    lapack_int *info );\nvoid LAPACK_zpptri( char* uplo, lapack_int* n, lapack_complex_double* ap,\n                    lapack_int *info );\nvoid LAPACK_ssytri( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    const lapack_int* ipiv, float* work, lapack_int *info );\nvoid LAPACK_dsytri( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    const lapack_int* ipiv, double* work, lapack_int *info );\nvoid LAPACK_csytri( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, const lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zsytri( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, const lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_chetri( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, const lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zhetri( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, const lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_ssptri( char* uplo, lapack_int* n, float* ap,\n                    const lapack_int* ipiv, float* work, lapack_int *info );\nvoid LAPACK_dsptri( char* uplo, lapack_int* n, double* ap,\n                    const lapack_int* ipiv, double* work, lapack_int *info );\nvoid LAPACK_csptri( char* uplo, lapack_int* n, lapack_complex_float* ap,\n                    const lapack_int* ipiv, lapack_complex_float* work,\n                    lapack_int *info );\nvoid LAPACK_zsptri( char* uplo, lapack_int* n, lapack_complex_double* ap,\n                    const lapack_int* ipiv, lapack_complex_double* work,\n                    lapack_int *info );\nvoid LAPACK_chptri( char* uplo, lapack_int* n, lapack_complex_float* ap,\n                    const lapack_int* ipiv, lapack_complex_float* work,\n                    lapack_int *info );\nvoid LAPACK_zhptri( char* uplo, lapack_int* n, lapack_complex_double* ap,\n                    const lapack_int* ipiv, lapack_complex_double* work,\n                    lapack_int *info );\nvoid LAPACK_strtri( char* uplo, char* diag, lapack_int* n, float* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_dtrtri( char* uplo, char* diag, lapack_int* n, double* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_ctrtri( char* uplo, char* diag, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_ztrtri( char* uplo, char* diag, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_dtftri( char* transr, char* uplo, char* diag, lapack_int* n,\n                    double* a, lapack_int *info );\nvoid LAPACK_stftri( char* transr, char* uplo, char* diag, lapack_int* n,\n                    float* a, lapack_int *info );\nvoid LAPACK_ztftri( char* transr, char* uplo, char* diag, lapack_int* n,\n                    lapack_complex_double* a, lapack_int *info );\nvoid LAPACK_ctftri( char* transr, char* uplo, char* diag, lapack_int* n,\n                    lapack_complex_float* a, lapack_int *info );\nvoid LAPACK_stptri( char* uplo, char* diag, lapack_int* n, float* ap,\n                    lapack_int *info );\nvoid LAPACK_dtptri( char* uplo, char* diag, lapack_int* n, double* ap,\n                    lapack_int *info );\nvoid LAPACK_ctptri( char* uplo, char* diag, lapack_int* n,\n                    lapack_complex_float* ap, lapack_int *info );\nvoid LAPACK_ztptri( char* uplo, char* diag, lapack_int* n,\n                    lapack_complex_double* ap, lapack_int *info );\nvoid LAPACK_sgeequ( lapack_int* m, lapack_int* n, const float* a,\n                    lapack_int* lda, float* r, float* c, float* rowcnd,\n                    float* colcnd, float* amax, lapack_int *info );\nvoid LAPACK_dgeequ( lapack_int* m, lapack_int* n, const double* a,\n                    lapack_int* lda, double* r, double* c, double* rowcnd,\n                    double* colcnd, double* amax, lapack_int *info );\nvoid LAPACK_cgeequ( lapack_int* m, lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, float* r, float* c, float* rowcnd,\n                    float* colcnd, float* amax, lapack_int *info );\nvoid LAPACK_zgeequ( lapack_int* m, lapack_int* n,\n                    const lapack_complex_double* a, lapack_int* lda, double* r,\n                    double* c, double* rowcnd, double* colcnd, double* amax,\n                    lapack_int *info );\nvoid LAPACK_dgeequb( lapack_int* m, lapack_int* n, const double* a,\n                     lapack_int* lda, double* r, double* c, double* rowcnd,\n                     double* colcnd, double* amax, lapack_int *info );\nvoid LAPACK_sgeequb( lapack_int* m, lapack_int* n, const float* a,\n                     lapack_int* lda, float* r, float* c, float* rowcnd,\n                     float* colcnd, float* amax, lapack_int *info );\nvoid LAPACK_zgeequb( lapack_int* m, lapack_int* n,\n                     const lapack_complex_double* a, lapack_int* lda, double* r,\n                     double* c, double* rowcnd, double* colcnd, double* amax,\n                     lapack_int *info );\nvoid LAPACK_cgeequb( lapack_int* m, lapack_int* n,\n                     const lapack_complex_float* a, lapack_int* lda, float* r,\n                     float* c, float* rowcnd, float* colcnd, float* amax,\n                     lapack_int *info );\nvoid LAPACK_sgbequ( lapack_int* m, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, const float* ab, lapack_int* ldab, float* r,\n                    float* c, float* rowcnd, float* colcnd, float* amax,\n                    lapack_int *info );\nvoid LAPACK_dgbequ( lapack_int* m, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, const double* ab, lapack_int* ldab,\n                    double* r, double* c, double* rowcnd, double* colcnd,\n                    double* amax, lapack_int *info );\nvoid LAPACK_cgbequ( lapack_int* m, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, const lapack_complex_float* ab,\n                    lapack_int* ldab, float* r, float* c, float* rowcnd,\n                    float* colcnd, float* amax, lapack_int *info );\nvoid LAPACK_zgbequ( lapack_int* m, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, const lapack_complex_double* ab,\n                    lapack_int* ldab, double* r, double* c, double* rowcnd,\n                    double* colcnd, double* amax, lapack_int *info );\nvoid LAPACK_dgbequb( lapack_int* m, lapack_int* n, lapack_int* kl,\n                     lapack_int* ku, const double* ab, lapack_int* ldab,\n                     double* r, double* c, double* rowcnd, double* colcnd,\n                     double* amax, lapack_int *info );\nvoid LAPACK_sgbequb( lapack_int* m, lapack_int* n, lapack_int* kl,\n                     lapack_int* ku, const float* ab, lapack_int* ldab,\n                     float* r, float* c, float* rowcnd, float* colcnd,\n                     float* amax, lapack_int *info );\nvoid LAPACK_zgbequb( lapack_int* m, lapack_int* n, lapack_int* kl,\n                     lapack_int* ku, const lapack_complex_double* ab,\n                     lapack_int* ldab, double* r, double* c, double* rowcnd,\n                     double* colcnd, double* amax, lapack_int *info );\nvoid LAPACK_cgbequb( lapack_int* m, lapack_int* n, lapack_int* kl,\n                     lapack_int* ku, const lapack_complex_float* ab,\n                     lapack_int* ldab, float* r, float* c, float* rowcnd,\n                     float* colcnd, float* amax, lapack_int *info );\nvoid LAPACK_spoequ( lapack_int* n, const float* a, lapack_int* lda, float* s,\n                    float* scond, float* amax, lapack_int *info );\nvoid LAPACK_dpoequ( lapack_int* n, const double* a, lapack_int* lda, double* s,\n                    double* scond, double* amax, lapack_int *info );\nvoid LAPACK_cpoequ( lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, float* s, float* scond, float* amax,\n                    lapack_int *info );\nvoid LAPACK_zpoequ( lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, double* s, double* scond, double* amax,\n                    lapack_int *info );\nvoid LAPACK_dpoequb( lapack_int* n, const double* a, lapack_int* lda, double* s,\n                     double* scond, double* amax, lapack_int *info );\nvoid LAPACK_spoequb( lapack_int* n, const float* a, lapack_int* lda, float* s,\n                     float* scond, float* amax, lapack_int *info );\nvoid LAPACK_zpoequb( lapack_int* n, const lapack_complex_double* a,\n                     lapack_int* lda, double* s, double* scond, double* amax,\n                     lapack_int *info );\nvoid LAPACK_cpoequb( lapack_int* n, const lapack_complex_float* a,\n                     lapack_int* lda, float* s, float* scond, float* amax,\n                     lapack_int *info );\nvoid LAPACK_sppequ( char* uplo, lapack_int* n, const float* ap, float* s,\n                    float* scond, float* amax, lapack_int *info );\nvoid LAPACK_dppequ( char* uplo, lapack_int* n, const double* ap, double* s,\n                    double* scond, double* amax, lapack_int *info );\nvoid LAPACK_cppequ( char* uplo, lapack_int* n, const lapack_complex_float* ap,\n                    float* s, float* scond, float* amax, lapack_int *info );\nvoid LAPACK_zppequ( char* uplo, lapack_int* n, const lapack_complex_double* ap,\n                    double* s, double* scond, double* amax, lapack_int *info );\nvoid LAPACK_spbequ( char* uplo, lapack_int* n, lapack_int* kd, const float* ab,\n                    lapack_int* ldab, float* s, float* scond, float* amax,\n                    lapack_int *info );\nvoid LAPACK_dpbequ( char* uplo, lapack_int* n, lapack_int* kd, const double* ab,\n                    lapack_int* ldab, double* s, double* scond, double* amax,\n                    lapack_int *info );\nvoid LAPACK_cpbequ( char* uplo, lapack_int* n, lapack_int* kd,\n                    const lapack_complex_float* ab, lapack_int* ldab, float* s,\n                    float* scond, float* amax, lapack_int *info );\nvoid LAPACK_zpbequ( char* uplo, lapack_int* n, lapack_int* kd,\n                    const lapack_complex_double* ab, lapack_int* ldab,\n                    double* s, double* scond, double* amax, lapack_int *info );\nvoid LAPACK_dsyequb( char* uplo, lapack_int* n, const double* a,\n                     lapack_int* lda, double* s, double* scond, double* amax,\n                     double* work, lapack_int *info );\nvoid LAPACK_ssyequb( char* uplo, lapack_int* n, const float* a, lapack_int* lda,\n                     float* s, float* scond, float* amax, float* work,\n                     lapack_int *info );\nvoid LAPACK_zsyequb( char* uplo, lapack_int* n, const lapack_complex_double* a,\n                     lapack_int* lda, double* s, double* scond, double* amax,\n                     lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_csyequb( char* uplo, lapack_int* n, const lapack_complex_float* a,\n                     lapack_int* lda, float* s, float* scond, float* amax,\n                     lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zheequb( char* uplo, lapack_int* n, const lapack_complex_double* a,\n                     lapack_int* lda, double* s, double* scond, double* amax,\n                     lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_cheequb( char* uplo, lapack_int* n, const lapack_complex_float* a,\n                     lapack_int* lda, float* s, float* scond, float* amax,\n                     lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_sgesv( lapack_int* n, lapack_int* nrhs, float* a, lapack_int* lda,\n                   lapack_int* ipiv, float* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_dgesv( lapack_int* n, lapack_int* nrhs, double* a, lapack_int* lda,\n                   lapack_int* ipiv, double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_cgesv( lapack_int* n, lapack_int* nrhs, lapack_complex_float* a,\n                   lapack_int* lda, lapack_int* ipiv, lapack_complex_float* b,\n                   lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zgesv( lapack_int* n, lapack_int* nrhs, lapack_complex_double* a,\n                   lapack_int* lda, lapack_int* ipiv, lapack_complex_double* b,\n                   lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dsgesv( lapack_int* n, lapack_int* nrhs, double* a, lapack_int* lda,\n                    lapack_int* ipiv, double* b, lapack_int* ldb, double* x,\n                    lapack_int* ldx, double* work, float* swork,\n                    lapack_int* iter, lapack_int *info );\nvoid LAPACK_zcgesv( lapack_int* n, lapack_int* nrhs, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    lapack_complex_double* work, lapack_complex_float* swork,\n                    double* rwork, lapack_int* iter, lapack_int *info );\nvoid LAPACK_sgesvx( char* fact, char* trans, lapack_int* n, lapack_int* nrhs,\n                    float* a, lapack_int* lda, float* af, lapack_int* ldaf,\n                    lapack_int* ipiv, char* equed, float* r, float* c, float* b,\n                    lapack_int* ldb, float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dgesvx( char* fact, char* trans, lapack_int* n, lapack_int* nrhs,\n                    double* a, lapack_int* lda, double* af, lapack_int* ldaf,\n                    lapack_int* ipiv, char* equed, double* r, double* c,\n                    double* b, lapack_int* ldb, double* x, lapack_int* ldx,\n                    double* rcond, double* ferr, double* berr, double* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgesvx( char* fact, char* trans, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* af, lapack_int* ldaf,\n                    lapack_int* ipiv, char* equed, float* r, float* c,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zgesvx( char* fact, char* trans, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* af, lapack_int* ldaf,\n                    lapack_int* ipiv, char* equed, double* r, double* c,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* rcond,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sgbsv( lapack_int* n, lapack_int* kl, lapack_int* ku,\n                   lapack_int* nrhs, float* ab, lapack_int* ldab,\n                   lapack_int* ipiv, float* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_dgbsv( lapack_int* n, lapack_int* kl, lapack_int* ku,\n                   lapack_int* nrhs, double* ab, lapack_int* ldab,\n                   lapack_int* ipiv, double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_cgbsv( lapack_int* n, lapack_int* kl, lapack_int* ku,\n                   lapack_int* nrhs, lapack_complex_float* ab, lapack_int* ldab,\n                   lapack_int* ipiv, lapack_complex_float* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_zgbsv( lapack_int* n, lapack_int* kl, lapack_int* ku,\n                   lapack_int* nrhs, lapack_complex_double* ab,\n                   lapack_int* ldab, lapack_int* ipiv, lapack_complex_double* b,\n                   lapack_int* ldb, lapack_int *info );\nvoid LAPACK_sgbsvx( char* fact, char* trans, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, lapack_int* nrhs, float* ab,\n                    lapack_int* ldab, float* afb, lapack_int* ldafb,\n                    lapack_int* ipiv, char* equed, float* r, float* c, float* b,\n                    lapack_int* ldb, float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dgbsvx( char* fact, char* trans, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, lapack_int* nrhs, double* ab,\n                    lapack_int* ldab, double* afb, lapack_int* ldafb,\n                    lapack_int* ipiv, char* equed, double* r, double* c,\n                    double* b, lapack_int* ldb, double* x, lapack_int* ldx,\n                    double* rcond, double* ferr, double* berr, double* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgbsvx( char* fact, char* trans, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, lapack_int* nrhs, lapack_complex_float* ab,\n                    lapack_int* ldab, lapack_complex_float* afb,\n                    lapack_int* ldafb, lapack_int* ipiv, char* equed, float* r,\n                    float* c, lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zgbsvx( char* fact, char* trans, lapack_int* n, lapack_int* kl,\n                    lapack_int* ku, lapack_int* nrhs, lapack_complex_double* ab,\n                    lapack_int* ldab, lapack_complex_double* afb,\n                    lapack_int* ldafb, lapack_int* ipiv, char* equed, double* r,\n                    double* c, lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* rcond,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sgtsv( lapack_int* n, lapack_int* nrhs, float* dl, float* d,\n                   float* du, float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dgtsv( lapack_int* n, lapack_int* nrhs, double* dl, double* d,\n                   double* du, double* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_cgtsv( lapack_int* n, lapack_int* nrhs, lapack_complex_float* dl,\n                   lapack_complex_float* d, lapack_complex_float* du,\n                   lapack_complex_float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zgtsv( lapack_int* n, lapack_int* nrhs, lapack_complex_double* dl,\n                   lapack_complex_double* d, lapack_complex_double* du,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_sgtsvx( char* fact, char* trans, lapack_int* n, lapack_int* nrhs,\n                    const float* dl, const float* d, const float* du,\n                    float* dlf, float* df, float* duf, float* du2,\n                    lapack_int* ipiv, const float* b, lapack_int* ldb, float* x,\n                    lapack_int* ldx, float* rcond, float* ferr, float* berr,\n                    float* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dgtsvx( char* fact, char* trans, lapack_int* n, lapack_int* nrhs,\n                    const double* dl, const double* d, const double* du,\n                    double* dlf, double* df, double* duf, double* du2,\n                    lapack_int* ipiv, const double* b, lapack_int* ldb,\n                    double* x, lapack_int* ldx, double* rcond, double* ferr,\n                    double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_cgtsvx( char* fact, char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* dl,\n                    const lapack_complex_float* d,\n                    const lapack_complex_float* du, lapack_complex_float* dlf,\n                    lapack_complex_float* df, lapack_complex_float* duf,\n                    lapack_complex_float* du2, lapack_int* ipiv,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zgtsvx( char* fact, char* trans, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* dl,\n                    const lapack_complex_double* d,\n                    const lapack_complex_double* du, lapack_complex_double* dlf,\n                    lapack_complex_double* df, lapack_complex_double* duf,\n                    lapack_complex_double* du2, lapack_int* ipiv,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* rcond,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sposv( char* uplo, lapack_int* n, lapack_int* nrhs, float* a,\n                   lapack_int* lda, float* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_dposv( char* uplo, lapack_int* n, lapack_int* nrhs, double* a,\n                   lapack_int* lda, double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_cposv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zposv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_dsposv( char* uplo, lapack_int* n, lapack_int* nrhs, double* a,\n                    lapack_int* lda, double* b, lapack_int* ldb, double* x,\n                    lapack_int* ldx, double* work, float* swork,\n                    lapack_int* iter, lapack_int *info );\nvoid LAPACK_zcposv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx,\n                    lapack_complex_double* work, lapack_complex_float* swork,\n                    double* rwork, lapack_int* iter, lapack_int *info );\nvoid LAPACK_sposvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    float* a, lapack_int* lda, float* af, lapack_int* ldaf,\n                    char* equed, float* s, float* b, lapack_int* ldb, float* x,\n                    lapack_int* ldx, float* rcond, float* ferr, float* berr,\n                    float* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dposvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    double* a, lapack_int* lda, double* af, lapack_int* ldaf,\n                    char* equed, double* s, double* b, lapack_int* ldb,\n                    double* x, lapack_int* ldx, double* rcond, double* ferr,\n                    double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_cposvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* af, lapack_int* ldaf, char* equed,\n                    float* s, lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zposvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* af, lapack_int* ldaf, char* equed,\n                    double* s, lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* rcond,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sppsv( char* uplo, lapack_int* n, lapack_int* nrhs, float* ap,\n                   float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dppsv( char* uplo, lapack_int* n, lapack_int* nrhs, double* ap,\n                   double* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_cppsv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* ap, lapack_complex_float* b,\n                   lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zppsv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* ap, lapack_complex_double* b,\n                   lapack_int* ldb, lapack_int *info );\nvoid LAPACK_sppsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    float* ap, float* afp, char* equed, float* s, float* b,\n                    lapack_int* ldb, float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dppsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    double* ap, double* afp, char* equed, double* s, double* b,\n                    lapack_int* ldb, double* x, lapack_int* ldx, double* rcond,\n                    double* ferr, double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_cppsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_float* ap, lapack_complex_float* afp,\n                    char* equed, float* s, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* x, lapack_int* ldx,\n                    float* rcond, float* ferr, float* berr,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zppsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_double* ap, lapack_complex_double* afp,\n                    char* equed, double* s, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    double* rcond, double* ferr, double* berr,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_spbsv( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                   float* ab, lapack_int* ldab, float* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_dpbsv( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                   double* ab, lapack_int* ldab, double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_cpbsv( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                   lapack_complex_float* ab, lapack_int* ldab,\n                   lapack_complex_float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zpbsv( char* uplo, lapack_int* n, lapack_int* kd, lapack_int* nrhs,\n                   lapack_complex_double* ab, lapack_int* ldab,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_spbsvx( char* fact, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_int* nrhs, float* ab, lapack_int* ldab, float* afb,\n                    lapack_int* ldafb, char* equed, float* s, float* b,\n                    lapack_int* ldb, float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dpbsvx( char* fact, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_int* nrhs, double* ab, lapack_int* ldab, double* afb,\n                    lapack_int* ldafb, char* equed, double* s, double* b,\n                    lapack_int* ldb, double* x, lapack_int* ldx, double* rcond,\n                    double* ferr, double* berr, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_cpbsvx( char* fact, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_int* nrhs, lapack_complex_float* ab,\n                    lapack_int* ldab, lapack_complex_float* afb,\n                    lapack_int* ldafb, char* equed, float* s,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zpbsvx( char* fact, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_int* nrhs, lapack_complex_double* ab,\n                    lapack_int* ldab, lapack_complex_double* afb,\n                    lapack_int* ldafb, char* equed, double* s,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* x, lapack_int* ldx, double* rcond,\n                    double* ferr, double* berr, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sptsv( lapack_int* n, lapack_int* nrhs, float* d, float* e,\n                   float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dptsv( lapack_int* n, lapack_int* nrhs, double* d, double* e,\n                   double* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_cptsv( lapack_int* n, lapack_int* nrhs, float* d,\n                   lapack_complex_float* e, lapack_complex_float* b,\n                   lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zptsv( lapack_int* n, lapack_int* nrhs, double* d,\n                   lapack_complex_double* e, lapack_complex_double* b,\n                   lapack_int* ldb, lapack_int *info );\nvoid LAPACK_sptsvx( char* fact, lapack_int* n, lapack_int* nrhs, const float* d,\n                    const float* e, float* df, float* ef, const float* b,\n                    lapack_int* ldb, float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, float* work, lapack_int *info );\nvoid LAPACK_dptsvx( char* fact, lapack_int* n, lapack_int* nrhs,\n                    const double* d, const double* e, double* df, double* ef,\n                    const double* b, lapack_int* ldb, double* x,\n                    lapack_int* ldx, double* rcond, double* ferr, double* berr,\n                    double* work, lapack_int *info );\nvoid LAPACK_cptsvx( char* fact, lapack_int* n, lapack_int* nrhs, const float* d,\n                    const lapack_complex_float* e, float* df,\n                    lapack_complex_float* ef, const lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* x, lapack_int* ldx,\n                    float* rcond, float* ferr, float* berr,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zptsvx( char* fact, lapack_int* n, lapack_int* nrhs,\n                    const double* d, const lapack_complex_double* e, double* df,\n                    lapack_complex_double* ef, const lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    double* rcond, double* ferr, double* berr,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_ssysv( char* uplo, lapack_int* n, lapack_int* nrhs, float* a,\n                   lapack_int* lda, lapack_int* ipiv, float* b, lapack_int* ldb,\n                   float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dsysv( char* uplo, lapack_int* n, lapack_int* nrhs, double* a,\n                   lapack_int* lda, lapack_int* ipiv, double* b,\n                   lapack_int* ldb, double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_csysv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* a, lapack_int* lda, lapack_int* ipiv,\n                   lapack_complex_float* b, lapack_int* ldb,\n                   lapack_complex_float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_zsysv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* a, lapack_int* lda, lapack_int* ipiv,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_ssysvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const float* a, lapack_int* lda, float* af,\n                    lapack_int* ldaf, lapack_int* ipiv, const float* b,\n                    lapack_int* ldb, float* x, lapack_int* ldx, float* rcond,\n                    float* ferr, float* berr, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dsysvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* a, lapack_int* lda, double* af,\n                    lapack_int* ldaf, lapack_int* ipiv, const double* b,\n                    lapack_int* ldb, double* x, lapack_int* ldx, double* rcond,\n                    double* ferr, double* berr, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_csysvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* af, lapack_int* ldaf,\n                    lapack_int* ipiv, const lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* x, lapack_int* ldx,\n                    float* rcond, float* ferr, float* berr,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zsysvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* af, lapack_int* ldaf,\n                    lapack_int* ipiv, const lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    double* rcond, double* ferr, double* berr,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_chesv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* a, lapack_int* lda, lapack_int* ipiv,\n                   lapack_complex_float* b, lapack_int* ldb,\n                   lapack_complex_float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_zhesv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* a, lapack_int* lda, lapack_int* ipiv,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_chesvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* af, lapack_int* ldaf,\n                    lapack_int* ipiv, const lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* x, lapack_int* ldx,\n                    float* rcond, float* ferr, float* berr,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zhesvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* af, lapack_int* ldaf,\n                    lapack_int* ipiv, const lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    double* rcond, double* ferr, double* berr,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sspsv( char* uplo, lapack_int* n, lapack_int* nrhs, float* ap,\n                   lapack_int* ipiv, float* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_dspsv( char* uplo, lapack_int* n, lapack_int* nrhs, double* ap,\n                   lapack_int* ipiv, double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_cspsv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* ap, lapack_int* ipiv,\n                   lapack_complex_float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zspsv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* ap, lapack_int* ipiv,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_sspsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const float* ap, float* afp, lapack_int* ipiv,\n                    const float* b, lapack_int* ldb, float* x, lapack_int* ldx,\n                    float* rcond, float* ferr, float* berr, float* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dspsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* ap, double* afp, lapack_int* ipiv,\n                    const double* b, lapack_int* ldb, double* x,\n                    lapack_int* ldx, double* rcond, double* ferr, double* berr,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cspsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* ap, lapack_complex_float* afp,\n                    lapack_int* ipiv, const lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* x, lapack_int* ldx,\n                    float* rcond, float* ferr, float* berr,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zspsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* ap, lapack_complex_double* afp,\n                    lapack_int* ipiv, const lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    double* rcond, double* ferr, double* berr,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_chpsv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* ap, lapack_int* ipiv,\n                   lapack_complex_float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zhpsv( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* ap, lapack_int* ipiv,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_int *info );\nvoid LAPACK_chpsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* ap, lapack_complex_float* afp,\n                    lapack_int* ipiv, const lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* x, lapack_int* ldx,\n                    float* rcond, float* ferr, float* berr,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zhpsvx( char* fact, char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* ap, lapack_complex_double* afp,\n                    lapack_int* ipiv, const lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* x, lapack_int* ldx,\n                    double* rcond, double* ferr, double* berr,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_sgeqrf( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    float* tau, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dgeqrf( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    double* tau, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cgeqrf( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* tau,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zgeqrf( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sgeqpf( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* jpvt, float* tau, float* work,\n                    lapack_int *info );\nvoid LAPACK_dgeqpf( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* jpvt, double* tau, double* work,\n                    lapack_int *info );\nvoid LAPACK_cgeqpf( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* jpvt,\n                    lapack_complex_float* tau, lapack_complex_float* work,\n                    float* rwork, lapack_int *info );\nvoid LAPACK_zgeqpf( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* jpvt,\n                    lapack_complex_double* tau, lapack_complex_double* work,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sgeqp3( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* jpvt, float* tau, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dgeqp3( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* jpvt, double* tau, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgeqp3( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* jpvt,\n                    lapack_complex_float* tau, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_int *info );\nvoid LAPACK_zgeqp3( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* jpvt,\n                    lapack_complex_double* tau, lapack_complex_double* work,\n                    lapack_int* lwork, double* rwork, lapack_int *info );\nvoid LAPACK_sorgqr( lapack_int* m, lapack_int* n, lapack_int* k, float* a,\n                    lapack_int* lda, const float* tau, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dorgqr( lapack_int* m, lapack_int* n, lapack_int* k, double* a,\n                    lapack_int* lda, const double* tau, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sormqr( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const float* a, lapack_int* lda,\n                    const float* tau, float* c, lapack_int* ldc, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dormqr( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const double* a, lapack_int* lda,\n                    const double* tau, double* c, lapack_int* ldc, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cungqr( lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* tau, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zungqr( lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cunmqr( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* tau,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zunmqr( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* tau,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sgelqf( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    float* tau, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dgelqf( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    double* tau, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cgelqf( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* tau,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zgelqf( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sorglq( lapack_int* m, lapack_int* n, lapack_int* k, float* a,\n                    lapack_int* lda, const float* tau, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dorglq( lapack_int* m, lapack_int* n, lapack_int* k, double* a,\n                    lapack_int* lda, const double* tau, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sormlq( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const float* a, lapack_int* lda,\n                    const float* tau, float* c, lapack_int* ldc, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dormlq( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const double* a, lapack_int* lda,\n                    const double* tau, double* c, lapack_int* ldc, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cunglq( lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* tau, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zunglq( lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cunmlq( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* tau,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zunmlq( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* tau,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sgeqlf( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    float* tau, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dgeqlf( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    double* tau, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cgeqlf( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* tau,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zgeqlf( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sorgql( lapack_int* m, lapack_int* n, lapack_int* k, float* a,\n                    lapack_int* lda, const float* tau, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dorgql( lapack_int* m, lapack_int* n, lapack_int* k, double* a,\n                    lapack_int* lda, const double* tau, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cungql( lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* tau, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zungql( lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sormql( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const float* a, lapack_int* lda,\n                    const float* tau, float* c, lapack_int* ldc, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dormql( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const double* a, lapack_int* lda,\n                    const double* tau, double* c, lapack_int* ldc, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cunmql( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* tau,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zunmql( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* tau,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sgerqf( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    float* tau, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dgerqf( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    double* tau, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cgerqf( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* tau,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zgerqf( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sorgrq( lapack_int* m, lapack_int* n, lapack_int* k, float* a,\n                    lapack_int* lda, const float* tau, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dorgrq( lapack_int* m, lapack_int* n, lapack_int* k, double* a,\n                    lapack_int* lda, const double* tau, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cungrq( lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* tau, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zungrq( lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sormrq( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const float* a, lapack_int* lda,\n                    const float* tau, float* c, lapack_int* ldc, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dormrq( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const double* a, lapack_int* lda,\n                    const double* tau, double* c, lapack_int* ldc, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cunmrq( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* tau,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zunmrq( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* tau,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_stzrzf( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    float* tau, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dtzrzf( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    double* tau, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_ctzrzf( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* tau,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_ztzrzf( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sormrz( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, lapack_int* l, const float* a,\n                    lapack_int* lda, const float* tau, float* c,\n                    lapack_int* ldc, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dormrz( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, lapack_int* l, const double* a,\n                    lapack_int* lda, const double* tau, double* c,\n                    lapack_int* ldc, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cunmrz( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, lapack_int* l, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* tau,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zunmrz( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* k, lapack_int* l,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* tau, lapack_complex_double* c,\n                    lapack_int* ldc, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sggqrf( lapack_int* n, lapack_int* m, lapack_int* p, float* a,\n                    lapack_int* lda, float* taua, float* b, lapack_int* ldb,\n                    float* taub, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dggqrf( lapack_int* n, lapack_int* m, lapack_int* p, double* a,\n                    lapack_int* lda, double* taua, double* b, lapack_int* ldb,\n                    double* taub, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cggqrf( lapack_int* n, lapack_int* m, lapack_int* p,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* taua, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* taub,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zggqrf( lapack_int* n, lapack_int* m, lapack_int* p,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* taua, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* taub,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sggrqf( lapack_int* m, lapack_int* p, lapack_int* n, float* a,\n                    lapack_int* lda, float* taua, float* b, lapack_int* ldb,\n                    float* taub, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dggrqf( lapack_int* m, lapack_int* p, lapack_int* n, double* a,\n                    lapack_int* lda, double* taua, double* b, lapack_int* ldb,\n                    double* taub, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cggrqf( lapack_int* m, lapack_int* p, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* taua, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* taub,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zggrqf( lapack_int* m, lapack_int* p, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* taua, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* taub,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sgebrd( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    float* d, float* e, float* tauq, float* taup, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dgebrd( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    double* d, double* e, double* tauq, double* taup,\n                    double* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgebrd( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, float* d, float* e,\n                    lapack_complex_float* tauq, lapack_complex_float* taup,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zgebrd( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, double* d, double* e,\n                    lapack_complex_double* tauq, lapack_complex_double* taup,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sgbbrd( char* vect, lapack_int* m, lapack_int* n, lapack_int* ncc,\n                    lapack_int* kl, lapack_int* ku, float* ab, lapack_int* ldab,\n                    float* d, float* e, float* q, lapack_int* ldq, float* pt,\n                    lapack_int* ldpt, float* c, lapack_int* ldc, float* work,\n                    lapack_int *info );\nvoid LAPACK_dgbbrd( char* vect, lapack_int* m, lapack_int* n, lapack_int* ncc,\n                    lapack_int* kl, lapack_int* ku, double* ab,\n                    lapack_int* ldab, double* d, double* e, double* q,\n                    lapack_int* ldq, double* pt, lapack_int* ldpt, double* c,\n                    lapack_int* ldc, double* work, lapack_int *info );\nvoid LAPACK_cgbbrd( char* vect, lapack_int* m, lapack_int* n, lapack_int* ncc,\n                    lapack_int* kl, lapack_int* ku, lapack_complex_float* ab,\n                    lapack_int* ldab, float* d, float* e,\n                    lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* pt, lapack_int* ldpt,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zgbbrd( char* vect, lapack_int* m, lapack_int* n, lapack_int* ncc,\n                    lapack_int* kl, lapack_int* ku, lapack_complex_double* ab,\n                    lapack_int* ldab, double* d, double* e,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* pt, lapack_int* ldpt,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_sorgbr( char* vect, lapack_int* m, lapack_int* n, lapack_int* k,\n                    float* a, lapack_int* lda, const float* tau, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dorgbr( char* vect, lapack_int* m, lapack_int* n, lapack_int* k,\n                    double* a, lapack_int* lda, const double* tau, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sormbr( char* vect, char* side, char* trans, lapack_int* m,\n                    lapack_int* n, lapack_int* k, const float* a,\n                    lapack_int* lda, const float* tau, float* c,\n                    lapack_int* ldc, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dormbr( char* vect, char* side, char* trans, lapack_int* m,\n                    lapack_int* n, lapack_int* k, const double* a,\n                    lapack_int* lda, const double* tau, double* c,\n                    lapack_int* ldc, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cungbr( char* vect, lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* tau, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zungbr( char* vect, lapack_int* m, lapack_int* n, lapack_int* k,\n                    lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cunmbr( char* vect, char* side, char* trans, lapack_int* m,\n                    lapack_int* n, lapack_int* k, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* tau,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zunmbr( char* vect, char* side, char* trans, lapack_int* m,\n                    lapack_int* n, lapack_int* k,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* tau, lapack_complex_double* c,\n                    lapack_int* ldc, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sbdsqr( char* uplo, lapack_int* n, lapack_int* ncvt,\n                    lapack_int* nru, lapack_int* ncc, float* d, float* e,\n                    float* vt, lapack_int* ldvt, float* u, lapack_int* ldu,\n                    float* c, lapack_int* ldc, float* work, lapack_int *info );\nvoid LAPACK_dbdsqr( char* uplo, lapack_int* n, lapack_int* ncvt,\n                    lapack_int* nru, lapack_int* ncc, double* d, double* e,\n                    double* vt, lapack_int* ldvt, double* u, lapack_int* ldu,\n                    double* c, lapack_int* ldc, double* work,\n                    lapack_int *info );\nvoid LAPACK_cbdsqr( char* uplo, lapack_int* n, lapack_int* ncvt,\n                    lapack_int* nru, lapack_int* ncc, float* d, float* e,\n                    lapack_complex_float* vt, lapack_int* ldvt,\n                    lapack_complex_float* u, lapack_int* ldu,\n                    lapack_complex_float* c, lapack_int* ldc, float* work,\n                    lapack_int *info );\nvoid LAPACK_zbdsqr( char* uplo, lapack_int* n, lapack_int* ncvt,\n                    lapack_int* nru, lapack_int* ncc, double* d, double* e,\n                    lapack_complex_double* vt, lapack_int* ldvt,\n                    lapack_complex_double* u, lapack_int* ldu,\n                    lapack_complex_double* c, lapack_int* ldc, double* work,\n                    lapack_int *info );\nvoid LAPACK_sbdsdc( char* uplo, char* compq, lapack_int* n, float* d, float* e,\n                    float* u, lapack_int* ldu, float* vt, lapack_int* ldvt,\n                    float* q, lapack_int* iq, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dbdsdc( char* uplo, char* compq, lapack_int* n, double* d,\n                    double* e, double* u, lapack_int* ldu, double* vt,\n                    lapack_int* ldvt, double* q, lapack_int* iq, double* work,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_sbdsvdx( char* uplo, char* jobz, char* range,\n                     lapack_int* n, float* d, float* e,\n                     float* vl, float* vu,\n                     lapack_int* il, lapack_int* iu, lapack_int* ns,\n                     float* s, float* z, lapack_int* ldz,\n                     float* work, lapack_int *iwork, lapack_int *info );\nvoid LAPACK_dbdsvdx( char* uplo, char* jobz, char* range,\n                     lapack_int* n, double* d, double* e,\n                     double* vl, double* vu,\n                     lapack_int* il, lapack_int* iu, lapack_int* ns,\n                     double* s, double* z, lapack_int* ldz,\n                     double* work, lapack_int *iwork, lapack_int *info );\nvoid LAPACK_ssytrd( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    float* d, float* e, float* tau, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dsytrd( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    double* d, double* e, double* tau, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sorgtr( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    const float* tau, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dorgtr( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    const double* tau, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sormtr( char* side, char* uplo, char* trans, lapack_int* m,\n                    lapack_int* n, const float* a, lapack_int* lda,\n                    const float* tau, float* c, lapack_int* ldc, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dormtr( char* side, char* uplo, char* trans, lapack_int* m,\n                    lapack_int* n, const double* a, lapack_int* lda,\n                    const double* tau, double* c, lapack_int* ldc, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_chetrd( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, float* d, float* e,\n                    lapack_complex_float* tau, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zhetrd( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, double* d, double* e,\n                    lapack_complex_double* tau, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cungtr( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* tau,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zungtr( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cunmtr( char* side, char* uplo, char* trans, lapack_int* m,\n                    lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* tau,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zunmtr( char* side, char* uplo, char* trans, lapack_int* m,\n                    lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* tau,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_ssptrd( char* uplo, lapack_int* n, float* ap, float* d, float* e,\n                    float* tau, lapack_int *info );\nvoid LAPACK_dsptrd( char* uplo, lapack_int* n, double* ap, double* d, double* e,\n                    double* tau, lapack_int *info );\nvoid LAPACK_sopgtr( char* uplo, lapack_int* n, const float* ap,\n                    const float* tau, float* q, lapack_int* ldq, float* work,\n                    lapack_int *info );\nvoid LAPACK_dopgtr( char* uplo, lapack_int* n, const double* ap,\n                    const double* tau, double* q, lapack_int* ldq, double* work,\n                    lapack_int *info );\nvoid LAPACK_sopmtr( char* side, char* uplo, char* trans, lapack_int* m,\n                    lapack_int* n, const float* ap, const float* tau, float* c,\n                    lapack_int* ldc, float* work, lapack_int *info );\nvoid LAPACK_dopmtr( char* side, char* uplo, char* trans, lapack_int* m,\n                    lapack_int* n, const double* ap, const double* tau,\n                    double* c, lapack_int* ldc, double* work,\n                    lapack_int *info );\nvoid LAPACK_chptrd( char* uplo, lapack_int* n, lapack_complex_float* ap,\n                    float* d, float* e, lapack_complex_float* tau,\n                    lapack_int *info );\nvoid LAPACK_zhptrd( char* uplo, lapack_int* n, lapack_complex_double* ap,\n                    double* d, double* e, lapack_complex_double* tau,\n                    lapack_int *info );\nvoid LAPACK_cupgtr( char* uplo, lapack_int* n, const lapack_complex_float* ap,\n                    const lapack_complex_float* tau, lapack_complex_float* q,\n                    lapack_int* ldq, lapack_complex_float* work,\n                    lapack_int *info );\nvoid LAPACK_zupgtr( char* uplo, lapack_int* n, const lapack_complex_double* ap,\n                    const lapack_complex_double* tau, lapack_complex_double* q,\n                    lapack_int* ldq, lapack_complex_double* work,\n                    lapack_int *info );\nvoid LAPACK_cupmtr( char* side, char* uplo, char* trans, lapack_int* m,\n                    lapack_int* n, const lapack_complex_float* ap,\n                    const lapack_complex_float* tau, lapack_complex_float* c,\n                    lapack_int* ldc, lapack_complex_float* work,\n                    lapack_int *info );\nvoid LAPACK_zupmtr( char* side, char* uplo, char* trans, lapack_int* m,\n                    lapack_int* n, const lapack_complex_double* ap,\n                    const lapack_complex_double* tau, lapack_complex_double* c,\n                    lapack_int* ldc, lapack_complex_double* work,\n                    lapack_int *info );\nvoid LAPACK_ssbtrd( char* vect, char* uplo, lapack_int* n, lapack_int* kd,\n                    float* ab, lapack_int* ldab, float* d, float* e, float* q,\n                    lapack_int* ldq, float* work, lapack_int *info );\nvoid LAPACK_dsbtrd( char* vect, char* uplo, lapack_int* n, lapack_int* kd,\n                    double* ab, lapack_int* ldab, double* d, double* e,\n                    double* q, lapack_int* ldq, double* work,\n                    lapack_int *info );\nvoid LAPACK_chbtrd( char* vect, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_complex_float* ab, lapack_int* ldab, float* d,\n                    float* e, lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zhbtrd( char* vect, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_complex_double* ab, lapack_int* ldab, double* d,\n                    double* e, lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_ssterf( lapack_int* n, float* d, float* e, lapack_int *info );\nvoid LAPACK_dsterf( lapack_int* n, double* d, double* e, lapack_int *info );\nvoid LAPACK_ssteqr( char* compz, lapack_int* n, float* d, float* e, float* z,\n                    lapack_int* ldz, float* work, lapack_int *info );\nvoid LAPACK_dsteqr( char* compz, lapack_int* n, double* d, double* e, double* z,\n                    lapack_int* ldz, double* work, lapack_int *info );\nvoid LAPACK_csteqr( char* compz, lapack_int* n, float* d, float* e,\n                    lapack_complex_float* z, lapack_int* ldz, float* work,\n                    lapack_int *info );\nvoid LAPACK_zsteqr( char* compz, lapack_int* n, double* d, double* e,\n                    lapack_complex_double* z, lapack_int* ldz, double* work,\n                    lapack_int *info );\nvoid LAPACK_sstemr( char* jobz, char* range, lapack_int* n, float* d, float* e,\n                    float* vl, float* vu, lapack_int* il, lapack_int* iu,\n                    lapack_int* m, float* w, float* z, lapack_int* ldz,\n                    lapack_int* nzc, lapack_int* isuppz, lapack_logical* tryrac,\n                    float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dstemr( char* jobz, char* range, lapack_int* n, double* d,\n                    double* e, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, lapack_int* m, double* w, double* z,\n                    lapack_int* ldz, lapack_int* nzc, lapack_int* isuppz,\n                    lapack_logical* tryrac, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_cstemr( char* jobz, char* range, lapack_int* n, float* d, float* e,\n                    float* vl, float* vu, lapack_int* il, lapack_int* iu,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_int* nzc, lapack_int* isuppz,\n                    lapack_logical* tryrac, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_zstemr( char* jobz, char* range, lapack_int* n, double* d,\n                    double* e, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, lapack_int* m, double* w,\n                    lapack_complex_double* z, lapack_int* ldz, lapack_int* nzc,\n                    lapack_int* isuppz, lapack_logical* tryrac, double* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_sstedc( char* compz, lapack_int* n, float* d, float* e, float* z,\n                    lapack_int* ldz, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dstedc( char* compz, lapack_int* n, double* d, double* e, double* z,\n                    lapack_int* ldz, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_cstedc( char* compz, lapack_int* n, float* d, float* e,\n                    lapack_complex_float* z, lapack_int* ldz,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zstedc( char* compz, lapack_int* n, double* d, double* e,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_sstegr( char* jobz, char* range, lapack_int* n, float* d, float* e,\n                    float* vl, float* vu, lapack_int* il, lapack_int* iu,\n                    float* abstol, lapack_int* m, float* w, float* z,\n                    lapack_int* ldz, lapack_int* isuppz, float* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_dstegr( char* jobz, char* range, lapack_int* n, double* d,\n                    double* e, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, double* abstol, lapack_int* m, double* w,\n                    double* z, lapack_int* ldz, lapack_int* isuppz,\n                    double* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_cstegr( char* jobz, char* range, lapack_int* n, float* d, float* e,\n                    float* vl, float* vu, lapack_int* il, lapack_int* iu,\n                    float* abstol, lapack_int* m, float* w,\n                    lapack_complex_float* z, lapack_int* ldz,\n                    lapack_int* isuppz, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_zstegr( char* jobz, char* range, lapack_int* n, double* d,\n                    double* e, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, double* abstol, lapack_int* m, double* w,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_int* isuppz, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_spteqr( char* compz, lapack_int* n, float* d, float* e, float* z,\n                    lapack_int* ldz, float* work, lapack_int *info );\nvoid LAPACK_dpteqr( char* compz, lapack_int* n, double* d, double* e, double* z,\n                    lapack_int* ldz, double* work, lapack_int *info );\nvoid LAPACK_cpteqr( char* compz, lapack_int* n, float* d, float* e,\n                    lapack_complex_float* z, lapack_int* ldz, float* work,\n                    lapack_int *info );\nvoid LAPACK_zpteqr( char* compz, lapack_int* n, double* d, double* e,\n                    lapack_complex_double* z, lapack_int* ldz, double* work,\n                    lapack_int *info );\nvoid LAPACK_sstebz( char* range, char* order, lapack_int* n, float* vl,\n                    float* vu, lapack_int* il, lapack_int* iu, float* abstol,\n                    const float* d, const float* e, lapack_int* m,\n                    lapack_int* nsplit, float* w, lapack_int* iblock,\n                    lapack_int* isplit, float* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dstebz( char* range, char* order, lapack_int* n, double* vl,\n                    double* vu, lapack_int* il, lapack_int* iu, double* abstol,\n                    const double* d, const double* e, lapack_int* m,\n                    lapack_int* nsplit, double* w, lapack_int* iblock,\n                    lapack_int* isplit, double* work, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_sstein( lapack_int* n, const float* d, const float* e,\n                    lapack_int* m, const float* w, const lapack_int* iblock,\n                    const lapack_int* isplit, float* z, lapack_int* ldz,\n                    float* work, lapack_int* iwork, lapack_int* ifailv,\n                    lapack_int *info );\nvoid LAPACK_dstein( lapack_int* n, const double* d, const double* e,\n                    lapack_int* m, const double* w, const lapack_int* iblock,\n                    const lapack_int* isplit, double* z, lapack_int* ldz,\n                    double* work, lapack_int* iwork, lapack_int* ifailv,\n                    lapack_int *info );\nvoid LAPACK_cstein( lapack_int* n, const float* d, const float* e,\n                    lapack_int* m, const float* w, const lapack_int* iblock,\n                    const lapack_int* isplit, lapack_complex_float* z,\n                    lapack_int* ldz, float* work, lapack_int* iwork,\n                    lapack_int* ifailv, lapack_int *info );\nvoid LAPACK_zstein( lapack_int* n, const double* d, const double* e,\n                    lapack_int* m, const double* w, const lapack_int* iblock,\n                    const lapack_int* isplit, lapack_complex_double* z,\n                    lapack_int* ldz, double* work, lapack_int* iwork,\n                    lapack_int* ifailv, lapack_int *info );\nvoid LAPACK_sdisna( char* job, lapack_int* m, lapack_int* n, const float* d,\n                    float* sep, lapack_int *info );\nvoid LAPACK_ddisna( char* job, lapack_int* m, lapack_int* n, const double* d,\n                    double* sep, lapack_int *info );\nvoid LAPACK_ssygst( lapack_int* itype, char* uplo, lapack_int* n, float* a,\n                    lapack_int* lda, const float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_dsygst( lapack_int* itype, char* uplo, lapack_int* n, double* a,\n                    lapack_int* lda, const double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_chegst( lapack_int* itype, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_zhegst( lapack_int* itype, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int *info );\nvoid LAPACK_sspgst( lapack_int* itype, char* uplo, lapack_int* n, float* ap,\n                    const float* bp, lapack_int *info );\nvoid LAPACK_dspgst( lapack_int* itype, char* uplo, lapack_int* n, double* ap,\n                    const double* bp, lapack_int *info );\nvoid LAPACK_chpgst( lapack_int* itype, char* uplo, lapack_int* n,\n                    lapack_complex_float* ap, const lapack_complex_float* bp,\n                    lapack_int *info );\nvoid LAPACK_zhpgst( lapack_int* itype, char* uplo, lapack_int* n,\n                    lapack_complex_double* ap, const lapack_complex_double* bp,\n                    lapack_int *info );\nvoid LAPACK_ssbgst( char* vect, char* uplo, lapack_int* n, lapack_int* ka,\n                    lapack_int* kb, float* ab, lapack_int* ldab,\n                    const float* bb, lapack_int* ldbb, float* x,\n                    lapack_int* ldx, float* work, lapack_int *info );\nvoid LAPACK_dsbgst( char* vect, char* uplo, lapack_int* n, lapack_int* ka,\n                    lapack_int* kb, double* ab, lapack_int* ldab,\n                    const double* bb, lapack_int* ldbb, double* x,\n                    lapack_int* ldx, double* work, lapack_int *info );\nvoid LAPACK_chbgst( char* vect, char* uplo, lapack_int* n, lapack_int* ka,\n                    lapack_int* kb, lapack_complex_float* ab, lapack_int* ldab,\n                    const lapack_complex_float* bb, lapack_int* ldbb,\n                    lapack_complex_float* x, lapack_int* ldx,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zhbgst( char* vect, char* uplo, lapack_int* n, lapack_int* ka,\n                    lapack_int* kb, lapack_complex_double* ab, lapack_int* ldab,\n                    const lapack_complex_double* bb, lapack_int* ldbb,\n                    lapack_complex_double* x, lapack_int* ldx,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_spbstf( char* uplo, lapack_int* n, lapack_int* kb, float* bb,\n                    lapack_int* ldbb, lapack_int *info );\nvoid LAPACK_dpbstf( char* uplo, lapack_int* n, lapack_int* kb, double* bb,\n                    lapack_int* ldbb, lapack_int *info );\nvoid LAPACK_cpbstf( char* uplo, lapack_int* n, lapack_int* kb,\n                    lapack_complex_float* bb, lapack_int* ldbb,\n                    lapack_int *info );\nvoid LAPACK_zpbstf( char* uplo, lapack_int* n, lapack_int* kb,\n                    lapack_complex_double* bb, lapack_int* ldbb,\n                    lapack_int *info );\nvoid LAPACK_sgehrd( lapack_int* n, lapack_int* ilo, lapack_int* ihi, float* a,\n                    lapack_int* lda, float* tau, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dgehrd( lapack_int* n, lapack_int* ilo, lapack_int* ihi, double* a,\n                    lapack_int* lda, double* tau, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgehrd( lapack_int* n, lapack_int* ilo, lapack_int* ihi,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* tau, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zgehrd( lapack_int* n, lapack_int* ilo, lapack_int* ihi,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* tau, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sorghr( lapack_int* n, lapack_int* ilo, lapack_int* ihi, float* a,\n                    lapack_int* lda, const float* tau, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dorghr( lapack_int* n, lapack_int* ilo, lapack_int* ihi, double* a,\n                    lapack_int* lda, const double* tau, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sormhr( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi, const float* a,\n                    lapack_int* lda, const float* tau, float* c,\n                    lapack_int* ldc, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dormhr( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi, const double* a,\n                    lapack_int* lda, const double* tau, double* c,\n                    lapack_int* ldc, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cunghr( lapack_int* n, lapack_int* ilo, lapack_int* ihi,\n                    lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* tau, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zunghr( lapack_int* n, lapack_int* ilo, lapack_int* ihi,\n                    lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cunmhr( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* tau, lapack_complex_float* c,\n                    lapack_int* ldc, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zunmhr( char* side, char* trans, lapack_int* m, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* tau, lapack_complex_double* c,\n                    lapack_int* ldc, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sgebal( char* job, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* ilo, lapack_int* ihi, float* scale,\n                    lapack_int *info );\nvoid LAPACK_dgebal( char* job, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* ilo, lapack_int* ihi, double* scale,\n                    lapack_int *info );\nvoid LAPACK_cgebal( char* job, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ilo, lapack_int* ihi,\n                    float* scale, lapack_int *info );\nvoid LAPACK_zgebal( char* job, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ilo, lapack_int* ihi,\n                    double* scale, lapack_int *info );\nvoid LAPACK_sgebak( char* job, char* side, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, const float* scale, lapack_int* m,\n                    float* v, lapack_int* ldv, lapack_int *info );\nvoid LAPACK_dgebak( char* job, char* side, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, const double* scale, lapack_int* m,\n                    double* v, lapack_int* ldv, lapack_int *info );\nvoid LAPACK_cgebak( char* job, char* side, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, const float* scale, lapack_int* m,\n                    lapack_complex_float* v, lapack_int* ldv,\n                    lapack_int *info );\nvoid LAPACK_zgebak( char* job, char* side, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, const double* scale, lapack_int* m,\n                    lapack_complex_double* v, lapack_int* ldv,\n                    lapack_int *info );\nvoid LAPACK_shseqr( char* job, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, float* h, lapack_int* ldh, float* wr,\n                    float* wi, float* z, lapack_int* ldz, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dhseqr( char* job, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, double* h, lapack_int* ldh, double* wr,\n                    double* wi, double* z, lapack_int* ldz, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_chseqr( char* job, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, lapack_complex_float* h, lapack_int* ldh,\n                    lapack_complex_float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zhseqr( char* job, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, lapack_complex_double* h, lapack_int* ldh,\n                    lapack_complex_double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_shsein( char* job, char* eigsrc, char* initv,\n                    lapack_logical* select, lapack_int* n, const float* h,\n                    lapack_int* ldh, float* wr, const float* wi, float* vl,\n                    lapack_int* ldvl, float* vr, lapack_int* ldvr,\n                    lapack_int* mm, lapack_int* m, float* work,\n                    lapack_int* ifaill, lapack_int* ifailr, lapack_int *info );\nvoid LAPACK_dhsein( char* job, char* eigsrc, char* initv,\n                    lapack_logical* select, lapack_int* n, const double* h,\n                    lapack_int* ldh, double* wr, const double* wi, double* vl,\n                    lapack_int* ldvl, double* vr, lapack_int* ldvr,\n                    lapack_int* mm, lapack_int* m, double* work,\n                    lapack_int* ifaill, lapack_int* ifailr, lapack_int *info );\nvoid LAPACK_chsein( char* job, char* eigsrc, char* initv,\n                    const lapack_logical* select, lapack_int* n,\n                    const lapack_complex_float* h, lapack_int* ldh,\n                    lapack_complex_float* w, lapack_complex_float* vl,\n                    lapack_int* ldvl, lapack_complex_float* vr,\n                    lapack_int* ldvr, lapack_int* mm, lapack_int* m,\n                    lapack_complex_float* work, float* rwork,\n                    lapack_int* ifaill, lapack_int* ifailr, lapack_int *info );\nvoid LAPACK_zhsein( char* job, char* eigsrc, char* initv,\n                    const lapack_logical* select, lapack_int* n,\n                    const lapack_complex_double* h, lapack_int* ldh,\n                    lapack_complex_double* w, lapack_complex_double* vl,\n                    lapack_int* ldvl, lapack_complex_double* vr,\n                    lapack_int* ldvr, lapack_int* mm, lapack_int* m,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int* ifaill, lapack_int* ifailr, lapack_int *info );\nvoid LAPACK_strevc( char* side, char* howmny, lapack_logical* select,\n                    lapack_int* n, const float* t, lapack_int* ldt, float* vl,\n                    lapack_int* ldvl, float* vr, lapack_int* ldvr,\n                    lapack_int* mm, lapack_int* m, float* work,\n                    lapack_int *info );\nvoid LAPACK_dtrevc( char* side, char* howmny, lapack_logical* select,\n                    lapack_int* n, const double* t, lapack_int* ldt, double* vl,\n                    lapack_int* ldvl, double* vr, lapack_int* ldvr,\n                    lapack_int* mm, lapack_int* m, double* work,\n                    lapack_int *info );\nvoid LAPACK_ctrevc( char* side, char* howmny, const lapack_logical* select,\n                    lapack_int* n, lapack_complex_float* t, lapack_int* ldt,\n                    lapack_complex_float* vl, lapack_int* ldvl,\n                    lapack_complex_float* vr, lapack_int* ldvr, lapack_int* mm,\n                    lapack_int* m, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_ztrevc( char* side, char* howmny, const lapack_logical* select,\n                    lapack_int* n, lapack_complex_double* t, lapack_int* ldt,\n                    lapack_complex_double* vl, lapack_int* ldvl,\n                    lapack_complex_double* vr, lapack_int* ldvr, lapack_int* mm,\n                    lapack_int* m, lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_strsna( char* job, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const float* t, lapack_int* ldt,\n                    const float* vl, lapack_int* ldvl, const float* vr,\n                    lapack_int* ldvr, float* s, float* sep, lapack_int* mm,\n                    lapack_int* m, float* work, lapack_int* ldwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dtrsna( char* job, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const double* t, lapack_int* ldt,\n                    const double* vl, lapack_int* ldvl, const double* vr,\n                    lapack_int* ldvr, double* s, double* sep, lapack_int* mm,\n                    lapack_int* m, double* work, lapack_int* ldwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_ctrsna( char* job, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const lapack_complex_float* t,\n                    lapack_int* ldt, const lapack_complex_float* vl,\n                    lapack_int* ldvl, const lapack_complex_float* vr,\n                    lapack_int* ldvr, float* s, float* sep, lapack_int* mm,\n                    lapack_int* m, lapack_complex_float* work,\n                    lapack_int* ldwork, float* rwork, lapack_int *info );\nvoid LAPACK_ztrsna( char* job, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const lapack_complex_double* t,\n                    lapack_int* ldt, const lapack_complex_double* vl,\n                    lapack_int* ldvl, const lapack_complex_double* vr,\n                    lapack_int* ldvr, double* s, double* sep, lapack_int* mm,\n                    lapack_int* m, lapack_complex_double* work,\n                    lapack_int* ldwork, double* rwork, lapack_int *info );\nvoid LAPACK_strexc( char* compq, lapack_int* n, float* t, lapack_int* ldt,\n                    float* q, lapack_int* ldq, lapack_int* ifst,\n                    lapack_int* ilst, float* work, lapack_int *info );\nvoid LAPACK_dtrexc( char* compq, lapack_int* n, double* t, lapack_int* ldt,\n                    double* q, lapack_int* ldq, lapack_int* ifst,\n                    lapack_int* ilst, double* work, lapack_int *info );\nvoid LAPACK_ctrexc( char* compq, lapack_int* n, lapack_complex_float* t,\n                    lapack_int* ldt, lapack_complex_float* q, lapack_int* ldq,\n                    lapack_int* ifst, lapack_int* ilst, lapack_int *info );\nvoid LAPACK_ztrexc( char* compq, lapack_int* n, lapack_complex_double* t,\n                    lapack_int* ldt, lapack_complex_double* q, lapack_int* ldq,\n                    lapack_int* ifst, lapack_int* ilst, lapack_int *info );\nvoid LAPACK_strsen( char* job, char* compq, const lapack_logical* select,\n                    lapack_int* n, float* t, lapack_int* ldt, float* q,\n                    lapack_int* ldq, float* wr, float* wi, lapack_int* m,\n                    float* s, float* sep, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dtrsen( char* job, char* compq, const lapack_logical* select,\n                    lapack_int* n, double* t, lapack_int* ldt, double* q,\n                    lapack_int* ldq, double* wr, double* wi, lapack_int* m,\n                    double* s, double* sep, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ctrsen( char* job, char* compq, const lapack_logical* select,\n                    lapack_int* n, lapack_complex_float* t, lapack_int* ldt,\n                    lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* w, lapack_int* m, float* s,\n                    float* sep, lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_ztrsen( char* job, char* compq, const lapack_logical* select,\n                    lapack_int* n, lapack_complex_double* t, lapack_int* ldt,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* w, lapack_int* m, double* s,\n                    double* sep, lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_strsyl( char* trana, char* tranb, lapack_int* isgn, lapack_int* m,\n                    lapack_int* n, const float* a, lapack_int* lda,\n                    const float* b, lapack_int* ldb, float* c, lapack_int* ldc,\n                    float* scale, lapack_int *info );\nvoid LAPACK_dtrsyl( char* trana, char* tranb, lapack_int* isgn, lapack_int* m,\n                    lapack_int* n, const double* a, lapack_int* lda,\n                    const double* b, lapack_int* ldb, double* c,\n                    lapack_int* ldc, double* scale, lapack_int *info );\nvoid LAPACK_ctrsyl( char* trana, char* tranb, lapack_int* isgn, lapack_int* m,\n                    lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* b,\n                    lapack_int* ldb, lapack_complex_float* c, lapack_int* ldc,\n                    float* scale, lapack_int *info );\nvoid LAPACK_ztrsyl( char* trana, char* tranb, lapack_int* isgn, lapack_int* m,\n                    lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* b,\n                    lapack_int* ldb, lapack_complex_double* c, lapack_int* ldc,\n                    double* scale, lapack_int *info );\nvoid LAPACK_sgghrd( char* compq, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, float* a, lapack_int* lda, float* b,\n                    lapack_int* ldb, float* q, lapack_int* ldq, float* z,\n                    lapack_int* ldz, lapack_int *info );\nvoid LAPACK_dgghrd( char* compq, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, double* a, lapack_int* lda, double* b,\n                    lapack_int* ldb, double* q, lapack_int* ldq, double* z,\n                    lapack_int* ldz, lapack_int *info );\nvoid LAPACK_cgghrd( char* compq, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* z, lapack_int* ldz,\n                    lapack_int *info );\nvoid LAPACK_zgghrd( char* compq, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_int *info );\nvoid LAPACK_sgghd3( char* compq, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, float* a, lapack_int* lda, float* b,\n                    lapack_int* ldb, float* q, lapack_int* ldq, float* z,\n                    lapack_int* ldz, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dgghd3( char* compq, char* compz, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, double* a, lapack_int* lda, double* b,\n                    lapack_int* ldb, double* q, lapack_int* ldq, double* z,\n                    lapack_int* ldz, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cgghd3( char* compq, char* compz, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* z, lapack_int* ldz,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zgghd3( char* compq, char* compz, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_sggbal( char* job, lapack_int* n, float* a, lapack_int* lda,\n                    float* b, lapack_int* ldb, lapack_int* ilo, lapack_int* ihi,\n                    float* lscale, float* rscale, float* work,\n                    lapack_int *info );\nvoid LAPACK_dggbal( char* job, lapack_int* n, double* a, lapack_int* lda,\n                    double* b, lapack_int* ldb, lapack_int* ilo,\n                    lapack_int* ihi, double* lscale, double* rscale,\n                    double* work, lapack_int *info );\nvoid LAPACK_cggbal( char* job, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int* ilo, lapack_int* ihi, float* lscale,\n                    float* rscale, float* work, lapack_int *info );\nvoid LAPACK_zggbal( char* job, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* b, lapack_int* ldb,\n                    lapack_int* ilo, lapack_int* ihi, double* lscale,\n                    double* rscale, double* work, lapack_int *info );\nvoid LAPACK_sggbak( char* job, char* side, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, const float* lscale, const float* rscale,\n                    lapack_int* m, float* v, lapack_int* ldv,\n                    lapack_int *info );\nvoid LAPACK_dggbak( char* job, char* side, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, const double* lscale, const double* rscale,\n                    lapack_int* m, double* v, lapack_int* ldv,\n                    lapack_int *info );\nvoid LAPACK_cggbak( char* job, char* side, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, const float* lscale, const float* rscale,\n                    lapack_int* m, lapack_complex_float* v, lapack_int* ldv,\n                    lapack_int *info );\nvoid LAPACK_zggbak( char* job, char* side, lapack_int* n, lapack_int* ilo,\n                    lapack_int* ihi, const double* lscale, const double* rscale,\n                    lapack_int* m, lapack_complex_double* v, lapack_int* ldv,\n                    lapack_int *info );\nvoid LAPACK_shgeqz( char* job, char* compq, char* compz, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi, float* h, lapack_int* ldh,\n                    float* t, lapack_int* ldt, float* alphar, float* alphai,\n                    float* beta, float* q, lapack_int* ldq, float* z,\n                    lapack_int* ldz, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dhgeqz( char* job, char* compq, char* compz, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi, double* h,\n                    lapack_int* ldh, double* t, lapack_int* ldt, double* alphar,\n                    double* alphai, double* beta, double* q, lapack_int* ldq,\n                    double* z, lapack_int* ldz, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_chgeqz( char* job, char* compq, char* compz, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi, lapack_complex_float* h,\n                    lapack_int* ldh, lapack_complex_float* t, lapack_int* ldt,\n                    lapack_complex_float* alpha, lapack_complex_float* beta,\n                    lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* z, lapack_int* ldz,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zhgeqz( char* job, char* compq, char* compz, lapack_int* n,\n                    lapack_int* ilo, lapack_int* ihi, lapack_complex_double* h,\n                    lapack_int* ldh, lapack_complex_double* t, lapack_int* ldt,\n                    lapack_complex_double* alpha, lapack_complex_double* beta,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_stgevc( char* side, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const float* s, lapack_int* lds,\n                    const float* p, lapack_int* ldp, float* vl,\n                    lapack_int* ldvl, float* vr, lapack_int* ldvr,\n                    lapack_int* mm, lapack_int* m, float* work,\n                    lapack_int *info );\nvoid LAPACK_dtgevc( char* side, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const double* s, lapack_int* lds,\n                    const double* p, lapack_int* ldp, double* vl,\n                    lapack_int* ldvl, double* vr, lapack_int* ldvr,\n                    lapack_int* mm, lapack_int* m, double* work,\n                    lapack_int *info );\nvoid LAPACK_ctgevc( char* side, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const lapack_complex_float* s,\n                    lapack_int* lds, const lapack_complex_float* p,\n                    lapack_int* ldp, lapack_complex_float* vl, lapack_int* ldvl,\n                    lapack_complex_float* vr, lapack_int* ldvr, lapack_int* mm,\n                    lapack_int* m, lapack_complex_float* work, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_ztgevc( char* side, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const lapack_complex_double* s,\n                    lapack_int* lds, const lapack_complex_double* p,\n                    lapack_int* ldp, lapack_complex_double* vl,\n                    lapack_int* ldvl, lapack_complex_double* vr,\n                    lapack_int* ldvr, lapack_int* mm, lapack_int* m,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int *info );\nvoid LAPACK_stgexc( lapack_logical* wantq, lapack_logical* wantz, lapack_int* n,\n                    float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                    float* q, lapack_int* ldq, float* z, lapack_int* ldz,\n                    lapack_int* ifst, lapack_int* ilst, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dtgexc( lapack_logical* wantq, lapack_logical* wantz, lapack_int* n,\n                    double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                    double* q, lapack_int* ldq, double* z, lapack_int* ldz,\n                    lapack_int* ifst, lapack_int* ilst, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_ctgexc( lapack_logical* wantq, lapack_logical* wantz, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* z, lapack_int* ldz, lapack_int* ifst,\n                    lapack_int* ilst, lapack_int *info );\nvoid LAPACK_ztgexc( lapack_logical* wantq, lapack_logical* wantz, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* z, lapack_int* ldz, lapack_int* ifst,\n                    lapack_int* ilst, lapack_int *info );\nvoid LAPACK_stgsen( lapack_int* ijob, lapack_logical* wantq,\n                    lapack_logical* wantz, const lapack_logical* select,\n                    lapack_int* n, float* a, lapack_int* lda, float* b,\n                    lapack_int* ldb, float* alphar, float* alphai, float* beta,\n                    float* q, lapack_int* ldq, float* z, lapack_int* ldz,\n                    lapack_int* m, float* pl, float* pr, float* dif,\n                    float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dtgsen( lapack_int* ijob, lapack_logical* wantq,\n                    lapack_logical* wantz, const lapack_logical* select,\n                    lapack_int* n, double* a, lapack_int* lda, double* b,\n                    lapack_int* ldb, double* alphar, double* alphai,\n                    double* beta, double* q, lapack_int* ldq, double* z,\n                    lapack_int* ldz, lapack_int* m, double* pl, double* pr,\n                    double* dif, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ctgsen( lapack_int* ijob, lapack_logical* wantq,\n                    lapack_logical* wantz, const lapack_logical* select,\n                    lapack_int* n, lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* alpha, lapack_complex_float* beta,\n                    lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* z, lapack_int* ldz, lapack_int* m,\n                    float* pl, float* pr, float* dif,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ztgsen( lapack_int* ijob, lapack_logical* wantq,\n                    lapack_logical* wantz, const lapack_logical* select,\n                    lapack_int* n, lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* alpha, lapack_complex_double* beta,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* z, lapack_int* ldz, lapack_int* m,\n                    double* pl, double* pr, double* dif,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_stgsyl( char* trans, lapack_int* ijob, lapack_int* m, lapack_int* n,\n                    const float* a, lapack_int* lda, const float* b,\n                    lapack_int* ldb, float* c, lapack_int* ldc, const float* d,\n                    lapack_int* ldd, const float* e, lapack_int* lde, float* f,\n                    lapack_int* ldf, float* scale, float* dif, float* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dtgsyl( char* trans, lapack_int* ijob, lapack_int* m, lapack_int* n,\n                    const double* a, lapack_int* lda, const double* b,\n                    lapack_int* ldb, double* c, lapack_int* ldc,\n                    const double* d, lapack_int* ldd, const double* e,\n                    lapack_int* lde, double* f, lapack_int* ldf, double* scale,\n                    double* dif, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_ctgsyl( char* trans, lapack_int* ijob, lapack_int* m, lapack_int* n,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    const lapack_complex_float* d, lapack_int* ldd,\n                    const lapack_complex_float* e, lapack_int* lde,\n                    lapack_complex_float* f, lapack_int* ldf, float* scale,\n                    float* dif, lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_ztgsyl( char* trans, lapack_int* ijob, lapack_int* m, lapack_int* n,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    const lapack_complex_double* d, lapack_int* ldd,\n                    const lapack_complex_double* e, lapack_int* lde,\n                    lapack_complex_double* f, lapack_int* ldf, double* scale,\n                    double* dif, lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_stgsna( char* job, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const float* a, lapack_int* lda,\n                    const float* b, lapack_int* ldb, const float* vl,\n                    lapack_int* ldvl, const float* vr, lapack_int* ldvr,\n                    float* s, float* dif, lapack_int* mm, lapack_int* m,\n                    float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dtgsna( char* job, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const double* a, lapack_int* lda,\n                    const double* b, lapack_int* ldb, const double* vl,\n                    lapack_int* ldvl, const double* vr, lapack_int* ldvr,\n                    double* s, double* dif, lapack_int* mm, lapack_int* m,\n                    double* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_ctgsna( char* job, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* b,\n                    lapack_int* ldb, const lapack_complex_float* vl,\n                    lapack_int* ldvl, const lapack_complex_float* vr,\n                    lapack_int* ldvr, float* s, float* dif, lapack_int* mm,\n                    lapack_int* m, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_ztgsna( char* job, char* howmny, const lapack_logical* select,\n                    lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* b,\n                    lapack_int* ldb, const lapack_complex_double* vl,\n                    lapack_int* ldvl, const lapack_complex_double* vr,\n                    lapack_int* ldvr, double* s, double* dif, lapack_int* mm,\n                    lapack_int* m, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_sggsvp( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* p, lapack_int* n, float* a, lapack_int* lda,\n                    float* b, lapack_int* ldb, float* tola, float* tolb,\n                    lapack_int* k, lapack_int* l, float* u, lapack_int* ldu,\n                    float* v, lapack_int* ldv, float* q, lapack_int* ldq,\n                    lapack_int* iwork, float* tau, float* work,\n                    lapack_int *info );\nvoid LAPACK_dggsvp( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* p, lapack_int* n, double* a, lapack_int* lda,\n                    double* b, lapack_int* ldb, double* tola, double* tolb,\n                    lapack_int* k, lapack_int* l, double* u, lapack_int* ldu,\n                    double* v, lapack_int* ldv, double* q, lapack_int* ldq,\n                    lapack_int* iwork, double* tau, double* work,\n                    lapack_int *info );\nvoid LAPACK_cggsvp( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* p, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* b, lapack_int* ldb,\n                    float* tola, float* tolb, lapack_int* k, lapack_int* l,\n                    lapack_complex_float* u, lapack_int* ldu,\n                    lapack_complex_float* v, lapack_int* ldv,\n                    lapack_complex_float* q, lapack_int* ldq, lapack_int* iwork,\n                    float* rwork, lapack_complex_float* tau,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zggsvp( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* p, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* b, lapack_int* ldb,\n                    double* tola, double* tolb, lapack_int* k, lapack_int* l,\n                    lapack_complex_double* u, lapack_int* ldu,\n                    lapack_complex_double* v, lapack_int* ldv,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_int* iwork, double* rwork,\n                    lapack_complex_double* tau, lapack_complex_double* work,\n                    lapack_int *info );\nvoid LAPACK_sggsvp3( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                     lapack_int* p, lapack_int* n, float* a, lapack_int* lda,\n                     float* b, lapack_int* ldb, float* tola, float* tolb,\n                     lapack_int* k, lapack_int* l, float* u, lapack_int* ldu,\n                     float* v, lapack_int* ldv, float* q, lapack_int* ldq,\n                     lapack_int* iwork, float* tau, float* work,\n                     lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dggsvp3( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                     lapack_int* p, lapack_int* n, double* a, lapack_int* lda,\n                     double* b, lapack_int* ldb, double* tola, double* tolb,\n                     lapack_int* k, lapack_int* l, double* u, lapack_int* ldu,\n                     double* v, lapack_int* ldv, double* q, lapack_int* ldq,\n                     lapack_int* iwork, double* tau, double* work,\n                     lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cggsvp3( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                     lapack_int* p, lapack_int* n, lapack_complex_float* a,\n                     lapack_int* lda, lapack_complex_float* b, lapack_int* ldb,\n                     float* tola, float* tolb, lapack_int* k, lapack_int* l,\n                     lapack_complex_float* u, lapack_int* ldu,\n                     lapack_complex_float* v, lapack_int* ldv,\n                     lapack_complex_float* q, lapack_int* ldq, lapack_int* iwork,\n                     float* rwork, lapack_complex_float* tau,\n                     lapack_complex_float* work, lapack_int* lwork,\n                     lapack_int *info );\nvoid LAPACK_zggsvp3( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                     lapack_int* p, lapack_int* n, lapack_complex_double* a,\n                     lapack_int* lda, lapack_complex_double* b, lapack_int* ldb,\n                     double* tola, double* tolb, lapack_int* k, lapack_int* l,\n                     lapack_complex_double* u, lapack_int* ldu,\n                     lapack_complex_double* v, lapack_int* ldv,\n                     lapack_complex_double* q, lapack_int* ldq,\n                     lapack_int* iwork, double* rwork,\n                     lapack_complex_double* tau, lapack_complex_double* work,\n                     lapack_int* lwork, lapack_int *info );\nvoid LAPACK_stgsja( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* p, lapack_int* n, lapack_int* k, lapack_int* l,\n                    float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                    float* tola, float* tolb, float* alpha, float* beta,\n                    float* u, lapack_int* ldu, float* v, lapack_int* ldv,\n                    float* q, lapack_int* ldq, float* work, lapack_int* ncycle,\n                    lapack_int *info );\nvoid LAPACK_dtgsja( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* p, lapack_int* n, lapack_int* k, lapack_int* l,\n                    double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                    double* tola, double* tolb, double* alpha, double* beta,\n                    double* u, lapack_int* ldu, double* v, lapack_int* ldv,\n                    double* q, lapack_int* ldq, double* work,\n                    lapack_int* ncycle, lapack_int *info );\nvoid LAPACK_ctgsja( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* p, lapack_int* n, lapack_int* k, lapack_int* l,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb, float* tola,\n                    float* tolb, float* alpha, float* beta,\n                    lapack_complex_float* u, lapack_int* ldu,\n                    lapack_complex_float* v, lapack_int* ldv,\n                    lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* work, lapack_int* ncycle,\n                    lapack_int *info );\nvoid LAPACK_ztgsja( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* p, lapack_int* n, lapack_int* k, lapack_int* l,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb, double* tola,\n                    double* tolb, double* alpha, double* beta,\n                    lapack_complex_double* u, lapack_int* ldu,\n                    lapack_complex_double* v, lapack_int* ldv,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* work, lapack_int* ncycle,\n                    lapack_int *info );\nvoid LAPACK_sgels( char* trans, lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                   float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                   float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dgels( char* trans, lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                   double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                   double* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgels( char* trans, lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* b, lapack_int* ldb,\n                   lapack_complex_float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_zgels( char* trans, lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_sgelsy( lapack_int* m, lapack_int* n, lapack_int* nrhs, float* a,\n                    lapack_int* lda, float* b, lapack_int* ldb,\n                    lapack_int* jpvt, float* rcond, lapack_int* rank,\n                    float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dgelsy( lapack_int* m, lapack_int* n, lapack_int* nrhs, double* a,\n                    lapack_int* lda, double* b, lapack_int* ldb,\n                    lapack_int* jpvt, double* rcond, lapack_int* rank,\n                    double* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgelsy( lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb, lapack_int* jpvt,\n                    float* rcond, lapack_int* rank, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_int *info );\nvoid LAPACK_zgelsy( lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb, lapack_int* jpvt,\n                    double* rcond, lapack_int* rank,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sgelss( lapack_int* m, lapack_int* n, lapack_int* nrhs, float* a,\n                    lapack_int* lda, float* b, lapack_int* ldb, float* s,\n                    float* rcond, lapack_int* rank, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dgelss( lapack_int* m, lapack_int* n, lapack_int* nrhs, double* a,\n                    lapack_int* lda, double* b, lapack_int* ldb, double* s,\n                    double* rcond, lapack_int* rank, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgelss( lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb, float* s,\n                    float* rcond, lapack_int* rank, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_int *info );\nvoid LAPACK_zgelss( lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb, double* s,\n                    double* rcond, lapack_int* rank,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sgelsd( lapack_int* m, lapack_int* n, lapack_int* nrhs, float* a,\n                    lapack_int* lda, float* b, lapack_int* ldb, float* s,\n                    float* rcond, lapack_int* rank, float* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dgelsd( lapack_int* m, lapack_int* n, lapack_int* nrhs, double* a,\n                    lapack_int* lda, double* b, lapack_int* ldb, double* s,\n                    double* rcond, lapack_int* rank, double* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgelsd( lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb, float* s,\n                    float* rcond, lapack_int* rank, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_zgelsd( lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb, double* s,\n                    double* rcond, lapack_int* rank,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_sgglse( lapack_int* m, lapack_int* n, lapack_int* p, float* a,\n                    lapack_int* lda, float* b, lapack_int* ldb, float* c,\n                    float* d, float* x, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dgglse( lapack_int* m, lapack_int* n, lapack_int* p, double* a,\n                    lapack_int* lda, double* b, lapack_int* ldb, double* c,\n                    double* d, double* x, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cgglse( lapack_int* m, lapack_int* n, lapack_int* p,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* c, lapack_complex_float* d,\n                    lapack_complex_float* x, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zgglse( lapack_int* m, lapack_int* n, lapack_int* p,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* c, lapack_complex_double* d,\n                    lapack_complex_double* x, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sggglm( lapack_int* n, lapack_int* m, lapack_int* p, float* a,\n                    lapack_int* lda, float* b, lapack_int* ldb, float* d,\n                    float* x, float* y, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dggglm( lapack_int* n, lapack_int* m, lapack_int* p, double* a,\n                    lapack_int* lda, double* b, lapack_int* ldb, double* d,\n                    double* x, double* y, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_cggglm( lapack_int* n, lapack_int* m, lapack_int* p,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* d, lapack_complex_float* x,\n                    lapack_complex_float* y, lapack_complex_float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zggglm( lapack_int* n, lapack_int* m, lapack_int* p,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* d, lapack_complex_double* x,\n                    lapack_complex_double* y, lapack_complex_double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_ssyev( char* jobz, char* uplo, lapack_int* n, float* a,\n                   lapack_int* lda, float* w, float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_dsyev( char* jobz, char* uplo, lapack_int* n, double* a,\n                   lapack_int* lda, double* w, double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_cheev( char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_float* a, lapack_int* lda, float* w,\n                   lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                   lapack_int *info );\nvoid LAPACK_zheev( char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_double* a, lapack_int* lda, double* w,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   double* rwork, lapack_int *info );\nvoid LAPACK_ssyevd( char* jobz, char* uplo, lapack_int* n, float* a,\n                    lapack_int* lda, float* w, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dsyevd( char* jobz, char* uplo, lapack_int* n, double* a,\n                    lapack_int* lda, double* w, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_cheevd( char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda, float* w,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zheevd( char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda, double* w,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ssyevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    float* a, lapack_int* lda, float* vl, float* vu,\n                    lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, float* z, lapack_int* ldz,\n                    float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_dsyevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    double* a, lapack_int* lda, double* vl, double* vu,\n                    lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, double* z, lapack_int* ldz,\n                    double* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_cheevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda, float* vl,\n                    float* vu, lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_zheevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda, double* vl,\n                    double* vu, lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_complex_double* work,\n                    lapack_int* lwork, double* rwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_ssyevr( char* jobz, char* range, char* uplo, lapack_int* n,\n                    float* a, lapack_int* lda, float* vl, float* vu,\n                    lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, float* z, lapack_int* ldz,\n                    lapack_int* isuppz, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dsyevr( char* jobz, char* range, char* uplo, lapack_int* n,\n                    double* a, lapack_int* lda, double* vl, double* vu,\n                    lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, double* z, lapack_int* ldz,\n                    lapack_int* isuppz, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_cheevr( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda, float* vl,\n                    float* vu, lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_int* isuppz,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zheevr( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda, double* vl,\n                    double* vu, lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_int* isuppz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_sspev( char* jobz, char* uplo, lapack_int* n, float* ap, float* w,\n                   float* z, lapack_int* ldz, float* work, lapack_int *info );\nvoid LAPACK_dspev( char* jobz, char* uplo, lapack_int* n, double* ap, double* w,\n                   double* z, lapack_int* ldz, double* work, lapack_int *info );\nvoid LAPACK_chpev( char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_float* ap, float* w, lapack_complex_float* z,\n                   lapack_int* ldz, lapack_complex_float* work, float* rwork,\n                   lapack_int *info );\nvoid LAPACK_zhpev( char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_double* ap, double* w,\n                   lapack_complex_double* z, lapack_int* ldz,\n                   lapack_complex_double* work, double* rwork,\n                   lapack_int *info );\nvoid LAPACK_sspevd( char* jobz, char* uplo, lapack_int* n, float* ap, float* w,\n                    float* z, lapack_int* ldz, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dspevd( char* jobz, char* uplo, lapack_int* n, double* ap,\n                    double* w, double* z, lapack_int* ldz, double* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_chpevd( char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_float* ap, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_int* lrwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_zhpevd( char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_double* ap, double* w,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_sspevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    float* ap, float* vl, float* vu, lapack_int* il,\n                    lapack_int* iu, float* abstol, lapack_int* m, float* w,\n                    float* z, lapack_int* ldz, float* work, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_dspevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    double* ap, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, double* abstol, lapack_int* m, double* w,\n                    double* z, lapack_int* ldz, double* work, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_chpevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_float* ap, float* vl, float* vu,\n                    lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_complex_float* work, float* rwork,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_zhpevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_double* ap, double* vl, double* vu,\n                    lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_complex_double* work, double* rwork,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_ssbev( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                   float* ab, lapack_int* ldab, float* w, float* z,\n                   lapack_int* ldz, float* work, lapack_int *info );\nvoid LAPACK_dsbev( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                   double* ab, lapack_int* ldab, double* w, double* z,\n                   lapack_int* ldz, double* work, lapack_int *info );\nvoid LAPACK_chbev( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                   lapack_complex_float* ab, lapack_int* ldab, float* w,\n                   lapack_complex_float* z, lapack_int* ldz,\n                   lapack_complex_float* work, float* rwork, lapack_int *info );\nvoid LAPACK_zhbev( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                   lapack_complex_double* ab, lapack_int* ldab, double* w,\n                   lapack_complex_double* z, lapack_int* ldz,\n                   lapack_complex_double* work, double* rwork,\n                   lapack_int *info );\nvoid LAPACK_ssbevd( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                    float* ab, lapack_int* ldab, float* w, float* z,\n                    lapack_int* ldz, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dsbevd( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                    double* ab, lapack_int* ldab, double* w, double* z,\n                    lapack_int* ldz, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_chbevd( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_complex_float* ab, lapack_int* ldab, float* w,\n                    lapack_complex_float* z, lapack_int* ldz,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zhbevd( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_complex_double* ab, lapack_int* ldab, double* w,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ssbevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* kd, float* ab, lapack_int* ldab, float* q,\n                    lapack_int* ldq, float* vl, float* vu, lapack_int* il,\n                    lapack_int* iu, float* abstol, lapack_int* m, float* w,\n                    float* z, lapack_int* ldz, float* work,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_dsbevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* kd, double* ab, lapack_int* ldab, double* q,\n                    lapack_int* ldq, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, double* abstol, lapack_int* m, double* w,\n                    double* z, lapack_int* ldz, double* work,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_chbevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* kd, lapack_complex_float* ab, lapack_int* ldab,\n                    lapack_complex_float* q, lapack_int* ldq, float* vl,\n                    float* vu, lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_complex_float* work,\n                    float* rwork, lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_zhbevx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* kd, lapack_complex_double* ab, lapack_int* ldab,\n                    lapack_complex_double* q, lapack_int* ldq, double* vl,\n                    double* vu, lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_complex_double* work,\n                    double* rwork, lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_sstev( char* jobz, lapack_int* n, float* d, float* e, float* z,\n                   lapack_int* ldz, float* work, lapack_int *info );\nvoid LAPACK_dstev( char* jobz, lapack_int* n, double* d, double* e, double* z,\n                   lapack_int* ldz, double* work, lapack_int *info );\nvoid LAPACK_sstevd( char* jobz, lapack_int* n, float* d, float* e, float* z,\n                    lapack_int* ldz, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dstevd( char* jobz, lapack_int* n, double* d, double* e, double* z,\n                    lapack_int* ldz, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_sstevx( char* jobz, char* range, lapack_int* n, float* d, float* e,\n                    float* vl, float* vu, lapack_int* il, lapack_int* iu,\n                    float* abstol, lapack_int* m, float* w, float* z,\n                    lapack_int* ldz, float* work, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_dstevx( char* jobz, char* range, lapack_int* n, double* d,\n                    double* e, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, double* abstol, lapack_int* m, double* w,\n                    double* z, lapack_int* ldz, double* work, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_sstevr( char* jobz, char* range, lapack_int* n, float* d, float* e,\n                    float* vl, float* vu, lapack_int* il, lapack_int* iu,\n                    float* abstol, lapack_int* m, float* w, float* z,\n                    lapack_int* ldz, lapack_int* isuppz, float* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_dstevr( char* jobz, char* range, lapack_int* n, double* d,\n                    double* e, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, double* abstol, lapack_int* m, double* w,\n                    double* z, lapack_int* ldz, lapack_int* isuppz,\n                    double* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_sgees( char* jobvs, char* sort, LAPACK_S_SELECT2 select,\n                   lapack_int* n, float* a, lapack_int* lda, lapack_int* sdim,\n                   float* wr, float* wi, float* vs, lapack_int* ldvs,\n                   float* work, lapack_int* lwork, lapack_logical* bwork,\n                   lapack_int *info );\nvoid LAPACK_dgees( char* jobvs, char* sort, LAPACK_D_SELECT2 select,\n                   lapack_int* n, double* a, lapack_int* lda, lapack_int* sdim,\n                   double* wr, double* wi, double* vs, lapack_int* ldvs,\n                   double* work, lapack_int* lwork, lapack_logical* bwork,\n                   lapack_int *info );\nvoid LAPACK_cgees( char* jobvs, char* sort, LAPACK_C_SELECT1 select,\n                   lapack_int* n, lapack_complex_float* a, lapack_int* lda,\n                   lapack_int* sdim, lapack_complex_float* w,\n                   lapack_complex_float* vs, lapack_int* ldvs,\n                   lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                   lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_zgees( char* jobvs, char* sort, LAPACK_Z_SELECT1 select,\n                   lapack_int* n, lapack_complex_double* a, lapack_int* lda,\n                   lapack_int* sdim, lapack_complex_double* w,\n                   lapack_complex_double* vs, lapack_int* ldvs,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   double* rwork, lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_sgeesx( char* jobvs, char* sort, LAPACK_S_SELECT2 select,\n                    char* sense, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* sdim, float* wr, float* wi, float* vs,\n                    lapack_int* ldvs, float* rconde, float* rcondv, float* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_dgeesx( char* jobvs, char* sort, LAPACK_D_SELECT2 select,\n                    char* sense, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* sdim, double* wr, double* wi, double* vs,\n                    lapack_int* ldvs, double* rconde, double* rcondv,\n                    double* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_cgeesx( char* jobvs, char* sort, LAPACK_C_SELECT1 select,\n                    char* sense, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* sdim, lapack_complex_float* w,\n                    lapack_complex_float* vs, lapack_int* ldvs, float* rconde,\n                    float* rcondv, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_zgeesx( char* jobvs, char* sort, LAPACK_Z_SELECT1 select,\n                    char* sense, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* sdim, lapack_complex_double* w,\n                    lapack_complex_double* vs, lapack_int* ldvs, double* rconde,\n                    double* rcondv, lapack_complex_double* work,\n                    lapack_int* lwork, double* rwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_sgeev( char* jobvl, char* jobvr, lapack_int* n, float* a,\n                   lapack_int* lda, float* wr, float* wi, float* vl,\n                   lapack_int* ldvl, float* vr, lapack_int* ldvr, float* work,\n                   lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dgeev( char* jobvl, char* jobvr, lapack_int* n, double* a,\n                   lapack_int* lda, double* wr, double* wi, double* vl,\n                   lapack_int* ldvl, double* vr, lapack_int* ldvr, double* work,\n                   lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgeev( char* jobvl, char* jobvr, lapack_int* n,\n                   lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* w, lapack_complex_float* vl,\n                   lapack_int* ldvl, lapack_complex_float* vr, lapack_int* ldvr,\n                   lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                   lapack_int *info );\nvoid LAPACK_zgeev( char* jobvl, char* jobvr, lapack_int* n,\n                   lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* w, lapack_complex_double* vl,\n                   lapack_int* ldvl, lapack_complex_double* vr,\n                   lapack_int* ldvr, lapack_complex_double* work,\n                   lapack_int* lwork, double* rwork, lapack_int *info );\nvoid LAPACK_sgeevx( char* balanc, char* jobvl, char* jobvr, char* sense,\n                    lapack_int* n, float* a, lapack_int* lda, float* wr,\n                    float* wi, float* vl, lapack_int* ldvl, float* vr,\n                    lapack_int* ldvr, lapack_int* ilo, lapack_int* ihi,\n                    float* scale, float* abnrm, float* rconde, float* rcondv,\n                    float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_dgeevx( char* balanc, char* jobvl, char* jobvr, char* sense,\n                    lapack_int* n, double* a, lapack_int* lda, double* wr,\n                    double* wi, double* vl, lapack_int* ldvl, double* vr,\n                    lapack_int* ldvr, lapack_int* ilo, lapack_int* ihi,\n                    double* scale, double* abnrm, double* rconde,\n                    double* rcondv, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgeevx( char* balanc, char* jobvl, char* jobvr, char* sense,\n                    lapack_int* n, lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* w, lapack_complex_float* vl,\n                    lapack_int* ldvl, lapack_complex_float* vr,\n                    lapack_int* ldvr, lapack_int* ilo, lapack_int* ihi,\n                    float* scale, float* abnrm, float* rconde, float* rcondv,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zgeevx( char* balanc, char* jobvl, char* jobvr, char* sense,\n                    lapack_int* n, lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* w, lapack_complex_double* vl,\n                    lapack_int* ldvl, lapack_complex_double* vr,\n                    lapack_int* ldvr, lapack_int* ilo, lapack_int* ihi,\n                    double* scale, double* abnrm, double* rconde,\n                    double* rcondv, lapack_complex_double* work,\n                    lapack_int* lwork, double* rwork, lapack_int *info );\nvoid LAPACK_sgesvd( char* jobu, char* jobvt, lapack_int* m, lapack_int* n,\n                    float* a, lapack_int* lda, float* s, float* u,\n                    lapack_int* ldu, float* vt, lapack_int* ldvt, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dgesvd( char* jobu, char* jobvt, lapack_int* m, lapack_int* n,\n                    double* a, lapack_int* lda, double* s, double* u,\n                    lapack_int* ldu, double* vt, lapack_int* ldvt, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgesvd( char* jobu, char* jobvt, lapack_int* m, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda, float* s,\n                    lapack_complex_float* u, lapack_int* ldu,\n                    lapack_complex_float* vt, lapack_int* ldvt,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zgesvd( char* jobu, char* jobvt, lapack_int* m, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda, double* s,\n                    lapack_complex_double* u, lapack_int* ldu,\n                    lapack_complex_double* vt, lapack_int* ldvt,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sgesvdx( char* jobu, char* jobvt, char* range, lapack_int* m, lapack_int* n,\n                    float* a, lapack_int* lda, float* vl, float* vu,\n                    lapack_int* il, lapack_int* iu, lapack_int* ns, float* s, float* u,\n                    lapack_int* ldu, float* vt, lapack_int* ldvt, float* work,\n                    lapack_int* lwork, lapack_int *iwork, lapack_int *info );\nvoid LAPACK_dgesvdx( char* jobu, char* jobvt, char* range, lapack_int* m, lapack_int* n,\n                    double* a, lapack_int* lda, double* vl, double* vu,\n                    lapack_int* il, lapack_int* iu, lapack_int* ns, double* s, double* u,\n                    lapack_int* ldu, double* vt, lapack_int* ldvt, double* work,\n                    lapack_int* lwork, lapack_int *iwork, lapack_int *info );\nvoid LAPACK_cgesvdx( char* jobu, char* jobvt, char* range, lapack_int* m, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda, float* vl, float* vu,\n                    lapack_int* il, lapack_int* iu, lapack_int* ns, float* s,\n                    lapack_complex_float* u, lapack_int* ldu,\n                    lapack_complex_float* vt, lapack_int* ldvt,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int *iwork, lapack_int *info );\nvoid LAPACK_zgesvdx( char* jobu, char* jobvt, char* range, lapack_int* m, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda, double* vl, double* vu,\n                    lapack_int* il, lapack_int* iu, lapack_int* ns, double* s,\n                    lapack_complex_double* u, lapack_int* ldu,\n                    lapack_complex_double* vt, lapack_int* ldvt,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int *iwork, lapack_int *info );\nvoid LAPACK_sgesdd( char* jobz, lapack_int* m, lapack_int* n, float* a,\n                    lapack_int* lda, float* s, float* u, lapack_int* ldu,\n                    float* vt, lapack_int* ldvt, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dgesdd( char* jobz, lapack_int* m, lapack_int* n, double* a,\n                    lapack_int* lda, double* s, double* u, lapack_int* ldu,\n                    double* vt, lapack_int* ldvt, double* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgesdd( char* jobz, lapack_int* m, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda, float* s,\n                    lapack_complex_float* u, lapack_int* ldu,\n                    lapack_complex_float* vt, lapack_int* ldvt,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_zgesdd( char* jobz, lapack_int* m, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda, double* s,\n                    lapack_complex_double* u, lapack_int* ldu,\n                    lapack_complex_double* vt, lapack_int* ldvt,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dgejsv( char* joba, char* jobu, char* jobv, char* jobr, char* jobt,\n                    char* jobp, lapack_int* m, lapack_int* n, double* a,\n                    lapack_int* lda, double* sva, double* u, lapack_int* ldu,\n                    double* v, lapack_int* ldv, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_sgejsv( char* joba, char* jobu, char* jobv, char* jobr, char* jobt,\n                    char* jobp, lapack_int* m, lapack_int* n, float* a,\n                    lapack_int* lda, float* sva, float* u, lapack_int* ldu,\n                    float* v, lapack_int* ldv, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cgejsv( char* joba, char* jobu, char* jobv, char* jobr, char* jobt,\n                    char* jobp, lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, float* sva, lapack_complex_float* u, lapack_int* ldu,\n                    lapack_complex_float* v, lapack_int* ldv, lapack_complex_float* cwork,\n                    lapack_int* lwork, float* work, lapack_int* lrwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_zgejsv( char* joba, char* jobu, char* jobv, char* jobr, char* jobt,\n                    char* jobp, lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, double* sva, lapack_complex_double* u, lapack_int* ldu,\n                    lapack_complex_double* v, lapack_int* ldv, lapack_complex_double* cwork,\n                    lapack_int* lwork, double* work, lapack_int* lrwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dgesvj( char* joba, char* jobu, char* jobv, lapack_int* m,\n                    lapack_int* n, double* a, lapack_int* lda, double* sva,\n                    lapack_int* mv, double* v, lapack_int* ldv, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_sgesvj( char* joba, char* jobu, char* jobv, lapack_int* m,\n                    lapack_int* n, float* a, lapack_int* lda, float* sva,\n                    lapack_int* mv, float* v, lapack_int* ldv, float* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgesvj( char* joba, char* jobu, char* jobv, lapack_int* m,\n                    lapack_int* n, lapack_complex_float* a, lapack_int* lda, float* sva,\n                    lapack_int* mv, lapack_complex_float* v, lapack_int* ldv,\n                    lapack_complex_float* cwork, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int *info );\nvoid LAPACK_zgesvj( char* joba, char* jobu, char* jobv, lapack_int* m,\n                    lapack_int* n, lapack_complex_double* a, lapack_int* lda, double* sva,\n                    lapack_int* mv, lapack_complex_double* v, lapack_int* ldv,\n                    lapack_complex_double* cwork, lapack_int* lwork, double* rwork,\n                    lapack_int* lrwork, lapack_int *info );\nvoid LAPACK_sggsvd( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* n, lapack_int* p, lapack_int* k, lapack_int* l,\n                    float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                    float* alpha, float* beta, float* u, lapack_int* ldu,\n                    float* v, lapack_int* ldv, float* q, lapack_int* ldq,\n                    float* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dggsvd( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* n, lapack_int* p, lapack_int* k, lapack_int* l,\n                    double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                    double* alpha, double* beta, double* u, lapack_int* ldu,\n                    double* v, lapack_int* ldv, double* q, lapack_int* ldq,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_cggsvd( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* n, lapack_int* p, lapack_int* k, lapack_int* l,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb, float* alpha,\n                    float* beta, lapack_complex_float* u, lapack_int* ldu,\n                    lapack_complex_float* v, lapack_int* ldv,\n                    lapack_complex_float* q, lapack_int* ldq,\n                    lapack_complex_float* work, float* rwork, lapack_int* iwork,\n                    lapack_int *info );\nvoid LAPACK_zggsvd( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                    lapack_int* n, lapack_int* p, lapack_int* k, lapack_int* l,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb, double* alpha,\n                    double* beta, lapack_complex_double* u, lapack_int* ldu,\n                    lapack_complex_double* v, lapack_int* ldv,\n                    lapack_complex_double* q, lapack_int* ldq,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int* iwork, lapack_int *info );\nvoid LAPACK_sggsvd3( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                     lapack_int* n, lapack_int* p, lapack_int* k, lapack_int* l,\n                     float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                     float* alpha, float* beta, float* u, lapack_int* ldu,\n                     float* v, lapack_int* ldv, float* q, lapack_int* ldq,\n                     float* work, lapack_int* lwork, lapack_int* iwork,\n                     lapack_int *info );\nvoid LAPACK_dggsvd3( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                     lapack_int* n, lapack_int* p, lapack_int* k, lapack_int* l,\n                     double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                     double* alpha, double* beta, double* u, lapack_int* ldu,\n                     double* v, lapack_int* ldv, double* q, lapack_int* ldq,\n                     double* work, lapack_int* lwork, lapack_int* iwork,\n                     lapack_int *info );\nvoid LAPACK_cggsvd3( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                     lapack_int* n, lapack_int* p, lapack_int* k, lapack_int* l,\n                     lapack_complex_float* a, lapack_int* lda,\n                     lapack_complex_float* b, lapack_int* ldb, float* alpha,\n                     float* beta, lapack_complex_float* u, lapack_int* ldu,\n                     lapack_complex_float* v, lapack_int* ldv,\n                     lapack_complex_float* q, lapack_int* ldq,\n                     lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                     lapack_int* iwork, lapack_int *info );\nvoid LAPACK_zggsvd3( char* jobu, char* jobv, char* jobq, lapack_int* m,\n                     lapack_int* n, lapack_int* p, lapack_int* k, lapack_int* l,\n                     lapack_complex_double* a, lapack_int* lda,\n                     lapack_complex_double* b, lapack_int* ldb, double* alpha,\n                     double* beta, lapack_complex_double* u, lapack_int* ldu,\n                     lapack_complex_double* v, lapack_int* ldv,\n                     lapack_complex_double* q, lapack_int* ldq,\n                     lapack_complex_double* work, lapack_int* lwork,\n                     double* rwork, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_ssygv( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                   float* w, float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dsygv( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                   double* w, double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_chegv( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* b, lapack_int* ldb, float* w,\n                   lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                   lapack_int *info );\nvoid LAPACK_zhegv( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* b, lapack_int* ldb, double* w,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   double* rwork, lapack_int *info );\nvoid LAPACK_ssygvd( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                    float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                    float* w, float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dsygvd( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                    double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                    double* w, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_chegvd( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb, float* w,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zhegvd( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb, double* w,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ssygvx( lapack_int* itype, char* jobz, char* range, char* uplo,\n                    lapack_int* n, float* a, lapack_int* lda, float* b,\n                    lapack_int* ldb, float* vl, float* vu, lapack_int* il,\n                    lapack_int* iu, float* abstol, lapack_int* m, float* w,\n                    float* z, lapack_int* ldz, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_dsygvx( lapack_int* itype, char* jobz, char* range, char* uplo,\n                    lapack_int* n, double* a, lapack_int* lda, double* b,\n                    lapack_int* ldb, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, double* abstol, lapack_int* m, double* w,\n                    double* z, lapack_int* ldz, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_chegvx( lapack_int* itype, char* jobz, char* range, char* uplo,\n                    lapack_int* n, lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb, float* vl,\n                    float* vu, lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_zhegvx( lapack_int* itype, char* jobz, char* range, char* uplo,\n                    lapack_int* n, lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb, double* vl,\n                    double* vu, lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_complex_double* work,\n                    lapack_int* lwork, double* rwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_sspgv( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   float* ap, float* bp, float* w, float* z, lapack_int* ldz,\n                   float* work, lapack_int *info );\nvoid LAPACK_dspgv( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   double* ap, double* bp, double* w, double* z,\n                   lapack_int* ldz, double* work, lapack_int *info );\nvoid LAPACK_chpgv( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_float* ap, lapack_complex_float* bp, float* w,\n                   lapack_complex_float* z, lapack_int* ldz,\n                   lapack_complex_float* work, float* rwork, lapack_int *info );\nvoid LAPACK_zhpgv( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_double* ap, lapack_complex_double* bp,\n                   double* w, lapack_complex_double* z, lapack_int* ldz,\n                   lapack_complex_double* work, double* rwork,\n                   lapack_int *info );\nvoid LAPACK_sspgvd( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                    float* ap, float* bp, float* w, float* z, lapack_int* ldz,\n                    float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dspgvd( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                    double* ap, double* bp, double* w, double* z,\n                    lapack_int* ldz, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_chpgvd( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_float* ap, lapack_complex_float* bp,\n                    float* w, lapack_complex_float* z, lapack_int* ldz,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zhpgvd( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_double* ap, lapack_complex_double* bp,\n                    double* w, lapack_complex_double* z, lapack_int* ldz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_sspgvx( lapack_int* itype, char* jobz, char* range, char* uplo,\n                    lapack_int* n, float* ap, float* bp, float* vl, float* vu,\n                    lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, float* z, lapack_int* ldz,\n                    float* work, lapack_int* iwork, lapack_int* ifail,\n                    lapack_int *info );\nvoid LAPACK_dspgvx( lapack_int* itype, char* jobz, char* range, char* uplo,\n                    lapack_int* n, double* ap, double* bp, double* vl,\n                    double* vu, lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, double* z, lapack_int* ldz,\n                    double* work, lapack_int* iwork, lapack_int* ifail,\n                    lapack_int *info );\nvoid LAPACK_chpgvx( lapack_int* itype, char* jobz, char* range, char* uplo,\n                    lapack_int* n, lapack_complex_float* ap,\n                    lapack_complex_float* bp, float* vl, float* vu,\n                    lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_complex_float* work, float* rwork,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_zhpgvx( lapack_int* itype, char* jobz, char* range, char* uplo,\n                    lapack_int* n, lapack_complex_double* ap,\n                    lapack_complex_double* bp, double* vl, double* vu,\n                    lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_complex_double* work, double* rwork,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_ssbgv( char* jobz, char* uplo, lapack_int* n, lapack_int* ka,\n                   lapack_int* kb, float* ab, lapack_int* ldab, float* bb,\n                   lapack_int* ldbb, float* w, float* z, lapack_int* ldz,\n                   float* work, lapack_int *info );\nvoid LAPACK_dsbgv( char* jobz, char* uplo, lapack_int* n, lapack_int* ka,\n                   lapack_int* kb, double* ab, lapack_int* ldab, double* bb,\n                   lapack_int* ldbb, double* w, double* z, lapack_int* ldz,\n                   double* work, lapack_int *info );\nvoid LAPACK_chbgv( char* jobz, char* uplo, lapack_int* n, lapack_int* ka,\n                   lapack_int* kb, lapack_complex_float* ab, lapack_int* ldab,\n                   lapack_complex_float* bb, lapack_int* ldbb, float* w,\n                   lapack_complex_float* z, lapack_int* ldz,\n                   lapack_complex_float* work, float* rwork, lapack_int *info );\nvoid LAPACK_zhbgv( char* jobz, char* uplo, lapack_int* n, lapack_int* ka,\n                   lapack_int* kb, lapack_complex_double* ab, lapack_int* ldab,\n                   lapack_complex_double* bb, lapack_int* ldbb, double* w,\n                   lapack_complex_double* z, lapack_int* ldz,\n                   lapack_complex_double* work, double* rwork,\n                   lapack_int *info );\nvoid LAPACK_ssbgvd( char* jobz, char* uplo, lapack_int* n, lapack_int* ka,\n                    lapack_int* kb, float* ab, lapack_int* ldab, float* bb,\n                    lapack_int* ldbb, float* w, float* z, lapack_int* ldz,\n                    float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dsbgvd( char* jobz, char* uplo, lapack_int* n, lapack_int* ka,\n                    lapack_int* kb, double* ab, lapack_int* ldab, double* bb,\n                    lapack_int* ldbb, double* w, double* z, lapack_int* ldz,\n                    double* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_chbgvd( char* jobz, char* uplo, lapack_int* n, lapack_int* ka,\n                    lapack_int* kb, lapack_complex_float* ab, lapack_int* ldab,\n                    lapack_complex_float* bb, lapack_int* ldbb, float* w,\n                    lapack_complex_float* z, lapack_int* ldz,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zhbgvd( char* jobz, char* uplo, lapack_int* n, lapack_int* ka,\n                    lapack_int* kb, lapack_complex_double* ab, lapack_int* ldab,\n                    lapack_complex_double* bb, lapack_int* ldbb, double* w,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ssbgvx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* ka, lapack_int* kb, float* ab, lapack_int* ldab,\n                    float* bb, lapack_int* ldbb, float* q, lapack_int* ldq,\n                    float* vl, float* vu, lapack_int* il, lapack_int* iu,\n                    float* abstol, lapack_int* m, float* w, float* z,\n                    lapack_int* ldz, float* work, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_dsbgvx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* ka, lapack_int* kb, double* ab,\n                    lapack_int* ldab, double* bb, lapack_int* ldbb, double* q,\n                    lapack_int* ldq, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, double* abstol, lapack_int* m, double* w,\n                    double* z, lapack_int* ldz, double* work, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_chbgvx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* ka, lapack_int* kb, lapack_complex_float* ab,\n                    lapack_int* ldab, lapack_complex_float* bb,\n                    lapack_int* ldbb, lapack_complex_float* q, lapack_int* ldq,\n                    float* vl, float* vu, lapack_int* il, lapack_int* iu,\n                    float* abstol, lapack_int* m, float* w,\n                    lapack_complex_float* z, lapack_int* ldz,\n                    lapack_complex_float* work, float* rwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_zhbgvx( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* ka, lapack_int* kb, lapack_complex_double* ab,\n                    lapack_int* ldab, lapack_complex_double* bb,\n                    lapack_int* ldbb, lapack_complex_double* q, lapack_int* ldq,\n                    double* vl, double* vu, lapack_int* il, lapack_int* iu,\n                    double* abstol, lapack_int* m, double* w,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_complex_double* work, double* rwork,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_sgges( char* jobvsl, char* jobvsr, char* sort,\n                   LAPACK_S_SELECT3 selctg, lapack_int* n, float* a,\n                   lapack_int* lda, float* b, lapack_int* ldb, lapack_int* sdim,\n                   float* alphar, float* alphai, float* beta, float* vsl,\n                   lapack_int* ldvsl, float* vsr, lapack_int* ldvsr,\n                   float* work, lapack_int* lwork, lapack_logical* bwork,\n                   lapack_int *info );\nvoid LAPACK_dgges( char* jobvsl, char* jobvsr, char* sort,\n                   LAPACK_D_SELECT3 selctg, lapack_int* n, double* a,\n                   lapack_int* lda, double* b, lapack_int* ldb,\n                   lapack_int* sdim, double* alphar, double* alphai,\n                   double* beta, double* vsl, lapack_int* ldvsl, double* vsr,\n                   lapack_int* ldvsr, double* work, lapack_int* lwork,\n                   lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_cgges( char* jobvsl, char* jobvsr, char* sort,\n                   LAPACK_C_SELECT2 selctg, lapack_int* n,\n                   lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* b, lapack_int* ldb, lapack_int* sdim,\n                   lapack_complex_float* alpha, lapack_complex_float* beta,\n                   lapack_complex_float* vsl, lapack_int* ldvsl,\n                   lapack_complex_float* vsr, lapack_int* ldvsr,\n                   lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                   lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_zgges( char* jobvsl, char* jobvsr, char* sort,\n                   LAPACK_Z_SELECT2 selctg, lapack_int* n,\n                   lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* b, lapack_int* ldb, lapack_int* sdim,\n                   lapack_complex_double* alpha, lapack_complex_double* beta,\n                   lapack_complex_double* vsl, lapack_int* ldvsl,\n                   lapack_complex_double* vsr, lapack_int* ldvsr,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   double* rwork, lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_sgges3( char* jobvsl, char* jobvsr, char* sort,\n                    LAPACK_S_SELECT3 selctg, lapack_int* n,\n                    float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                    lapack_int* sdim, float* alphar, float* alphai,\n                    float* beta, float* vsl, lapack_int* ldvsl,\n                    float* vsr, lapack_int* ldvsr,\n                    float* work, lapack_int* lwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_dgges3( char* jobvsl, char* jobvsr, char* sort,\n                    LAPACK_D_SELECT3 selctg, lapack_int* n, double* a,\n                    lapack_int* lda, double* b, lapack_int* ldb,\n                    lapack_int* sdim, double* alphar, double* alphai,\n                    double* beta, double* vsl, lapack_int* ldvsl, double* vsr,\n                    lapack_int* ldvsr, double* work, lapack_int* lwork,\n                    lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_cgges3( char* jobvsl, char* jobvsr, char* sort,\n                    LAPACK_C_SELECT2 selctg, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_int* sdim,\n                    lapack_complex_float* alpha, lapack_complex_float* beta,\n                    lapack_complex_float* vsl, lapack_int* ldvsl,\n                    lapack_complex_float* vsr, lapack_int* ldvsr,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_zgges3( char* jobvsl, char* jobvsr, char* sort,\n                    LAPACK_Z_SELECT2 selctg, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb, lapack_int* sdim,\n                    lapack_complex_double* alpha, lapack_complex_double* beta,\n                    lapack_complex_double* vsl, lapack_int* ldvsl,\n                    lapack_complex_double* vsr, lapack_int* ldvsr,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_sggesx( char* jobvsl, char* jobvsr, char* sort,\n                    LAPACK_S_SELECT3 selctg, char* sense, lapack_int* n,\n                    float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                    lapack_int* sdim, float* alphar, float* alphai, float* beta,\n                    float* vsl, lapack_int* ldvsl, float* vsr,\n                    lapack_int* ldvsr, float* rconde, float* rcondv,\n                    float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_dggesx( char* jobvsl, char* jobvsr, char* sort,\n                    LAPACK_D_SELECT3 selctg, char* sense, lapack_int* n,\n                    double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                    lapack_int* sdim, double* alphar, double* alphai,\n                    double* beta, double* vsl, lapack_int* ldvsl, double* vsr,\n                    lapack_int* ldvsr, double* rconde, double* rcondv,\n                    double* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_cggesx( char* jobvsl, char* jobvsr, char* sort,\n                    LAPACK_C_SELECT2 selctg, char* sense, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb, lapack_int* sdim,\n                    lapack_complex_float* alpha, lapack_complex_float* beta,\n                    lapack_complex_float* vsl, lapack_int* ldvsl,\n                    lapack_complex_float* vsr, lapack_int* ldvsr, float* rconde,\n                    float* rcondv, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_zggesx( char* jobvsl, char* jobvsr, char* sort,\n                    LAPACK_Z_SELECT2 selctg, char* sense, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb, lapack_int* sdim,\n                    lapack_complex_double* alpha, lapack_complex_double* beta,\n                    lapack_complex_double* vsl, lapack_int* ldvsl,\n                    lapack_complex_double* vsr, lapack_int* ldvsr,\n                    double* rconde, double* rcondv, lapack_complex_double* work,\n                    lapack_int* lwork, double* rwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_sggev( char* jobvl, char* jobvr, lapack_int* n, float* a,\n                   lapack_int* lda, float* b, lapack_int* ldb, float* alphar,\n                   float* alphai, float* beta, float* vl, lapack_int* ldvl,\n                   float* vr, lapack_int* ldvr, float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_dggev( char* jobvl, char* jobvr, lapack_int* n, double* a,\n                   lapack_int* lda, double* b, lapack_int* ldb, double* alphar,\n                   double* alphai, double* beta, double* vl, lapack_int* ldvl,\n                   double* vr, lapack_int* ldvr, double* work,\n                   lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cggev( char* jobvl, char* jobvr, lapack_int* n,\n                   lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* b, lapack_int* ldb,\n                   lapack_complex_float* alpha, lapack_complex_float* beta,\n                   lapack_complex_float* vl, lapack_int* ldvl,\n                   lapack_complex_float* vr, lapack_int* ldvr,\n                   lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                   lapack_int *info );\nvoid LAPACK_zggev( char* jobvl, char* jobvr, lapack_int* n,\n                   lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_complex_double* alpha, lapack_complex_double* beta,\n                   lapack_complex_double* vl, lapack_int* ldvl,\n                   lapack_complex_double* vr, lapack_int* ldvr,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   double* rwork, lapack_int *info );\nvoid LAPACK_sggev3( char* jobvl, char* jobvr, lapack_int* n, float* a,\n                    lapack_int* lda, float* b, lapack_int* ldb, float* alphar,\n                    float* alphai, float* beta, float* vl, lapack_int* ldvl,\n                    float* vr, lapack_int* ldvr, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dggev3( char* jobvl, char* jobvr, lapack_int* n, double* a,\n                    lapack_int* lda, double* b, lapack_int* ldb, double* alphar,\n                    double* alphai, double* beta, double* vl, lapack_int* ldvl,\n                    double* vr, lapack_int* ldvr, double* work,\n                    lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cggev3( char* jobvl, char* jobvr, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* alpha, lapack_complex_float* beta,\n                    lapack_complex_float* vl, lapack_int* ldvl,\n                    lapack_complex_float* vr, lapack_int* ldvr,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int *info );\nvoid LAPACK_zggev3( char* jobvl, char* jobvr, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* alpha, lapack_complex_double* beta,\n                    lapack_complex_double* vl, lapack_int* ldvl,\n                    lapack_complex_double* vr, lapack_int* ldvr,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int *info );\nvoid LAPACK_sggevx( char* balanc, char* jobvl, char* jobvr, char* sense,\n                    lapack_int* n, float* a, lapack_int* lda, float* b,\n                    lapack_int* ldb, float* alphar, float* alphai, float* beta,\n                    float* vl, lapack_int* ldvl, float* vr, lapack_int* ldvr,\n                    lapack_int* ilo, lapack_int* ihi, float* lscale,\n                    float* rscale, float* abnrm, float* bbnrm, float* rconde,\n                    float* rcondv, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_dggevx( char* balanc, char* jobvl, char* jobvr, char* sense,\n                    lapack_int* n, double* a, lapack_int* lda, double* b,\n                    lapack_int* ldb, double* alphar, double* alphai,\n                    double* beta, double* vl, lapack_int* ldvl, double* vr,\n                    lapack_int* ldvr, lapack_int* ilo, lapack_int* ihi,\n                    double* lscale, double* rscale, double* abnrm,\n                    double* bbnrm, double* rconde, double* rcondv, double* work,\n                    lapack_int* lwork, lapack_int* iwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_cggevx( char* balanc, char* jobvl, char* jobvr, char* sense,\n                    lapack_int* n, lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* alpha, lapack_complex_float* beta,\n                    lapack_complex_float* vl, lapack_int* ldvl,\n                    lapack_complex_float* vr, lapack_int* ldvr, lapack_int* ilo,\n                    lapack_int* ihi, float* lscale, float* rscale, float* abnrm,\n                    float* bbnrm, float* rconde, float* rcondv,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* iwork, lapack_logical* bwork,\n                    lapack_int *info );\nvoid LAPACK_zggevx( char* balanc, char* jobvl, char* jobvr, char* sense,\n                    lapack_int* n, lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* alpha, lapack_complex_double* beta,\n                    lapack_complex_double* vl, lapack_int* ldvl,\n                    lapack_complex_double* vr, lapack_int* ldvr,\n                    lapack_int* ilo, lapack_int* ihi, double* lscale,\n                    double* rscale, double* abnrm, double* bbnrm,\n                    double* rconde, double* rcondv, lapack_complex_double* work,\n                    lapack_int* lwork, double* rwork, lapack_int* iwork,\n                    lapack_logical* bwork, lapack_int *info );\nvoid LAPACK_dsfrk( char* transr, char* uplo, char* trans, lapack_int* n,\n                   lapack_int* k, double* alpha, const double* a,\n                   lapack_int* lda, double* beta, double* c );\nvoid LAPACK_ssfrk( char* transr, char* uplo, char* trans, lapack_int* n,\n                   lapack_int* k, float* alpha, const float* a, lapack_int* lda,\n                   float* beta, float* c );\nvoid LAPACK_zhfrk( char* transr, char* uplo, char* trans, lapack_int* n,\n                   lapack_int* k, double* alpha, const lapack_complex_double* a,\n                   lapack_int* lda, double* beta, lapack_complex_double* c );\nvoid LAPACK_chfrk( char* transr, char* uplo, char* trans, lapack_int* n,\n                   lapack_int* k, float* alpha, const lapack_complex_float* a,\n                   lapack_int* lda, float* beta, lapack_complex_float* c );\nvoid LAPACK_dtfsm( char* transr, char* side, char* uplo, char* trans,\n                   char* diag, lapack_int* m, lapack_int* n, double* alpha,\n                   const double* a, double* b, lapack_int* ldb );\nvoid LAPACK_stfsm( char* transr, char* side, char* uplo, char* trans,\n                   char* diag, lapack_int* m, lapack_int* n, float* alpha,\n                   const float* a, float* b, lapack_int* ldb );\nvoid LAPACK_ztfsm( char* transr, char* side, char* uplo, char* trans,\n                   char* diag, lapack_int* m, lapack_int* n,\n                   lapack_complex_double* alpha, const lapack_complex_double* a,\n                   lapack_complex_double* b, lapack_int* ldb );\nvoid LAPACK_ctfsm( char* transr, char* side, char* uplo, char* trans,\n                   char* diag, lapack_int* m, lapack_int* n,\n                   lapack_complex_float* alpha, const lapack_complex_float* a,\n                   lapack_complex_float* b, lapack_int* ldb );\nvoid LAPACK_dtfttp( char* transr, char* uplo, lapack_int* n, const double* arf,\n                    double* ap, lapack_int *info );\nvoid LAPACK_stfttp( char* transr, char* uplo, lapack_int* n, const float* arf,\n                    float* ap, lapack_int *info );\nvoid LAPACK_ztfttp( char* transr, char* uplo, lapack_int* n,\n                    const lapack_complex_double* arf, lapack_complex_double* ap,\n                    lapack_int *info );\nvoid LAPACK_ctfttp( char* transr, char* uplo, lapack_int* n,\n                    const lapack_complex_float* arf, lapack_complex_float* ap,\n                    lapack_int *info );\nvoid LAPACK_dtfttr( char* transr, char* uplo, lapack_int* n, const double* arf,\n                    double* a, lapack_int* lda, lapack_int *info );\nvoid LAPACK_stfttr( char* transr, char* uplo, lapack_int* n, const float* arf,\n                    float* a, lapack_int* lda, lapack_int *info );\nvoid LAPACK_ztfttr( char* transr, char* uplo, lapack_int* n,\n                    const lapack_complex_double* arf, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_ctfttr( char* transr, char* uplo, lapack_int* n,\n                    const lapack_complex_float* arf, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_dtpttf( char* transr, char* uplo, lapack_int* n, const double* ap,\n                    double* arf, lapack_int *info );\nvoid LAPACK_stpttf( char* transr, char* uplo, lapack_int* n, const float* ap,\n                    float* arf, lapack_int *info );\nvoid LAPACK_ztpttf( char* transr, char* uplo, lapack_int* n,\n                    const lapack_complex_double* ap, lapack_complex_double* arf,\n                    lapack_int *info );\nvoid LAPACK_ctpttf( char* transr, char* uplo, lapack_int* n,\n                    const lapack_complex_float* ap, lapack_complex_float* arf,\n                    lapack_int *info );\nvoid LAPACK_dtpttr( char* uplo, lapack_int* n, const double* ap, double* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_stpttr( char* uplo, lapack_int* n, const float* ap, float* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_ztpttr( char* uplo, lapack_int* n, const lapack_complex_double* ap,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_ctpttr( char* uplo, lapack_int* n, const lapack_complex_float* ap,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_dtrttf( char* transr, char* uplo, lapack_int* n, const double* a,\n                    lapack_int* lda, double* arf, lapack_int *info );\nvoid LAPACK_strttf( char* transr, char* uplo, lapack_int* n, const float* a,\n                    lapack_int* lda, float* arf, lapack_int *info );\nvoid LAPACK_ztrttf( char* transr, char* uplo, lapack_int* n,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* arf, lapack_int *info );\nvoid LAPACK_ctrttf( char* transr, char* uplo, lapack_int* n,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* arf, lapack_int *info );\nvoid LAPACK_dtrttp( char* uplo, lapack_int* n, const double* a, lapack_int* lda,\n                    double* ap, lapack_int *info );\nvoid LAPACK_strttp( char* uplo, lapack_int* n, const float* a, lapack_int* lda,\n                    float* ap, lapack_int *info );\nvoid LAPACK_ztrttp( char* uplo, lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* ap,\n                    lapack_int *info );\nvoid LAPACK_ctrttp( char* uplo, lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* ap,\n                    lapack_int *info );\nvoid LAPACK_sgeqrfp( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                     float* tau, float* work, lapack_int* lwork,\n                     lapack_int *info );\nvoid LAPACK_dgeqrfp( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                     double* tau, double* work, lapack_int* lwork,\n                     lapack_int *info );\nvoid LAPACK_cgeqrfp( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                     lapack_int* lda, lapack_complex_float* tau,\n                     lapack_complex_float* work, lapack_int* lwork,\n                     lapack_int *info );\nvoid LAPACK_zgeqrfp( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                     lapack_int* lda, lapack_complex_double* tau,\n                     lapack_complex_double* work, lapack_int* lwork,\n                     lapack_int *info );\nvoid LAPACK_clacgv( lapack_int* n, lapack_complex_float* x, lapack_int* incx );\nvoid LAPACK_zlacgv( lapack_int* n, lapack_complex_double* x, lapack_int* incx );\nvoid LAPACK_slarnv( lapack_int* idist, lapack_int* iseed, lapack_int* n,\n                    float* x );\nvoid LAPACK_dlarnv( lapack_int* idist, lapack_int* iseed, lapack_int* n,\n                    double* x );\nvoid LAPACK_clarnv( lapack_int* idist, lapack_int* iseed, lapack_int* n,\n                    lapack_complex_float* x );\nvoid LAPACK_zlarnv( lapack_int* idist, lapack_int* iseed, lapack_int* n,\n                    lapack_complex_double* x );\nvoid LAPACK_sgeqr2( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    float* tau, float* work, lapack_int *info );\nvoid LAPACK_dgeqr2( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    double* tau, double* work, lapack_int *info );\nvoid LAPACK_cgeqr2( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* tau,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zgeqr2( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_slacn2( lapack_int* n, float* v, float* x, lapack_int* isgn,\n                    float* est, lapack_int* kase, lapack_int* isave );\nvoid LAPACK_dlacn2( lapack_int* n, double* v, double* x, lapack_int* isgn,\n                    double* est, lapack_int* kase, lapack_int* isave );\nvoid LAPACK_clacn2( lapack_int* n, lapack_complex_float* v,\n                    lapack_complex_float* x, float* est,\n                    lapack_int* kase, lapack_int* isave );\nvoid LAPACK_zlacn2( lapack_int* n, lapack_complex_double* v,\n                    lapack_complex_double* x, double* est,\n                    lapack_int* kase, lapack_int* isave );\nvoid LAPACK_slacpy( char* uplo, lapack_int* m, lapack_int* n, const float* a,\n                    lapack_int* lda, float* b, lapack_int* ldb );\nvoid LAPACK_dlacpy( char* uplo, lapack_int* m, lapack_int* n, const double* a,\n                    lapack_int* lda, double* b, lapack_int* ldb );\nvoid LAPACK_clacpy( char* uplo, lapack_int* m, lapack_int* n,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb );\nvoid LAPACK_zlacpy( char* uplo, lapack_int* m, lapack_int* n,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb );\n\nvoid LAPACK_clacp2( char* uplo, lapack_int* m, lapack_int* n, const float* a,\n                    lapack_int* lda, lapack_complex_float* b, lapack_int* ldb );\nvoid LAPACK_zlacp2( char* uplo, lapack_int* m, lapack_int* n, const double* a,\n                    lapack_int* lda, lapack_complex_double* b,\n                    lapack_int* ldb );\n\nvoid LAPACK_sgetf2( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_dgetf2( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_cgetf2( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_zgetf2( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv, lapack_int *info );\nvoid LAPACK_slaswp( lapack_int* n, float* a, lapack_int* lda, lapack_int* k1,\n                    lapack_int* k2, const lapack_int* ipiv, lapack_int* incx );\nvoid LAPACK_dlaswp( lapack_int* n, double* a, lapack_int* lda, lapack_int* k1,\n                    lapack_int* k2, const lapack_int* ipiv, lapack_int* incx );\nvoid LAPACK_claswp( lapack_int* n, lapack_complex_float* a, lapack_int* lda,\n                    lapack_int* k1, lapack_int* k2, const lapack_int* ipiv,\n                    lapack_int* incx );\nvoid LAPACK_zlaswp( lapack_int* n, lapack_complex_double* a, lapack_int* lda,\n                    lapack_int* k1, lapack_int* k2, const lapack_int* ipiv,\n                    lapack_int* incx );\nfloat LAPACK_slange( char* norm, lapack_int* m, lapack_int* n, const float* a,\n                    lapack_int* lda, float* work );\ndouble LAPACK_dlange( char* norm, lapack_int* m, lapack_int* n, const double* a,\n                    lapack_int* lda, double* work );\nfloat LAPACK_clange( char* norm, lapack_int* m, lapack_int* n,\n                    const lapack_complex_float* a, lapack_int* lda, float* work );\ndouble LAPACK_zlange( char* norm, lapack_int* m, lapack_int* n,\n                    const lapack_complex_double* a, lapack_int* lda, double* work );\nfloat LAPACK_clanhe( char* norm, char* uplo, lapack_int* n,\n                    const lapack_complex_float* a, lapack_int* lda, float* work );\ndouble LAPACK_zlanhe( char* norm, char* uplo, lapack_int* n,\n                    const lapack_complex_double* a, lapack_int* lda, double* work );\nfloat LAPACK_slansy( char* norm, char* uplo, lapack_int* n, const float* a,\n                    lapack_int* lda, float* work );\ndouble LAPACK_dlansy( char* norm, char* uplo, lapack_int* n, const double* a,\n                    lapack_int* lda, double* work );\nfloat LAPACK_clansy( char* norm, char* uplo, lapack_int* n,\n                    const lapack_complex_float* a, lapack_int* lda, float* work );\ndouble LAPACK_zlansy( char* norm, char* uplo, lapack_int* n,\n                    const lapack_complex_double* a, lapack_int* lda, double* work );\nfloat LAPACK_slantr( char* norm, char* uplo, char* diag, lapack_int* m,\n                    lapack_int* n, const float* a, lapack_int* lda, float* work );\ndouble LAPACK_dlantr( char* norm, char* uplo, char* diag, lapack_int* m,\n                    lapack_int* n, const double* a, lapack_int* lda, double* work );\nfloat LAPACK_clantr( char* norm, char* uplo, char* diag, lapack_int* m,\n                    lapack_int* n, const lapack_complex_float* a, lapack_int* lda,\n                    float* work );\ndouble LAPACK_zlantr( char* norm, char* uplo, char* diag, lapack_int* m,\n                    lapack_int* n, const lapack_complex_double* a, lapack_int* lda,\n                    double* work );\nfloat LAPACK_slamch( char* cmach );\ndouble LAPACK_dlamch( char* cmach );\nvoid LAPACK_sgelq2( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                    float* tau, float* work, lapack_int *info );\nvoid LAPACK_dgelq2( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                    double* tau, double* work, lapack_int *info );\nvoid LAPACK_cgelq2( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* tau,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zgelq2( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* tau,\n                    lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_slarfb( char* side, char* trans, char* direct, char* storev,\n                    lapack_int* m, lapack_int* n, lapack_int* k, const float* v,\n                    lapack_int* ldv, const float* t, lapack_int* ldt, float* c,\n                    lapack_int* ldc, float* work, lapack_int* ldwork );\nvoid LAPACK_dlarfb( char* side, char* trans, char* direct, char* storev,\n                    lapack_int* m, lapack_int* n, lapack_int* k,\n                    const double* v, lapack_int* ldv, const double* t,\n                    lapack_int* ldt, double* c, lapack_int* ldc, double* work,\n                    lapack_int* ldwork );\nvoid LAPACK_clarfb( char* side, char* trans, char* direct, char* storev,\n                    lapack_int* m, lapack_int* n, lapack_int* k,\n                    const lapack_complex_float* v, lapack_int* ldv,\n                    const lapack_complex_float* t, lapack_int* ldt,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* ldwork );\nvoid LAPACK_zlarfb( char* side, char* trans, char* direct, char* storev,\n                    lapack_int* m, lapack_int* n, lapack_int* k,\n                    const lapack_complex_double* v, lapack_int* ldv,\n                    const lapack_complex_double* t, lapack_int* ldt,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work, lapack_int* ldwork );\nvoid LAPACK_slarfg( lapack_int* n, float* alpha, float* x, lapack_int* incx,\n                    float* tau );\nvoid LAPACK_dlarfg( lapack_int* n, double* alpha, double* x, lapack_int* incx,\n                    double* tau );\nvoid LAPACK_clarfg( lapack_int* n, lapack_complex_float* alpha,\n                    lapack_complex_float* x, lapack_int* incx,\n                    lapack_complex_float* tau );\nvoid LAPACK_zlarfg( lapack_int* n, lapack_complex_double* alpha,\n                    lapack_complex_double* x, lapack_int* incx,\n                    lapack_complex_double* tau );\nvoid LAPACK_slarft( char* direct, char* storev, lapack_int* n, lapack_int* k,\n                    const float* v, lapack_int* ldv, const float* tau, float* t,\n                    lapack_int* ldt );\nvoid LAPACK_dlarft( char* direct, char* storev, lapack_int* n, lapack_int* k,\n                    const double* v, lapack_int* ldv, const double* tau,\n                    double* t, lapack_int* ldt );\nvoid LAPACK_clarft( char* direct, char* storev, lapack_int* n, lapack_int* k,\n                    const lapack_complex_float* v, lapack_int* ldv,\n                    const lapack_complex_float* tau, lapack_complex_float* t,\n                    lapack_int* ldt );\nvoid LAPACK_zlarft( char* direct, char* storev, lapack_int* n, lapack_int* k,\n                    const lapack_complex_double* v, lapack_int* ldv,\n                    const lapack_complex_double* tau, lapack_complex_double* t,\n                    lapack_int* ldt );\nvoid LAPACK_slarfx( char* side, lapack_int* m, lapack_int* n, const float* v,\n                    float* tau, float* c, lapack_int* ldc, float* work );\nvoid LAPACK_dlarfx( char* side, lapack_int* m, lapack_int* n, const double* v,\n                    double* tau, double* c, lapack_int* ldc, double* work );\nvoid LAPACK_clarfx( char* side, lapack_int* m, lapack_int* n,\n                    const lapack_complex_float* v, lapack_complex_float* tau,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work );\nvoid LAPACK_zlarfx( char* side, lapack_int* m, lapack_int* n,\n                    const lapack_complex_double* v, lapack_complex_double* tau,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work );\nvoid LAPACK_slag2d( lapack_int* m, lapack_int* n, const float* sa,\n                    lapack_int* ldsa, double* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_dlag2s( lapack_int* m, lapack_int* n, const double* a,\n                    lapack_int* lda, float* sa, lapack_int* ldsa,\n                    lapack_int *info );\nvoid LAPACK_clag2z( lapack_int* m, lapack_int* n,\n                    const lapack_complex_float* sa, lapack_int* ldsa,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_zlag2c( lapack_int* m, lapack_int* n,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_float* sa, lapack_int* ldsa,\n                    lapack_int *info );\nvoid LAPACK_slauum( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_dlauum( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int *info );\nvoid LAPACK_clauum( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_zlauum( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_slascl( char* type, lapack_int* kl, lapack_int* ku, float* cfrom,\n                    float* cto, lapack_int* m, lapack_int* n, float* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_dlascl( char* type, lapack_int* kl, lapack_int* ku, double* cfrom,\n                    double* cto, lapack_int* m, lapack_int* n, double* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_clascl( char* type, lapack_int* kl, lapack_int* ku, float* cfrom,\n                    float* cto, lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_zlascl( char* type, lapack_int* kl, lapack_int* ku, double* cfrom,\n                    double* cto, lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int *info );\nvoid LAPACK_slaset( char* uplo, lapack_int* m, lapack_int* n, float* alpha,\n                    float* beta, float* a, lapack_int* lda );\nvoid LAPACK_dlaset( char* uplo, lapack_int* m, lapack_int* n, double* alpha,\n                    double* beta, double* a, lapack_int* lda );\nvoid LAPACK_claset( char* uplo, lapack_int* m, lapack_int* n,\n                    lapack_complex_float* alpha, lapack_complex_float* beta,\n                    lapack_complex_float* a, lapack_int* lda );\nvoid LAPACK_zlaset( char* uplo, lapack_int* m, lapack_int* n,\n                    lapack_complex_double* alpha, lapack_complex_double* beta,\n                    lapack_complex_double* a, lapack_int* lda );\nvoid LAPACK_slasrt( char* id, lapack_int* n, float* d, lapack_int *info );\nvoid LAPACK_dlasrt( char* id, lapack_int* n, double* d, lapack_int *info );\nvoid LAPACK_slapmr( lapack_logical* forwrd, lapack_int* m, lapack_int* n,\n                    float* x, lapack_int* ldx, lapack_int* k );\nvoid LAPACK_dlapmr( lapack_logical* forwrd, lapack_int* m, lapack_int* n,\n                    double* x, lapack_int* ldx, lapack_int* k );\nvoid LAPACK_clapmr( lapack_logical* forwrd, lapack_int* m, lapack_int* n,\n                    lapack_complex_float* x, lapack_int* ldx, lapack_int* k );\nvoid LAPACK_zlapmr( lapack_logical* forwrd, lapack_int* m, lapack_int* n,\n                    lapack_complex_double* x, lapack_int* ldx, lapack_int* k );\nvoid LAPACK_slapmt( lapack_logical* forwrd, lapack_int* m, lapack_int* n,\n                    float* x, lapack_int* ldx, lapack_int* k );\nvoid LAPACK_dlapmt( lapack_logical* forwrd, lapack_int* m, lapack_int* n,\n                    double* x, lapack_int* ldx, lapack_int* k );\nvoid LAPACK_clapmt( lapack_logical* forwrd, lapack_int* m, lapack_int* n,\n                    lapack_complex_float* x, lapack_int* ldx, lapack_int* k );\nvoid LAPACK_zlapmt( lapack_logical* forwrd, lapack_int* m, lapack_int* n,\n                    lapack_complex_double* x, lapack_int* ldx, lapack_int* k );\nfloat LAPACK_slapy2( float* x, float* y );\ndouble LAPACK_dlapy2( double* x, double* y );\nfloat LAPACK_slapy3( float* x, float* y, float* z );\ndouble LAPACK_dlapy3( double* x, double* y, double* z );\nvoid LAPACK_slartgp( float* f, float* g, float* cs, float* sn, float* r );\nvoid LAPACK_dlartgp( double* f, double* g, double* cs, double* sn, double* r );\nvoid LAPACK_slartgs( float* x, float* y, float* sigma, float* cs, float* sn );\nvoid LAPACK_dlartgs( double* x, double* y, double* sigma, double* cs,\n                     double* sn );\n/* LAPACK 3.3.0 */\nvoid LAPACK_cbbcsd( char* jobu1, char* jobu2,\n                    char* jobv1t, char* jobv2t, char* trans,\n                    lapack_int* m, lapack_int* p, lapack_int* q,\n                    float* theta, float* phi,\n                    lapack_complex_float* u1, lapack_int* ldu1,\n                    lapack_complex_float* u2, lapack_int* ldu2,\n                    lapack_complex_float* v1t, lapack_int* ldv1t,\n                    lapack_complex_float* v2t, lapack_int* ldv2t,\n                    float* b11d, float* b11e, float* b12d,\n                    float* b12e, float* b21d, float* b21e,\n                    float* b22d, float* b22e, float* rwork,\n                    lapack_int* lrwork , lapack_int *info );\nvoid LAPACK_cheswapr( char* uplo, lapack_int* n, lapack_complex_float* a,\n                      lapack_int* lda, lapack_int* i1, lapack_int* i2 );\nvoid LAPACK_chetri2( char* uplo, lapack_int* n,\n                     lapack_complex_float* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     lapack_complex_float* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_chetri2x( char* uplo, lapack_int* n,\n                      lapack_complex_float* a, lapack_int* lda,\n                      const lapack_int* ipiv,\n                      lapack_complex_float* work, lapack_int* nb , lapack_int *info );\nvoid LAPACK_chetrs2( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const lapack_complex_float* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     lapack_complex_float* b, lapack_int* ldb,\n                     lapack_complex_float* work , lapack_int *info );\nvoid LAPACK_csyconv( char* uplo, char* way,\n                     lapack_int* n, lapack_complex_float* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     lapack_complex_float* e , lapack_int *info );\nvoid LAPACK_csyswapr( char* uplo, lapack_int* n,\n                      lapack_complex_float* a, lapack_int* lda,\n                      lapack_int* i1, lapack_int* i2 );\nvoid LAPACK_csytri2( char* uplo, lapack_int* n,\n                     lapack_complex_float* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     lapack_complex_float* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_csytri2x( char* uplo, lapack_int* n,\n                      lapack_complex_float* a, lapack_int* lda,\n                      const lapack_int* ipiv,\n                      lapack_complex_float* work, lapack_int* nb , lapack_int *info );\nvoid LAPACK_csytrs2( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const lapack_complex_float* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     lapack_complex_float* b, lapack_int* ldb,\n                     lapack_complex_float* work , lapack_int *info );\nvoid LAPACK_cunbdb( char* trans, char* signs,\n                    lapack_int* m, lapack_int* p, lapack_int* q,\n                    lapack_complex_float* x11, lapack_int* ldx11,\n                    lapack_complex_float* x12, lapack_int* ldx12,\n                    lapack_complex_float* x21, lapack_int* ldx21,\n                    lapack_complex_float* x22, lapack_int* ldx22,\n                    float* theta, float* phi,\n                    lapack_complex_float* taup1,\n                    lapack_complex_float* taup2,\n                    lapack_complex_float* tauq1,\n                    lapack_complex_float* tauq2,\n                    lapack_complex_float* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_cuncsd( char* jobu1, char* jobu2,\n                    char* jobv1t, char* jobv2t, char* trans,\n                    char* signs, lapack_int* m, lapack_int* p,\n                    lapack_int* q, lapack_complex_float* x11,\n                    lapack_int* ldx11, lapack_complex_float* x12,\n                    lapack_int* ldx12, lapack_complex_float* x21,\n                    lapack_int* ldx21, lapack_complex_float* x22,\n                    lapack_int* ldx22, float* theta,\n                    lapack_complex_float* u1, lapack_int* ldu1,\n                    lapack_complex_float* u2, lapack_int* ldu2,\n                    lapack_complex_float* v1t, lapack_int* ldv1t,\n                    lapack_complex_float* v2t, lapack_int* ldv2t,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    float* rwork, lapack_int* lrwork,\n                    lapack_int* iwork , lapack_int *info );\nvoid LAPACK_cuncsd2by1( char* jobu1, char* jobu2,\n                    char* jobv1t, lapack_int* m, lapack_int* p,\n                    lapack_int* q, lapack_complex_float* x11,\n                    lapack_int* ldx11, lapack_complex_float* x21,\n                    lapack_int* ldx21, float* theta,\n                    lapack_complex_float* u1, lapack_int* ldu1,\n                    lapack_complex_float* u2, lapack_int* ldu2,\n                    lapack_complex_float* v1t, lapack_int* ldv1t,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    float* rwork, lapack_int* lrwork,\n                    lapack_int* iwork , lapack_int *info );\nvoid LAPACK_dbbcsd( char* jobu1, char* jobu2,\n                    char* jobv1t, char* jobv2t, char* trans,\n                    lapack_int* m, lapack_int* p, lapack_int* q,\n                    double* theta, double* phi, double* u1,\n                    lapack_int* ldu1, double* u2, lapack_int* ldu2,\n                    double* v1t, lapack_int* ldv1t, double* v2t,\n                    lapack_int* ldv2t, double* b11d, double* b11e,\n                    double* b12d, double* b12e, double* b21d,\n                    double* b21e, double* b22d, double* b22e,\n                    double* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_dorbdb( char* trans, char* signs,\n                    lapack_int* m, lapack_int* p, lapack_int* q,\n                    double* x11, lapack_int* ldx11, double* x12,\n                    lapack_int* ldx12, double* x21, lapack_int* ldx21,\n                    double* x22, lapack_int* ldx22, double* theta,\n                    double* phi, double* taup1, double* taup2,\n                    double* tauq1, double* tauq2, double* work,\n                    lapack_int* lwork , lapack_int *info );\nvoid LAPACK_dorcsd( char* jobu1, char* jobu2,\n                    char* jobv1t, char* jobv2t, char* trans,\n                    char* signs, lapack_int* m, lapack_int* p,\n                    lapack_int* q, double* x11, lapack_int* ldx11,\n                    double* x12, lapack_int* ldx12, double* x21,\n                    lapack_int* ldx21, double* x22, lapack_int* ldx22,\n                    double* theta, double* u1, lapack_int* ldu1,\n                    double* u2, lapack_int* ldu2, double* v1t,\n                    lapack_int* ldv1t, double* v2t, lapack_int* ldv2t,\n                    double* work, lapack_int* lwork,\n                    lapack_int* iwork , lapack_int *info );\nvoid LAPACK_dorcsd2by1( char* jobu1, char* jobu2,\n                    char* jobv1t, lapack_int* m, lapack_int* p,\n                    lapack_int* q, double* x11, lapack_int* ldx11,\n                    double* x21, lapack_int* ldx21,\n                    double* theta, double* u1, lapack_int* ldu1,\n                    double* u2, lapack_int* ldu2, double* v1t,\n                    lapack_int* ldv1t, double* work, lapack_int* lwork,\n                    lapack_int* iwork , lapack_int *info );\nvoid LAPACK_dsyconv( char* uplo, char* way,\n                     lapack_int* n, double* a, lapack_int* lda,\n                     const lapack_int* ipiv, double* e , lapack_int *info );\nvoid LAPACK_dsyswapr( char* uplo, lapack_int* n, double* a,\n                      lapack_int* lda, lapack_int* i1, lapack_int* i2 );\nvoid LAPACK_dsytri2( char* uplo, lapack_int* n,\n                     double* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     double* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_dsytri2x( char* uplo, lapack_int* n,\n                      double* a, lapack_int* lda,\n                      const lapack_int* ipiv, double* work,\n                      lapack_int* nb , lapack_int *info );\nvoid LAPACK_dsytrs2( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const double* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     double* b, lapack_int* ldb, double* work , lapack_int *info );\nvoid LAPACK_sbbcsd( char* jobu1, char* jobu2,\n                    char* jobv1t, char* jobv2t, char* trans,\n                    lapack_int* m, lapack_int* p, lapack_int* q,\n                    float* theta, float* phi, float* u1,\n                    lapack_int* ldu1, float* u2, lapack_int* ldu2,\n                    float* v1t, lapack_int* ldv1t, float* v2t,\n                    lapack_int* ldv2t, float* b11d, float* b11e,\n                    float* b12d, float* b12e, float* b21d,\n                    float* b21e, float* b22d, float* b22e,\n                    float* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_sorbdb( char* trans, char* signs,\n                    lapack_int* m, lapack_int* p, lapack_int* q,\n                    float* x11, lapack_int* ldx11, float* x12,\n                    lapack_int* ldx12, float* x21, lapack_int* ldx21,\n                    float* x22, lapack_int* ldx22, float* theta,\n                    float* phi, float* taup1, float* taup2,\n                    float* tauq1, float* tauq2, float* work,\n                    lapack_int* lwork , lapack_int *info );\nvoid LAPACK_sorcsd( char* jobu1, char* jobu2,\n                    char* jobv1t, char* jobv2t, char* trans,\n                    char* signs, lapack_int* m, lapack_int* p,\n                    lapack_int* q, float* x11, lapack_int* ldx11,\n                    float* x12, lapack_int* ldx12, float* x21,\n                    lapack_int* ldx21, float* x22, lapack_int* ldx22,\n                    float* theta, float* u1, lapack_int* ldu1,\n                    float* u2, lapack_int* ldu2, float* v1t,\n                    lapack_int* ldv1t, float* v2t, lapack_int* ldv2t,\n                    float* work, lapack_int* lwork,\n                    lapack_int* iwork , lapack_int *info );\nvoid LAPACK_sorcsd2by1( char* jobu1, char* jobu2,\n                    char* jobv1t, lapack_int* m, lapack_int* p,\n                    lapack_int* q, float* x11, lapack_int* ldx11,\n                    float* x21, lapack_int* ldx21,\n                    float* theta, float* u1, lapack_int* ldu1,\n                    float* u2, lapack_int* ldu2, float* v1t,\n                    lapack_int* ldv1t, float* work, lapack_int* lwork,\n                    lapack_int* iwork , lapack_int *info );\nvoid LAPACK_ssyconv( char* uplo, char* way,\n                     lapack_int* n, float* a, lapack_int* lda,\n                     const lapack_int* ipiv, float* e , lapack_int *info );\nvoid LAPACK_ssyswapr( char* uplo, lapack_int* n, float* a,\n                      lapack_int* lda, lapack_int* i1, lapack_int* i2 );\nvoid LAPACK_ssytri2( char* uplo, lapack_int* n,\n                     float* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     float* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_ssytri2x( char* uplo, lapack_int* n,\n                      float* a, lapack_int* lda,\n                      const lapack_int* ipiv, float* work,\n                      lapack_int* nb , lapack_int *info );\nvoid LAPACK_ssytrs2( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const float* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     float* b, lapack_int* ldb, float* work , lapack_int *info );\nvoid LAPACK_zbbcsd( char* jobu1, char* jobu2,\n                    char* jobv1t, char* jobv2t, char* trans,\n                    lapack_int* m, lapack_int* p, lapack_int* q,\n                    double* theta, double* phi,\n                    lapack_complex_double* u1, lapack_int* ldu1,\n                    lapack_complex_double* u2, lapack_int* ldu2,\n                    lapack_complex_double* v1t, lapack_int* ldv1t,\n                    lapack_complex_double* v2t, lapack_int* ldv2t,\n                    double* b11d, double* b11e, double* b12d,\n                    double* b12e, double* b21d, double* b21e,\n                    double* b22d, double* b22e, double* rwork,\n                    lapack_int* lrwork , lapack_int *info );\nvoid LAPACK_zheswapr( char* uplo, lapack_int* n, lapack_complex_double* a,\n                      lapack_int* lda, lapack_int* i1, lapack_int* i2 );\nvoid LAPACK_zhetri2( char* uplo, lapack_int* n,\n                     lapack_complex_double* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     lapack_complex_double* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_zhetri2x( char* uplo, lapack_int* n,\n                      lapack_complex_double* a, lapack_int* lda,\n                      const lapack_int* ipiv,\n                      lapack_complex_double* work, lapack_int* nb , lapack_int *info );\nvoid LAPACK_zhetrs2( char* uplo, lapack_int* n,\n                     lapack_int* nrhs,\n                     const lapack_complex_double* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     lapack_complex_double* b, lapack_int* ldb,\n                     lapack_complex_double* work , lapack_int *info );\nvoid LAPACK_zsyconv( char* uplo, char* way,\n                     lapack_int* n, lapack_complex_double* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     lapack_complex_double* e , lapack_int *info );\nvoid LAPACK_zsyswapr( char* uplo, lapack_int* n, lapack_complex_double* a,\n                      lapack_int* lda, lapack_int* i1,\n                      lapack_int* i2 );\nvoid LAPACK_zsytri2( char* uplo, lapack_int* n,\n                     lapack_complex_double* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     lapack_complex_double* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_zsytri2x( char* uplo, lapack_int* n,\n                      lapack_complex_double* a, lapack_int* lda,\n                      const lapack_int* ipiv,\n                      lapack_complex_double* work, lapack_int* nb , lapack_int *info );\nvoid LAPACK_zsytrs2( char* uplo, lapack_int* n,\n                     lapack_int* nrhs,\n                     const lapack_complex_double* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     lapack_complex_double* b, lapack_int* ldb,\n                     lapack_complex_double* work , lapack_int *info );\nvoid LAPACK_zunbdb( char* trans, char* signs,\n                    lapack_int* m, lapack_int* p, lapack_int* q,\n                    lapack_complex_double* x11, lapack_int* ldx11,\n                    lapack_complex_double* x12, lapack_int* ldx12,\n                    lapack_complex_double* x21, lapack_int* ldx21,\n                    lapack_complex_double* x22, lapack_int* ldx22,\n                    double* theta, double* phi,\n                    lapack_complex_double* taup1,\n                    lapack_complex_double* taup2,\n                    lapack_complex_double* tauq1,\n                    lapack_complex_double* tauq2,\n                    lapack_complex_double* work, lapack_int* lwork , lapack_int *info );\nvoid LAPACK_zuncsd( char* jobu1, char* jobu2,\n                    char* jobv1t, char* jobv2t, char* trans,\n                    char* signs, lapack_int* m, lapack_int* p,\n                    lapack_int* q, lapack_complex_double* x11,\n                    lapack_int* ldx11, lapack_complex_double* x12,\n                    lapack_int* ldx12, lapack_complex_double* x21,\n                    lapack_int* ldx21, lapack_complex_double* x22,\n                    lapack_int* ldx22, double* theta,\n                    lapack_complex_double* u1, lapack_int* ldu1,\n                    lapack_complex_double* u2, lapack_int* ldu2,\n                    lapack_complex_double* v1t, lapack_int* ldv1t,\n                    lapack_complex_double* v2t, lapack_int* ldv2t,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork,\n                    lapack_int* iwork , lapack_int *info );\nvoid LAPACK_zuncsd2by1( char* jobu1, char* jobu2,\n                    char* jobv1t, lapack_int* m, lapack_int* p,\n                    lapack_int* q, lapack_complex_double* x11,\n                    lapack_int* ldx11, lapack_complex_double* x21,\n                    lapack_int* ldx21, double* theta,\n                    lapack_complex_double* u1, lapack_int* ldu1,\n                    lapack_complex_double* u2, lapack_int* ldu2,\n                    lapack_complex_double* v1t, lapack_int* ldv1t,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork,\n                    lapack_int* iwork , lapack_int *info );\n/* LAPACK 3.4.0 */\nvoid LAPACK_sgemqrt( char* side, char* trans, lapack_int* m, lapack_int* n,\n                     lapack_int* k, lapack_int* nb, const float* v,\n                     lapack_int* ldv, const float* t, lapack_int* ldt, float* c,\n                     lapack_int* ldc, float* work, lapack_int *info );\nvoid LAPACK_dgemqrt( char* side, char* trans, lapack_int* m, lapack_int* n,\n                     lapack_int* k, lapack_int* nb, const double* v,\n                     lapack_int* ldv, const double* t, lapack_int* ldt,\n                     double* c, lapack_int* ldc, double* work,\n                     lapack_int *info );\nvoid LAPACK_cgemqrt( char* side, char* trans, lapack_int* m, lapack_int* n,\n                     lapack_int* k, lapack_int* nb,\n                     const lapack_complex_float* v, lapack_int* ldv,\n                     const lapack_complex_float* t, lapack_int* ldt,\n                     lapack_complex_float* c, lapack_int* ldc,\n                     lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zgemqrt( char* side, char* trans, lapack_int* m, lapack_int* n,\n                     lapack_int* k, lapack_int* nb,\n                     const lapack_complex_double* v, lapack_int* ldv,\n                     const lapack_complex_double* t, lapack_int* ldt,\n                     lapack_complex_double* c, lapack_int* ldc,\n                     lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_sgeqrt( lapack_int* m, lapack_int* n, lapack_int* nb, float* a,\n                    lapack_int* lda, float* t, lapack_int* ldt, float* work,\n                    lapack_int *info );\nvoid LAPACK_dgeqrt( lapack_int* m, lapack_int* n, lapack_int* nb, double* a,\n                    lapack_int* lda, double* t, lapack_int* ldt, double* work,\n                    lapack_int *info );\nvoid LAPACK_cgeqrt( lapack_int* m, lapack_int* n, lapack_int* nb,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* t, lapack_int* ldt,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_zgeqrt( lapack_int* m, lapack_int* n, lapack_int* nb,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* t, lapack_int* ldt,\n                    lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_sgeqrt2( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                     float* t, lapack_int* ldt, lapack_int *info );\nvoid LAPACK_dgeqrt2( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                     double* t, lapack_int* ldt, lapack_int *info );\nvoid LAPACK_cgeqrt2( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                     lapack_int* lda, lapack_complex_float* t, lapack_int* ldt,\n                     lapack_int *info );\nvoid LAPACK_zgeqrt2( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                     lapack_int* lda, lapack_complex_double* t, lapack_int* ldt,\n                     lapack_int *info );\nvoid LAPACK_sgeqrt3( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                     float* t, lapack_int* ldt, lapack_int *info );\nvoid LAPACK_dgeqrt3( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                     double* t, lapack_int* ldt, lapack_int *info );\nvoid LAPACK_cgeqrt3( lapack_int* m, lapack_int* n, lapack_complex_float* a,\n                     lapack_int* lda, lapack_complex_float* t, lapack_int* ldt,\n                     lapack_int *info );\nvoid LAPACK_zgeqrt3( lapack_int* m, lapack_int* n, lapack_complex_double* a,\n                     lapack_int* lda, lapack_complex_double* t, lapack_int* ldt,\n                     lapack_int *info );\nvoid LAPACK_stpmqrt( char* side, char* trans, lapack_int* m, lapack_int* n,\n                     lapack_int* k, lapack_int* l, lapack_int* nb,\n                     const float* v, lapack_int* ldv, const float* t,\n                     lapack_int* ldt, float* a, lapack_int* lda, float* b,\n                     lapack_int* ldb, float* work, lapack_int *info );\nvoid LAPACK_dtpmqrt( char* side, char* trans, lapack_int* m, lapack_int* n,\n                     lapack_int* k, lapack_int* l, lapack_int* nb,\n                     const double* v, lapack_int* ldv, const double* t,\n                     lapack_int* ldt, double* a, lapack_int* lda, double* b,\n                     lapack_int* ldb, double* work, lapack_int *info );\nvoid LAPACK_ctpmqrt( char* side, char* trans, lapack_int* m, lapack_int* n,\n                     lapack_int* k, lapack_int* l, lapack_int* nb,\n                     const lapack_complex_float* v, lapack_int* ldv,\n                     const lapack_complex_float* t, lapack_int* ldt,\n                     lapack_complex_float* a, lapack_int* lda,\n                     lapack_complex_float* b, lapack_int* ldb,\n                     lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_ztpmqrt( char* side, char* trans, lapack_int* m, lapack_int* n,\n                     lapack_int* k, lapack_int* l, lapack_int* nb,\n                     const lapack_complex_double* v, lapack_int* ldv,\n                     const lapack_complex_double* t, lapack_int* ldt,\n                     lapack_complex_double* a, lapack_int* lda,\n                     lapack_complex_double* b, lapack_int* ldb,\n                     lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_stpqrt( lapack_int* m, lapack_int* n, lapack_int* l, lapack_int* nb,\n                    float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                    float* t, lapack_int* ldt, float* work, lapack_int *info );\nvoid LAPACK_dtpqrt( lapack_int* m, lapack_int* n, lapack_int* l, lapack_int* nb,\n                    double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                    double* t, lapack_int* ldt, double* work,\n                    lapack_int *info );\nvoid LAPACK_ctpqrt( lapack_int* m, lapack_int* n, lapack_int* l, lapack_int* nb,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* t, lapack_int* ldt,\n                    lapack_complex_float* work, lapack_int *info );\nvoid LAPACK_ztpqrt( lapack_int* m, lapack_int* n, lapack_int* l, lapack_int* nb,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* t, lapack_int* ldt,\n                    lapack_complex_double* work, lapack_int *info );\nvoid LAPACK_stpqrt2( lapack_int* m, lapack_int* n, lapack_int* l,\n                     float* a, lapack_int* lda,\n                     float* b, lapack_int* ldb,\n                     float* t, lapack_int* ldt,\n                     lapack_int *info );\nvoid LAPACK_dtpqrt2( lapack_int* m, lapack_int* n, lapack_int* l,\n                     double* a, lapack_int* lda,\n                     double* b, lapack_int* ldb,\n                     double* t, lapack_int* ldt,\n                     lapack_int *info );\nvoid LAPACK_ctpqrt2( lapack_int* m, lapack_int* n, lapack_int* l,\n                     lapack_complex_float* a, lapack_int* lda,\n                     lapack_complex_float* b, lapack_int* ldb,\n                     lapack_complex_float* t, lapack_int* ldt,\n                     lapack_int *info );\nvoid LAPACK_ztpqrt2( lapack_int* m, lapack_int* n, lapack_int* l,\n                     lapack_complex_double* a, lapack_int* lda,\n                     lapack_complex_double* b, lapack_int* ldb,\n                     lapack_complex_double* t, lapack_int* ldt,\n                     lapack_int *info );\nvoid LAPACK_stprfb( char* side, char* trans, char* direct, char* storev,\n                    lapack_int* m, lapack_int* n, lapack_int* k, lapack_int* l,\n                    const float* v, lapack_int* ldv, const float* t,\n                    lapack_int* ldt, float* a, lapack_int* lda, float* b,\n                    lapack_int* ldb, const float* work,\n                    lapack_int* ldwork );\nvoid LAPACK_dtprfb( char* side, char* trans, char* direct, char* storev,\n                    lapack_int* m, lapack_int* n, lapack_int* k, lapack_int* l,\n                    const double* v, lapack_int* ldv, const double* t,\n                    lapack_int* ldt, double* a, lapack_int* lda, double* b,\n                    lapack_int* ldb, const double* work,\n                    lapack_int* ldwork );\nvoid LAPACK_ctprfb( char* side, char* trans, char* direct, char* storev,\n                    lapack_int* m, lapack_int* n, lapack_int* k, lapack_int* l,\n                    const lapack_complex_float* v, lapack_int* ldv,\n                    const lapack_complex_float* t, lapack_int* ldt,\n                    lapack_complex_float* a, lapack_int* lda,\n                    lapack_complex_float* b, lapack_int* ldb,\n                    lapack_complex_float* work, lapack_int* ldwork );\nvoid LAPACK_ztprfb( char* side, char* trans, char* direct, char* storev,\n                    lapack_int* m, lapack_int* n, lapack_int* k, lapack_int* l,\n                    const lapack_complex_double* v, lapack_int* ldv,\n                    const lapack_complex_double* t, lapack_int* ldt,\n                    lapack_complex_double* a, lapack_int* lda,\n                    lapack_complex_double* b, lapack_int* ldb,\n                    lapack_complex_double* work, lapack_int* ldwork );\n/* LAPACK 3.5.0 */\nvoid LAPACK_ssysv_rook( char* uplo, lapack_int* n, lapack_int* nrhs, float* a,\n                        lapack_int* lda, lapack_int* ipiv, float* b,\n                        lapack_int* ldb, float* work, lapack_int* lwork,\n                        lapack_int *info );\nvoid LAPACK_ssytrf_rook( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* ipiv, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dsysv_rook( char* uplo, lapack_int* n, lapack_int* nrhs, double* a,\n                        lapack_int* lda, lapack_int* ipiv, double* b,\n                        lapack_int* ldb, double* work, lapack_int* lwork,\n                        lapack_int *info );\nvoid LAPACK_dsytrf_rook( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* ipiv, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_csysv_rook( char* uplo, lapack_int* n, lapack_int* nrhs,\n                        lapack_complex_float* a, lapack_int* lda,\n                        lapack_int* ipiv, lapack_complex_float* b,\n                        lapack_int* ldb, lapack_complex_float* work,\n                        lapack_int* lwork, lapack_int *info );\nvoid LAPACK_csytrf_rook( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zsysv_rook( char* uplo, lapack_int* n, lapack_int* nrhs,\n                        lapack_complex_double* a, lapack_int* lda,\n                        lapack_int* ipiv, lapack_complex_double* b,\n                        lapack_int* ldb, lapack_complex_double* work,\n                        lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zsytrf_rook( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_ssytrs_rook( char* uplo, lapack_int* n, lapack_int* nrhs, const float* a,\n                    lapack_int* lda, const lapack_int* ipiv, float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dsytrs_rook( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const double* a, lapack_int* lda, const lapack_int* ipiv,\n                    double* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_csytrs_rook( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zsytrs_rook( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_chetrf_rook( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zhetrf_rook( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_chetrs_rook( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_float* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zhetrs_rook( char* uplo, lapack_int* n, lapack_int* nrhs,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_int* ipiv, lapack_complex_double* b,\n                    lapack_int* ldb, lapack_int *info );\nvoid LAPACK_ilaver( const lapack_int* vers_major, const lapack_int* vers_minor,\n                     const lapack_int* vers_patch );\n\n/* LAPACK 3.7.0 */\nvoid LAPACK_ssysv_aa( char* uplo, lapack_int* n, lapack_int* nrhs, float* a,\n                   lapack_int* lda, lapack_int* ipiv, float* b, lapack_int* ldb,\n                   float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dsysv_aa( char* uplo, lapack_int* n, lapack_int* nrhs, double* a,\n                   lapack_int* lda, lapack_int* ipiv, double* b,\n                   lapack_int* ldb, double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_csysv_aa( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* a, lapack_int* lda, lapack_int* ipiv,\n                   lapack_complex_float* b, lapack_int* ldb,\n                   lapack_complex_float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_zsysv_aa( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* a, lapack_int* lda, lapack_int* ipiv,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_chesv_aa( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* a, lapack_int* lda, lapack_int* ipiv,\n                   lapack_complex_float* b, lapack_int* ldb,\n                   lapack_complex_float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_zhesv_aa( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* a, lapack_int* lda, lapack_int* ipiv,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   lapack_int *info );\n\nvoid LAPACK_ssytrf_aa( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    lapack_int* ipiv, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dsytrf_aa( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    lapack_int* ipiv, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_csytrf_aa( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zsytrf_aa( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_chetrf_aa( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zhetrf_aa( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\n\nvoid LAPACK_ssytrs_aa( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const float* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     float* b, lapack_int* ldb, float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dsytrs_aa( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const double* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     double* b, lapack_int* ldb, double* work, lapack_int* lwork,  lapack_int *info );\nvoid LAPACK_csytrs_aa( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const lapack_complex_float* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     lapack_complex_float* b, lapack_int* ldb,\n                     lapack_complex_float* work , lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zsytrs_aa( char* uplo, lapack_int* n,\n                     lapack_int* nrhs,\n                     const lapack_complex_double* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     lapack_complex_double* b, lapack_int* ldb,\n                     lapack_complex_double* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_chetrs_aa( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const lapack_complex_float* a,\n                     lapack_int* lda, const lapack_int* ipiv,\n                     lapack_complex_float* b, lapack_int* ldb,\n                     lapack_complex_float* work , lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zhetrs_aa( char* uplo, lapack_int* n,\n                     lapack_int* nrhs,\n                     const lapack_complex_double* a, lapack_int* lda,\n                     const lapack_int* ipiv,\n                     lapack_complex_double* b, lapack_int* ldb,\n                     lapack_complex_double* work, lapack_int* lwork, lapack_int *info );\n\nvoid LAPACK_ssysv_rk( char* uplo, lapack_int* n, lapack_int* nrhs, float* a,\n                   lapack_int* lda, float* e, lapack_int* ipiv, float* b, lapack_int* ldb,\n                   float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dsysv_rk( char* uplo, lapack_int* n, lapack_int* nrhs, double* a,\n                   lapack_int* lda, double* e, lapack_int* ipiv, double* b,\n                   lapack_int* ldb, double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_csysv_rk( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* e, lapack_int* ipiv,\n                   lapack_complex_float* b, lapack_int* ldb,\n                   lapack_complex_float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_zsysv_rk( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* e, lapack_int* ipiv,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_chesv_rk( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* e, lapack_int* ipiv,\n                   lapack_complex_float* b, lapack_int* ldb,\n                   lapack_complex_float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_zhesv_rk( char* uplo, lapack_int* n, lapack_int* nrhs,\n                   lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* e, lapack_int* ipiv,\n                   lapack_complex_double* b, lapack_int* ldb,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   lapack_int *info );\n\nvoid LAPACK_ssytrf_rk( char* uplo, lapack_int* n, float* a, lapack_int* lda,\n                    float* e, lapack_int* ipiv, float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_dsytrf_rk( char* uplo, lapack_int* n, double* a, lapack_int* lda,\n                    double* e, lapack_int* ipiv, double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_csytrf_rk( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* e, lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zsytrf_rk( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* e, lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_chetrf_rk( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, lapack_complex_float* e, lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int *info );\nvoid LAPACK_zhetrf_rk( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, lapack_complex_double* e, lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int *info );\n\nvoid LAPACK_ssytrs_3( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const float* a,\n                     lapack_int* lda, const float* e, const lapack_int* ipiv,\n                     float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_dsytrs_3( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const double* a,\n                     lapack_int* lda, const double* e, const lapack_int* ipiv,\n                     double* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_csytrs_3( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const lapack_complex_float* a,\n                     lapack_int* lda, const lapack_complex_float* e,\n                     const lapack_int* ipiv,\n                     lapack_complex_float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zsytrs_3( char* uplo, lapack_int* n,\n                     lapack_int* nrhs,\n                     const lapack_complex_double* a, lapack_int* lda,\n                     const lapack_complex_double* e, const lapack_int* ipiv,\n                     lapack_complex_double* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_chetrs_3( char* uplo, lapack_int* n,\n                     lapack_int* nrhs, const lapack_complex_float* a,\n                     lapack_int* lda, const lapack_complex_float* e,\n                     const lapack_int* ipiv,\n                     lapack_complex_float* b, lapack_int* ldb, lapack_int *info );\nvoid LAPACK_zhetrs_3( char* uplo, lapack_int* n,\n                     lapack_int* nrhs,\n                     const lapack_complex_double* a, lapack_int* lda,\n                     const lapack_complex_double* e,\n                     const lapack_int* ipiv,\n                     lapack_complex_double* b, lapack_int* ldb,  lapack_int *info );\n\nvoid LAPACK_ssytri_3( char* uplo, lapack_int* n, float* a, lapack_int* lda, const float* e, \n                    const lapack_int* ipiv, float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dsytri_3( char* uplo, lapack_int* n, double* a, lapack_int* lda, const double* e,\n                    const lapack_int* ipiv, double* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_csytri_3( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* e, const lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zsytri_3( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* e, const lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_chetri_3( char* uplo, lapack_int* n, lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* e, const lapack_int* ipiv,\n                    lapack_complex_float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_zhetri_3( char* uplo, lapack_int* n, lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* e, const lapack_int* ipiv,\n                    lapack_complex_double* work, lapack_int* lwork, lapack_int *info );\n\nvoid LAPACK_ssycon_3( char* uplo, lapack_int* n, const float* a, lapack_int* lda, const float* e, \n                    const lapack_int* ipiv, float* anorm, float* rcond,\n                    float* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_dsycon_3( char* uplo, lapack_int* n, const double* a, lapack_int* lda, const double* e,\n                    const lapack_int* ipiv, double* anorm, double* rcond,\n                    double* work, lapack_int* iwork, lapack_int *info );\nvoid LAPACK_csycon_3( char* uplo, lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* e, const lapack_int* ipiv, float* anorm,\n                    float* rcond, lapack_complex_float* work,\n                    lapack_int *info );\nvoid LAPACK_zsycon_3( char* uplo, lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* e, const lapack_int* ipiv, double* anorm,\n                    double* rcond, lapack_complex_double* work,\n                    lapack_int *info );\nvoid LAPACK_checon_3( char* uplo, lapack_int* n, const lapack_complex_float* a,\n                    lapack_int* lda, const lapack_complex_float* e, const lapack_int* ipiv, float* anorm,\n                    float* rcond, lapack_complex_float* work,\n                    lapack_int *info );\nvoid LAPACK_zhecon_3( char* uplo, lapack_int* n, const lapack_complex_double* a,\n                    lapack_int* lda, const lapack_complex_double* e, const lapack_int* ipiv, double* anorm,\n                    double* rcond, lapack_complex_double* work,\n                    lapack_int *info );\n\nvoid LAPACK_sgelq( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                   float* t, lapack_int* tsize, float* work, lapack_int* lwork,\n                   lapack_int* info );\nvoid LAPACK_dgelq( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                   double* t, lapack_int* tsize, double* work, lapack_int* lwork,\n                   lapack_int* info );\nvoid LAPACK_cgelq( lapack_int* m, lapack_int* n, lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* t, lapack_int* tsize, lapack_complex_float* work, lapack_int* lwork,\n                   lapack_int* info );\nvoid LAPACK_zgelq( lapack_int* m, lapack_int* n, lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* t, lapack_int* tsize, lapack_complex_double* work, lapack_int* lwork,\n                   lapack_int* info );\n\nvoid LAPACK_sgemlq( char* side, char* trans, lapack_int* m, lapack_int* n, lapack_int* k,\n                    const float* a, lapack_int* lda,\n                    const float* t, lapack_int* tsize,\n                    float* c, lapack_int* ldc,\n                    float* work, lapack_int* lwork,\n                    lapack_int* info );\nvoid LAPACK_dgemlq( char* side, char* trans, lapack_int* m, lapack_int* n, lapack_int* k,\n                    const double* a, lapack_int* lda,\n                    const double* t, lapack_int* tsize,\n                    double* c, lapack_int* ldc,\n                    double* work, lapack_int* lwork,\n                    lapack_int* info );\nvoid LAPACK_cgemlq( char* side, char* trans, lapack_int* m, lapack_int* n, lapack_int* k,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* t, lapack_int* tsize,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int* info );\nvoid LAPACK_zgemlq( char* side, char* trans, lapack_int* m, lapack_int* n, lapack_int* k,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* t, lapack_int* tsize,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int* info );\n\nvoid LAPACK_sgeqr( lapack_int* m, lapack_int* n, float* a, lapack_int* lda,\n                   float* t, lapack_int* tsize, float* work, lapack_int* lwork,\n                   lapack_int* info );\nvoid LAPACK_dgeqr( lapack_int* m, lapack_int* n, double* a, lapack_int* lda,\n                   double* t, lapack_int* tsize, double* work, lapack_int* lwork,\n                   lapack_int* info );\nvoid LAPACK_cgeqr( lapack_int* m, lapack_int* n, lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* t, lapack_int* tsize, lapack_complex_float* work, lapack_int* lwork,\n                   lapack_int* info );\nvoid LAPACK_zgeqr( lapack_int* m, lapack_int* n, lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* t, lapack_int* tsize, lapack_complex_double* work, lapack_int* lwork,\n                   lapack_int* info );\n\nvoid LAPACK_sgemqr( char* side, char* trans, lapack_int* m, lapack_int* n, lapack_int* k,\n                    const float* a, lapack_int* lda,\n                    const float* t, lapack_int* tsize,\n                    float* c, lapack_int* ldc,\n                    float* work, lapack_int* lwork,\n                    lapack_int* info );\nvoid LAPACK_dgemqr( char* side, char* trans, lapack_int* m, lapack_int* n, lapack_int* k,\n                    const double* a, lapack_int* lda,\n                    const double* t, lapack_int* tsize,\n                    double* c, lapack_int* ldc,\n                    double* work, lapack_int* lwork,\n                    lapack_int* info );\nvoid LAPACK_cgemqr( char* side, char* trans, lapack_int* m, lapack_int* n, lapack_int* k,\n                    const lapack_complex_float* a, lapack_int* lda,\n                    const lapack_complex_float* t, lapack_int* tsize,\n                    lapack_complex_float* c, lapack_int* ldc,\n                    lapack_complex_float* work, lapack_int* lwork,\n                    lapack_int* info );\nvoid LAPACK_zgemqr( char* side, char* trans, lapack_int* m, lapack_int* n, lapack_int* k,\n                    const lapack_complex_double* a, lapack_int* lda,\n                    const lapack_complex_double* t, lapack_int* tsize,\n                    lapack_complex_double* c, lapack_int* ldc,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    lapack_int* info );\n\nvoid LAPACK_sgetsls( char* trans, lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                     float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                     float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dgetsls( char* trans, lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                     double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                     double* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_cgetsls( char* trans, lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                     lapack_complex_float* a, lapack_int* lda,\n                     lapack_complex_float* b, lapack_int* ldb,\n                     lapack_complex_float* work, lapack_int* lwork,\n                     lapack_int *info );\nvoid LAPACK_zgetsls( char* trans, lapack_int* m, lapack_int* n, lapack_int* nrhs,\n                     lapack_complex_double* a, lapack_int* lda,\n                     lapack_complex_double* b, lapack_int* ldb,\n                     lapack_complex_double* work, lapack_int* lwork,\n                     lapack_int *info );\n\nvoid LAPACK_ssyev_2stage( char* jobz, char* uplo, lapack_int* n, float* a,\n                   lapack_int* lda, float* w, float* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_dsyev_2stage( char* jobz, char* uplo, lapack_int* n, double* a,\n                   lapack_int* lda, double* w, double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_cheev_2stage( char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_float* a, lapack_int* lda, float* w,\n                   lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                   lapack_int *info );\nvoid LAPACK_zheev_2stage( char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_double* a, lapack_int* lda, double* w,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   double* rwork, lapack_int *info );\nvoid LAPACK_ssyevd_2stage( char* jobz, char* uplo, lapack_int* n, float* a,\n                    lapack_int* lda, float* w, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dsyevd_2stage( char* jobz, char* uplo, lapack_int* n, double* a,\n                    lapack_int* lda, double* w, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_cheevd_2stage( char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda, float* w,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zheevd_2stage( char* jobz, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda, double* w,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ssyevx_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    float* a, lapack_int* lda, float* vl, float* vu,\n                    lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, float* z, lapack_int* ldz,\n                    float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_dsyevx_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    double* a, lapack_int* lda, double* vl, double* vu,\n                    lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, double* z, lapack_int* ldz,\n                    double* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_cheevx_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda, float* vl,\n                    float* vu, lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_complex_float* work,\n                    lapack_int* lwork, float* rwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_zheevx_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda, double* vl,\n                    double* vu, lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_complex_double* work,\n                    lapack_int* lwork, double* rwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_ssyevr_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    float* a, lapack_int* lda, float* vl, float* vu,\n                    lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, float* z, lapack_int* ldz,\n                    lapack_int* isuppz, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dsyevr_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    double* a, lapack_int* lda, double* vl, double* vu,\n                    lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, double* z, lapack_int* ldz,\n                    lapack_int* isuppz, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_cheevr_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_float* a, lapack_int* lda, float* vl,\n                    float* vu, lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_int* isuppz,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zheevr_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_complex_double* a, lapack_int* lda, double* vl,\n                    double* vu, lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_int* isuppz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ssbev_2stage( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                   float* ab, lapack_int* ldab, float* w, float* z,\n                   lapack_int* ldz, float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dsbev_2stage( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                   double* ab, lapack_int* ldab, double* w, double* z,\n                   lapack_int* ldz, double* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_chbev_2stage( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                   lapack_complex_float* ab, lapack_int* ldab, float* w,\n                   lapack_complex_float* z, lapack_int* ldz,\n                   lapack_complex_float* work, lapack_int* lwork, float* rwork, lapack_int *info );\nvoid LAPACK_zhbev_2stage( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                   lapack_complex_double* ab, lapack_int* ldab, double* w,\n                   lapack_complex_double* z, lapack_int* ldz,\n                   lapack_complex_double* work, lapack_int* lwork, double* rwork,\n                   lapack_int *info );\nvoid LAPACK_ssbevd_2stage( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                    float* ab, lapack_int* ldab, float* w, float* z,\n                    lapack_int* ldz, float* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_dsbevd_2stage( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                    double* ab, lapack_int* ldab, double* w, double* z,\n                    lapack_int* ldz, double* work, lapack_int* lwork,\n                    lapack_int* iwork, lapack_int* liwork, lapack_int *info );\nvoid LAPACK_chbevd_2stage( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_complex_float* ab, lapack_int* ldab, float* w,\n                    lapack_complex_float* z, lapack_int* ldz,\n                    lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* lrwork, lapack_int* iwork, lapack_int* liwork,\n                    lapack_int *info );\nvoid LAPACK_zhbevd_2stage( char* jobz, char* uplo, lapack_int* n, lapack_int* kd,\n                    lapack_complex_double* ab, lapack_int* ldab, double* w,\n                    lapack_complex_double* z, lapack_int* ldz,\n                    lapack_complex_double* work, lapack_int* lwork,\n                    double* rwork, lapack_int* lrwork, lapack_int* iwork,\n                    lapack_int* liwork, lapack_int *info );\nvoid LAPACK_ssbevx_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* kd, float* ab, lapack_int* ldab, float* q,\n                    lapack_int* ldq, float* vl, float* vu, lapack_int* il,\n                    lapack_int* iu, float* abstol, lapack_int* m, float* w,\n                    float* z, lapack_int* ldz, float* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_dsbevx_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* kd, double* ab, lapack_int* ldab, double* q,\n                    lapack_int* ldq, double* vl, double* vu, lapack_int* il,\n                    lapack_int* iu, double* abstol, lapack_int* m, double* w,\n                    double* z, lapack_int* ldz, double* work, lapack_int* lwork, lapack_int* iwork,\n                    lapack_int* ifail, lapack_int *info );\nvoid LAPACK_chbevx_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* kd, lapack_complex_float* ab, lapack_int* ldab,\n                    lapack_complex_float* q, lapack_int* ldq, float* vl,\n                    float* vu, lapack_int* il, lapack_int* iu, float* abstol,\n                    lapack_int* m, float* w, lapack_complex_float* z,\n                    lapack_int* ldz, lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_zhbevx_2stage( char* jobz, char* range, char* uplo, lapack_int* n,\n                    lapack_int* kd, lapack_complex_double* ab, lapack_int* ldab,\n                    lapack_complex_double* q, lapack_int* ldq, double* vl,\n                    double* vu, lapack_int* il, lapack_int* iu, double* abstol,\n                    lapack_int* m, double* w, lapack_complex_double* z,\n                    lapack_int* ldz, lapack_complex_double* work, lapack_int* lwork, double* rwork,\n                    lapack_int* iwork, lapack_int* ifail, lapack_int *info );\nvoid LAPACK_ssygv_2stage( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   float* a, lapack_int* lda, float* b, lapack_int* ldb,\n                   float* w, float* work, lapack_int* lwork, lapack_int *info );\nvoid LAPACK_dsygv_2stage( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   double* a, lapack_int* lda, double* b, lapack_int* ldb,\n                   double* w, double* work, lapack_int* lwork,\n                   lapack_int *info );\nvoid LAPACK_chegv_2stage( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_float* a, lapack_int* lda,\n                   lapack_complex_float* b, lapack_int* ldb, float* w,\n                   lapack_complex_float* work, lapack_int* lwork, float* rwork,\n                   lapack_int *info );\nvoid LAPACK_zhegv_2stage( lapack_int* itype, char* jobz, char* uplo, lapack_int* n,\n                   lapack_complex_double* a, lapack_int* lda,\n                   lapack_complex_double* b, lapack_int* ldb, double* w,\n                   lapack_complex_double* work, lapack_int* lwork,\n                   double* rwork, lapack_int *info );\n\n#endif /* !defined(MW_HAVE_LAPACK_DECLS) && !defined(mllapack_h) */\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _LAPACKE_H_ */\n"},{"name":"lapacke_config.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*****************************************************************************\n  Copyright (c) 2010, Intel Corp.\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of Intel Corporation nor the names of its contributors\n      may be used to endorse or promote products derived from this software\n      without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n  THE POSSIBILITY OF SUCH DAMAGE.\n******************************************************************************\n* Contents: Native C interface to LAPACK\n* Author: Intel Corporation\n* Generated May, 2011\n*****************************************************************************/\n\n#ifndef _LAPACKE_CONFIG_H_\n#define _LAPACKE_CONFIG_H_\n\n#ifdef __cplusplus\n#if defined(LAPACK_COMPLEX_CPP)\n#include <complex>\n#endif\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include <stdlib.h>\n#include <stddef.h>\n\n#ifndef lapack_int\n#define lapack_int              ptrdiff_t\n#endif\n\n#ifndef lapack_logical\n#define lapack_logical          lapack_int\n#endif\n\n#ifndef LAPACK_COMPLEX_CUSTOM\n\n#if defined(LAPACK_COMPLEX_STRUCTURE)\n\ntypedef struct { float real, imag; } _lapack_complex_float;\ntypedef struct { double real, imag; } _lapack_complex_double;\n#define lapack_complex_float  _lapack_complex_float\n#define lapack_complex_double _lapack_complex_double\n#define lapack_complex_float_real(z)  ((z).real)\n#define lapack_complex_float_imag(z)  ((z).imag)\n#define lapack_complex_double_real(z)  ((z).real)\n#define lapack_complex_double_imag(z)  ((z).imag)\n\n#elif defined(LAPACK_COMPLEX_C99)\n\n#include <complex.h>\n#define lapack_complex_float    float _Complex\n#define lapack_complex_double   double _Complex\n#define lapack_complex_float_real(z)       (creal(z))\n#define lapack_complex_float_imag(z)       (cimag(z))\n#define lapack_complex_double_real(z)       (creal(z))\n#define lapack_complex_double_imag(z)       (cimag(z))\n\n#elif defined(LAPACK_COMPLEX_CPP)\n\n#define lapack_complex_float std::complex<float>\n#define lapack_complex_double std::complex<double>\n#define lapack_complex_float_real(z)       ((z).real())\n#define lapack_complex_float_imag(z)       ((z).imag())\n#define lapack_complex_double_real(z)       ((z).real())\n#define lapack_complex_double_imag(z)       ((z).imag())\n\n#else\n\n#include <complex.h>\n#define lapack_complex_float    float _Complex\n#define lapack_complex_double   double _Complex\n#define lapack_complex_float_real(z)       (creal(z))\n#define lapack_complex_float_imag(z)       (cimag(z))\n#define lapack_complex_double_real(z)       (creal(z))\n#define lapack_complex_double_imag(z)       (cimag(z))\n\n#endif\n\nlapack_complex_float lapack_make_complex_float( float re, float im );\nlapack_complex_double lapack_make_complex_double( double re, double im );\n\n#endif\n\n#ifndef LAPACK_malloc\n#define LAPACK_malloc( size )   malloc( size )\n#endif\n\n#ifndef LAPACK_free\n#define LAPACK_free( p )        free( p )\n#endif\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _LAPACKE_CONFIG_H_ */\n"},{"name":"libmwboxfilter.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2014-2017 The MathWorks, Inc. */\n\n#ifndef _LIBMWBOXFILTER_H_\n#define _LIBMWBOXFILTER_H_\n\n\n#ifndef LIBMWBOXFILTER_API\n#    define LIBMWBOXFILTER_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n\n/* uint8_T */\nEXTERN_C LIBMWBOXFILTER_API void boxfilter_uint8(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,\n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            uint8_T*    outBuf,\n      const real64_T*   outDims,\n      const real64_T    nPlanes);\n\n/* int8_T */\nEXTERN_C LIBMWBOXFILTER_API void boxfilter_int8(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,\n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            int8_T*     outBuf,\n      const real64_T*   outDims,\n      const real64_T    nPlanes);\n\n/* uint16_T */\nEXTERN_C LIBMWBOXFILTER_API void boxfilter_uint16(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,\n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            uint16_T*   outBuf,\n      const real64_T*   outDims,\n      const real64_T    nPlanes);\n\n/* int16_T */\nEXTERN_C LIBMWBOXFILTER_API void boxfilter_int16(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,\n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            int16_T*    outBuf,\n      const real64_T*   outDims,\n      const real64_T    nPlanes);\n\n/* uint32_T */\nEXTERN_C LIBMWBOXFILTER_API void boxfilter_uint32(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,\n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            uint32_T*   outBuf,\n      const real64_T*   outDims,\n      const real64_T    nPlanes);\n\n/* int32_T */\nEXTERN_C LIBMWBOXFILTER_API void boxfilter_int32(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,\n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            int32_T*    outBuf,\n      const real64_T*   outDims,\n      const real64_T    nPlanes);\n\n/* real32_T */\nEXTERN_C LIBMWBOXFILTER_API void boxfilter_real32(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,\n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            real32_T*   outBuf,\n      const real64_T*   outDims,\n      const real64_T    nPlanes);\n\n/*  real64_T */\nEXTERN_C LIBMWBOXFILTER_API void boxfilter_real64(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,\n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            real64_T*   outBuf,\n      const real64_T*   outDims,\n      const real64_T    nPlanes);\n\n#endif\n"},{"name":"libmwboxfilter3.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2014-2015 The MathWorks, Inc. */\n\n#ifndef _LIBMWBOXFILTER3_H_\n#define _LIBMWBOXFILTER3_H_\n\n\n#ifndef LIBMWBOXFILTER3_API\n#    define LIBMWBOXFILTER3_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#include <tmwtypes.h>\n\n\n/* uint8_T */\nEXTERN_C LIBMWBOXFILTER3_API void boxfilter3_uint8(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,  \n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            uint8_T*    outBuf,\n      const real64_T*   outDims);\n\n/* int8_T */\nEXTERN_C LIBMWBOXFILTER3_API void boxfilter3_int8(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,  \n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            int8_T*     outBuf,\n      const real64_T*   outDims);\n\n/* uint16_T */\nEXTERN_C LIBMWBOXFILTER3_API void boxfilter3_uint16(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,  \n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            uint16_T*   outBuf,\n      const real64_T*   outDims);\n\n/* int16_T */\nEXTERN_C LIBMWBOXFILTER3_API void boxfilter3_int16(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,  \n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            int16_T*    outBuf,\n      const real64_T*   outDims);\n\n/* uint32_T */\nEXTERN_C LIBMWBOXFILTER3_API void boxfilter3_uint32(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,  \n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            uint32_T*   outBuf,\n      const real64_T*   outDims);\n\n/* int32_T */\nEXTERN_C LIBMWBOXFILTER3_API void boxfilter3_int32(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,  \n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            int32_T*    outBuf,\n      const real64_T*   outDims);\n\n/* real32_T */\nEXTERN_C LIBMWBOXFILTER3_API void boxfilter3_real32(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,  \n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            real32_T*   outBuf,\n      const real64_T*   outDims);\n\n/*  real64_T */\nEXTERN_C LIBMWBOXFILTER3_API void boxfilter3_real64(\n      const real64_T*   intImageBuf,\n      const real64_T*   intImageDims,  \n      const real64_T*   kernelDims,\n      const real64_T    kernelWeight,\n      const real64_T*   pre,\n            real64_T*   outBuf,\n      const real64_T*   outDims);\n\n#endif\n"},{"name":"libmwbwdistEDT.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n\n#ifndef _BWDISTEDT_\n#define _BWDISTEDT_\n\n\n#ifndef LIBMWBWDISTEDT_API\n#    define LIBMWBWDISTEDT_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWBWDISTEDT_API\nvoid bwdistEDT_boolean(const boolean_T* bw,         /** Pointer to bw image */\n\t\t       const real64_T* input_size,  /** Pointer to bw image size */\n\t\t       const real64_T num_dims,     /** Number of dimensions in image */\n\t\t       real32_T* d);                /** Output - distance to nearest non-zero pixel */\n\n\n#endif\n"},{"name":"libmwbwdistEDTFT.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2019 The MathWorks, Inc. */\n\n#ifndef _BWDISTEDTFT_\n#define _BWDISTEDTFT_\n\n\n#ifndef LIBMWBWDISTEDTFT_API\n#    define LIBMWBWDISTEDTFT_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* uint32_T */\nEXTERN_C LIBMWBWDISTEDTFT_API\nvoid bwdistEDTFT32_boolean(const boolean_T* bw,        /** Pointer to bw image */\n                           const real64_T* input_size, /** Pointer to bw image size */\n                           const real64_T num_dims,    /** Number of dimensions in image */\n                           real32_T* d,                /** Output - distance to nearest non-zero pixel */\n                           uint32_T* labels);          /** Output - label, feature transform (linear index to nearest non-zero pixel). Pass NULL to skip this computation. */\n\n#endif\n"},{"name":"libmwbwdistEDTFT_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2019 The MathWorks, Inc. */\n\n#ifndef _BWDISTEDTFT_TBB_\n#define _BWDISTEDTFT_TBB_\n\n\n#ifndef LIBMWBWDISTEDTFT_TBB_API\n#    define LIBMWBWDISTEDTFT_TBB_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* uint32_T */\nEXTERN_C LIBMWBWDISTEDTFT_TBB_API\nvoid bwdistEDTFT32_tbb_boolean(const boolean_T* bw,     /** Pointer to bw image */\n                           const real64_T* input_size,  /** Pointer to bw image size */\n                           const real64_T num_dims,     /** Number of dimensions in image */\n                           real32_T* d,                 /** Output - distance to nearest non-zero pixel */\n                           uint32_T* labels);           /** Output - label, feature transform (linear index to nearest non-zero pixel). Pass NULL to skip this computation. */\n\n#endif\n"},{"name":"libmwbwdistEDT_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n\n#ifndef _BWDISTEDT_TBB_\n#define _BWDISTEDT_TBB_\n\n\n#ifndef LIBMWBWDISTEDT_TBB_API\n#    define LIBMWBWDISTEDT_TBB_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWBWDISTEDT_TBB_API\nvoid bwdistEDT_tbb_boolean(const boolean_T* bw,     /** Pointer to bw image */\n\t\t       const real64_T* input_size,          /** Pointer to bw image size */\n\t\t       const real64_T num_dims,             /** Number of dimensions in image */\n\t\t       real32_T* d);                        /** Output - distance to nearest non-zero pixel */\n\n\n#endif\n"},{"name":"libmwbwlookup.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, inc. */\n#ifndef _BWLOOKUP_H_\n#define _BWLOOKUP_H_\n\n#ifndef LIBMWBWLOOKUP_API\n#    define LIBMWBWLOOKUP_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/*\n * inNumDims should be 2\n * lutLength should be 16 or 512\n */\n\n/* boolean_T */\nEXTERN_C LIBMWBWLOOKUP_API\nvoid bwlookup_boolean(const boolean_T* const in,\n        const real64_T*  const inDims,\n        const real64_T         inNumDims,\n        const boolean_T* const lut,\n        const real64_T         lutLength,\n        boolean_T*             out);\n/* uint8_T */\nEXTERN_C LIBMWBWLOOKUP_API\nvoid bwlookup_uint8(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const uint8_T* const   lut,\n        const real64_T         lutLength,\n        uint8_T*             out);\n/* uint16_T */\nEXTERN_C LIBMWBWLOOKUP_API\nvoid bwlookup_uint16(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const uint16_T* const  lut,\n        const real64_T         lutLength,\n        uint16_T*             out);\n/* uint32_T */\nEXTERN_C LIBMWBWLOOKUP_API\nvoid bwlookup_uint32(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const uint32_T* const  lut,\n        const real64_T         lutLength,\n        uint32_T*             out);\n/* int8_T */\nEXTERN_C LIBMWBWLOOKUP_API\nvoid bwlookup_int8(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const int8_T* const    lut,\n        const real64_T         lutLength,\n        int8_T*             out);\n/* int16_T */\nEXTERN_C LIBMWBWLOOKUP_API\nvoid bwlookup_int16(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const int16_T* const   lut,\n        const real64_T         lutLength,\n        int16_T*             out);\n/* int32_T */\nEXTERN_C LIBMWBWLOOKUP_API\nvoid bwlookup_int32(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const int32_T* const   lut,\n        const real64_T         lutLength,\n        int32_T*             out);\n/* real32_T */\nEXTERN_C LIBMWBWLOOKUP_API\nvoid bwlookup_real32(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const real32_T* const  lut,\n        const real64_T         lutLength,\n        real32_T*             out);\n/* real64_T */\nEXTERN_C LIBMWBWLOOKUP_API\nvoid bwlookup_real64(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const real64_T* const  lut,\n        const real64_T         lutLength,\n        real64_T*             out);\n\n#endif\n"},{"name":"libmwbwlookup_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2014 The MathWorks, inc. */\n#ifndef _BWLOOKUP_TBB_H_\n#define _BWLOOKUP_TBB_H_\n\n#ifndef LIBMWBWLOOKUP_TBB_API\n#    define LIBMWBWLOOKUP_TBB_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/*\n * inNumDims should be 2\n * lutLength should be 16 or 512\n */\n\n/* boolean_T */\nEXTERN_C LIBMWBWLOOKUP_TBB_API\nvoid bwlookup_tbb_boolean(const boolean_T* const in,\n        const real64_T*  const inDims,\n        const real64_T         inNumDims,\n        const boolean_T* const lut,\n        const real64_T         lutLength,\n        boolean_T*             out);\n/* uint8_T */\nEXTERN_C LIBMWBWLOOKUP_TBB_API\nvoid bwlookup_tbb_uint8(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const uint8_T* const   lut,\n        const real64_T         lutLength,\n        uint8_T*             out);\n/* uint16_T */\nEXTERN_C LIBMWBWLOOKUP_TBB_API\nvoid bwlookup_tbb_uint16(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const uint16_T* const  lut,\n        const real64_T         lutLength,\n        uint16_T*             out);\n/* uint32_T */\nEXTERN_C LIBMWBWLOOKUP_TBB_API\nvoid bwlookup_tbb_uint32(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const uint32_T* const  lut,\n        const real64_T         lutLength,\n        uint32_T*             out);\n/* int8_T */\nEXTERN_C LIBMWBWLOOKUP_TBB_API\nvoid bwlookup_tbb_int8(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const int8_T* const    lut,\n        const real64_T         lutLength,\n        int8_T*             out);\n/* int16_T */\nEXTERN_C LIBMWBWLOOKUP_TBB_API\nvoid bwlookup_tbb_int16(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const int16_T* const   lut,\n        const real64_T         lutLength,\n        int16_T*             out);\n/* int32_T */\nEXTERN_C LIBMWBWLOOKUP_TBB_API\nvoid bwlookup_tbb_int32(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const int32_T* const   lut,\n        const real64_T         lutLength,\n        int32_T*             out);\n/* real32_T */\nEXTERN_C LIBMWBWLOOKUP_TBB_API\nvoid bwlookup_tbb_real32(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const real32_T* const  lut,\n        const real64_T         lutLength,\n        real32_T*             out);\n/* real64_T */\nEXTERN_C LIBMWBWLOOKUP_TBB_API\nvoid bwlookup_tbb_real64(const boolean_T* const in,\n        const real64_T* const  inDims,\n        const real64_T         inNumDims,\n        const real64_T* const  lut,\n        const real64_T         lutLength,\n        real64_T*             out);\n\n#endif\n"},{"name":"libmwbwpackc.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _BWPACKC_H_\n#define _BWPACKC_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWBWPACKC_API\n#    define LIBMWBWPACKC_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWBWPACKC_API void bwPacking(const boolean_T *BW,\n\t\t\t\t\t\t\t\t\t\t\tconst real64_T *inSize,\n\t\t\t\t\t\t\t\t\t\t\tuint32_T *outputBuffer,\n\t\t\t\t\t\t\t\t\t\t\tconst real64_T *outSize,\n                                            const boolean_T isColumnMajor);\n#endif /* _BWPACKC_H_ */\n"},{"name":"libmwbwpackctbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _BWPACKCTBB_H_\n#define _BWPACKCTBB_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWBWPACKCTBB_API\n#    define LIBMWBWPACKCTBB_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWBWPACKCTBB_API void bwPackingtbb(const boolean_T *BW,\n                                               const real64_T *inSize,\n                                               uint32_T *outputBuffer,\n                                               const real64_T *outSize,\n                                               const boolean_T isColumnMajor);\n\n#endif /* _BWPACKCTBB_H_ */\n"},{"name":"libmwbwunpackc.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _BWUNPACKC_H_\n#define _BWUNPACKC_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWBWUNPACKC_API\n#    define LIBMWBWUNPACKC_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWBWUNPACKC_API void bwUnpacking(const uint32_T *inputBuffer,\n                                             const real64_T *inSize,\n                                             boolean_T *BW,\n                                             const real64_T *outSize,\n                                             const boolean_T isColumnMajor);\n\n\n#endif /* _BWUNPACKC_H_ */\n"},{"name":"libmwbwunpackctbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _BWUNPACKCTBB_H_\n#define _BWUNPACKCTBB_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWBWUNPACKCTBB_API\n#    define LIBMWBWUNPACKCTBB_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWBWUNPACKCTBB_API void bwUnpackingtbb(const uint32_T *inputBuffer,\n                                                   const real64_T *inSize,\n\t\t\t\t\t\t\t\t\t\t\t\t   boolean_T *BW,\n                                                   const real64_T *outSize,\n                                                   const boolean_T isColumnMajor);\n\n\n#endif /* _BWUNPACKCTBB_H_ */\n"},{"name":"libmwcannythresholding_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n\n#ifndef _CANNYTHRESHOLDING_TBB_H_\n#define _CANNYTHRESHOLDING_TBB_H_\n\n\n#ifndef LIBMWCANNYTHRESHOLDING_TBB_API\n#    define LIBMWCANNYTHRESHOLDING_TBB_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* \n * API Description\n * ---------------\n *\n * pDx          -   Pointer to input image filtered by derivative of \n *                  Gaussian along x.\n * pDy          -   Pointer to input image filtered by derivative of \n *                  Gaussian along y.\n * pMag         -   Pointer to gradient magnitude image.\n * pSize        -   Pointer to 2 element array containing size of input \n *                  image. This represents the size of Dx, Dy, Mag and E.\n * lowThresh    -   Low threshold to be used to identify weak edges.\n * pE           -   Pointer to output edge map. All elements in the image \n *                  buffer are expected to be initialized to 0 (false).\n * \n */\n\n\n/*real32*/\nEXTERN_C LIBMWCANNYTHRESHOLDING_TBB_API void cannythresholding_real32_tbb(\n    const\treal32_T\t*\tpDx,\n\tconst\treal32_T\t*\tpDy,\n\tconst\treal32_T\t*\tpMag,\n    const   real64_T    *   pSize,\n\tconst\treal64_T\t\tlowThresh,\n            boolean_T\t*\tpE);\n\n/*real64*/\nEXTERN_C LIBMWCANNYTHRESHOLDING_TBB_API void cannythresholding_real64_tbb(\n    const\treal64_T\t*\tpDx,\n\tconst\treal64_T\t*\tpDy,\n\tconst\treal64_T\t*\tpMag,\n    const   real64_T    *   pSize,    \n\tconst\treal64_T\t\tlowThresh,\n            boolean_T\t*\tpE);\n\n#endif\n"},{"name":"libmwddist.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n\n#ifndef _DDIST_\n#define _DDIST_\n\n\n#ifndef LIBMWDDIST_API\n#    define LIBMWDDIST_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* uint32_T */\nEXTERN_C LIBMWDDIST_API\nvoid ddist32_boolean(const boolean_T* bw,        /** Pointer to bw image */\n\t\t     const real64_T* input_size, /** Pointer to bw image size */\n\t\t     const real64_T num_dims,    /** Number of dimensions in image */\n\t\t     const boolean_T* conn,      /** Pointer to binary connectivity array */\n\t\t     const real64_T* conn_size,  /** Pointer to connectivity size */\n\t\t     const real64_T conn_dims,   /** connectivity dimensions */\n\t\t     const real64_T* inweights,  /** Pointer to weights. Same size as conn */\n\t\t     real32_T* d,                /** Output - distance to nearest non-zero pixel */\n\t\t     uint32_T* labels);          /** Output - label, feature transform (linear index to nearest non-zero pixel). Pass NULL to skip this computation. */\n\n\n#endif\n"},{"name":"libmwedgesobelprewitt_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2016 The MathWorks, Inc. */\n\n#ifndef _EDGESOBELPREWITT_TBB_H_\n#define _EDGESOBELPREWITT_TBB_H_\n\n\n#ifndef LIBMWEDGESOBELPREWITT_TBB_API\n#    define LIBMWEDGESOBELPREWITT_TBB_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/*real32*/\nEXTERN_C LIBMWEDGESOBELPREWITT_TBB_API void edgesobelprewitt_real32_tbb(\n    const   real32_T          *    pImage,\n    const   real64_T          *    srcSize,\n    const   boolean_T              isSobel,\n    const   real64_T               kx,\n    const   real64_T               ky,        \n            real32_T          *    pGradientX,\n            real32_T          *    pGradientY,\n            real32_T          *    pMagnitude);\n\n/*real64*/\nEXTERN_C LIBMWEDGESOBELPREWITT_TBB_API void edgesobelprewitt_real64_tbb(\n    const   real64_T          *    pImage,\n    const   real64_T          *    srcSize,\n\tconst   boolean_T              isSobel,\n    const   real64_T               kx,\n    const   real64_T               ky,        \n            real64_T          *    pGradientX,\n            real64_T          *    pGradientY,\n            real64_T          *    pMagnitude);\n/*bool*/\nEXTERN_C LIBMWEDGESOBELPREWITT_TBB_API void edgesobelprewitt_boolean_tbb(\n\tconst   boolean_T         *    pImage,\n    const   real64_T          *    srcSize,\n\tconst   boolean_T              isSobel,\n    const   real64_T               kx,\n    const   real64_T               ky,        \n            real32_T          *    pGradientX,\n            real32_T          *    pGradientY,\n            real32_T          *    pMagnitude);\n/*uint8*/\nEXTERN_C LIBMWEDGESOBELPREWITT_TBB_API void edgesobelprewitt_uint8_tbb(\n    const   uint8_T           *    pImage,\n    const   real64_T          *    srcSize,\n\tconst   boolean_T              isSobel,\n    const   real64_T               kx,\n    const   real64_T               ky,        \n            real32_T          *    pGradientX,\n            real32_T          *    pGradientY,\n            real32_T          *    pMagnitude);\n/*uint16*/\nEXTERN_C LIBMWEDGESOBELPREWITT_TBB_API void edgesobelprewitt_uint16_tbb(\n    const   uint16_T          *    pImage,\n    const   real64_T          *    srcSize,\n\tconst   boolean_T              isSobel,\n    const   real64_T               kx,\n    const   real64_T               ky,        \n            real32_T          *    pGradientX,\n            real32_T          *    pGradientY,\n            real32_T          *    pMagnitude);\n/*int16*/\nEXTERN_C LIBMWEDGESOBELPREWITT_TBB_API void edgesobelprewitt_int16_tbb(\n    const   int16_T           *    pImage,\n    const   real64_T          *    srcSize,\n\tconst   boolean_T              isSobel,\n    const   real64_T               kx,\n    const   real64_T               ky,        \n            real32_T          *    pGradientX,\n            real32_T          *    pGradientY,\n            real32_T          *    pMagnitude);\n\n#endif\n"},{"name":"libmwedgethinning_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2017 The MathWorks, Inc. */\n\n#ifndef _EDGETHINNING_TBB_H_\n#define _EDGETHINNING_TBB_H_\n\n\n#ifndef LIBMWEDGETHINNING_TBB_API\n#    define LIBMWEDGETHINNING_TBB_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/*real32*/\nEXTERN_C LIBMWEDGETHINNING_TBB_API void edgethinning_real32_tbb(\n\tconst\treal32_T\t*\tpB,\n\tconst\treal32_T\t*\tpBx,\n\tconst\treal32_T\t*\tpBy,\n\tconst\treal64_T\t\tkx,\n\tconst\treal64_T\t\tky,\n\tconst \tint8_T \t\t* \toffset,\n\tconst\treal64_T\t\teps,\n\tconst\treal64_T\t\tcutoff,\n\t       \tboolean_T\t*\tdst,\n\tconst\treal64_T\t*\tdstSize);\n\n/*real64*/\nEXTERN_C LIBMWEDGETHINNING_TBB_API void edgethinning_real64_tbb(\n\tconst\treal64_T\t*\tpB,\n\tconst\treal64_T\t*\tpBx,\n\tconst\treal64_T\t*\tpBy,\n\tconst\treal64_T\t\tkx,\n\tconst\treal64_T\t\tky,\n\tconst \tint8_T \t\t* \toffset,\n\tconst\treal64_T\t\teps,\n\tconst\treal64_T\t\tcutoff,\n       \t\tboolean_T\t*\tdst,\n\tconst\treal64_T\t*\tdstSize);\n\n#endif\n"},{"name":"libmwgetnumcores.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012-2013 The MathWorks, Inc. */\n#ifndef _GETNUMCORES_H_\n#define _GETNUMCORES_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWGETNUMCORES_API\n#    define LIBMWGETNUMCORES_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWGETNUMCORES_API void getnumcores(\n        real64_T *proc);\n\n#endif /* _GETNUMCORES_H_ */\n"},{"name":"libmwgrayto16.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _GRAYTO16_H_\n#define _GRAYTO16_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWGRAYTO16_API\n#    define LIBMWGRAYTO16_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWGRAYTO16_API void grayto16_double(\n\tconst real64_T* inpIm,\n\tuint16_T* outIm,\n\tconst real64_T numIm);\n\nEXTERN_C LIBMWGRAYTO16_API void grayto16_single(\n\tconst real32_T* inpIm,\n\tuint16_T* outIm,\n\tconst real64_T numIm);\n\nEXTERN_C LIBMWGRAYTO16_API void grayto16_uint8(\n\tconst uint8_T* inpIm,\n\tuint16_T* outIm,\n\tconst real64_T numIm);\n\n\n#endif /* _GRAYTO16_H_ */\n"},{"name":"libmwgrayto8.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2014 The MathWorks, Inc. */\n#ifndef _GRAYTO8_H_\n#define _GRAYTO8_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWGRAYTO8_API\n#    define LIBMWGRAYTO8_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWGRAYTO8_API void grayto8_real64(\n\tconst real64_T* inpIm,\n\tuint8_T* outIm,\n\tconst real64_T numIm);\n\nEXTERN_C LIBMWGRAYTO8_API void grayto8_real32(\n\tconst real32_T* inpIm,\n\tuint8_T* outIm,\n\tconst real64_T numIm);\n\nEXTERN_C LIBMWGRAYTO8_API void grayto8_uint16(\n\tconst uint16_T* inpIm,\n\tuint8_T* outIm,\n\tconst real64_T numIm);\n\n\n#endif /* _GRAYTO8_H_ */\n"},{"name":"libmwgrayxform.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2014 The MathWorks, Inc. */\n#ifndef _GRAYXFORM_H_\n#define _GRAYXFORM_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWGRAYXFORM_API\n#    define LIBMWGRAYXFORM_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWGRAYXFORM_API void grayxform_real64(\n        const real64_T *in, \n        const real64_T inNumElems, \n        const real64_T inRows, \n        const real64_T inColsEtc,\n        const real64_T *tform, \n        const real64_T tformNumElems,\n        real64_T *out);\n\nEXTERN_C LIBMWGRAYXFORM_API void grayxform_real32(\n        const real32_T *in, \n        const real64_T inNumElems, \n        const real64_T inRows, \n        const real64_T inColsEtc,\n        const real64_T *tform, \n        const real64_T tformNumElems,\n        real32_T *out);\n\nEXTERN_C LIBMWGRAYXFORM_API void grayxform_uint16(\n        const uint16_T *in, \n        const real64_T inNumElems, \n        const real64_T inRows, \n        const real64_T inColsEtc,\n        const real64_T *tform, \n        const real64_T tformNumElems,\n        uint16_T *out);\n\nEXTERN_C LIBMWGRAYXFORM_API void grayxform_uint8(\n        const uint8_T *in, \n        const real64_T inNumElems, \n        const real64_T inRows, \n        const real64_T inColsEtc,\n        const real64_T *tform, \n        const real64_T tformNumElems,\n        uint8_T *out);\n\n#endif /* _GRAYXFORM_H_ */\n"},{"name":"libmwgrayxform_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2014 The MathWorks, Inc. */\n#ifndef _GRAYXFORM_TBB_H_\n#define _GRAYXFORM_TBB_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWGRAYXFORM_TBB_API\n#    define LIBMWGRAYXFORM_TBB_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWGRAYXFORM_TBB_API void grayxform_tbb_real64(\n        const real64_T *in, \n        const real64_T inNumElems, \n        const real64_T inRows, \n        const real64_T inColsEtc,\n        const real64_T *tform, \n        const real64_T tformNumElems,\n        real64_T *out);\n\nEXTERN_C LIBMWGRAYXFORM_TBB_API void grayxform_tbb_real32(\n        const real32_T *in, \n        const real64_T inNumElems, \n        const real64_T inRows, \n        const real64_T inColsEtc,\n        const real64_T *tform, \n        const real64_T tformNumElems,\n        real32_T *out);\n\nEXTERN_C LIBMWGRAYXFORM_TBB_API void grayxform_tbb_uint16(\n        const uint16_T *in, \n        const real64_T inNumElems, \n        const real64_T inRows, \n        const real64_T inColsEtc,\n        const real64_T *tform, \n        const real64_T tformNumElems,\n        uint16_T *out);\n\nEXTERN_C LIBMWGRAYXFORM_TBB_API void grayxform_tbb_uint8(\n        const uint8_T *in, \n        const real64_T inNumElems, \n        const real64_T inRows, \n        const real64_T inColsEtc,\n        const real64_T *tform, \n        const real64_T tformNumElems,\n        uint8_T *out);\n\n#endif /* _GRAYXFORM_TBB_H_ */\n"},{"name":"libmwimfilter.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n\n#ifndef _LIBMWIMFILTER_H_\n#define _LIBMWIMFILTER_H_\n\n\n#ifndef LIBMWIMFILTER_API\n#    define LIBMWIMFILTER_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* boolean */\nEXTERN_C LIBMWIMFILTER_API void imfilter_boolean(\n            const boolean_T *inBuf, \n            boolean_T       *outBuf,\n            real64_T         numOutDims,\n            const real64_T  *outSize,\n            real64_T         numPadDims,\n            const real64_T  *padSize,\n            const real64_T  *nonZeroKernel,\n            real64_T         numKernElem,\n            const boolean_T *conn,\n            real64_T         nconnDims,\n            const real64_T  *connDims,\n            const real64_T  *start,\n            real64_T         numStartElem,\n            boolean_T        sameSize,\n            boolean_T        convMode);\n\n\n\n/* uint8_T */\nEXTERN_C LIBMWIMFILTER_API void imfilter_uint8(\n            const uint8_T   *inBuf, \n            uint8_T         *outBuf,\n            real64_T         numOutDims,\n            const real64_T  *outSize,\n            real64_T         numPadDims,\n            const real64_T  *padSize,\n            const real64_T  *nonZeroKernel,\n            real64_T         numKernElem,\n            const boolean_T *conn,\n            real64_T         numConnDims,\n            const real64_T  *connSize,\n            const real64_T  *start,\n            real64_T         numStartElem,\n            boolean_T        sameSize,\n            boolean_T        convMode);\n\n/* int8_T */\nEXTERN_C LIBMWIMFILTER_API void imfilter_int8(\n            const int8_T    *inBuf, \n            int8_T          *outBuf,\n            real64_T         numOutDims,\n            const real64_T  *outSize,\n            real64_T         numPadDims,\n            const real64_T  *padSize,\n            const real64_T  *nonZeroKernel,\n            real64_T         numKernElem,\n            const boolean_T *conn,\n            real64_T         numConnDims,\n            const real64_T  *connSize,\n            const real64_T  *start,\n            real64_T         numStartElem,\n            boolean_T        sameSize,\n            boolean_T        convMode);\n\n/* uint16_T */\nEXTERN_C LIBMWIMFILTER_API void imfilter_uint16(\n            const uint16_T  *inBuf, \n            uint16_T        *outBuf,\n            real64_T         numOutDims,\n            const real64_T  *outSize,\n            real64_T         numPadDims,\n            const real64_T  *padSize,\n            const real64_T  *nonZeroKernel,\n            real64_T         numKernElem,\n            const boolean_T *conn,\n            real64_T         numConnDims,\n            const real64_T  *connSize,\n            const real64_T  *start,\n            real64_T         numStartElem,\n            boolean_T        sameSize,\n            boolean_T        convMode);\n\n/* int16_T */\nEXTERN_C LIBMWIMFILTER_API void imfilter_int16(\n            const int16_T   *inBuf, \n            int16_T         *outBuf,\n            real64_T         numOutDims,\n            const real64_T  *outSize,\n            real64_T         numPadDims,\n            const real64_T  *padSize,\n            const real64_T  *nonZeroKernel,\n            real64_T         numKernElem,\n            const boolean_T *conn,\n            real64_T         numConnDims,\n            const real64_T  *connSize,\n            const real64_T  *start,\n            real64_T         numStartElem,\n            boolean_T        sameSize,\n            boolean_T        convMode);\n\n/* uint32_T */\nEXTERN_C LIBMWIMFILTER_API void imfilter_uint32(\n            const uint32_T  *inBuf, \n            uint32_T        *outBuf,\n            real64_T         numOutDims,\n            const real64_T  *outSize,\n            real64_T         numPadDims,\n            const real64_T  *padSize,\n            const real64_T  *nonZeroKernel,\n            real64_T         numKernElem,\n            const boolean_T *conn,\n            real64_T         numConnDims,\n            const real64_T  *connSize,\n            const real64_T  *start,\n            real64_T         numStartElem,\n            boolean_T        sameSize,\n            boolean_T        convMode);\n\n/* int32_T */\nEXTERN_C LIBMWIMFILTER_API void imfilter_int32(\n            const int32_T   *inBuf, \n            int32_T         *outBuf,\n            real64_T         numOutDims,\n            const real64_T  *outSize,\n            real64_T         numPadDims,\n            const real64_T  *padSize,\n            const real64_T  *nonZeroKernel,\n            real64_T         numKernElem,\n            const boolean_T *conn,\n            real64_T         numConnDims,\n            const real64_T  *connSize,\n            const real64_T  *start,\n            real64_T         numStartElem,\n            boolean_T        sameSize,\n            boolean_T        convMode);\n\n/* real32_T */\nEXTERN_C LIBMWIMFILTER_API void imfilter_real32(\n            const real32_T  *inBuf, \n            real32_T        *outBuf,\n            real64_T         numOutDims,\n            const real64_T  *outSize,\n            real64_T         numPadDims,\n            const real64_T  *padSize,\n            const real64_T  *nonZeroKernel,\n            real64_T         numKernElem,\n            const boolean_T *conn,\n            real64_T         numConnDims,\n            const real64_T  *connSize,\n            const real64_T  *start,\n            real64_T         numStartElem,\n            boolean_T        sameSize,\n            boolean_T        convMode);\n\n/*  real64_T */\nEXTERN_C LIBMWIMFILTER_API void imfilter_real64(\n            const real64_T  *inBuf, \n            real64_T        *outBuf,\n            real64_T         numOutDims,\n            const real64_T  *outSize,\n            real64_T         numPadDims,\n            const real64_T  *padSize,\n            const real64_T  *nonZeroKernel,\n            real64_T         numKernElem,\n            const boolean_T *conn,\n            real64_T         numConnDims,\n            const real64_T  *connSize,\n            const real64_T  *start,\n            real64_T         numStartElem,\n            boolean_T        sameSize,\n            boolean_T        convMode);\n\n#endif\n"},{"name":"libmwimlincomb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _IMLINCOMB_H_\n#define _IMLINCOMB_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWIMLINCOMB_API\n#    define LIBMWIMLINCOMB_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWIMLINCOMB_API void imlincomb_real64(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_API void imlincomb_real32(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_API void imlincomb_int32(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_API void imlincomb_uint32(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_API void imlincomb_int16(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_API void imlincomb_uint16(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_API void imlincomb_int8(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_API void imlincomb_uint8(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_API void imlincomb_boolean(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\n#endif /* _IMLINCOMB_H_ */\n"},{"name":"libmwimlincomb_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _IMLINCOMB_TBB_H_\n#define _IMLINCOMB_TBB_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWIMLINCOMB_TBB_API\n#    define LIBMWIMLINCOMB_TBB_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWIMLINCOMB_TBB_API void imlincomb_tbb_real64(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_TBB_API void imlincomb_tbb_real32(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_TBB_API void imlincomb_tbb_int32(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_TBB_API void imlincomb_tbb_uint32(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_TBB_API void imlincomb_tbb_int16(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_TBB_API void imlincomb_tbb_uint16(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_TBB_API void imlincomb_tbb_int8(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_TBB_API void imlincomb_tbb_uint8(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\nEXTERN_C LIBMWIMLINCOMB_TBB_API void imlincomb_tbb_boolean(\n        const real64_T  *fScalars,\n        real64_T         fNumScalars,\n        void            *output_image,\n        int8_T           outputClass,\n        real64_T         fNumElements,\n        real64_T         fNumImages,\n        ...);\n\n#endif /* _IMLINCOMB_TBB_H_ */\n"},{"name":"libmwimreconstruct.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012 The MathWorks, Inc. */\n\n#ifndef _IMRECONSTRUCT_\n#define _IMRECONSTRUCT_\n\n\n#ifndef LIBMWIMRECONSTRUCT_API\n#    define LIBMWIMRECONSTRUCT_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* boolean */\nEXTERN_C LIBMWIMRECONSTRUCT_API void imreconstruct_boolean(\n    boolean_T*       marker,\n    const boolean_T* mask,\n    const real64_T   nimdims,\n    const real64_T*  imSize,\n    const boolean_T* conn,\n    const real64_T   nconndims,\n    const real64_T*  connSize);\n\n/* uint8_T */\nEXTERN_C LIBMWIMRECONSTRUCT_API void imreconstruct_uint8(\n    uint8_T*         marker,\n    const uint8_T*   mask,\n    const real64_T   nimdims,\n    const real64_T*  imSize,\n    const boolean_T* conn,\n    const real64_T   nconndims,\n    const real64_T*  connSize);\n\n/* int8_T */\nEXTERN_C LIBMWIMRECONSTRUCT_API void imreconstruct_int8(\n    int8_T*          marker,\n    const int8_T*    mask,\n    const real64_T   nimdims,\n    const real64_T*  imSize,\n    const boolean_T* conn,\n    const real64_T   nconndims,\n    const real64_T*  connSize);\n\n/* uint16_T */\nEXTERN_C LIBMWIMRECONSTRUCT_API void imreconstruct_uint16(\n    uint16_T*        marker,\n    const uint16_T*  mask,\n    const real64_T   nimdims,\n    const real64_T*  imSize,\n    const boolean_T* conn,\n    const real64_T   nconndims,\n    const real64_T*  connSize);\n\n/* int16_T */\nEXTERN_C LIBMWIMRECONSTRUCT_API void imreconstruct_int16(\n    int16_T*         marker,\n    const int16_T*   mask,\n    const real64_T   nimdims,\n    const real64_T*  imSize,\n    const boolean_T* conn,\n    const real64_T   nconndims,\n    const real64_T*  connSize);\n\n/* uint32_T */\nEXTERN_C LIBMWIMRECONSTRUCT_API void imreconstruct_uint32(\n    uint32_T*        marker,\n    const uint32_T*  mask,\n    const real64_T   nimdims,\n    const real64_T*  imSize,\n    const boolean_T* conn,\n    const real64_T   nconndims,\n    const real64_T*  connSize);\n\n/* int32_T */\nEXTERN_C LIBMWIMRECONSTRUCT_API void imreconstruct_int32(\n    int32_T*         marker,\n    const int32_T*   mask,\n    const real64_T   nimdims,\n    const real64_T*  imSize,\n    const boolean_T* conn,\n    const real64_T   nconndims,\n    const real64_T*  connSize);\n\n/* single */\nEXTERN_C LIBMWIMRECONSTRUCT_API void imreconstruct_real32(\n    real32_T*        marker,\n    const real32_T*  mask,\n    const real64_T   nimdims,\n    const real64_T*  imSize,\n    const boolean_T* conn,\n    const real64_T   nconndims,\n    const real64_T*  connSize);\n\n/*  real64_T */\nEXTERN_C LIBMWIMRECONSTRUCT_API void imreconstruct_real64(\n    real64_T*        marker,\n    const real64_T*  mask,\n    const real64_T   nimdims,\n    const real64_T*  imSize,\n    const boolean_T* conn,\n    const real64_T   nconndims,\n    const real64_T*  connSize);\n\n#endif\n"},{"name":"libmwimregionalmax.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012-2013 The MathWorks, Inc. */\n#ifndef _LIBMWIMREGIONALMAX_H_\n#define _LIBMWIMREGIONALMAX_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWIMREGIONALMAX_API\n#    define LIBMWIMREGIONALMAX_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/*boolean_T*/\nEXTERN_C LIBMWIMREGIONALMAX_API void imregionalmax_boolean(\n        const boolean_T* F,\n        boolean_T* BW,\n        const real64_T nimdims,\n        const real64_T *imSize,\n        const boolean_T* conn,\n        const real64_T nconndims,\n        const real64_T *connSize);\n\n/*uint8_T*/\nEXTERN_C LIBMWIMREGIONALMAX_API void imregionalmax_uint8(\n        const uint8_T* F,\n        boolean_T*   BW,\n        const real64_T nimdims,\n        const real64_T *imSize,\n        const boolean_T* conn,\n        const real64_T nconndims,\n        const real64_T *connSize);\n\n/*int8_T*/\nEXTERN_C LIBMWIMREGIONALMAX_API void imregionalmax_int8(\n        const int8_T* F,\n        boolean_T*   BW,\n        const real64_T nimdims,\n        const real64_T *imSize,\n        const boolean_T* conn,\n        const real64_T nconndims,\n        const real64_T *connSize);\n\n/*uint16_T*/\nEXTERN_C LIBMWIMREGIONALMAX_API void imregionalmax_uint16(\n        const uint16_T* F,\n        boolean_T*   BW,\n        const real64_T nimdims,\n        const real64_T *imSize,\n        const boolean_T* conn,\n        const real64_T nconndims,\n        const real64_T *connSize);\n\n/*int16_T*/\nEXTERN_C LIBMWIMREGIONALMAX_API void imregionalmax_int16(\n        const int16_T* F,\n        boolean_T*   BW,\n        const real64_T nimdims,\n        const real64_T *imSize,\n        const boolean_T* conn,\n        const real64_T nconndims,\n        const real64_T *connSize);\n\n/*uint32_T*/\nEXTERN_C LIBMWIMREGIONALMAX_API void imregionalmax_uint32(\n        const uint32_T* F,\n        boolean_T*   BW,\n        const real64_T nimdims,\n        const real64_T *imSize,\n        const boolean_T* conn,\n        const real64_T nconndims,\n        const real64_T *connSize);\n\n/*int32_T*/\nEXTERN_C LIBMWIMREGIONALMAX_API void imregionalmax_int32(\n        const int32_T* F,\n        boolean_T*   BW,\n        const real64_T nimdims,\n        const real64_T *imSize,\n        const boolean_T* conn,\n        const real64_T nconndims,\n        const real64_T *connSize);\n\n/*single*/\nEXTERN_C LIBMWIMREGIONALMAX_API void imregionalmax_real32(\n        const real32_T* F,\n        boolean_T*   BW,\n        const real64_T nimdims,\n        const real64_T *imSize,\n        const boolean_T* conn,\n        const real64_T nconndims,\n        const real64_T *connSize);\n\n/*double*/\nEXTERN_C LIBMWIMREGIONALMAX_API void imregionalmax_real64(\n        const real64_T* F,\n        boolean_T*   BW,\n        const real64_T nimdims,\n        const real64_T *imSize,\n        const boolean_T* conn,\n        const real64_T nconndims,\n        const real64_T *connSize);\n\n#endif /* _LIBMWIMREGIONALMAX_H_ */\n"},{"name":"libmwimterp2d.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018 The MathWorks, Inc. */\n\n#ifndef _IMTERP2D_\n#define _IMTERP2D_\n\n\n#ifndef LIBMWIMTERP2D_API\n#    define LIBMWIMTERP2D_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/*\n    real32_T query points\n*/\n\n/* boolean */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d32f_boolean(\n    const boolean_T*       image,\n    const real64_T*  imSize,\n    const real32_T*   Xq,\n    const real32_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const boolean_T*   extrapValues,\n     boolean_T* output);\n\n/* uint8_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d32f_uint8(\n    const uint8_T*         image,\n    const real64_T*  imSize,\n    const real32_T*   Xq,\n    const real32_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const uint8_T*   extrapValues,\n     uint8_T*   output);\n\n/* int8_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d32f_int8(\n    const int8_T*          image,\n    const real64_T*  imSize,\n    const real32_T*   Xq,\n    const real32_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const int8_T*   extrapValues,\n     int8_T*    output);\n\n/* uint16_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d32f_uint16(\n    const uint16_T*        image,\n    const real64_T*  imSize,\n    const real32_T*   Xq,\n    const real32_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const uint16_T*   extrapValues,\n     uint16_T*  output);\n\n/* int16_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d32f_int16(\n    const int16_T*         image,\n    const real64_T*  imSize,\n    const real32_T*   Xq,\n    const real32_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const int16_T*   extrapValues,\n     int16_T*   output);\n\n/* uint32_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d32f_uint32(\n    const uint32_T*        image,\n    const real64_T*  imSize,\n    const real32_T*   Xq,\n    const real32_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const uint32_T*   extrapValues,\n     uint32_T*  output);\n\n/* int32_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d32f_int32(\n    const int32_T*         image,\n    const real64_T*  imSize,\n    const real32_T*   Xq,\n    const real32_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const int32_T*   extrapValues,\n     int32_T*   output);\n\n/* single */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d32f_real32(\n    const real32_T*        image,\n    const real64_T*  imSize,\n    const real32_T*   Xq,\n    const real32_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const real32_T*   extrapValues,\n     real32_T*  output);\n\n/*  real64_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d32f_real64(\n    const real64_T*        image,\n    const real64_T*  imSize,\n    const real32_T*   Xq,\n    const real32_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const real64_T*   extrapValues,\n     real64_T*  output);\n\n/*\n    real64_T query points\n*/\n\n/* boolean */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d64f_boolean(\n    const boolean_T*       image,\n    const real64_T*  imSize,\n    const real64_T*   Xq,\n    const real64_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const boolean_T*   extrapValues,\n     boolean_T* output);\n\n/* uint8_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d64f_uint8(\n    const uint8_T*         image,\n    const real64_T*  imSize,\n    const real64_T*   Xq,\n    const real64_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const uint8_T*   extrapValues,\n     uint8_T*   output);\n\n/* int8_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d64f_int8(\n    const int8_T*          image,\n    const real64_T*  imSize,\n    const real64_T*   Xq,\n    const real64_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const int8_T*   extrapValues,\n     int8_T*    output);\n\n/* uint16_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d64f_uint16(\n    const uint16_T*        image,\n    const real64_T*  imSize,\n    const real64_T*   Xq,\n    const real64_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const uint16_T*   extrapValues,\n     uint16_T*  output);\n\n/* int16_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d64f_int16(\n    const int16_T*         image,\n    const real64_T*  imSize,\n    const real64_T*   Xq,\n    const real64_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const int16_T*   extrapValues,\n     int16_T*   output);\n\n/* uint32_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d64f_uint32(\n    const uint32_T*        image,\n    const real64_T*  imSize,\n    const real64_T*   Xq,\n    const real64_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const uint32_T*   extrapValues,\n     uint32_T*  output);\n\n/* int32_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d64f_int32(\n    const int32_T*         image,\n    const real64_T*  imSize,\n    const real64_T*   Xq,\n    const real64_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const int32_T*   extrapValues,\n     int32_T*   output);\n\n/* single */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d64f_real32(\n    const real32_T*        image,\n    const real64_T*  imSize,\n    const real64_T*   Xq,\n    const real64_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const real32_T*   extrapValues,\n     real32_T*  output);\n\n/*  real64_T */\nEXTERN_C LIBMWIMTERP2D_API void imterp2d64f_real64(\n    const real64_T*        image,\n    const real64_T*  imSize,\n    const real64_T*   Xq,\n    const real64_T*   Yq,\n    const real64_T*  outSize,\n    const real64_T method,\n    const boolean_T  doScalarExtrap,\n    const real64_T*   extrapValues,\n     real64_T*  output);\n\n#endif\n"},{"name":"libmwint16touint16.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _INT16TOUINT16_H_\n#define _INT16TOUINT16_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWINT16TOUINT16_API\n#    define LIBMWINT16TOUINT16_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWINT16TOUINT16_API void int16touint16_fun(\n        const int16_T    *pr,\n        uint16_T         *qr,\n        const real64_T    numElements);\n\n#endif /* _INT16TOUINT16_H_ */\n"},{"name":"libmwint32touint32.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _INT32TOUINT32_H_\n#define _INT32TOUINT32_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWINT32TOUINT32_API\n#    define LIBMWINT32TOUINT32_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWINT32TOUINT32_API void int32touint32_fun(\n        const int32_T    *pr,\n        uint32_T         *qr,\n        const real64_T    numElements);\n\n#endif /* _INT32TOUINT32_H_ */\n"},{"name":"libmwint8touint8.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _INT8TOUINT8_H_\n#define _INT8TOUINT8_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWINT8TOUINT8_API\n#    define LIBMWINT8TOUINT8_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWINT8TOUINT8_API void int8touint8_fun(\n        const int8_T   *pr,\n        uint8_T        *qr,\n        const real64_T  numElements);\n\n#endif /* _INT8TOUINT8_H_ */\n"},{"name":"libmwintlut.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2014 The MathWorks, Inc. */\n#ifndef _INTLUT_H_\n#define _INTLUT_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWINTLUT_API\n#    define LIBMWINTLUT_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWINTLUT_API void intlut_uint8(const uint8_T *A, const real64_T *dimsA, const real64_T numDimsA,\n                                           const uint8_T *LUT, const real64_T numLUT, \n                                           uint8_T *B);\n\nEXTERN_C LIBMWINTLUT_API void intlut_uint16(const uint16_T *A, const real64_T *dimsA, const real64_T numDimsA,\n                                            const uint16_T *LUT, const real64_T numLUT, \n                                            uint16_T *B);\n\n\nEXTERN_C LIBMWINTLUT_API void intlut_int16(const int16_T *A, const real64_T *dimsA, const real64_T numDimsA,\n                                           const int16_T *LUT, const real64_T numLUT, \n                                           int16_T *B);\n\n\n#endif /* _INTLUT_H_ */\n"},{"name":"libmwintluttbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2014 The MathWorks, Inc. */\n#ifndef _INTLUTTBB_H_\n#define _INTLUTTBB_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWINTLUTTBB_API\n#    define LIBMWINTLUTTBB_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWINTLUTTBB_API void intlut_tbb_uint8(const uint8_T *A, const real64_T *dimsA, const real64_T numDimsA,\n                                                  const uint8_T *LUT, const real64_T numLUT, \n                                                  uint8_T *B);\n\nEXTERN_C LIBMWINTLUTTBB_API void intlut_tbb_uint16(const uint16_T *A, const real64_T *dimsA, const real64_T numDimsA,\n                                                   const uint16_T *LUT, const real64_T numLUT, \n                                                   uint16_T *B);\n\n\nEXTERN_C LIBMWINTLUTTBB_API void intlut_tbb_int16(const int16_T *A, const real64_T *dimsA, const real64_T numDimsA,\n                                                  const int16_T *LUT, const real64_T numLUT, \n                                                  int16_T *B);\n\n\n#endif /* _INTLUTTBB_H_ */\n"},{"name":"libmwippfilter.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2017 The MathWorks, Inc. */\n\n#ifndef _LIBMWIPPFILTER_H_\n#define _LIBMWIPPFILTER_H_\n\n#ifndef LIBMWIPPFILTER_API\n#    define LIBMWIPPFILTER_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\ntypedef enum BorderType {ZeroPad, Replicate, InMemory} BorderType;\n\nEXTERN_C LIBMWIPPFILTER_API void ippfilter_uint8(\n        const uint8_T  *inBuf, \n        uint8_T        *outBuf, \n        const real64_T *outSize, \n        real64_T        numPadDims,\n        const real64_T *padSize, \n        const real64_T *kernel, \n        const real64_T *kernelSize, \n        boolean_T       convMode);\n\nEXTERN_C LIBMWIPPFILTER_API void ippfilter_uint16(\n        const uint16_T *inBuf, \n        uint16_T       *outBuf, \n        const real64_T *outSize, \n        const real64_T  numPadDims, \n        const real64_T *padSize,\n        const real64_T *kernel, \n        const real64_T *kernelSize, \n        boolean_T       convMode);\n\nEXTERN_C LIBMWIPPFILTER_API void ippfilter_int16(\n        const int16_T  *inBuf, \n        int16_T        *outBuf, \n        const real64_T *outSize, \n        const real64_T  numPadDims, \n        const real64_T *padSize,\n        const real64_T *kernel, \n        const real64_T *kernelSize, \n        boolean_T       convMode);\n\nEXTERN_C LIBMWIPPFILTER_API void ippfilter_real32(\n        const real32_T *inBuf, \n        real32_T       *outBuf, \n        const real64_T *outSize, \n        const real64_T  numPadDims, \n        const real64_T *padSize,\n        const real64_T *kernel, \n        const real64_T *kernelSize, \n        boolean_T       convMode);\n\nEXTERN_C LIBMWIPPFILTER_API void ippfilter_real64(\n        const real64_T *inBuf, \n        real64_T       *outBuf, \n        const real64_T *outSize, \n        real64_T        numPadDims, \n        const real64_T *padSize,  \n        const real64_T *kernel, \n        const real64_T *kernelSize, \n        boolean_T       convMode);\n\nEXTERN_C LIBMWIPPFILTER_API void ippfilter_bordertype_uint8(\n        const uint8_T  *inBuf,\n        uint8_T        *outBuf,\n        const real64_T *outSize,\n        real64_T        numPadDims,\n        const real64_T *padSize,\n        const real64_T *kernel,\n        const real64_T *kernelSize,\n        boolean_T       convMode,\n        BorderType      borderType);\n\nEXTERN_C LIBMWIPPFILTER_API void ippfilter_bordertype_real32(\n        const real32_T *inBuf,\n        real32_T       *outBuf,\n        const real64_T *outSize,\n        real64_T        numPadDims,\n        const real64_T *padSize,\n        const real64_T *kernel,\n        const real64_T *kernelSize,\n        boolean_T       convMode,\n        BorderType      borderType);\n\n\n\n#endif\n\n"},{"name":"libmwippgeotrans.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2017 The MathWorks, Inc. */\n#ifndef _IPPGEOTRANS_H_\n#define _IPPGEOTRANS_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWIPPGEOTRANS_API\n#    define LIBMWIPPGEOTRANS_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWIPPGEOTRANS_API void ippgeotransCaller_real32(real32_T *pDst, real64_T *dstSizeDouble, const real64_T ndims,\n                                                     const real32_T *pSrc,  real64_T *srcSize, const real64_T numelSrc,\n                                                     const real64_T *tformPtr,  int8_T interpMethodEnum, const real64_T *fillVal,\n                                                     const boolean_T isColumnMajor);\n\nEXTERN_C LIBMWIPPGEOTRANS_API void ippgeotransCaller_real64(real64_T *pDst, real64_T *dstSizeDouble, const real64_T ndims,\n                                                     const real64_T *pSrc,  real64_T *srcSize, const real64_T numelSrc,\n                                                     const real64_T *tformPtr,  int8_T interpMethodEnum, const real64_T *fillVal,\n                                                     const boolean_T isColumnMajor);\n\nEXTERN_C LIBMWIPPGEOTRANS_API void ippgeotransCaller_uint8(uint8_T *pDst, real64_T *dstSizeDouble, const real64_T ndims,\n                                                     const uint8_T *pSrc,  real64_T *srcSize, const real64_T numelSrc,\n                                                     const real64_T *tformPtr,  int8_T interpMethodEnum, const real64_T *fillVal,\n                                                     const boolean_T isColumnMajor);\n\nEXTERN_C LIBMWIPPGEOTRANS_API void ippgeotransCaller_uint16(uint16_T *pDst, real64_T *dstSizeDouble, const real64_T ndims,\n                                                     const uint16_T *pSrc,  real64_T *srcSize, const real64_T numelSrc,\n                                                     const real64_T *tformPtr,  int8_T interpMethodEnum, const real64_T *fillVal,\n                                                     const boolean_T isColumnMajor);\n\n#endif /* _IPPGEOTRANS_H_ */\n"},{"name":"libmwippmedianfilter.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2014 The MathWorks, inc. */\n#ifndef _LIBMWIPPMEDIANFILTER_HPP_\n#define _LIBMWIPPMEDIANFILTER_HPP_\n\n#ifndef LIBMWIPPMEDIANFILTER_API\n#    define LIBMWIPPMEDIANFILTER_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n\nEXTERN_C LIBMWIPPMEDIANFILTER_API\nvoid ippMedianFilter_uint8(\n        const  uint8_T     *   srcImg,\n        const  real64_T    *   srcSize,\n        const  real64_T    *   maskSz,        \n               uint8_T     *   dstImg);\n\nEXTERN_C LIBMWIPPMEDIANFILTER_API\nvoid ippMedianFilter_uint16(\n        const  uint16_T    *   srcImg,\n        const  real64_T    *   srcSize,\n        const  real64_T    *   maskSz,        \n               uint16_T    *   dstImg);\n\nEXTERN_C LIBMWIPPMEDIANFILTER_API\nvoid ippMedianFilter_int16(\n        const  int16_T     *   srcImg,\n        const  real64_T    *   srcSize,\n        const  real64_T    *   maskSz,        \n               int16_T     *   dstImg);\n\nEXTERN_C LIBMWIPPMEDIANFILTER_API\nvoid ippMedianFilter_real32(\n        const  real32_T    *   srcImg,\n        const  real64_T    *   srcSize,\n        const  real64_T    *   maskSz,        \n               real32_T    *   dstImg);\n#endif\n"},{"name":"libmwippreconstruct.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012-2014 The MathWorks, Inc. */\n\n#ifndef _IPPRECONSTRUCT_\n#define _IPPRECONSTRUCT_\n\n#ifndef LIBMWIPPRECONSTRUCT_API\n#    define LIBMWIPPRECONSTRUCT_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWIPPRECONSTRUCT_API void ippreconstruct_uint8(\n    uint8_T*        marker,\n    const uint8_T*  mask,\n    const real64_T* imSize,\n    const real64_T  modeFlag);\n\nEXTERN_C LIBMWIPPRECONSTRUCT_API void ippreconstruct_uint16(\n    uint16_T*       marker,\n    const uint16_T* mask,\n    const real64_T* imSize,\n    const real64_T  modeFlag);\n\nEXTERN_C LIBMWIPPRECONSTRUCT_API void ippreconstruct_real32(\n    real32_T*       marker,\n    const real32_T* mask,\n    const real64_T* imSize,\n    const real64_T  modeFlag);\n\nEXTERN_C LIBMWIPPRECONSTRUCT_API void ippreconstruct_real64(\n    real64_T*       marker,\n    const real64_T* mask,\n    const real64_T* imSize,\n    const real64_T  modeFlag);\n\n#endif\n"},{"name":"libmwjpegreader.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2016 The MathWorks, Inc. */\n\n/* This file is used for imread code generation. The API is for internal \n purposes and is subject to change. */\n\n#ifndef _JPEGREADER_H_\n#define _JPEGREADER_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWJPEGREADER_API\n#    define LIBMWJPEGREADER_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWJPEGREADER_API void jpegreader_getimagesize(\n\tconst char *filename, \n    real64_T   *imgDims,\n    int8_T     *fileStatus,\n    int8_T     *colorSpaceStatus,\n    real64_T   *libjpegMsgCode, \n    char       *libjpegErrWarnBuffer,\n    int8_T     *errWarnFlag);\n\nEXTERN_C LIBMWJPEGREADER_API void jpegreader_uint8(\n\tconst char     *filename, \n\tuint8_T        *img,\n    const real64_T *imgDims,\n    const real64_T  imgNumDims,\n    int8_T         *fileStatus,\n    int8_T         *libjpegReadDone,\n    real64_T       *libjpegMsgCode, \n    char           *libjpegErrWarnBuffer,\n    int8_T         *errWarnFlag);\n\n#endif /* _JPEGREADER_H_ */\n"},{"name":"libmwmorphop_binary.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, inc. */\n#ifndef _MORPHOP_BINARY_H_\n#define _MORPHOP_BINARY_H_\n\n#ifndef LIBMWMORPHOP_BINARY_API\n#    define LIBMWMORPHOP_BINARY_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWMORPHOP_BINARY_API\nvoid dilate_binary(const boolean_T* in,   const real64_T* const inDims,   const real64_T inNumDims,\n                   const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                         boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_API\nvoid dilate_binary_twod(const boolean_T* const in, const real64_T* const inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                              boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_API\nvoid dilate_binary_ones33(const boolean_T* const in, const real64_T* const inDims, const real64_T inNumDims,\n                          const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                                boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_API\nvoid erode_binary(const boolean_T* in,   const real64_T* const inDims,   const real64_T inNumDims,\n                  const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                        boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_API\nvoid erode_binary_twod(const boolean_T* const in, const real64_T* const inDims, const real64_T inNumDims,\n                       const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                             boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_API\nvoid erode_binary_ones33(const boolean_T* const in, const real64_T* const inDims, const real64_T inNumDims,\n                         const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                               boolean_T* out);\n\n#endif"},{"name":"libmwmorphop_binary_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, inc. */\n#ifndef _MORPHOP_BINARY_TBB_H_\n#define _MORPHOP_BINARY_TBB_H_\n\n#ifndef LIBMWMORPHOP_BINARY_TBB_API\n#    define LIBMWMORPHOP_BINARY_TBB_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWMORPHOP_BINARY_TBB_API\nvoid dilate_binary_tbb(const boolean_T* in,   const real64_T* const inDims,   const real64_T inNumDims,\n                   const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                         boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_TBB_API\nvoid dilate_binary_twod_tbb(const boolean_T* const in, const real64_T* const inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                              boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_TBB_API\nvoid dilate_binary_ones33_tbb(const boolean_T* const in, const real64_T* const inDims, const real64_T inNumDims,\n                          const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                                boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_TBB_API\nvoid erode_binary_tbb(const boolean_T* in,   const real64_T* const inDims,   const real64_T inNumDims,\n                  const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                        boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_TBB_API\nvoid erode_binary_twod_tbb(const boolean_T* const in, const real64_T* const inDims, const real64_T inNumDims,\n                       const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                             boolean_T* out);\n\nEXTERN_C LIBMWMORPHOP_BINARY_TBB_API\nvoid erode_binary_ones33_tbb(const boolean_T* const in, const real64_T* const inDims, const real64_T inNumDims,\n                         const boolean_T* nhood, const real64_T* const nhoodDims, const real64_T nhoodNumDims,\n                               boolean_T* out);\n\n#endif"},{"name":"libmwmorphop_flat.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, inc. */\n#ifndef _LIBMWMORPHOP_FLAT_HPP_\n#define _LIBMWMORPHOP_FLAT_HPP_\n\n#ifndef LIBMWMORPHOP_FLAT_API\n#    define LIBMWMORPHOP_FLAT_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid dilate_flat_boolean(\n                         const boolean_T* const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                         boolean_T*       out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid erode_flat_boolean(\n                         const boolean_T* const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                         boolean_T*       out);\n\n\n/* uint8_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid dilate_flat_uint8(\n                         const uint8_T*   const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                         uint8_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid erode_flat_uint8(\n                         const uint8_T*   const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                         uint8_T*         out);\n\n\n/* uint16_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid dilate_flat_uint16(\n                         const uint16_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               uint16_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid erode_flat_uint16(\n                         const uint16_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               uint16_T*         out);\n\n\n\n/* uint32_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid dilate_flat_uint32(\n                         const uint32_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               uint32_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid erode_flat_uint32(\n                         const uint32_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               uint32_T*         out);\n\n\n\n/* int8_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid dilate_flat_int8(\n                         const int8_T*    const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                               int8_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid erode_flat_int8(\n                         const int8_T*    const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                               int8_T*         out);\n\n\n\n/* int16_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid dilate_flat_int16(\n                         const int16_T *   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               int16_T *         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid erode_flat_int16(\n                         const int16_T *   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               int16_T *         out);\n\n\n\n/* int32_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid dilate_flat_int32(\n                         const int32_T *   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               int32_T *         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid erode_flat_int32(\n                         const int32_T *   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               int32_T *         out);\n\n\n\n/* real32_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid dilate_flat_real32(\n                         const real32_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               real32_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid erode_flat_real32(\n                         const real32_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               real32_T*         out);\n\n\n\n/* real64_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid dilate_flat_real64(\n                         const real64_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               real64_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_API\nvoid erode_flat_real64(\n                         const real64_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               real64_T*         out);\n\n\n\n\n#endif\n"},{"name":"libmwmorphop_flat_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, inc. */\n#ifndef _LIBMWMORPHOP_FLAT_TBB_HPP_\n#define _LIBMWMORPHOP_FLAT_TBB_HPP_\n\n#ifndef LIBMWMORPHOP_FLAT_TBB_API\n#    define LIBMWMORPHOP_FLAT_TBB_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid dilate_flat_boolean_tbb(\n                         const boolean_T* const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                               boolean_T*       out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid erode_flat_boolean_tbb(\n                         const boolean_T* const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                         boolean_T*       out);\n\n\n/* uint8_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid dilate_flat_uint8_tbb(\n                         const uint8_T*   const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                         uint8_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid erode_flat_uint8_tbb(\n                         const uint8_T*   const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                         uint8_T*         out);\n\n\n/* uint16_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid dilate_flat_uint16_tbb(\n                         const uint16_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               uint16_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid erode_flat_uint16_tbb(\n                         const uint16_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               uint16_T*         out);\n\n\n\n/* uint32_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid dilate_flat_uint32_tbb(\n                         const uint32_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               uint32_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid erode_flat_uint32_tbb(\n                         const uint32_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               uint32_T*         out);\n\n\n\n/* int8_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid dilate_flat_int8_tbb(\n                         const int8_T*    const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                               int8_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid erode_flat_int8_tbb(\n                         const int8_T*    const in,\n                         const real64_T*    const inDims,\n                         const real64_T           inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*    const nhoodDims,\n                         const real64_T           nhoodNumDims,\n                               int8_T*         out);\n\n\n\n/* int16_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid dilate_flat_int16_tbb(\n                         const int16_T *   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               int16_T *         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid erode_flat_int16_tbb(\n                         const int16_T *   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               int16_T *         out);\n\n\n\n/* int32_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid dilate_flat_int32_tbb(\n                         const int32_T *   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               int32_T *         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid erode_flat_int32_tbb(\n                         const int32_T *   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               int32_T *         out);\n\n\n\n/* real32_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid dilate_flat_real32_tbb(\n                         const real32_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               real32_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid erode_flat_real32_tbb(\n                         const real32_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               real32_T*         out);\n\n\n\n/* real64_T */\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid dilate_flat_real64_tbb(\n                         const real64_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               real64_T*         out);\n\nEXTERN_C LIBMWMORPHOP_FLAT_TBB_API\nvoid erode_flat_real64_tbb(\n                         const real64_T*   const in,\n                         const real64_T*     const inDims,\n                         const real64_T            inNumDims,\n                         const boolean_T*  const nhood,\n                         const real64_T*     const nhoodDims,\n                         const real64_T            nhoodNumDims,\n                               real64_T*         out);\n\n\n\n\n#endif\n"},{"name":"libmwmorphop_ipp.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2019 The MathWorks, Inc. */\n#ifndef _LIBMWMORPHOP_IPP_HPP_\n#define _LIBMWMORPHOP_IPP_HPP_\n\n#ifndef LIBMWMORPHOP_IPP_API\n#    define LIBMWMORPHOP_IPP_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n\nEXTERN_C LIBMWMORPHOP_IPP_API\nvoid dilate_uint8_ipp(const uint8_T* const src, const real64_T* const inDims,\n                      const boolean_T* nhood, const real64_T* const nhoodDims,\n                      uint8_T* dst);\nEXTERN_C LIBMWMORPHOP_IPP_API\nvoid dilate_uint16_ipp(const uint16_T* const src, const real64_T* const inDims,\n                      const boolean_T* nhood, const real64_T* const nhoodDims,\n                      uint16_T* dst);\nEXTERN_C LIBMWMORPHOP_IPP_API\nvoid dilate_int16_ipp(const int16_T* const src, const real64_T* const inDims,\n                      const boolean_T* nhood, const real64_T* const nhoodDims,\n                      int16_T* dst);\nEXTERN_C LIBMWMORPHOP_IPP_API\nvoid dilate_real32_ipp(const real32_T* const src, const real64_T* const inDims,\n                      const boolean_T* nhood, const real64_T* const nhoodDims,\n                      real32_T* dst);\n\nEXTERN_C LIBMWMORPHOP_IPP_API\nvoid erode_uint8_ipp(const uint8_T* const src, const real64_T* const inDims,\n                      const boolean_T* nhood, const real64_T* const nhoodDims,\n                      uint8_T* dst);\nEXTERN_C LIBMWMORPHOP_IPP_API\nvoid erode_uint16_ipp(const uint16_T* const src, const real64_T* const inDims,\n                      const boolean_T* nhood, const real64_T* const nhoodDims,\n                      uint16_T* dst);\nEXTERN_C LIBMWMORPHOP_IPP_API\nvoid erode_int16_ipp(const int16_T* const src, const real64_T* const inDims,\n                      const boolean_T* nhood, const real64_T* const nhoodDims,\n                      int16_T* dst);\nEXTERN_C LIBMWMORPHOP_IPP_API\nvoid erode_real32_ipp(const real32_T* const src, const real64_T* const inDims,\n                      const boolean_T* nhood, const real64_T* const nhoodDims,\n                      real32_T* dst);\n\n#endif\n"},{"name":"libmwmorphop_nonflat.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, inc. */\n#ifndef _MORPHOP_NONFLAT_H_\n#define _MORPHOP_NONFLAT_H_\n\n#ifndef LIBMWMORPHOP_NONFLAT_API\n#    define LIBMWMORPHOP_NONFLAT_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n\n/* boolean_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid dilate_nonflat_boolean(const boolean_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        boolean_T* out);\n\n/* uint8_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid dilate_nonflat_uint8(const uint8_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        uint8_T* out);\n\n/* uint16_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid dilate_nonflat_uint16(const uint16_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        uint16_T* out);\n\n/* uint32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid dilate_nonflat_uint32(const uint32_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        uint32_T* out);\n\n/* int8_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid dilate_nonflat_int8(const int8_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        int8_T* out);\n\n/* int16_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid dilate_nonflat_int16(const int16_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        int16_T* out);\n\n/* int32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid dilate_nonflat_int32(const int32_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        int32_T* out);\n\n/* real32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid dilate_nonflat_real32(const real32_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        real32_T* out);\n\n/* real64_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid dilate_nonflat_real64(const real64_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        real64_T* out);\n\n\n\n/* boolean_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid erode_nonflat_boolean(const boolean_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        boolean_T* out);\n\n/* uint8_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid erode_nonflat_uint8(const uint8_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        uint8_T* out);\n\n/* uint16_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid erode_nonflat_uint16(const uint16_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        uint16_T* out);\n\n/* uint32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid erode_nonflat_uint32(const uint32_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        uint32_T* out);\n\n/* int8_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid erode_nonflat_int8(const int8_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        int8_T* out);\n\n/* int16_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid erode_nonflat_int16(const int16_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        int16_T* out);\n\n/* int32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid erode_nonflat_int32(const int32_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        int32_T* out);\n\n/* real32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid erode_nonflat_real32(const real32_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        real32_T* out);\n\n/* real64_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_API\nvoid erode_nonflat_real64(const real64_T* const in, const real64_T* inDims, const real64_T inNumDims,\n                        const boolean_T* nhood, const real64_T* nhoodDims, const real64_T nhoodNumDims,\n                        const real64_T* heights,\n                        real64_T* out);\n\n#endif\n"},{"name":"libmwmorphop_nonflat_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, inc. */\n#ifndef _MORPHOP_NONFLAT_TBB_H_\n#define _MORPHOP_NONFLAT_TBB_H_\n\n#ifndef LIBMWMORPHOP_NONFLAT_TBB_API\n#    define LIBMWMORPHOP_NONFLAT_TBB_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n\n/* boolean_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid dilate_nonflat_boolean_tbb(const boolean_T* const in,\n                                const real64_T*  const inDims,\n                                const real64_T         inNumDims,\n                                const boolean_T* const nhood,\n                                const real64_T*  const nhoodDims,\n                                const real64_T         nhoodNumDims,\n                                const real64_T*  const heights,\n                                      boolean_T*       out);\n\n/* uint8_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid dilate_nonflat_uint8_tbb(const uint8_T*   const in,\n                              const real64_T*  const inDims,\n                              const real64_T         inNumDims,\n                              const boolean_T* const nhood,\n                              const real64_T*  const nhoodDims,\n                              const real64_T         nhoodNumDims,\n                              const real64_T*  const heights,\n                                    uint8_T*         out);\n\n/* uint16_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid dilate_nonflat_uint16_tbb(const uint16_T*  const in,\n                               const real64_T*  const inDims,\n                               const real64_T         inNumDims,\n                               const boolean_T* const nhood,\n                               const real64_T*  const nhoodDims,\n                               const real64_T         nhoodNumDims,\n                               const real64_T*  const heights,\n                                     uint16_T*        out);\n\n/* uint32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid dilate_nonflat_uint32_tbb(const uint32_T*  const in,\n                               const real64_T*  const inDims,\n                               const real64_T         inNumDims,\n                               const boolean_T* const nhood,\n                               const real64_T*  const nhoodDims,\n                               const real64_T         nhoodNumDims,\n                               const real64_T*  const heights,\n                                     uint32_T*        out);\n\n/* int8_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid dilate_nonflat_int8_tbb(const int8_T*    const in,\n                             const real64_T*  const inDims,\n                             const real64_T         inNumDims,\n                             const boolean_T* const nhood,\n                             const real64_T*  const nhoodDims,\n                             const real64_T         nhoodNumDims,\n                             const real64_T*  const heights,\n                                   int8_T*          out);\n\n/* int16_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid dilate_nonflat_int16_tbb(const int16_T*   const in,\n                              const real64_T*  const inDims,\n                              const real64_T         inNumDims,\n                              const boolean_T* const nhood,\n                              const real64_T*  const nhoodDims,\n                              const real64_T         nhoodNumDims,\n                              const real64_T*  const heights,\n                                    int16_T*         out);\n\n\n/* int32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid dilate_nonflat_int32_tbb(const int32_T*   const in,\n                              const real64_T*  const inDims,\n                              const real64_T         inNumDims,\n                              const boolean_T* const nhood,\n                              const real64_T*  const nhoodDims,\n                              const real64_T         nhoodNumDims,\n                              const real64_T*  const heights,\n                                    int32_T*         out);\n\n\n/* real32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid dilate_nonflat_real32_tbb(const real32_T*  const in,\n                               const real64_T*  const inDims,\n                               const real64_T         inNumDims,\n                               const boolean_T* const nhood,\n                               const real64_T*  const nhoodDims,\n                               const real64_T         nhoodNumDims,\n                               const real64_T*  const heights,\n                                     real32_T*        out);\n\n\n/* real64_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid dilate_nonflat_real64_tbb(const real64_T*  const in,\n                               const real64_T*  const inDims,\n                               const real64_T         inNumDims,\n                               const boolean_T* const nhood,\n                               const real64_T*  const nhoodDims,\n                               const real64_T         nhoodNumDims,\n                               const real64_T*  const heights,\n                                     real64_T*        out);\n\n\n\n\n/* boolean_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid erode_nonflat_boolean_tbb(const boolean_T* const in,\n                               const real64_T*  const inDims,\n                               const real64_T         inNumDims,\n                               const boolean_T* const nhood,\n                               const real64_T*  const nhoodDims,\n                               const real64_T         nhoodNumDims,\n                               const real64_T*  const heights,\n                                     boolean_T*       out);\n\n/* uint8_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid erode_nonflat_uint8_tbb(const uint8_T*   const in,\n                             const real64_T*  const inDims,\n                             const real64_T         inNumDims,\n                             const boolean_T* const nhood,\n                             const real64_T*  const nhoodDims,\n                             const real64_T         nhoodNumDims,\n                             const real64_T*  const heights,\n                                   uint8_T*         out);\n\n/* uint16_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid erode_nonflat_uint16_tbb(const uint16_T*  const in,\n                              const real64_T*  const inDims,\n                              const real64_T         inNumDims,\n                              const boolean_T* const nhood,\n                              const real64_T*  const nhoodDims,\n                              const real64_T         nhoodNumDims,\n                              const real64_T*  const heights,\n                                    uint16_T*        out);\n\n/* uint32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid erode_nonflat_uint32_tbb(const uint32_T*  const in,\n                              const real64_T*  const inDims,\n                              const real64_T         inNumDims,\n                              const boolean_T* const nhood,\n                              const real64_T*  const nhoodDims,\n                              const real64_T         nhoodNumDims,\n                              const real64_T*  const heights,\n                                    uint32_T*        out);\n\n/* int8_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid erode_nonflat_int8_tbb(const int8_T*    const in,\n                            const real64_T*  const inDims,\n                            const real64_T         inNumDims,\n                            const boolean_T* const nhood,\n                            const real64_T*  const nhoodDims,\n                            const real64_T         nhoodNumDims,\n                            const real64_T*  const heights,\n                                  int8_T*          out);\n\n/* int16_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid erode_nonflat_int16_tbb(const int16_T*   const in,\n                             const real64_T*  const inDims,\n                             const real64_T         inNumDims,\n                             const boolean_T* const nhood,\n                             const real64_T*  const nhoodDims,\n                             const real64_T         nhoodNumDims,\n                             const real64_T*  const heights,\n                                   int16_T*         out);\n\n\n/* int32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid erode_nonflat_int32_tbb(const int32_T*   const in,\n                             const real64_T*  const inDims,\n                             const real64_T         inNumDims,\n                             const boolean_T* const nhood,\n                             const real64_T*  const nhoodDims,\n                             const real64_T         nhoodNumDims,\n                             const real64_T*  const heights,\n                                   int32_T*         out);\n\n\n/* real32_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid erode_nonflat_real32_tbb(const real32_T*  const in,\n                              const real64_T*  const inDims,\n                              const real64_T         inNumDims,\n                              const boolean_T* const nhood,\n                              const real64_T*  const nhoodDims,\n                              const real64_T         nhoodNumDims,\n                              const real64_T*  const heights,\n                                    real32_T*        out);\n\n\n/* real64_T */\nEXTERN_C LIBMWMORPHOP_NONFLAT_TBB_API\nvoid erode_nonflat_real64_tbb(const real64_T*  const in,\n                              const real64_T*  const inDims,\n                              const real64_T         inNumDims,\n                              const boolean_T* const nhood,\n                              const real64_T*  const nhoodDims,\n                              const real64_T         nhoodNumDims,\n                              const real64_T*  const heights,\n                                    real64_T*        out);\n#endif\n"},{"name":"libmwmorphop_packed.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, inc. */\n#ifndef _LIBMWMORPHOP_PACKED_HPP_\n#define _LIBMWMORPHOP_PACKED_HPP_\n\n#ifndef LIBMWMORPHOP_PACKED_API\n#    define LIBMWMORPHOP_PACKED_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n\nEXTERN_C LIBMWMORPHOP_PACKED_API\nvoid dilate_packed_uint32(const uint32_T* const  in,\n                          const real64_T* const  inDims,\n                          const real64_T         inNumDims,\n                          const boolean_T* const nhood,\n                          const real64_T*  const nhoodDims,\n                          const real64_T         nhoodNumDims,\n                                uint32_T*        out,\n                          const boolean_T        columnMajor);\n\nEXTERN_C LIBMWMORPHOP_PACKED_API\nvoid erode_packed_uint32(const uint32_T* const  in,\n                         const real64_T* const  inDims,\n                         const real64_T         inNumDims,\n                         const boolean_T* const nhood,\n                         const real64_T*  const nhoodDims,\n                         const real64_T         nhoodNumDims,\n                         const real64_T         unpacked_M,\n                               uint32_T*        out,\n                         const boolean_T        columnMajor);\n\n#endif"},{"name":"libmwordfilt2.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _ORDFILT2_H_\n#define _ORDFILT2_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWORDFILT2_API\n#    define LIBMWORDFILT2_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWORDFILT2_API void ordfilt2_boolean(const boolean_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                                 const int32_T *offsets, const real64_T numOffsets, \n                                                 const real64_T* const domainSize, const real64_T order, \n                                                 boolean_T* B, const real64_T* const outputSize,\n                                                 const boolean_T columnMajor);\n\nEXTERN_C LIBMWORDFILT2_API void ordfilt2_real64(const real64_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                                const int32_T *offsets, const real64_T numOffsets, \n                                                const real64_T* const domainSize, const real64_T order, \n                                                real64_T* B, const real64_T* const outputSize,\n                                                const boolean_T columnMajor);\n\nEXTERN_C LIBMWORDFILT2_API void ordfilt2_offsets(const real64_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                                 const int32_T *offsets, const real64_T numOffsets, \n                                                 const real64_T* const domainSize, const real64_T order, const real64_T* add,\n                                                 real64_T* B, const real64_T* const outputSize);\n\nEXTERN_C LIBMWORDFILT2_API void ordfilt2_real32(const real32_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                                const int32_T *offsets, const real64_T numOffsets, \n                                                const real64_T* const domainSize, const real64_T order, \n                                                real32_T* B, const real64_T* const outputSize,\n                                                const boolean_T columnMajor);\n      \nEXTERN_C LIBMWORDFILT2_API void ordfilt2_int8(const int8_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                              const int32_T *offsets, const real64_T numOffsets, \n                                              const real64_T* const domainSize, const real64_T order, \n                                              int8_T* B, const real64_T* const outputSize,\n                                              const boolean_T columnMajor);\n\nEXTERN_C LIBMWORDFILT2_API void ordfilt2_uint8(const uint8_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                               const int32_T *offsets, const real64_T numOffsets, \n                                               const real64_T* const domainSize, const real64_T order, \n                                               uint8_T* B, const real64_T* const outputSize,\n                                               const boolean_T columnMajor);\n\nEXTERN_C LIBMWORDFILT2_API void ordfilt2_int16(const int16_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                               const int32_T *offsets, const real64_T numOffsets, \n                                               const real64_T* const domainSize, const real64_T order, \n                                               int16_T* B, const real64_T* const outputSize,\n                                               const boolean_T columnMajor);\n\nEXTERN_C LIBMWORDFILT2_API void ordfilt2_uint16(const uint16_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                                const int32_T *offsets, const real64_T numOffsets, \n                                                const real64_T* const domainSize, const real64_T order,  \n                                                uint16_T* B, const real64_T* const outputSize,\n                                                const boolean_T columnMajor);\n\nEXTERN_C LIBMWORDFILT2_API void ordfilt2_int32(const int32_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                               const int32_T *offsets, const real64_T numOffsets, \n                                               const real64_T* const domainSize, const real64_T order,  \n                                               int32_T* B, const real64_T* const outputSize,\n                                               const boolean_T columnMajor);\n\nEXTERN_C LIBMWORDFILT2_API void ordfilt2_uint32(const uint32_T* A, const real64_T Ma, const real64_T* const startIdx, \n                                                const int32_T *offsets, const real64_T numOffsets, \n                                                const real64_T* const domainSize, const real64_T order,  \n                                                uint32_T* B, const real64_T* const outputSize,\n                                                const boolean_T columnMajor);\n\n\n#endif /* _ORDFILT2_H_ */\n"},{"name":"libmwremap.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _REMAP_H_\n#define _REMAP_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWREMAP_API\n#    define LIBMWREMAP_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWREMAP_API void remap_real64(const real64_T *pSrc, \n                                          const real64_T *srcSize, \n                                          const real64_T ndims,\n                                          real64_T *px, \n                                          real64_T *py, \n                                          int8_T interpolationMethod,\n                                          real64_T *fillVal,\n                                          real64_T *pDst, \n                                          const real64_T *dstSize, \n                                          const real64_T numelDst);\n\nEXTERN_C LIBMWREMAP_API void remap_real32(const real32_T *pSrc, \n                                          const real64_T *srcSize, \n                                          const real64_T ndims,\n                                          real32_T *px, \n                                          real32_T *py, \n                                          int8_T interpolationMethod,\n                                          real32_T *fillVal,\n                                          real32_T *pDst, \n                                          const real64_T *dstSize, \n                                          const real64_T numelDst);\n\nEXTERN_C LIBMWREMAP_API void remap_uint8(const uint8_T *pSrc, \n                                         const real64_T *srcSize, \n                                         const real64_T ndims,\n                                         real32_T *px, \n                                         real32_T *py, \n                                         int8_T interpolationMethod,\n                                         uint8_T *fillVal,\n                                         uint8_T *pDst, \n                                         const real64_T *dstSize, \n                                         const real64_T numelDst);\n\n\n#endif /* _REMAP_H_ */\n"},{"name":"libmwremaptbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _REMAPTBB_H_\n#define _REMAPTBB_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWREMAPTBB_API\n#    define LIBMWREMAPTBB_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWREMAPTBB_API void remaptbb_real64(const real64_T *pSrc, \n                                                const real64_T *srcSize, \n                                                const real64_T ndims,\n                                                real64_T *px, \n                                                real64_T *py, \n                                                int8_T interpolationMethod, \n                                                real64_T *fillVal,\n                                                real64_T *pDst, \n                                                const real64_T *dstSize, \n                                                const real64_T numelDst);\n\nEXTERN_C LIBMWREMAPTBB_API void remaptbb_real32(const real32_T *pSrc, \n                                                const real64_T *srcSize, \n                                                const real64_T ndims,\n                                                real32_T *px, \n                                                real32_T *py, \n                                                int8_T interpolationMethod, \n                                                real32_T *fillVal,\n                                                real32_T *pDst, \n                                                const real64_T *dstSize, \n                                                const real64_T numelDst);\n\nEXTERN_C LIBMWREMAPTBB_API void remaptbb_uint8(const uint8_T *pSrc, \n                                               const real64_T *srcSize, \n                                               const real64_T ndims,\n                                               real32_T *px, \n                                               real32_T *py, \n                                               int8_T interpolationMethod, \n                                               uint8_T *fillVal,\n                                               uint8_T *pDst, \n                                               const real64_T *dstSize, \n                                               const real64_T numelDst);\n\n#endif /* _REMAPTBB_H_ */\n"},{"name":"libmwrgb2gray_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2014-2017 The MathWorks, Inc. */\n#ifndef _RGB2GRAY_TBB_H_\n#define _RGB2GRAY_TBB_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWRGB2GRAY_TBB_API\n#    define LIBMWRGB2GRAY_TBB_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWRGB2GRAY_TBB_API void rgb2gray_tbb_real64(\n\tconst real64_T* inputImage,\n\tconst real64_T numPixels,\n\treal64_T* outputImage,\n    const boolean_T isColumnMajor);\n\nEXTERN_C LIBMWRGB2GRAY_TBB_API void rgb2gray_tbb_real32(\n\tconst real32_T* inputImage,\n\tconst real64_T numPixels,\n\treal32_T* outputImage,\n    const boolean_T isColumnMajor);\n\nEXTERN_C LIBMWRGB2GRAY_TBB_API void rgb2gray_tbb_uint16(\n\tconst uint16_T* inputImage,\n\tconst real64_T numPixels,\n\tuint16_T* outputImage,\n    const boolean_T isColumnMajor);\n\nEXTERN_C LIBMWRGB2GRAY_TBB_API void rgb2gray_tbb_uint8(\n\tconst uint8_T* inputImage,\n\tconst real64_T numPixels,\n\tuint8_T* outputImage,\n    const boolean_T isColumnMajor);\n\n#endif /* _RGB2GRAY_TBB_H_ */\n"},{"name":"libmwrgb2hsv_tbb.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015 The MathWorks, Inc. */\n#ifndef _RGB2HSV_H_\n#define _RGB2HSV_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWRGB2HSV_TBB_API\n#    define LIBMWRGB2HSV_TBB_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWRGB2HSV_TBB_API void rgb2hsv_tbb_real64(\n\tconst real64_T* inputImage, \n\tconst real64_T numPixels,\n\treal64_T* outputImage,\n    const boolean_T isColumnMajor);\n\nEXTERN_C LIBMWRGB2HSV_TBB_API void rgb2hsv_tbb_real32(\n\tconst real32_T* inputImage, \n\tconst real64_T numPixels,\n\treal32_T* outputImage,\n    const boolean_T isColumnMajor);\n\nEXTERN_C LIBMWRGB2HSV_TBB_API void rgb2hsv_tbb_uint16(\n\tconst uint16_T* inputImage, \n\tconst real64_T numPixels,\n\treal64_T* outputImage,\n    const boolean_T isColumnMajor);\n\nEXTERN_C LIBMWRGB2HSV_TBB_API void rgb2hsv_tbb_uint8(\n\tconst uint8_T* inputImage, \n\tconst real64_T numPixels,\n\treal64_T* outputImage,\n    const boolean_T isColumnMajor);\n\n#endif /* _RGB2HSV_H_ */\n"},{"name":"libmwslsa_sim.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLSA_SIM_H\n#define SLSA_SIM_H\n\n/**\n * @file slsa_sim.h\n *\n * This file contains macros to control the scoping of the exported classes\n * and functions from this module. This file should be included by all the\n * in this module.\n *\n */\n\n/* Copyright 2011-2020 The MathWorks, Inc. */\n\n#ifdef BUILDING_LIBMWSLSA_SIM\n /* being included from inside SLSA_SIM module */\n  #include \"package.h\"\n  #define SLSA_SIM_PUBLISHED_C        extern \"C\" DLL_EXPORT_SYM\n#else\n /* being included from outside, such as raccel code */\n  #if defined(__cplusplus)\n /* Needed for non-inlined C++ S-functions */\n    #define SLSA_SIM_PUBLISHED_C     extern \"C\"\n  #else\n    #define SLSA_SIM_PUBLISHED_C     extern\n  #endif\n#endif\n\n#endif //SLSA_SIM_H\n"},{"name":"libmwtbbhist.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2014 The MathWorks, Inc. */\n\n#ifndef _LIBMWTBBHIST_H_\n#define _LIBMWTBBHIST_H_\n\n\n#ifndef LIBMWTBBHIST_API\n#    define LIBMWTBBHIST_API\n#endif\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* uint8_T*/\nEXTERN_C LIBMWTBBHIST_API void tbbhist_uint8(\n        const uint8_T  *in,\n        const real64_T  numInElem,\n        const real64_T  numRows,\n        const real64_T  numCols,\n        real64_T       *out,\n        const real64_T  numOutElem,\n        const real64_T  numBins,\n        boolean_T      *rngFlag,\n        boolean_T      *nanFlag);\n\n/* uint8_T scaled*/\nEXTERN_C LIBMWTBBHIST_API void tbbhist_uint8_scaled(\n        const uint8_T  *in,\n        const real64_T  numInElem,\n        const real64_T  numRows,\n        const real64_T  numCols,\n        real64_T       *out,\n        const real64_T  numOutElem,\n        const real64_T  maxVal,\n        const real64_T  numBins,\n        boolean_T      *rngFlag,\n        boolean_T      *nanFlag);\n\n/* uint16_T */\nEXTERN_C LIBMWTBBHIST_API void tbbhist_uint16(\n        const uint16_T  *in,\n        const real64_T  numInElem,\n        const real64_T  numRows,\n        const real64_T  numCols,\n        real64_T       *out,\n        const real64_T  numOutElem,\n        const real64_T  numBins,\n        boolean_T      *rngFlag,\n        boolean_T      *nanFlag);\n\n/* uint16_T scaled */\nEXTERN_C LIBMWTBBHIST_API void tbbhist_uint16_scaled(\n        const uint16_T *in,\n        const real64_T  numInElem,\n        const real64_T  numRows,\n        const real64_T  numCols,\n        real64_T       *out,\n        const real64_T  numOutElem,\n        const real64_T  maxVal,\n        const real64_T  numBins,\n        boolean_T      *rngFlag,\n        boolean_T      *nanFlag);\n\n/* uint32_T scaled */\nEXTERN_C LIBMWTBBHIST_API void tbbhist_uint32_scaled(\n        const uint32_T *in,\n        const real64_T  numInElem,\n        const real64_T  numRows,\n        const real64_T  numCols,\n        real64_T       *out,\n        const real64_T  numOutElem,\n        const real64_T  maxVal,\n        const real64_T  numBins,\n        boolean_T      *rngFlag,\n        boolean_T      *nanFlag);\n\n/* real32_T */\nEXTERN_C LIBMWTBBHIST_API void tbbhist_real32(\n        const real32_T  *in,\n        const real64_T  numInElem,\n        const real64_T  numRows,\n        const real64_T  numCols,\n        real64_T       *out,\n        const real64_T  numOutElem,\n        const real64_T  numBins,\n        boolean_T      *rngFlag,\n        boolean_T      *nanFlag);\n\n/* real32_T scaled */\nEXTERN_C LIBMWTBBHIST_API void tbbhist_real32_scaled(\n        const real32_T  *in,\n        const real64_T  numInElem,\n        const real64_T  numRows,\n        const real64_T  numCols,\n        real64_T       *out,\n        const real64_T  numOutElem,\n        const real64_T  maxVal,\n        const real64_T  numBins,\n        boolean_T      *rngFlag,\n        boolean_T      *nanFlag);\n\n/*  real64_T */\nEXTERN_C LIBMWTBBHIST_API void tbbhist_real64(\n        const real64_T  *in,\n        const real64_T  numInElem,\n        const real64_T  numRows,\n        const real64_T  numCols,\n        real64_T       *out,\n        const real64_T  numOutElem,\n        const real64_T  numBins,\n        boolean_T      *rngFlag,\n        boolean_T      *nanFlag);\n\n/* real64_T scaled */\nEXTERN_C LIBMWTBBHIST_API void tbbhist_real64_scaled(\n        const real64_T  *in,\n        const real64_T  numInElem,\n        const real64_T  numRows,\n        const real64_T  numCols,\n        real64_T       *out,\n        const real64_T  numOutElem,\n        const real64_T  maxVal,\n        const real64_T  numBins,\n        boolean_T      *rngFlag,\n        boolean_T      *nanFlag);\n\n#endif\n"},{"name":"libmwuint16toint16.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013 The MathWorks, Inc. */\n#ifndef _UINT16TOINT16_H_\n#define _UINT16TOINT16_H_\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWUINT16TOINT16_API\n#    define LIBMWUINT16TOINT16_API\n#endif\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C LIBMWUINT16TOINT16_API void uint16toint16_uint16(\n        const uint16_T    *pr,\n        int16_T         *qr,\n        const real64_T    numElements);\n\n#endif /* _UINT16TOINT16_H_ */\n"},{"name":"mat.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Published header for libmat, the mat library.\n   Copyright 1984-2018 The MathWorks, Inc.\n   This file containes types, macros, and declarations necessary to\n   interface MEX files with the current version of MATLAB.\n   \n   See the release notes for information on supporting earlier versions. */\n\n#ifndef mat_h\n#define mat_h\n\n#include \"matrix.h\"\n\n#if defined(TARGET_API_VERSION)\n#if !(TARGET_API_VERSION == 700 || TARGET_API_VERSION == 800)\n#error invalid TARGET_VERSION_API definition\n#elif defined(MEX_DOUBLE_HANDLE) && TARGET_API_VERSION != 700\n#error It is illegal to use MEX_DOUBLE_HANDLE with linear versioning\n#elif defined(MX_COMPAT_32) && TARGET_API_VERSION != 700\n#error It is illegal to use MX_COMPAT_32 with linear versioning\n#endif\n#endif\n\n\n#if TARGET_API_VERSION == 800\n\n#define matOpen matOpen_800\n#define matClose matClose_800\n#define matGetFp matGetFp_800\n#define matPutVariable matPutVariable_800\n#define matPutVariableAsGlobal matPutVariableAsGlobal_800\n#define matGetVariable matGetVariable_800\n#define matGetNextVariable matGetNextVariable_800\n#define matGetNextVariableInfo matGetNextVariableInfo_800\n#define matGetVariableInfo matGetVariableInfo_800\n#define matDeleteVariable matDeleteVariable_800\n#define matGetDir matGetDir_800\n#define matGetErrno matGetErrno_800\n\n#endif /* TARGET_API_VERSION */\n/*\n * Copyright 1984-2018 The MathWorks, Inc.\n * All Rights Reserved.\n */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifdef mat_core_api_h\n#error the published and developer mat APIs cannot be combined\n#endif\n\n#ifndef mat_published_c_api_h\n#define mat_published_c_api_h\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMAT_API\n#  define LIBMAT_API \n#endif\n\n#include <stdio.h>  /* for FILE */\n\n#include \"matrix.h\" /* for mxArray */\n\n/**\n * \\file\n * \\ingroup mat_pub_C_api\n */\n\n\n/* incomplete typedef for MATFile */\n#ifdef __cplusplus\nclass MATFile;\n#else\ntypedef struct MatFile_tag MATFile;\n#endif\n\n#ifndef LIBMAT_API_OFFERS_ERROR_ENUMS\ntypedef int matError;\n#endif\n\n/* \n * Open a MAT-file \"filename\" using mode \"mode\".  Return\n * a pointer to a MATFile for use with other MAT API functions.\n *\n * Current valid entries for \"mode\" are\n * \"r\"    == read only.\n * \"w\"    == write only (deletes any existing file with name <filename>).\n * \"w4\"   == as \"w\", but create a MATLAB 4.0 MAT-file.\n * \"w7.3\" == as \"w\", but create a MATLAB 7.3 MAT-file.\n * \"u\"    == update.  Read and write allowed, existing file is not deleted.\n * \n * Return NULL if an error occurs.\n */\nEXTERN_C LIBMAT_API MATFile* matOpen(const char *filename, const char * mode);\n\n\n/*\n * Close a MAT-file opened with matOpen.\n * The pointer-to-MATfile argument is invalid, once matClose returns.\n * Return zero for success, EOF on error.\n */\nEXTERN_C LIBMAT_API matError matClose(MATFile *pMF);\n\n/*\n * Return zero if MATFile is successfully openedno error, nonzero value otherwise.\n */\nEXTERN_C LIBMAT_API matError matGetErrno(MATFile *pMF);\n\n\n/*\n * Return the ANSI C FILE pointer obtained when the MAT-file was opened.\n * Warning: the FILE pointer may be NULL in the case of a MAT file format\n * that does not allow access to the raw file pointer.\n */\nEXTERN_C LIBMAT_API FILE * matGetFp(MATFile *pMF);\n\n\n/*\n * Write array value with the specified name to the MAT-file, deleting any \n * previously existing variable with that name in the MAT-file.\n *\n * Return zero for success, nonzero for error.\n */\nEXTERN_C LIBMAT_API matError matPutVariable(MATFile * pMF, const char * name, const mxArray * pA);\n\n\n/*\n * Write array value with the specified name to the MAT-file pMF, deleting any \n * previously existing variable in the MAT-file with the same name.\n *\n * The variable will be written such that when the MATLAB LOAD command \n * loads the variable, it will automatically place it in the \n * global workspace and establish a link to it in the local\n * workspace (as if the command \"global <varname>\" had been\n * issued after the variable was loaded.)\n *\n * Return zero for success, nonzero for error.\n */\nEXTERN_C LIBMAT_API matError matPutVariableAsGlobal(MATFile * pMF, const char * name, const mxArray * pA);\n\n\n/*\n * Read the array value for the specified variable name from a MAT-file.\n *\n * Return NULL if an error occurs.\n */\nEXTERN_C LIBMAT_API mxArray * matGetVariable(MATFile * pMF, const char * name);\n\n\n/* \n * Read the next array value from the current file location of the MAT-file\n * pMF.  This function should only be used in conjunction with \n * matOpen and matClose.  Passing pMF to any other API functions\n * will cause matGetNextVariable() to work incorrectly.\n *\n * Return NULL if an error occurs.\n */\nEXTERN_C LIBMAT_API mxArray * matGetNextVariable(MATFile *pMF, const char **nameptr);\n\n\n/*\n * Read the array header of the next array value in a MAT-file.  \n * This function should only be used in conjunction with \n * matOpen and matClose.  Passing pMF to any other API functions\n * will cause matGetNextVariableInfo to work incorrectly.\n * \n * See the description of matGetVariableInfo() for the definition\n * and valid uses of an array header.\n *\n * Return NULL if an error occurs.\n */ \nEXTERN_C LIBMAT_API mxArray * matGetNextVariableInfo(MATFile *pMF, const char **nameptr);\n\n\n/*\n * Read the array header for the variable with the specified name from \n * the MAT-file.\n * \n * An array header contains all the same information as an\n * array, except that the pr, pi, ir, and jc data structures are \n * not allocated for non-recursive data types.  That is,\n * Cells, structures, and objects contain pointers to other\n * array headers, but numeric, string, and sparse arrays do not \n * contain valid data in their pr, pi, ir, or jc fields.\n *\n * The purpose of an array header is to gain fast access to \n * information about an array without reading all the array's\n * actual data.  Thus, functions such as mxGetM, mxGetN, and mxGetClassID\n * can be used with array headers, but mxGetPr, mxGetPi, mxGetIr, mxGetJc,\n * mxSetPr, mxSetPi, mxSetIr, and mxSetJc cannot.\n *\n * An array header should NEVER be returned to MATLAB (for example via the\n * MEX API), or any other non-matrix access API function that expects a\n * full mxArray (examples include engPutVariable(), matPutVariable(), and \n * mexPutVariable()).\n *\n * Return NULL if an error occurs.\n */\nEXTERN_C LIBMAT_API mxArray * matGetVariableInfo(MATFile *pMF, const char * name);\n\n\n/*\n * Remove a variable with with the specified name from the MAT-file pMF.\n *\n * Return zero on success, non-zero on error.\n */\nEXTERN_C LIBMAT_API matError matDeleteVariable(MATFile *pMF, const char *name);\n\n\n/* \n * Get a list of the names of the arrays in a MAT-file.\n * The array of strings returned by this function contains \"num\"\n * entries.  It is allocated with one call to mxCalloc, and so \n * can (must) be freed with one call to mxFree.\n *\n * If there are no arrays in the MAT-file, return value \n * is NULL and num is set to zero.  If an error occurs,\n * return value is NULL and num is set to a negative number.\n */\nEXTERN_C LIBMAT_API char ** matGetDir(MATFile * pMF, int *num);\n\n#endif /* mat_published_c_api_h */\n\n#endif /* mat_h */\n"},{"name":"matrix.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * External header for the libmx library.\n *\n * Copyright 1984-2018 The MathWorks, Inc.\n * All Rights Reserved.\n */\n\n#ifdef MDA_ARRAY_HPP_\n#error Using MATLAB Data API with C Matrix API is not supported.\n#endif\n\n#if defined(_MSC_VER)\n#pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n#pragma once\n#endif\n\n#ifndef matrix_h\n#define matrix_h\n\n#include <stdlib.h>\n#include <stddef.h>\n#include \"tmwtypes.h\"\n\n#ifdef __cplusplus\n#define LIBMMWMATRIX_PUBLISHED_API_EXTERN_C extern \"C\"\n#else\n#define LIBMMWMATRIX_PUBLISHED_API_EXTERN_C extern\n#endif\n\n\n\n#define MW_FIRST_API_VERSION 700\n#define R2017b 700\n#define R2018a 800\n#define R2018b 800\n#define R2019a 800\n#define R2019b 800\n#define R201aa 800\n#define R201ab 800\n#define R201ba 800\n#define R201bb 800\n#define R201ca 800\n#define R201cb 800\n#define R201da 800\n#define R201db 800\n#define R201ea 800\n#define R201eb 800\n#define R201fa 800\n#define R201fb 800\n#define R2020a 800\n#define R2020b 800\n#define R2021a 800\n#define R2021b 800\n#define MW_LATEST_API_VERSION 800\n\n\n#define MW_REL2VER(A) A \n\n#if defined(MX_COMPAT_32) || defined(MEX_DOUBLE_HANDLE)\n\n#if defined(MATLAB_MEXCMD_RELEASE) || defined(MATLAB_MEXSRC_RELEASE)\n\n/* Errors! Legacy knobs cannot be used with release-based hard knobs */\n\n#if defined(MX_COMPAT_32) && defined(MATLAB_MEXCMD_RELEASE)\n#error \"MEX command option -R20XXx is incompatible with MX_COMPAT_32\"\n#endif\n\n#if defined(MEX_DOUBLE_HANDLE) && defined(MATLAB_MEXCMD_RELEASE)\n#error \"MEX command option -R20XXx is incompatible with MEX_DOUBLE_HANDLE\"\n#endif\n\n#if defined(MX_COMPAT_32) && defined(MATLAB_MEXSRC_RELEASE)\n#error \"Source code macro MATLAB_MEXSRC_RELEASE is incompatible with MX_COMPAT_32\"\n#endif\n\n#if defined(MEX_DOUBLE_HANDLE) && defined(MATLAB_MEXSRC_RELEASE)\n#error \"Source code macro MATLAB_MEXSRC_RELEASE is incompatible with MEX_DOUBLE_HANDLE\"\n#endif\n\n#else\n\n/* Legacy knobs are defined  */\n\n#define MATLAB_TARGET_API_VERSION MW_FIRST_API_VERSION\n\n#endif\n\n#else /* defined(MX_COMPAT_32) || defined(MEX_DOUBLE_HANDLE) */\n\n/* No Legacy knobs. Check release-based tag */\n\n#if defined(MATLAB_MEXCMD_RELEASE)\n#define MW_MEXCMD_VERSION MW_REL2VER(MATLAB_MEXCMD_RELEASE)\n#if MW_MEXCMD_VERSION < MW_FIRST_API_VERSION\n#error invalid MATLAB_MEXCMD_RELEASE definition\n#endif\n#endif\n\n#if defined(MATLAB_MEXSRC_RELEASE)\n#define MW_MEXSRC_VERSION MW_REL2VER(MATLAB_MEXSRC_RELEASE)\n#if MW_MEXSRC_VERSION < MW_FIRST_API_VERSION\n#error invalid MATLAB_MEXSRC_RELEASE definition\n#endif\n#endif\n      \n#if defined(MATLAB_DEFAULT_RELEASE)\n#define MW_DEFAULT_VERSION MW_REL2VER(MATLAB_DEFAULT_RELEASE)\n#if MW_DEFAULT_VERSION < MW_FIRST_API_VERSION\n#error invalid MATLAB_DEFAULT_RELEASE definition\n#endif\n#endif\n\n#if defined(MATLAB_MEXCMD_RELEASE) && defined(MATLAB_MEXSRC_RELEASE)\n#if MW_MEXCMD_VERSION != MW_MEXSRC_VERSION\n#error \"MEX command option -R20XXx is incompatible with MATLAB_MEXSRC_RELEASE\"\n#endif\n#endif\n\n#if defined(MATLAB_MEXCMD_RELEASE) || defined(MATLAB_MEXSRC_RELEASE)\n\n/* Check whether MEXCMD and MEXSRC release tags are compatible */\n\n#if defined(MATLAB_MEXCMD_RELEASE)\n#define MATLAB_TARGET_API_VERSION MW_MEXCMD_VERSION\n#else\n#define MATLAB_TARGET_API_VERSION MW_MEXSRC_VERSION\n#endif\n\n#else /* defined(MATLAB_MEXCMD_RELEASE) || defined(MATLAB_MEXSRC_RELEASE) */\n\n#if defined(MATLAB_DEFAULT_RELEASE)\n#define MATLAB_TARGET_API_VERSION MW_DEFAULT_VERSION\n#else\n\n/* None of the input macros are defined. Use LATEST */\n#define MATLAB_TARGET_API_VERSION MW_LATEST_API_VERSION\n\n#endif /* defined(MATLAB_DEFAULT_RELEASE) */\n\n#endif /* defined(MATLAB_MEXCMD_RELEASE) || defined(MATLAB_MEXSRC_RELEASE) */\n\n#endif /* defined(MX_COMPAT_32) || defined(MEX_DOUBLE_HANDLE) */\n\n#if defined(TARGET_API_VERSION)\n#if MATLAB_TARGET_API_VERSION != TARGET_API_VERSION\n#error MATLAB_TARGET_API_VERSION != TARGET_API_VERSION\n#endif\n#else\n#define TARGET_API_VERSION MATLAB_TARGET_API_VERSION\n#endif\n\n\n\n/**\n * Forward declaration for mxArray\n */\ntypedef struct mxArray_tag mxArray;\n\n/**\n * MEX-file entry point type\n */\ntypedef void (*mxFunctionPtr)(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);\n\n/**\n * Maximum mxArray name length\n */\n#define mxMAXNAM TMW_NAME_LENGTH_MAX\n\n/**\n * Logical type\n */\ntypedef bool mxLogical;\n\n/**\n * Required for Unicode support in MATLAB\n */\ntypedef CHAR16_T mxChar;\n\n/**\n * mxArray classes.\n */\ntypedef enum {\n    mxUNKNOWN_CLASS = 0,\n    mxCELL_CLASS,\n    mxSTRUCT_CLASS,\n    mxLOGICAL_CLASS,\n    mxCHAR_CLASS,\n    mxVOID_CLASS,\n    mxDOUBLE_CLASS,\n    mxSINGLE_CLASS,\n    mxINT8_CLASS,\n    mxUINT8_CLASS,\n    mxINT16_CLASS,\n    mxUINT16_CLASS,\n    mxINT32_CLASS,\n    mxUINT32_CLASS,\n    mxINT64_CLASS,\n    mxUINT64_CLASS,\n    mxFUNCTION_CLASS,\n    mxOPAQUE_CLASS,\n    mxOBJECT_CLASS,\n#if defined(_LP64) || defined(_WIN64)\n    mxINDEX_CLASS = mxUINT64_CLASS\n#else\n    mxINDEX_CLASS = mxUINT32_CLASS\n#endif\n} mxClassID;\n\n/**\n * Indicates whether floating-point mxArrays are real or complex.\n */\ntypedef enum { mxREAL, mxCOMPLEX } mxComplexity;\n\n/*\n * MATRIX numeric real data types\n */\ntypedef double mxDouble;\ntypedef float mxSingle;\ntypedef int8_T mxInt8;\ntypedef uint8_T mxUint8;\ntypedef int16_T mxInt16;\ntypedef uint16_T mxUint16;\ntypedef int32_T mxInt32;\ntypedef uint32_T mxUint32;\ntypedef int64_T mxInt64;\ntypedef uint64_T mxUint64;\n\n#if TARGET_API_VERSION >= 800\n/*\n * MATRIX numeric complex data types\n */\ntypedef struct { mxDouble real, imag; } mxComplexDouble;\ntypedef struct { mxSingle real, imag; } mxComplexSingle;\ntypedef struct { mxInt8 real, imag; } mxComplexInt8;\ntypedef struct { mxUint8 real, imag; } mxComplexUint8;\ntypedef struct { mxInt16 real, imag; } mxComplexInt16;\ntypedef struct { mxUint16 real, imag; } mxComplexUint16;\ntypedef struct { mxInt32 real, imag; } mxComplexInt32;\ntypedef struct { mxUint32 real, imag; } mxComplexUint32;\ntypedef struct { mxInt64 real, imag; } mxComplexInt64;\ntypedef struct { mxUint64 real, imag; } mxComplexUint64;\n\n#endif /* TARGET_API_VERSION >= 800 */\n\n#if defined(TARGET_API_VERSION)\n#if !(TARGET_API_VERSION == 700 || TARGET_API_VERSION == 800)\n#error invalid TARGET_VERSION_API definition\n#elif defined(MEX_DOUBLE_HANDLE) && TARGET_API_VERSION != 700\n#error It is illegal to use MEX_DOUBLE_HANDLE with linear versioning\n#elif defined(MX_COMPAT_32) && TARGET_API_VERSION != 700\n#error It is illegal to use MX_COMPAT_32 with linear versioning\n#endif\n#endif\n\n\n#if !defined(TARGET_API_VERSION) || TARGET_API_VERSION == 700\n\n/*\n * PUBLISHED APIs with changes in MATLAB 7.3\n */\n\n#if !defined(MX_COMPAT_32)\n\n#define mxSetProperty mxSetProperty_730\n#define mxGetProperty mxGetProperty_730\n#define mxSetField mxSetField_730\n#define mxSetFieldByNumber mxSetFieldByNumber_730\n#define mxGetFieldByNumber mxGetFieldByNumber_730\n#define mxGetField mxGetField_730\n#define mxCreateStructMatrix mxCreateStructMatrix_730\n#define mxCreateCellMatrix mxCreateCellMatrix_730\n#define mxCreateCharMatrixFromStrings mxCreateCharMatrixFromStrings_730\n#define mxGetString mxGetString_730\n#define mxGetNumberOfDimensions mxGetNumberOfDimensions_730\n#define mxGetDimensions mxGetDimensions_730\n#define mxSetDimensions mxSetDimensions_730\n#define mxSetIr mxSetIr_730\n#define mxGetIr mxGetIr_730\n#define mxSetJc mxSetJc_730\n#define mxGetJc mxGetJc_730\n#define mxCreateStructArray mxCreateStructArray_730\n#define mxCreateCharArray mxCreateCharArray_730\n#define mxCreateNumericArray mxCreateNumericArray_730\n#define mxCreateCellArray mxCreateCellArray_730\n#define mxCreateLogicalArray mxCreateLogicalArray_730\n#define mxGetCell mxGetCell_730\n#define mxSetCell mxSetCell_730\n#define mxSetNzmax mxSetNzmax_730\n#define mxSetN mxSetN_730\n#define mxSetM mxSetM_730\n#define mxGetNzmax mxGetNzmax_730\n#define mxCreateDoubleMatrix mxCreateDoubleMatrix_730\n#define mxCreateNumericMatrix mxCreateNumericMatrix_730\n#define mxCreateLogicalMatrix mxCreateLogicalMatrix_730\n#define mxCreateSparse mxCreateSparse_730\n#define mxCreateSparseLogicalMatrix mxCreateSparseLogicalMatrix_730\n#define mxGetNChars mxGetNChars_730\n#define mxCreateStringFromNChars mxCreateStringFromNChars_730\n#define mxCalcSingleSubscript mxCalcSingleSubscript_730\n#define mxGetDimensions_fcn mxGetDimensions_730\n\n#else /* MX_COMPAT_32 */\n\n/*\n * 32-bit compatibility APIs\n */\n\n#define mxGetNumberOfDimensions mxGetNumberOfDimensions_700\n#define mxGetDimensions mxGetDimensions_700\n#define mxGetDimensions_fcn mxGetDimensions_700\n#define mxGetIr mxGetIr_700\n#define mxGetJc mxGetJc_700\n#define mxGetCell mxGetCell_700\n#define mxGetNzmax mxGetNzmax_700\n#define mxSetNzmax mxSetNzmax_700\n#define mxGetFieldByNumber mxGetFieldByNumber_700\n#define mxSetProperty mxSetProperty_700\n#define mxGetProperty mxGetProperty_700\n#define mxSetField mxSetField_700\n#define mxSetFieldByNumber mxSetFieldByNumber_700\n#define mxGetField mxGetField_700\n#define mxCreateStructMatrix mxCreateStructMatrix_700\n#define mxCreateCellMatrix mxCreateCellMatrix_700\n#define mxCreateCharMatrixFromStrings mxCreateCharMatrixFromStrings_700\n#define mxGetString mxGetString_700\n#define mxSetDimensions mxSetDimensions_700\n#define mxSetIr mxSetIr_700\n#define mxSetJc mxSetJc_700\n#define mxCreateStructArray mxCreateStructArray_700\n#define mxCreateCharArray mxCreateCharArray_700\n#define mxCreateNumericArray mxCreateNumericArray_700\n#define mxCreateCellArray mxCreateCellArray_700\n#define mxCreateLogicalArray mxCreateLogicalArray_700\n#define mxSetCell mxSetCell_700\n#define mxSetN mxSetN_700\n#define mxSetM mxSetM_700\n#define mxCreateDoubleMatrix mxCreateDoubleMatrix_700\n#define mxCreateNumericMatrix mxCreateNumericMatrix_700\n#define mxCreateLogicalMatrix mxCreateLogicalMatrix_700\n#define mxCreateSparse mxCreateSparse_700\n#define mxCreateSparseLogicalMatrix mxCreateSparseLogicalMatrix_700\n#define mxGetNChars mxGetNChars_700\n#define mxCreateStringFromNChars mxCreateStringFromNChars_700\n#define mxCalcSingleSubscript mxCalcSingleSubscript_700\n\n#endif /* #ifdef MX_COMPAT_32 */\n\n\n#elif TARGET_API_VERSION == 800\n\n#define mxMalloc mxMalloc_800\n#define mxCalloc mxCalloc_800\n#define mxRealloc mxRealloc_800\n#define mxGetM mxGetM_800\n#define mxGetN mxGetN_800\n#define mxGetNumberOfElements mxGetNumberOfElements_800\n#define mxFree mxFree_800\n#define mxGetEps mxGetEps_800\n#define mxGetInf mxGetInf_800\n#define mxGetFieldNameByNumber mxGetFieldNameByNumber_800\n#define mxGetClassID mxGetClassID_800\n#define mxIsNumeric mxIsNumeric_800\n#define mxIsCell mxIsCell_800\n#define mxIsLogical mxIsLogical_800\n#define mxIsChar mxIsChar_800\n#define mxIsStruct mxIsStruct_800\n#define mxIsSparse mxIsSparse_800\n#define mxIsDouble mxIsDouble_800\n#define mxIsSingle mxIsSingle_800\n#define mxIsInt8 mxIsInt8_800\n#define mxIsUint8 mxIsUint8_800\n#define mxIsInt16 mxIsInt16_800\n#define mxIsUint16 mxIsUint16_800\n#define mxIsInt32 mxIsInt32_800\n#define mxIsUint32 mxIsUint32_800\n#define mxIsInt64 mxIsInt64_800\n#define mxIsUint64 mxIsUint64_800\n#define mxIsFromGlobalWS mxIsFromGlobalWS_800\n#define mxIsEmpty mxIsEmpty_800\n#define mxGetFieldNumber mxGetFieldNumber_800\n#define mxGetNumberOfFields mxGetNumberOfFields_800\n#define mxGetClassName mxGetClassName_800\n#define mxIsClass mxIsClass_800\n#define mxDestroyArray mxDestroyArray_800\n#define mxCreateDoubleScalar mxCreateDoubleScalar_800\n#define mxCreateString mxCreateString_800\n#define mxAddField mxAddField_800\n#define mxRemoveField mxRemoveField_800\n#define mxGetNaN mxGetNaN_800\n#define mxIsFinite mxIsFinite_800\n#define mxIsInf mxIsInf_800\n#define mxIsNaN mxIsNaN_800\n#define mxIsScalar mxIsScalar_800\n#define mxIsOpaque mxIsOpaque_800\n#define mxIsFunctionHandle mxIsFunctionHandle_800\n#define mxIsObject mxIsObject_800\n#define mxGetChars mxGetChars_800\n#define mxGetUserBits mxGetUserBits_800\n#define mxSetUserBits mxSetUserBits_800\n#define mxSetFromGlobalWS mxSetFromGlobalWS_800\n#define mxCreateUninitNumericMatrix mxCreateUninitNumericMatrix_800\n#define mxCreateUninitNumericArray mxCreateUninitNumericArray_800\n#define mxGetLogicals mxGetLogicals_800\n#define mxCreateLogicalScalar mxCreateLogicalScalar_800\n#define mxIsLogicalScalar mxIsLogicalScalar_800\n#define mxIsLogicalScalarTrue mxIsLogicalScalarTrue_800\n#define mxArrayToString mxArrayToString_800\n#define mxArrayToUTF8String mxArrayToUTF8String_800\n#define mxSetClassName mxSetClassName_800\n#define mxGetNumberOfDimensions mxGetNumberOfDimensions_800\n#define mxGetDimensions mxGetDimensions_800\n#define mxGetIr mxGetIr_800\n#define mxGetJc mxGetJc_800\n#define mxGetNzmax mxGetNzmax_800\n#define mxGetFieldByNumber mxGetFieldByNumber_800\n#define mxGetCell mxGetCell_800\n#define mxSetIr mxSetIr_800\n#define mxSetJc mxSetJc_800\n#define mxCalcSingleSubscript mxCalcSingleSubscript_800\n#define mxSetCell mxSetCell_800\n#define mxSetFieldByNumber mxSetFieldByNumber_800\n#define mxGetField mxGetField_800\n#define mxSetField mxSetField_800\n#define mxGetProperty mxGetProperty_800\n#define mxSetProperty mxSetProperty_800\n#define mxCreateNumericMatrix mxCreateNumericMatrix_800\n#define mxCreateNumericArray mxCreateNumericArray_800\n#define mxCreateCharArray mxCreateCharArray_800\n#define mxCreateDoubleMatrix mxCreateDoubleMatrix_800\n#define mxCreateSparse mxCreateSparse_800\n#define mxGetString mxGetString_800\n#define mxCreateCharMatrixFromStrings mxCreateCharMatrixFromStrings_800\n#define mxCreateCellMatrix mxCreateCellMatrix_800\n#define mxCreateCellArray mxCreateCellArray_800\n#define mxCreateStructMatrix mxCreateStructMatrix_800\n#define mxCreateStructArray mxCreateStructArray_800\n#define mxCreateLogicalArray mxCreateLogicalArray_800\n#define mxCreateLogicalMatrix mxCreateLogicalMatrix_800\n#define mxCreateSparseLogicalMatrix mxCreateSparseLogicalMatrix_800\n#define mxCreateStringFromNChars mxCreateStringFromNChars_800\n#define mxGetNChars mxGetNChars_800\n#define mxSetM mxSetM_800\n#define mxSetN mxSetN_800\n#define mxSetDimensions mxSetDimensions_800\n#define mxSetNzmax mxSetNzmax_800\n#define mxGetData mxGetData_800\n#define mxSetData mxSetData_800\n#define mxIsComplex mxIsComplex_800\n#define mxGetScalar mxGetScalar_800\n#define mxGetPr mxGetPr_800\n#define mxSetPr mxSetPr_800\n#define mxGetElementSize mxGetElementSize_800\n#define mxDuplicateArray mxDuplicateArray_800\n#define mxGetDoubles mxGetDoubles_800\n#define mxSetDoubles mxSetDoubles_800\n#define mxGetComplexDoubles mxGetComplexDoubles_800\n#define mxSetComplexDoubles mxSetComplexDoubles_800\n#define mxGetSingles mxGetSingles_800\n#define mxSetSingles mxSetSingles_800\n#define mxGetComplexSingles mxGetComplexSingles_800\n#define mxSetComplexSingles mxSetComplexSingles_800\n#define mxGetInt8s mxGetInt8s_800\n#define mxSetInt8s mxSetInt8s_800\n#define mxGetComplexInt8s mxGetComplexInt8s_800\n#define mxSetComplexInt8s mxSetComplexInt8s_800\n#define mxGetUint8s mxGetUint8s_800\n#define mxSetUint8s mxSetUint8s_800\n#define mxGetComplexUint8s mxGetComplexUint8s_800\n#define mxSetComplexUint8s mxSetComplexUint8s_800\n#define mxGetInt16s mxGetInt16s_800\n#define mxSetInt16s mxSetInt16s_800\n#define mxGetComplexInt16s mxGetComplexInt16s_800\n#define mxSetComplexInt16s mxSetComplexInt16s_800\n#define mxGetUint16s mxGetUint16s_800\n#define mxSetUint16s mxSetUint16s_800\n#define mxGetComplexUint16s mxGetComplexUint16s_800\n#define mxSetComplexUint16s mxSetComplexUint16s_800\n#define mxGetInt32s mxGetInt32s_800\n#define mxSetInt32s mxSetInt32s_800\n#define mxGetComplexInt32s mxGetComplexInt32s_800\n#define mxSetComplexInt32s mxSetComplexInt32s_800\n#define mxGetUint32s mxGetUint32s_800\n#define mxSetUint32s mxSetUint32s_800\n#define mxGetComplexUint32s mxGetComplexUint32s_800\n#define mxSetComplexUint32s mxSetComplexUint32s_800\n#define mxGetInt64s mxGetInt64s_800\n#define mxSetInt64s mxSetInt64s_800\n#define mxGetComplexInt64s mxGetComplexInt64s_800\n#define mxSetComplexInt64s mxSetComplexInt64s_800\n#define mxGetUint64s mxGetUint64s_800\n#define mxSetUint64s mxSetUint64s_800\n#define mxGetComplexUint64s mxGetComplexUint64s_800\n#define mxSetComplexUint64s mxSetComplexUint64s_800\n#define mxMakeArrayReal mxMakeArrayReal_800\n#define mxMakeArrayComplex mxMakeArrayComplex_800\n#define mxGetPi mxGetPiIsDeprecated\n#define mxGetImagData mxGetImagDataIsDeprecated\n#define mxSetImagData mxSetImagDataIsDeprecated\n#define mxSetPi mxSetPiIsDeprecated\n#define mxCreateSharedDataCopy mxCreateSharedDataCopyIsDeprecated\n#define mxCreateUninitDoubleMatrix mxCreateUninitDoubleMatrixIsDeprecated\n#define mxFastZeros mxFastZerosIsDeprecated\n#define mxUnreference mxUnreferenceIsDeprecated\n#define mxUnshareArray mxUnshareArrayIsDeprecated\n#define mxGetPropertyShared mxGetPropertySharedIsDeprecated\n#define mxSetPropertyShared mxSetPropertySharedIsDeprecated\n\n#endif /* TARGET_API_VERSION */\n\n/*\n * allocate memory, notifying registered listener\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void *mxMalloc(size_t n /* number of bytes */\n                                                   );\n\n/*\n * allocate cleared memory, notifying registered listener.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void *mxCalloc(size_t n,   /* number of objects */\n                                                   size_t size /* size of objects */\n                                                   );\n\n/*\n * free memory, notifying registered listener.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxFree(void *ptr) /* pointer to memory to be freed */;\n\n/*\n * reallocate memory, notifying registered listener.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void *mxRealloc(void *ptr, size_t size);\n\n/*\n * Get number of dimensions in array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mwSize mxGetNumberOfDimensions(const mxArray *pa);\n\n/*\n * Get pointer to dimension array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C const mwSize *mxGetDimensions(const mxArray *pa);\n\n/*\n * Get row dimension\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C size_t mxGetM(const mxArray *pa);\n\n/*\n * Get row data pointer for sparse numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mwIndex *mxGetIr(const mxArray *pa);\n\n/*\n * Get column data pointer for sparse numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mwIndex *mxGetJc(const mxArray *pa);\n\n/*\n * Get maximum nonzero elements for sparse numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mwSize mxGetNzmax(const mxArray *pa);\n\n/*\n * Set maximum nonzero elements for numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetNzmax(mxArray *pa, mwSize nzmax);\n\n/*\n * Return pointer to the nth field name\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C const char *mxGetFieldNameByNumber(const mxArray *pa, int n);\n\n\n/*\n * Return a pointer to the contents of the named field for\n * the ith element (zero based).\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxGetFieldByNumber(const mxArray *pa, mwIndex i, int fieldnum);\n\n/*\n * Get a pointer to the specified cell element.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxGetCell(const mxArray *pa, mwIndex i);\n\n/*\n * Return the class (category) of data that the array holds.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxClassID mxGetClassID(const mxArray *pa);\n\n/*\n * Get pointer to data\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void *mxGetData(const mxArray *pa /* pointer to array */\n                                                    );\n\n/*\n * Set pointer to data\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetData(mxArray *pa,  /* pointer to array */\n                                                   void *newdata /* pointer to data */\n                                                   );\n\n/*\n * Determine whether the specified array contains numeric (as opposed\n * to cell or struct) data.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsNumeric(const mxArray *pa);\n\n/*\n * Determine whether the given array is a cell array.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsCell(const mxArray *pa);\n\n/*\n * Determine whether the given array's logical flag is on.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsLogical(const mxArray *pa);\n\n/*\n * Determine whether the given array's scalar flag is on.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsScalar(const mxArray *pa);\n\n/*\n * Determine whether the given array contains character data.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsChar(const mxArray *pa);\n\n/*\n * Determine whether the given array is a structure array.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsStruct(const mxArray *pa);\n\n/*\n * Determine whether the given array is an opaque array.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsOpaque(const mxArray *pa);\n\n/*\n * Returns true if specified array is a function object.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsFunctionHandle(const mxArray *pa);\n\n/*\n * This function is deprecated and is preserved only for backward compatibility.\n * DO NOT USE if possible.\n * Is array user defined MATLAB v5 object\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsObject(const mxArray *pa /* pointer to array */\n                                                    );\n#if !defined(TARGET_API_VERSION) || (TARGET_API_VERSION == 700)\n/*\n * Get imaginary data pointer for numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void *mxGetImagData(const mxArray *pa /* pointer to array */\n                                                        );\n\n/*\n * Set imaginary data pointer for numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void\nmxSetImagData(mxArray *pa,  /* pointer to array */\n              void *newdata /* imaginary data array pointer */\n              );\n#endif\n\n/*\n * Determine whether the given array contains complex data.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsComplex(const mxArray *pa);\n\n/*\n * Determine whether the given array is a sparse (as opposed to full).\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsSparse(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * double-precision floating-point numbers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsDouble(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * single-precision floating-point numbers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsSingle(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * signed 8-bit integers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsInt8(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * unsigned 8-bit integers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsUint8(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * signed 16-bit integers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsInt16(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * unsigned 16-bit integers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsUint16(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * signed 32-bit integers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsInt32(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * unsigned 32-bit integers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsUint32(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * signed 64-bit integers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsInt64(const mxArray *pa);\n\n/*\n * Determine whether the specified array represents its data as\n * unsigned 64-bit integers.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsUint64(const mxArray *pa);\n\n/*\n * Get number of elements in array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C size_t mxGetNumberOfElements(\n    const mxArray *pa /* pointer to array */\n    );\n\n#if !defined(TARGET_API_VERSION) || (TARGET_API_VERSION == 700)\n/*\n * Get imaginary data pointer for numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C double *mxGetPi(const mxArray *pa /* pointer to array */\n                                                    );\n\n/*\n * Set imaginary data pointer for numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetPi(mxArray *pa, /* pointer to array */\n                                                 double *pi   /* imaginary data array pointer */\n                                                 );\n#endif\n\n/*\n * Get string array data\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxChar *mxGetChars(const mxArray *pa /* pointer to array */\n                                                       );\n\n/*\n * Get 8 bits of user data stored in the mxArray header.  NOTE: The state\n * of these bits is not guaranteed to be preserved after API function\n * calls.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxGetUserBits(const mxArray *pa /* pointer to array */\n                                                      );\n\n/*\n * Set 8 bits of user data stored in the mxArray header. NOTE: The state\n * of these bits is not guaranteed to be preserved after API function\n * calls.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetUserBits(mxArray *pa, /* pointer to array */\n                                                       int value);\n\n/*\n * Get the real component of the specified array's first data element.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C double mxGetScalar(const mxArray *pa);\n\n/*\n * Inform Watcom compilers that scalar double return values\n * will be in the FPU register.\n */\n#ifdef __WATCOMC__\n#pragma aux mxGetScalar value[8087];\n#endif\n\n/*\n * Is the isFromGlobalWorkspace bit set?\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsFromGlobalWS(const mxArray *pa);\n\n/*\n * Set the isFromGlobalWorkspace bit.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetFromGlobalWS(mxArray *pa, bool global);\n\n/*\n * Set row dimension\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetM(mxArray *pa, mwSize m);\n\n/*\n * Get column dimension\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C size_t mxGetN(const mxArray *pa);\n\n/*\n * Is array empty\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsEmpty(const mxArray *pa /* pointer to array */\n                                                   );\n/*\n * Get the index to the named field.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxGetFieldNumber(const mxArray *pa, const char *name);\n\n/*\n * Set row data pointer for sparse numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetIr(mxArray *pa, mwIndex *newir);\n\n/*\n * Set column data pointer for sparse numeric array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetJc(mxArray *pa, mwIndex *newjc);\n\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C double *mxGetPr(const mxArray *pa);\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetPr(mxArray *pa, double *newdata);\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C size_t mxGetElementSize(const mxArray *pa);\n\n/*\n * Return the offset (in number of elements) from the beginning of\n * the array to a given subscript.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mwIndex mxCalcSingleSubscript(const mxArray *pa,\n                                                                     mwSize nsubs,\n                                                                     const mwIndex *subs);\n\n/*\n * Get number of structure fields in array\n * Returns 0 if mxArray is non-struct.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxGetNumberOfFields(const mxArray *pa /* pointer to array */\n                                                            );\n\n/*\n * Set an element in a cell array to the specified value.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetCell(mxArray *pa, mwIndex i, mxArray *value);\n\n/*\n * Set pa[i][fieldnum] = value\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void \nmxSetFieldByNumber(mxArray *pa, mwIndex i, int fieldnum, mxArray *value);\n\n/*\n * Return a pointer to the contents of the named field for the ith\n * element (zero based).  Returns NULL on no such field or if the\n * field itself is NULL\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxGetField(const mxArray *pa, mwIndex i, const char *fieldname);\n\n/*\n * Sets the contents of the named field for the ith element (zero based).\n * The input 'value' is stored in the input array 'pa' - no copy is made.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void\nmxSetField(mxArray *pa, mwIndex i, const char *fieldname, mxArray *value);\n\n/*\n * mxGetProperty returns the value of a property for a given object and index.\n * The property must be public.\n *\n * If the given property name doesn't exist, or isn't public, or the object isn't\n * the right type, then mxGetProperty returns NULL.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxGetProperty(const mxArray *pa, const mwIndex i, const char *propname);\n\n/*\n * mxSetProperty sets the value of a property for a given object and index.\n * The property must be public.\n *\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void\nmxSetProperty(mxArray *pa, mwIndex i, const char *propname, const mxArray *value);\n\n/*\n * Return the name of an array's class.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C const char *mxGetClassName(const mxArray *pa);\n\n/*\n * Determine whether an array is a member of the specified class.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsClass(const mxArray *pa, const char *name);\n\n/*\n * Create a numeric matrix and initialize all its data elements to 0.\n * In standalone mode, out-of-memory will mean a NULL pointer is returned.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxCreateNumericMatrix(mwSize m, mwSize n, mxClassID classid, mxComplexity flag);\n\n/*\n * Create an uninitialized numeric matrix.\n * The resulting array must be freed with mxDestroyArray.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxCreateUninitNumericMatrix(size_t m, size_t n, mxClassID classid, mxComplexity flag);\n\n/*\n * Create an uninitialized numeric array.\n * The resulting array must be freed with mxDestroyArray.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxCreateUninitNumericArray(size_t ndim, size_t *dims, mxClassID classid, mxComplexity flag);\n\n/*\n * Set column dimension\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetN(mxArray *pa, mwSize n);\n\n/*\n * Set dimension array and number of dimensions.  Returns 0 on success and 1\n * if there was not enough memory available to reallocate the dimensions array.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int\nmxSetDimensions(mxArray *pa, const mwSize *pdims, mwSize ndims);\n\n/*\n * mxArray destructor\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxDestroyArray(mxArray *pa);\n\n/*\n * Create a numeric array and initialize all its data elements to 0.\n *\n * As with mxCreateNumericMatrix, in a standalone application,\n * out-of-memory will mean a NULL pointer is returned.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxCreateNumericArray(mwSize ndim, const mwSize *dims, mxClassID classid, mxComplexity flag);\n\n/*\n * Create an N-Dimensional array to hold string data;\n * initialize all elements to 0.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateCharArray(mwSize ndim, const mwSize *dims);\n\n/*\n * Create a two-dimensional array to hold double-precision\n * floating-point data; initialize each data element to 0.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxCreateDoubleMatrix(mwSize m, mwSize n, mxComplexity flag);\n\n/*\n * Get a properly typed pointer to the elements of a logical array.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxLogical *mxGetLogicals(const mxArray *pa);\n\n/*\n * Create a logical array and initialize its data elements to false.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateLogicalArray(mwSize ndim, const mwSize *dims);\n\n/*\n * Create a two-dimensional array to hold logical data and\n * initialize each data element to false.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateLogicalMatrix(mwSize m, mwSize n);\n\n/*\n * Create a logical scalar mxArray having the specified value.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateLogicalScalar(bool value);\n\n/*\n * Returns true if we have a valid logical scalar mxArray.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsLogicalScalar(const mxArray *pa);\n\n/*\n * Returns true if the logical scalar value is true.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsLogicalScalarTrue(const mxArray *pa);\n\n/*\n * Create a double-precision scalar mxArray initialized to the\n * value specified\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateDoubleScalar(double value);\n\n/*\n * Create a 2-Dimensional sparse array.\n *\n * Z = mxCreateSparse(m,n,nzmax,cmplx_flag);\n * An m-by-n, real or complex, sparse matrix with room for nzmax nonzeros.\n * Use this to allocate storage for a sparse matrix.\n * It allocates the structure, allocates the pr, pi, ir and jc arrays,\n * and sets all the fields, which may be changed later.\n * Avoids the question of malloc(0) by replacing nzmax = 0 with nzmax = 1.\n * Also sets Z->pr[0] = 0.0 so that the scalar sparse(0.0) acts like 0.0.\n *\n * Notice that the value of m is almost irrelevant.  It is only stored in\n * the mxSetM field of the matrix structure.  It does not affect the amount\n * of storage required by sparse matrices, or the amount of time required\n * by sparse algorithms.  Consequently, m can be \"infinite\".  The result\n * is a semi-infinite matrix with a finite number of columns and a finite,\n * but unspecified, number of nonzero rows.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxCreateSparse(mwSize m, mwSize n, mwSize nzmax, mxComplexity flag);\n\n/*\n * Create a 2-D sparse logical array\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxCreateSparseLogicalMatrix(mwSize m, mwSize n, mwSize nzmax);\n\n/*\n * Copies characters from a MATLAB array to a char array\n * This function will attempt to perform null termination if it is possible.\n * nChars is the number of bytes in the output buffer\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void\nmxGetNChars(const mxArray *pa, char *buf, mwSize nChars);\n\n/*\n * Converts a string array to a C-style string. The C-style string is in the\n * local codepage encoding. If the conversion for the entire Unicode string\n * cannot fit into the supplied character buffer, then the conversion includes\n * the last whole codepoint that will fit into the buffer. The string is thus\n * truncated at the greatest possible whole codepoint and does not split code-\n * points.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int\nmxGetString(const mxArray *pa, char *buf, mwSize buflen);\n\n/*\n * Create a NULL terminated C string from an mxArray of type mxCHAR_CLASS\n * Supports multibyte character sets.  The resulting string must be freed\n * with mxFree.  Returns NULL on out of memory or non-character arrays.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C char *mxArrayToString(const mxArray *pa);\n\n/*\n * Create a NULL terminated C string from an mxArray of type mxCHAR_CLASS\n * The C style string is in UTF-8 encoding. The resulting\n * string must be freed with mxFree. Returns NULL on out of memory or\n * non-character arrays.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C char *mxArrayToUTF8String(mxArray const *pa);\n\n/**\n * Create a character vector initialized from the first n bytes in str. The\n * supplied string is presumed to be in the local codepage encoding. The\n * character data format in the mxArray will be UTF-16.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateStringFromNChars(const char *str, mwSize n);\n\n/*\n * Create a character vector initialized from null-terminated string str. The\n * supplied string can use either UTF-8 encoding or the local codepage encoding.\n * The character data format in the mxArray will be UTF-16.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateString(const char *str);\n\n/*\n * Create a string array initialized to the strings in str.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateCharMatrixFromStrings(mwSize m, const char **str);\n\n/*\n * Create a 2-Dimensional cell array, with each cell initialized\n * to NULL.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateCellMatrix(mwSize m, mwSize n);\n\n/*\n * Create an N-Dimensional cell array, with each cell initialized\n * to NULL.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateCellArray(mwSize ndim, const mwSize *dims);\n\n/*\n * Create a 2-Dimensional structure array having the specified fields;\n * initialize all values to NULL.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxCreateStructMatrix(mwSize m, mwSize n, int nfields, const char **fieldnames);\n\n/*\n * Create an N-Dimensional structure array having the specified fields;\n * initialize all values to NULL.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *\nmxCreateStructArray(mwSize ndim, const mwSize *dims, int nfields, const char **fieldnames);\n\n/*\n * Make a deep copy of an array, return a pointer to the copy.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxDuplicateArray(const mxArray *in);\n\n/*\n * Set classname of an unvalidated object array.  It is illegal to\n * call this function on a previously validated object array.\n * Return 0 for success, 1 for failure.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxSetClassName(mxArray *pa, const char *classname);\n\n/*\n * Add a field to a structure array. Returns field number on success or -1\n * if inputs are invalid or an out of memory condition occurs.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxAddField(mxArray *pa, const char *fieldname);\n\n/*\n * Remove a field from a structure array.  Does nothing if no such field exists.\n * Does not destroy the field itself.\n*/\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxRemoveField(mxArray *pa, int field);\n\n/*\n * Function for obtaining MATLAB's concept of EPS\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C double mxGetEps(void);\n\n/*\n * Function for obtaining MATLAB's concept of INF (Used in MEX-File callback).\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C double mxGetInf(void);\n\n/*\n * Function for obtaining MATLAB's concept of NaN (Used in MEX-File callback).\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C double mxGetNaN(void);\n\n/*\n * test for finiteness in a machine-independent manner\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsFinite(double x /* value to test */\n                                                    );\n\n/*\n * test for infinity in a machine-independent manner\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsInf(double x /* value to test */\n                                                 );\n/*\n * test for NaN in a machine-independent manner\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C bool mxIsNaN(double x /* value to test */\n                                                 );\n#if !defined(TARGET_API_VERSION) || (TARGET_API_VERSION == 700)\n/*\n * Undocumented.  Removed in later APIs.\n */\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateSharedDataCopy(const mxArray *pa);\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxCreateUninitDoubleMatrix(int cmplx_flag, size_t m, size_t n);\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxFastZeros(int cmplx_flag, int m, int n);\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxUnreference(mxArray *pa);\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxUnshareArray(mxArray *pa, int level);\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C mxArray *mxGetPropertyShared(const mxArray *pa, size_t i, const char *propname);\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void mxSetPropertyShared(mxArray *pa, size_t i, const char *propname, const mxArray *value);\n#endif\n\n\n#if TARGET_API_VERSION >= 800\n\n/*\n * Typed data access for numeric arrays\n */\n#define MX_DECLARE_DATA_ACCESSORS(Name)                                                              \\\n    LIBMMWMATRIX_PUBLISHED_API_EXTERN_C mx##Name *mxGet##Name##s(mxArray const *);                   \\\n    LIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxSet##Name##s(mxArray *, mx##Name *);                   \\\n    LIBMMWMATRIX_PUBLISHED_API_EXTERN_C mx##Complex##Name *mxGet##Complex##Name##s(mxArray const *); \\\n    LIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxSet##Complex##Name##s(mxArray *, mx##Complex##Name *)\n\nMX_DECLARE_DATA_ACCESSORS(Double); /* mxDoubles*, mxComplexDoubles* in mx[SG]etDoubles, mx[SG]etComplexDoubles */\nMX_DECLARE_DATA_ACCESSORS(Single); /* mxSingles*, mxComplexSingles* in mx[SG]etSingles, mx[SG]etComplexSingles */\nMX_DECLARE_DATA_ACCESSORS(Int8);   /* mxInt8s*,   mxComplexInt8s*   in mx[SG]etInt8s,   mx[SG]etComplexInt8s   */\nMX_DECLARE_DATA_ACCESSORS(Uint8);  /* mxUint8s*,  mxComplexUint8s*  in mx[SG]etUint8s,  mx[SG]etComplexUint8s  */\nMX_DECLARE_DATA_ACCESSORS(Int16);  /* mxInt16s*,  mxComplexInt16s*  in mx[SG]etInt16s,  mx[SG]etComplexInt16s  */\nMX_DECLARE_DATA_ACCESSORS(Uint16); /* mxUint16s*, mxComplexUint16s* in mx[SG]etUint16s, mx[SG]etComplexUint16s */\nMX_DECLARE_DATA_ACCESSORS(Int32);  /* mxInt32s*,  mxComplexInt32s*  in mx[SG]etInt32s,  mx[SG]etComplexInt32s  */\nMX_DECLARE_DATA_ACCESSORS(Uint32); /* mxUint32s*, mxComplexUint32s* in mx[SG]etUint32s, mx[SG]etComplexUint32s */\nMX_DECLARE_DATA_ACCESSORS(Int64);  /* mxInt64s*,  mxComplexInt64s*  in mx[SG]etInt64s,  mx[SG]etComplexInt64s  */\nMX_DECLARE_DATA_ACCESSORS(Uint64); /* mxUint64s*, mxComplexUint64s* in mx[SG]etUint64s, mx[SG]etComplexUint64s */\n\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxMakeArrayReal(mxArray *);\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C int mxMakeArrayComplex(mxArray *);\n\n#endif /* TARGET_API_VERSION >= 800 */\n\n/*\nmxAssert(int expression, char *error_message)\n---------------------------------------------\n\n  Similar to ANSI C's assert() macro, the mxAssert macro checks the\n  value of an assertion, continuing execution only if the assertion\n  holds.  If 'expression' evaluates to be true, then the mxAssert does\n  nothing.  If, however, 'expression' is false, then mxAssert prints an\n  error message to the MATLAB Command Window, consisting of the failed\n  assertion's expression, the file name and line number where the failed\n  assertion occurred, and the string 'error_message'.  'error_message'\n  allows the user to specify a more understandable description of why\n  the assertion failed.  (Use an empty string if no extra description\n  should follow the failed assertion message.)  After a failed\n  assertion, control returns to the MATLAB command line.\n\n  mxAssertS, (the S for Simple), takes the same inputs as mxAssert.  It\n  does not print the text of the failed assertion, only the file and\n  line where the assertion failed, and the explanatory error_message.\n\n  Note that script MEX will turn off these assertions when building\n  optimized MEX-functions, so they should be used for debugging\n  purposes only.\n*/\n\n#ifdef MATLAB_MEX_FILE\n#ifndef NDEBUG\n\nLIBMMWMATRIX_PUBLISHED_API_EXTERN_C void\nmexPrintAssertion(const char *test, const char *fname, int linenum, const char *message);\n\n#define mxAssert(test, message)                                                                    \\\n    ((test) ? (void)0 : mexPrintAssertion(#test, __FILE__, __LINE__, message))\n#define mxAssertS(test, message)                                                                   \\\n    ((test) ? (void)0 : mexPrintAssertion(\"\", __FILE__, __LINE__, message))\n#else\n#define mxAssert(test, message) ((void)0)\n#define mxAssertS(test, message) ((void)0)\n#endif\n#else\n#include <assert.h>\n#define mxAssert(test, message) assert(test)\n#define mxAssertS(test, message) assert(test)\n#endif\n\n/* Current MATRIX published API version */\n#define MX_CURRENT_API_VER 0x08000000\n\n/* Backward compatible current MATRIX published API version */\n#define MX_API_VER MX_CURRENT_API_VER\n\n/* Backward compatible MATRIX published API versions */\n#define MX_LAST_32BIT_VER 0x07000000\n#define MX_LAST_SEPARATE_COMPLEX_VER 0x07300000\n\n/* Required MEX-file MATRIX published API version */\n#if TARGET_API_VERSION == 700\n#if defined(MX_COMPAT_32)\n#define MX_TARGET_API_VER MX_LAST_32BIT_VER\n#else\n#define MX_TARGET_API_VER MX_LAST_SEPARATE_COMPLEX_VER\n#endif\n#else\n#define MX_TARGET_API_VER MX_CURRENT_API_VER\n#endif\n\n/*\n * The following macros enable conditional compilation based on the\n * target published API. The macros can be used in a single source file\n * that is intended to be built against multiple matrix API versions.\n *\n * MX_HAS_64BIT_ARRAY_DIMS evaluates to a non-zero value if array\n * dimensions are 64 bits wide.\n *\n * MX_HAS_INTERLEAVED_COMPLEX evaluates to a non-zero value if complex\n * array data is interleaved.\n *\n */\n#define MX_HAS_64BIT_ARRAY_DIMS MX_TARGET_API_VER > MX_LAST_32BIT_VER\n#define MX_HAS_INTERLEAVED_COMPLEX MX_TARGET_API_VER > MX_LAST_SEPARATE_COMPLEX_VER\n\n/*\n * Inform Watcom compilers that scalar double return values\n * will be in the FPU register.\n */\n#ifdef __WATCOMC__\n#pragma aux mxGetEps value[8087];\n#pragma aux mxGetInf value[8087];\n#pragma aux mxGetNaN value[8087];\n#endif\n\n#endif /* matrix_h */\n"},{"name":"mclbase.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * PUBLISHed header for libmclbase, the mclbase library.\n *\n * Copyright 1984-2016 The MathWorks, Inc.\n */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef mclbase_published_api_h\n#define mclbase_published_api_h\n\n/* SWIG can't see these definitions, which are stored in package.h, so we\n   duplicate them here. */\n#ifdef _MSC_VER\n#define DLL_EXPORT_SYM __declspec(dllexport)\n#define DLL_IMPORT_SYM __declspec(dllimport)\n#elif __GNUC__ >= 4\n#define DLL_EXPORT_SYM __attribute__ ((visibility(\"default\")))\n#define DLL_IMPORT_SYM __attribute__ ((visibility(\"default\")))\n#else\n#define DLL_EXPORT_SYM\n#define DLL_IMPORT_SYM\n#endif\n\n\n#ifndef EXTERN_C\n#  ifdef __cplusplus\n#    define EXTERN_C extern \"C\"\n#  else\n#    define EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWMCLBASE_API\n#  define LIBMWMCLBASE_API DLL_IMPORT_SYM\n#endif\n\n#ifndef LIBMWMCLBASE_API_EXTERN_C\n#  define LIBMWMCLBASE_API_EXTERN_C EXTERN_C LIBMWMCLBASE_API\n#endif\n\nLIBMWMCLBASE_API_EXTERN_C void mclSetLastErrIdAndMsg(const char* newid, const char* newmsg);\n\n\nLIBMWMCLBASE_API_EXTERN_C const char* mclGetLastErrorMessage();\n\n\n/* Get stack trace string when error happens\n */\nLIBMWMCLBASE_API_EXTERN_C int mclGetStackTrace(char*** stack);\n\n\n/* Free the stack trace string allocated earlier\n */\nLIBMWMCLBASE_API_EXTERN_C int mclFreeStackTrace(char*** stack, int nStackDepth);\n\n\n#include <stdarg.h>\n#include <string.h>\n#include <wchar.h>\n#include \"tmwtypes.h\"\n\n/* Use cases for mcl runtime libraries.\n * Used to configure MVM use.\n */\n#define mclUndefined 0\n#define mclNoMvm 1\n#define mclStandaloneApp 2\n#define mclStandaloneContainer 3\n#define mclJavaBuilder 4\n#define mclMcc 5\n#define mclClient 6\n#define mclWebAppServer 7\n\n/* C-compatible definition of MVM ID type. */\ntypedef long MVMID_t;\n\n#define mclMATLABEx 1\n#define mclUserEx 2\n#define mclCOMEx 3\n\nLIBMWMCLBASE_API_EXTERN_C int mclGetLastExceptionType();\n\nLIBMWMCLBASE_API_EXTERN_C void mclAcquireMutex(void);\n\n\nLIBMWMCLBASE_API_EXTERN_C void mclReleaseMutex(void);\n\n\nLIBMWMCLBASE_API_EXTERN_C bool mclIsMCRInitialized();\n\n\nLIBMWMCLBASE_API_EXTERN_C bool mclIsJVMEnabled();\n\n\nLIBMWMCLBASE_API_EXTERN_C const char* mclGetLogFileName();\n\n\nLIBMWMCLBASE_API_EXTERN_C bool mclIsNoDisplaySet();\n\n\nLIBMWMCLBASE_API_EXTERN_C bool mclInitializeApplication(const char** options, size_t count);\n\n\nLIBMWMCLBASE_API_EXTERN_C bool mclTerminateApplication(void);\n\n\nLIBMWMCLBASE_API_EXTERN_C bool mclIsMcc();\n\n\ntypedef int (*mclOutputHandlerFcn)(const char *s);\n\n\n#include <string.h>\n\n\n/* Extract the path from a file name specified by either absolute or\n * relative path. For example:\n *\n *   /home/foo/bar.exe -> /home/foo\n *   ./bar.exe -> <full path to cwd>/bar.exe\n *   bar.exe -> <empty string>\n *\n * Returns a pointer to the memory passed in by the caller.\n */\nLIBMWMCLBASE_API_EXTERN_C void separatePathName(const char *fullname, char *buf, size_t bufLen);\n\n\ntypedef void* HMCRINSTANCE;\n\n\nLIBMWMCLBASE_API_EXTERN_C bool mclFreeStrArray(char **array, size_t elements);\n\n\n#include \"matrix.h\"\n\n\nLIBMWMCLBASE_API_EXTERN_C void mclFreeArrayList(int nargs, mxArray** ppxArgs);\n\n\nLIBMWMCLBASE_API_EXTERN_C mxArray *mclCreateCellArrayFromArrayList(int narray, mxArray *parray[]);\n\n\nLIBMWMCLBASE_API_EXTERN_C mxArray* mclCreateSharedCopy(mxArray* px);\n\n\nLIBMWMCLBASE_API_EXTERN_C mxArray* mclCreateEmptyArray(void);\n\n\nLIBMWMCLBASE_API_EXTERN_C mxArray* mclCreateSimpleFunctionHandle(mxFunctionPtr fcn);\n\n\nLIBMWMCLBASE_API_EXTERN_C mxArray* mclMxSerialize(mxArray * pa);\n\n\nLIBMWMCLBASE_API_EXTERN_C mxArray* mclMxDeserialize(const void* ps, size_t len);\n\n\nLIBMWMCLBASE_API_EXTERN_C void mclSetInterleavedCompatibility(bool bInterleavedCompatibility);\n\nLIBMWMCLBASE_API_EXTERN_C bool mclIsInterleavedCompatibility();\n\n/* Main functions passed to mclRunMain must be of this type. This typedef\n * must be placed OUTSIDE of an extern \"C\" block to ensure that it has the\n * right linkage in the automatically generated MCLMCRRT proxy API. See\n * mclmcrrt/GenLibProxyAPI.pl for more details.\n */\ntypedef int (*mclMainFcnType)(int, const char **);\n\n\nLIBMWMCLBASE_API_EXTERN_C int mclRunMain(mclMainFcnType run_main,\n                                         int argc,\n                                         const char **argv);\n\nLIBMWMCLBASE_API_EXTERN_C void mclCFRunLoopRun();\n\nLIBMWMCLBASE_API_EXTERN_C void mclCFRunLoopStop();\n\nLIBMWMCLBASE_API_EXTERN_C bool mclIsCFRunLoopReady();\n\n#endif /* mclbase_h */\n"},{"name":"mclcom.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"#ifndef MCLCOM_H\n#define MCLCOM_H\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n/* Struct for passing data conversion flags */\ntypedef struct _MCLCONVERSION_FLAGS\n{\n    mwArrayFormat InputFmt;     /* Input array format */\n    long nInputInd;             /* Input array format indirection flag */\n    mwArrayFormat OutputFmt;    /* Output array format */\n    long nOutputInd;            /* Output array format indirection flag */\n    bool bAutoResize;           /* Auto-resize-output flag for Excel ranges */\n    bool bTranspose;            /* Transpose-output flag */\n    long nTransposeInd;         /* Transpose-output indirection flag */\n    mxClassID nCoerceNumeric;   /* Coerce-all-numeric-input-to-type flag */\n    mwDateFormat InputDateFmt;  /* Input date format */\n    mxComplexity Complexity;    /* Input-is-complex flag */\n    bool bReal;                 /* Copy-to-real/imag-buffer flag */\n    bool bOutputAsDate;         /* Coerce-output-to-date flag */\n    long nDateBias;             /* Date bias to use in date conversion */\n    mwReplaceMissingData ReplaceMissing; /* Value to substitute for missing data for inputs*/\n\tmwReplaceMatlabNaN   ReplaceMatlabNaN; /*Value to substitute matlab NaN for outputs*/\n} _MCLCONVERSION_FLAGS, *MCLCONVERSION_FLAGS;\n\n#endif\n"},{"name":"mclcomclass.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2001-2016 The MathWorks, Inc. */\n\n#ifndef _MCLCOMCLASS_H_\n#define _MCLCOMCLASS_H_\n\n#pragma warning( disable : 4786 )\n#include \"mclmcrrt.h\"\n#include \"mwcomutil.h\"\n#include <olectl.h>\n#include <wchar.h>\n\n#ifdef __cplusplus\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n\n#ifndef HWND_MESSAGE\n#define HWND_MESSAGE (HWND)NULL\n#endif\n\n// Structure used to pass supporting info for objects into CMCLModule Init method.\n\ntypedef struct _MCLOBJECT_MAP_ENTRY\n{\n    // Pointer to CLSID value\n\n    const CLSID* pclsid;\n    // Pointer to function responsible for registering the class\n\n    HRESULT (__stdcall* pfnRegisterClass)(const GUID*, unsigned short, unsigned short, \n                                          const char*, const char*, const char*, const char*);\n    // Pointer to function responsible for unregistering the class\n\n    HRESULT (__stdcall* pfnUnregisterClass)(const char*, const char*);\n    // Pointer to function responsible for returning an instance of the object's class factory\n\n    HRESULT (__stdcall* pfnGetClassObject)(REFCLSID, REFIID, void**);\n    // Class's friendly name\n\n    const char* lpszFriendlyName;\n    // Class's version independent ProgID\n\n    const char* lpszVerIndProgID;\n    // Class's ProgID\n\n    const char* lpszProgID;\n} _MCLOBJECT_MAP_ENTRY, *MCLOBJECT_MAP_ENTRY;\n\nclass mwLock\n{\npublic:\n    mwLock()\n    {\n        mclAcquireMutex();\n    }\n    virtual ~mwLock()\n    {\n        mclReleaseMutex();\n    }\n};\n\nclass IMCLFeval\n{\npublic:\n    virtual bool Feval(HMCRINSTANCE hinst, const char* name, int nlhs, mxArray** plhs, int nrhs, mxArray** prhs) = 0;\n    virtual const char* getErrorMessage() const = 0;\n    virtual void RaiseEvent(OLECHAR* lpwszName, DISPID dispid, IDispatch* pDisp, DISPPARAMS* pDispParams) = 0;\n    virtual bool init(HINSTANCE hInstance) = 0;\n    virtual bool stop() = 0;\n};\n\nclass IMCLEvent\n{\npublic:\n    virtual void mclRaiseEventA(const char* lpszName, DISPID dispid, int nargin, mxArray** prhs) = 0;\n};\n\nclass IMCLEventMap\n{\npublic:\n    virtual int size() = 0;\n    virtual void add(void *context, IMCLEvent* pEvent) = 0;\n    virtual void remove(void *context, IMCLEvent* pEvent) = 0;\n    virtual void invokeA(void *context, const char* lpszName, DISPID dispid, int nargin, mxArray** prhs) = 0;\n};\n\ntypedef bool (*MCLInitializeInstancePtr)(HMCRINSTANCE*, const char* path_to_component);\ntypedef bool (*MCLInitializeInstanceExPtr)(HMCRINSTANCE*, const char* path_to_component, \n                                           mclCtfStream ctfStream);\ntypedef bool (*MCLTerminateInstancePtr)(HMCRINSTANCE*);\n\n#define WM_FEVALCOMPLETE WM_USER\n#define WM_EVENTPENDING WM_USER+1\n\n// Class for managing global list of event listeners.\nclass mclEventMap : public IMCLEventMap\n{\npublic:\n    mclEventMap(){}\n    virtual ~mclEventMap(){}\n    // Returns current number of listeners\n    int size()\n    {\n        mwLock lock;\n        return (int)m_events.size();\n    }\n    // Adds a listener\n    void add(void *context, IMCLEvent* pEvent)\n    {\n        mwLock lock;\n        if (!pEvent)\n            return;\n        std::map<void *, IMCLEvent*>::iterator it = m_events.find(context);\n        if (it == m_events.end())\n            m_events[context] = pEvent;\n    }\n    // Removes a listener\n    void remove(void *context, IMCLEvent* pEvent)\n    {\n        (void)pEvent;\n        mwLock lock;\n        std::map<void *, IMCLEvent*>::iterator it = m_events.find(context);\n        if (it != m_events.end())\n            m_events.erase(it);\n    }\n    // Invokes the named event in the listener of current call context.\n    void invokeA(void *context, const char* lpszName, DISPID dispid, int nargin, mxArray** prhs)\n    {\n        mwLock lock;\n        std::map<void *, IMCLEvent*>::iterator it = m_events.find(context);\n        if (it != m_events.end())\n        {\n            ((*it).second)->mclRaiseEventA(lpszName, dispid, nargin, prhs);\n        }\n    }\nprivate:\n    std::map<void *, IMCLEvent*> m_events; // Array of listeners\n};\n\n// Class for managing global list of event listeners for singleton MCR case.\nclass mclSingleEventMap : public IMCLEventMap\n{\npublic:\n    mclSingleEventMap(){}\n    virtual ~mclSingleEventMap(){}\n    // Returns current number of listeners\n    int size()\n    {\n        mwLock lock;\n        return (int)m_events.size();\n    }\n    // Adds a listener\n    void add(void *context, IMCLEvent* pEvent)\n    {\n        mwLock lock;\n        if (!pEvent)\n            return;\n        m_events.insert(pEvent);\n    }\n    // Removes a listener\n    void remove(void *context, IMCLEvent* pEvent)\n    {\n        context;\n        mwLock lock;\n        std::set<IMCLEvent*>::iterator it = m_events.find(pEvent);\n        if (it != m_events.end())\n            m_events.erase(it);\n    }\n    // Invokes the named event in the listener of current call context.\n    void invokeA(void *context, const char* lpszName, DISPID dispid, int nargin, mxArray** prhs)\n    {\n        context;\n        mwLock lock;\n        std::set<IMCLEvent*>::iterator it = m_events.begin();\n        while (it != m_events.end())\n        {\n            (*it)->mclRaiseEventA(lpszName, dispid, nargin, prhs);\n            it++;\n        }\n    }\nprivate:\n    std::set<IMCLEvent*> m_events; // Array of listeners\n};\n\n// Stack proxy for a mutex\nclass ModuleLock\n{\npublic:\n    ModuleLock()\n    {\n#if defined (mclcommain_h) || defined (mclxlmain_published_api_h)\n        RequestGlobalLock();\n#else\n        mclRequestGlobalLock();\n#endif\n    }\n    virtual ~ModuleLock()\n    {\n#if defined (mclcommain_h) || defined (mclxlmain_published_api_h)\n        ReleaseGlobalLock();\n#else\n        mclReleaseGlobalLock();\n#endif\n    }\nprivate:\n    ModuleLock(const ModuleLock& ml);\n    ModuleLock& operator=(const ModuleLock& ml);\n};\n\nclass mclSimpleFeval : public IMCLFeval\n{\npublic:\n    mclSimpleFeval(){}\n    virtual ~mclSimpleFeval(){}\n    // Calls feval.\n    virtual bool Feval(HMCRINSTANCE hinst, const char* name, int nlhs, mxArray** plhs, int nrhs, mxArray** prhs)\n    {\n        return mclFeval(hinst, name, nlhs, plhs, nrhs, prhs);\n    }\n    // Makes an event callback.\n    virtual void RaiseEvent(OLECHAR* lpwszName, DISPID mdispid, IDispatch* pDisp, DISPPARAMS* pDispParams)\n    {\n        DISPID dispid = 0;\n        VARIANT varResult;\n        HRESULT hr = S_OK;\n\n        VariantInit(&varResult);\n        if (SUCCEEDED(hr = pDisp->GetIDsOfNames(IID_NULL, &lpwszName, 1, LOCALE_USER_DEFAULT, &dispid)))\n        {\n            hr = pDisp->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, pDispParams, \n                                    &varResult, NULL, NULL);\n        }\n    }\n    virtual const char* getErrorMessage() const\n    {\n        return mclGetLastErrorMessage();\n    }\n    virtual bool init(HINSTANCE hInstance)\n    {\n        (void)hInstance;\n        return true;\n    }\n    virtual bool stop()\n    {\n        return true;\n    }\n};\n// Feval with events. Creates a thread on which all\n// feval calls are made. Calling thread waits on feval\n// thread to complete feval call. If an event arrives\n// before the feval call returns, the calling thread \n// executes the callback, then resumes waiting for the\n// the feval to finish. This ensures that synchronous\n// callbacks are always executed by the same thread that\n// made the original feval call. This is needed because \n// Visual Basic does not allow callbacks to be executed\n// on a seperate thread, and the MCR always calls back on\n// its thread, not the caller's.\nclass mclFevalWithEvents : public IMCLFeval\n{\nprivate:\n    // Class used to pass feval args when being called by\n    // Same thread as the message window runs on. When\n    // feval is complete, posts a message to the window.\n    class FevalArgs\n    {\n    public:\n        FevalArgs(HMCRINSTANCE hinst, const char* name, int nlhs, mxArray** plhs, int nrhs, mxArray** prhs, HWND hWnd)\n            : m_hinst(hinst), m_name(name), m_nlhs(nlhs), m_plhs(plhs), m_nrhs(nrhs), m_prhs(prhs), m_retval(false), m_hWnd(hWnd), m_errorMessage(\"\"){}\n        virtual ~FevalArgs(){}\n        virtual bool execute()\n        {\n            m_retval = mclFeval(m_hinst, m_name, m_nlhs, m_plhs, m_nrhs, m_prhs);\n            \n            if(!m_retval)\n            {\n                m_errorMessage = mclGetLastErrorMessage();\n            }\n            \n            PostMessage(m_hWnd, WM_FEVALCOMPLETE, 0, 0);\n            return m_retval;\n        }\n        bool retval() const {return m_retval;}\n        const char* getErrorMessage() const {return m_errorMessage;}\n    private:\n        HMCRINSTANCE m_hinst;\n        const char* m_name;\n        int m_nlhs;\n        mxArray** m_plhs;\n        int m_nrhs;\n        mxArray** m_prhs;\n        bool m_retval;\n        HWND m_hWnd;\n        const char* m_errorMessage;\n    private:\n        FevalArgs();\n    };\n    // Class used to pass event args\n    class EventArgs\n    {\n    public:\n        EventArgs(OLECHAR* lpwszName, DISPID dispid, IDispatch* pDisp, DISPPARAMS* pDispParams)\n        : m_lpwszName(lpwszName), m_dispid(dispid), m_pDisp(pDisp), m_pDispParams(pDispParams), m_hr(S_OK)\n        {\n            VariantInit(&m_varResult);\n        }\n        virtual ~EventArgs()\n        {\n            VariantClear(&m_varResult);\n        }\n        virtual bool execute()\n        {\n            DISPID dispid = 0;\n\n            m_hr = m_pDisp->Invoke(m_dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, m_pDispParams, \n                                     &m_varResult, NULL, NULL);\n            return (SUCCEEDED(m_hr));\n        }\n        HRESULT retval() {return m_hr;}\n    private:\n        OLECHAR* m_lpwszName;\n        IDispatch* m_pDisp;\n        DISPPARAMS* m_pDispParams;\n        VARIANT m_varResult;\n        HRESULT m_hr;\n        DISPID m_dispid;\n    private:\n        EventArgs();\n    };\npublic:\n    mclFevalWithEvents() : m_hInstance(NULL), m_hThread(NULL), m_hWnd(NULL), m_errorMessage(\"\") {}\n    virtual ~mclFevalWithEvents()\n    {\n        stop();\n    }\n    // Calls feval. Queues up the request, then\n    // waits for the call to finish.\n    virtual bool Feval(HMCRINSTANCE hinst, const char* name, int nlhs, mxArray** plhs, int nrhs, mxArray** prhs)\n    {\n        HWND hWnd = NULL;\n        BOOL bRet = FALSE;\n        MSG msg = {0, 0, 0, 0, 0, {0,0}};\n        if (!(hWnd = get_thread_window()))\n            return false;\n        FevalArgs Args(hinst, name, nlhs, plhs, nrhs, prhs, hWnd);\n        // Queue the request\n        add(&Args);\n        // Start timer to periodically refresh windows owned by this thread\n        SetTimer(hWnd, 1, 100, NULL);\n        // Process window message loop. Break when feval is finished.\n        while ((bRet = GetMessage(&msg, hWnd, 0, 0)) != 0)\n        {\n            if (bRet == -1)\n            {\n                return false;\n            }\n            else if (msg.message == WM_FEVALCOMPLETE)\n            {\n                break;\n            }\n            else if (msg.message == WM_TIMER)\n            {\n                DoEvents();\n            }\n            else\n            {\n                TranslateMessage(&msg);\n                DispatchMessage(&msg);\n            }\n        }\n        // Stop timer\n        KillTimer(hWnd, 1);\n        m_errorMessage = Args.getErrorMessage();\n        return Args.retval();\n    }\n\n    virtual const char* getErrorMessage() const\n    {\n        return m_errorMessage;\n    }\n    // Makes an event callback. Queues up the call,\n    // then waits for it to finish.\n    virtual void RaiseEvent(OLECHAR* lpwszName, DISPID dispid, IDispatch* pDisp, DISPPARAMS* pDispParams)\n    {\n        EventArgs Args(lpwszName, dispid, pDisp, pDispParams);\n        SendMessage(m_hWnd, WM_EVENTPENDING, 0, (LPARAM)(&Args));\n    }\n    // Performs idle processing.\n    void DoEvents()\n    {\n        EnumThreadWindows(GetCurrentThreadId(), EnumThreadWndProc, NULL);\n    }\n    // Starts the feval thread\n   virtual bool init(HINSTANCE hInstance)\n    {\n        m_hInstance = hInstance;\n        if (!(m_hExit = CreateEvent(NULL, FALSE, FALSE, NULL)))\n            return false;\n        if (!(m_hFevalPending = CreateEvent(NULL, FALSE, FALSE, NULL)))\n            return false;\n        WNDCLASS wc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        if (!GetClassInfo(m_hInstance, \"feval_window_class\", &wc))\n        {\n            WNDCLASS wc_new = {0, (WNDPROC)ModuleWndProc, 0, 0, m_hInstance, NULL, NULL, NULL, NULL, \"feval_window_class\"};\n            if (!RegisterClass(&wc_new))\n                return false;\n        }\n        if (!(m_hWnd = get_thread_window()))\n            return false;\n        if (!(m_hThread = CreateThread(NULL, 0, FevalProc, (LPVOID)this, 0, &m_dwThreadID)))\n            return false;\n        return true;\n    }\n    // Stops the feval thread, destroys window\n    virtual bool stop()\n    {\n        SetEvent(m_hExit);\n        WaitForSingleObject(m_hThread, INFINITE);\n        CloseHandle(m_hThread);\n        std::map<DWORD, HWND>::iterator it = m_ThreadData.begin();\n        while(it != m_ThreadData.end())\n        {\n            HWND hWnd = (*it).second;\n            if (hWnd)\n                DestroyWindow(hWnd);\n            it++;\n        }\n        UnregisterClass(\"feval_window_class\", m_hInstance);\n        m_hWnd = NULL;\n        m_ThreadData.clear();\n        CloseHandle(m_hExit);\n        CloseHandle(m_hFevalPending);\n        return true;\n    }\nprivate:\n    // Returns the HWND associated with the current thread\n    // A new HWND is created by this function the first time\n    // it gets called on a given thread.\n    HWND get_thread_window()\n    {\n        ModuleLock lock;\n        DWORD dwThreadID = GetCurrentThreadId();\n        HWND hWnd = NULL;\n        std::map<DWORD, HWND>::iterator it = m_ThreadData.find(dwThreadID);\n        if (it == m_ThreadData.end())\n        {\n            char tmp[128];\n            char window_name[128];\n            sprintf(tmp, \"%u\", dwThreadID);\n            strcpy(window_name, \"feval_\");\n            strcat(window_name, tmp);\n            strcat(window_name, \"_window\");\n            hWnd = CreateWindowEx(0, \"feval_window_class\", window_name, 0,\n                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\n                                HWND_MESSAGE, (HMENU)NULL, m_hInstance, NULL);\n            if (!hWnd)\n            {\n                return NULL;\n            }\n            m_ThreadData[dwThreadID] = hWnd;\n        }\n        else\n            hWnd = (*it).second;\n        return hWnd;\n    }\n    // Adds an feval call\n    void add(FevalArgs* pArgs)\n    {\n        ModuleLock lock;\n        m_fevalQueue.push(pArgs);\n        SetEvent(m_hFevalPending);\n    }\n    // Gets the next available feval call\n    FevalArgs* get_next()\n    {\n        ModuleLock lock;\n        if (m_fevalQueue.size() == 0)\n            return NULL;\n        FevalArgs* pArgs = m_fevalQueue.front();\n        m_fevalQueue.pop();\n        return pArgs;\n    }\n    // Feval thread function. Executes fevals as they become available,\n    // Exits when signaled to.\n    static DWORD WINAPI FevalProc(LPVOID pThis)\n    {\n        mclFevalWithEvents* pf = static_cast<mclFevalWithEvents*>(pThis);\n        HANDLE hEvents[2] = {pf->m_hFevalPending, pf->m_hExit};\n        DWORD dwWait = 0;\n\n        for (;;)\n        {\n            dwWait = WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);\n            if (dwWait == WAIT_OBJECT_0)\n            {\n                FevalArgs* pArgs = NULL;\n                while ((pArgs = pf->get_next()))\n                    pArgs->execute();\n            }\n            else if (dwWait == WAIT_OBJECT_0+1)\n                break;\n            else\n                return 1;\n        }\n        return 0;\n    }\n    // Window process for HWNDs created by this class.\n    static LRESULT CALLBACK ModuleWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n    {\n        switch (uMsg)\n        {\n        case WM_EVENTPENDING:\n            {\n                EventArgs* pArgs = (EventArgs*)lParam;\n                if (pArgs)\n                    pArgs->execute();\n                break;\n            }\n        default: \n            return DefWindowProc(hwnd, uMsg, wParam, lParam); \n        } \n        return 0; \n    }\n    // This function clears all WM_PAINT messages from the window\n    static BOOL CALLBACK EnumThreadWndProc(HWND hWnd, LPARAM lParam)\n    {\n        BOOL bRet = FALSE;\n        MSG msg = {0, 0, 0, 0, 0, {0,0}};\n        while((bRet = PeekMessage(&msg, hWnd, WM_PAINT, WM_PAINT, PM_REMOVE)))\n        {\n            if (bRet == -1)\n            {\n                return FALSE;\n            }\n            else\n            {\n                TranslateMessage(&msg);\n                DispatchMessage(&msg);\n            }\n        }\n        return TRUE;\n    }\nprivate:\n    HINSTANCE m_hInstance;                    // HINSTANCE passed from DLLMain\n    HANDLE m_hThread;\n    DWORD m_dwThreadID;\n    HANDLE m_hExit;\n    HANDLE m_hFevalPending;\n    std::queue<FevalArgs*> m_fevalQueue;\n    HWND m_hWnd;\n    std::map<DWORD, HWND> m_ThreadData;\n    const char* m_errorMessage;\n};\n/*------------------------------------------------------------------------------\n  CMCLModule class definition. The CMCLModule class is used as the global\n  DLL controller object for all COM DLL's. Manages global lock count, \n  registration/de-registration, and class factory services for the DLL.\n------------------------------------------------------------------------------*/\nclass CMCLModule\n{\n/*--------------------------------------\n  Construction/destruction\n--------------------------------------*/\npublic:\n    CMCLModule(bool with_events = false)\n    {\n        InitializeData(NULL, with_events);\n        m_pEvents = new mclEventMap();\n    }\n    CMCLModule(IMCLEventMap* pEvents, bool with_events = false)\n    {\n        InitializeData(NULL, with_events);\n        m_pEvents = pEvents;\n    }\n    CMCLModule(MCLInitializeInstancePtr pInit, MCLTerminateInstancePtr pTerm, bool with_events = false)\n    {\n        InitializeData(pTerm, with_events);\n        m_pInitialize = pInit;\n        m_pEvents = new mclEventMap();\n    }\n    CMCLModule(MCLInitializeInstancePtr pInit, MCLTerminateInstancePtr pTerm, IMCLEventMap* pEvents, bool with_events = false)\n    {\n        InitializeData(pTerm, with_events);\n        m_pInitialize = pInit;\n        m_pEvents = pEvents;\n    }\n\n    CMCLModule(MCLInitializeInstanceExPtr pInit, MCLTerminateInstancePtr pTerm, bool with_events = false)\n    {\n        InitializeData(pTerm, with_events);\n        m_pInitializeEx = pInit;\n        m_pEvents = new mclEventMap();\n    }\n    CMCLModule(MCLInitializeInstanceExPtr pInit, MCLTerminateInstancePtr pTerm, IMCLEventMap* pEvents, bool with_events = false)\n    {\n        InitializeData(pTerm, with_events);\n        m_pInitializeEx = pInit;\n        m_pEvents = pEvents;\n    }\n\n    virtual ~CMCLModule()\n    {\n        if (m_pFeval)\n            delete m_pFeval;\n        if (m_pEvents)\n            delete m_pEvents;\n    }\n/*--------------------------------------\n  Methods\n--------------------------------------*/\npublic:\n    // Initialization/uninitialization method to be called from DLLMain\n    virtual BOOL InitMain(MCLOBJECT_MAP_ENTRY pobjectmap, const GUID* plibid, WORD wMajor, WORD wMinor,\n                          HINSTANCE hInstance, DWORD dwReason, void* pv)\n    {\n        HRESULT hr = S_OK;\n        if (dwReason == DLL_PROCESS_ATTACH)\n        {\n            char szDllPath[_MAX_PATH];\n            char szDir[_MAX_DIR];\n            if (!Init(pobjectmap, hInstance, plibid, wMajor, wMinor))\n                return FALSE;\n            DisableThreadLibraryCalls(hInstance);\n            if (GetModuleFileName(hInstance, szDllPath, _MAX_PATH) > 0)\n            {\n                _splitpath(szDllPath, m_szPath, szDir, NULL, NULL);\n                strcat(m_szPath, szDir);\n            }\n        }\n        else if (dwReason == DLL_PROCESS_DETACH)\n        {\n            Term();\n        }\n        return TRUE;\n    }\n    // Initializes the class with object, instance, and type lib info\n    virtual bool Init(MCLOBJECT_MAP_ENTRY pobjectmap, HINSTANCE hInstance, const GUID* plibid, WORD wMajor, WORD wMinor)\n    {\n        if (isInitialized())\n            return true;\n        m_hInstance = hInstance;\n        m_plibid = plibid;\n        m_wMajor = wMajor;\n        m_wMinor = wMinor;\n        m_pObjectMap = pobjectmap;\n        if (!m_pFeval->init(hInstance))\n            return false;\n        m_bInitialized = TRUE;\n        m_bCompatibilitySet = FALSE;\n        return true;\n    }\n    // Uninitializes the class\n    virtual void Term()\n    {\n        if (!isInitialized())\n            return;\n        m_hInstance = NULL;\n        m_plibid = NULL;\n        m_wMajor = 0;\n        m_wMinor = 0;\n        m_bInitialized = FALSE;\n    }\n    // Returns the current lock count\n    long GetLockCount()\n    {\n        long cCount = 0;\n        InterlockedExchange(&cCount, m_cLockCount);\n        return cCount;\n    }\n    // Updates the registry for all classes in list and type lib. TRUE = Register, FALSE = Unregister\n    virtual HRESULT UpdateRegistry(BOOL bRegister)\n    {\n      HRESULT hr = S_OK;\n      \n      if (!isInitialized())\n        return E_FAIL;\n      if (bRegister)\n      {\n        char szDllPath[MAX_PATH];\n        OLECHAR *wDllPath=NULL;\n        ITypeLib* pTypeLib = 0;\n        \n        GetModuleFileName(m_hInstance, szDllPath, MAX_PATH);\n        try\n        {\n        int     wLength = (int)strlen (szDllPath) + 1; // +1 means don't forget the terminating null character\n        wDllPath = new OLECHAR[wLength];  \n        MultiByteToWideChar (\n            CP_ACP,            // code page \n            MB_PRECOMPOSED,    // character-type options \n            szDllPath,        // address of string to map \n            wLength,        // number of characters in string \n            wDllPath,        // address of wide-character buffer \n            wLength);        // size of buffer \n        hr = LoadTypeLibEx(wDllPath, REGKIND_REGISTER, &pTypeLib);\n        if(FAILED(hr)) {\n            delete wDllPath; \n            wDllPath = NULL; \n            return hr;\n        }\n        pTypeLib->Release();\n            if (m_pObjectMap == NULL)\n          return S_OK;\n        int i = 0;\n        while (m_pObjectMap[i].pclsid != NULL)\n        {\n          hr = m_pObjectMap[i].pfnRegisterClass(m_plibid, m_wMajor, m_wMinor, m_pObjectMap[i].lpszFriendlyName, \n                                                m_pObjectMap[i].lpszVerIndProgID, m_pObjectMap[i].lpszProgID, szDllPath);\n                if (FAILED(hr))\n            return hr;\n          i++;\n        }\n        \n        delete wDllPath; \n        wDllPath = NULL; \n        }\n        catch(...) {\n            if(wDllPath != NULL) {\n                delete wDllPath; \n                wDllPath = NULL;\n            }\n        }\n      }\n      else\n      {\n#ifdef _WIN64        \n        hr = UnRegisterTypeLib(*m_plibid, m_wMajor, m_wMinor, LANG_NEUTRAL, SYS_WIN64);\n        //since we add a \"win32\" key under typelib at the time of registration, \n        //we need to remove them here.\n        hr = UnRegisterTypeLib(*m_plibid, m_wMajor, m_wMinor, LANG_NEUTRAL, SYS_WIN32);\n#else\n        hr = UnRegisterTypeLib(*m_plibid, m_wMajor, m_wMinor, LANG_NEUTRAL, SYS_WIN32);\n#endif\n        int i = 0;\n        while (m_pObjectMap[i].pclsid != NULL)\n        {\n          hr = m_pObjectMap[i].pfnUnregisterClass(m_pObjectMap[i].lpszVerIndProgID, m_pObjectMap[i].lpszProgID);\n          if (FAILED(hr))\n            return hr;\n          i++;\n        }\n      }\n      return S_OK;\n    }\n    // Returns a class factory pointer for the specified CLSID\n    virtual HRESULT GetClassObject(REFCLSID clsid, REFIID iid, void** ppv)\n    {\n        if (!mclmcrInitialize2(mclStandaloneContainer)) \n            return CLASS_E_CLASSNOTAVAILABLE;\n\n        //COM application should be run in compatibility mode\n        if(!m_bCompatibilitySet)\n        {\n            mclSetInterleavedCompatibility(true);\n            m_bCompatibilitySet = TRUE;\n        }\n\n        if (!isInitialized())\n            return CLASS_E_CLASSNOTAVAILABLE;\n        if (m_pObjectMap == NULL)\n            return CLASS_E_CLASSNOTAVAILABLE;\n        int i = 0;\n        while (m_pObjectMap[i].pclsid != NULL)\n        {\n            if (*(m_pObjectMap[i].pclsid) == clsid)\n                return m_pObjectMap[i].pfnGetClassObject(clsid, iid, ppv);\n            i++;\n        }\n        return CLASS_E_CLASSNOTAVAILABLE;\n    }\n    // Increments the lock count\n    long Lock() {return InterlockedIncrement(&m_cLockCount);}\n    // Decrements the lock count\n    long Unlock() {return InterlockedDecrement(&m_cLockCount);}\n    // Returns a new type info pointer for the module's type lib\n    HRESULT GetTypeInfo(REFGUID riid, ITypeInfo** ppTypeInfo)\n    {\n        HRESULT hr = S_OK;\n        ITypeLib* pTypeLib = NULL;\n\n        if (!isInitialized())\n            return E_FAIL;\n        if(FAILED(hr = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, LANG_NEUTRAL, &pTypeLib)))\n            return hr;\n        hr = pTypeLib->GetTypeInfoOfGuid(riid, ppTypeInfo);\n        pTypeLib->Release();\n        return hr;\n    }\n    // Returns the progid for a given clsid, returns null if invalid clsid\n    const char* GetProgID(REFCLSID clsid)\n    {\n        int i = 0;\n        while (m_pObjectMap[i].pclsid != NULL)\n        {\n            if (*(m_pObjectMap[i].pclsid) == clsid)\n                return m_pObjectMap[i].lpszProgID;\n            i++;\n        }\n        return NULL;\n    }\n    // Initializes the MCR instance. Called by object constructors\n    virtual bool InitializeComponentInstance(HMCRINSTANCE* inst)\n    {\n        if (!m_pInitialize || !inst)\n            return false;\n        return m_pInitialize(inst, getPath());\n    }\n    // Initializes the MCR instance with CTF embedded in resource file. \n    // Called by object constructors\n    virtual bool InitializeComponentInstanceEx(HMCRINSTANCE* inst)\n    {\n        if (!m_pInitializeEx || !inst)\n            return false;\n        \n        DWORD ctfSize = 0;\n        char* ctfData = GetEmbeddedCtf(ctfSize);\n        if(ctfData == NULL || ctfSize <= 0)\n                return false;\n\n        mclCtfStream ctfStream = mclGetStreamFromArraySrc(ctfData, ctfSize);\n        bool bResult = m_pInitializeEx(inst, getPath(), ctfStream);\n        \n        if(ctfStream != NULL)\n        {\n            mclDestroyStream(ctfStream);\n        }\n        return bResult;\n    }\n    // Terminates an MCR instance. Called by object destructors.\n    virtual bool TerminateInstance(HMCRINSTANCE* inst)\n    {\n        if (!m_pTerminate || !inst)\n            return false;\n        return m_pTerminate(inst);\n    }\n    virtual BOOL isInitialized()\n    {\n        return m_bInitialized;\n    }\n    virtual void setInitialized(BOOL bInit)\n    {\n        m_bInitialized = bInit;\n    }\n    // Returns the path to the Dll\n    const char* getPath()\n    {\n        return m_szPath;\n    }\n    // Returns a reference to the Event map\n    virtual IMCLEventMap* getEventMap()\n    {\n        return m_pEvents;\n    }\n    virtual bool Feval(HMCRINSTANCE hinst, const char* name, int nlhs, mxArray** plhs, int nrhs, mxArray** prhs)\n    {\n        return m_pFeval->Feval(hinst, name, nlhs, plhs, nrhs, prhs);\n    }\n    virtual const char* getErrorMessage()\n    {\n        return m_pFeval->getErrorMessage();\n    }\n    virtual void RaiseEvent(OLECHAR* lpwszName, long dispid, IDispatch* pDisp, DISPPARAMS* pDispParams)\n    {\n      m_pFeval->RaiseEvent(lpwszName, dispid, pDisp, pDispParams);\n    }\n\n    char* GetEmbeddedCtf(DWORD& ctfSize)\n    {\n        DWORD err = 0; \n        ctfSize = 0;\n\n        HRSRC rsrc  = FindResource(m_hInstance, MAKEINTRESOURCE(2),\"RT_RCDATA\");\n        if(!rsrc)\n        {\n            err = GetLastError();\n            return NULL;\n        }\n       \n        ctfSize = SizeofResource(m_hInstance, rsrc);\n        HGLOBAL MemoryHandle = LoadResource(m_hInstance, rsrc);\n        if(MemoryHandle == NULL)\n        {\n            err = GetLastError();\n            return NULL;\n        }\n        char *ctfData = (char *) LockResource(MemoryHandle);\n        if(ctfData == NULL)\n        {\n            err = GetLastError();\n        }\n        \n        return ctfData;\n    }\n\nprivate:\n    void InitializeData(MCLTerminateInstancePtr pTerm, bool with_events)\n    {\n        m_cLockCount = 0;\n        m_hInstance = NULL;\n        m_pObjectMap = NULL;\n        m_plibid = NULL;\n        m_wMajor = 0;\n        m_wMinor = 0;\n        m_bInitialized = FALSE;\n        m_szPath[0] = '\\0';\n        m_pTerminate = pTerm;\n        m_pFeval = (with_events ? static_cast<IMCLFeval*>(new mclFevalWithEvents()) \n                                : static_cast<IMCLFeval*>(new mclSimpleFeval()));\n    }\n\n/*--------------------------------------\n  Properties\n--------------------------------------*/\nprotected:\n    MCLInitializeInstancePtr m_pInitialize; // Function used to create an MCR instance\n    MCLInitializeInstanceExPtr m_pInitializeEx; // Function used to create an MCR instance with embedded ctf\n    MCLTerminateInstancePtr m_pTerminate;   // Function to destroy an MCR instance\nprivate:\n    long m_cLockCount;                        // Lock count on module\n    HINSTANCE m_hInstance;                    // HINSTANCE passed from DLLMain\n    MCLOBJECT_MAP_ENTRY m_pObjectMap;        // Object info array\n    const GUID* m_plibid;                    // LIBID of type lib\n    BOOL m_bInitialized;                    // Is-initialized flag\n    BOOL m_bCompatibilitySet;               // Set-compatibility mode flag\n    WORD m_wMajor;                            // Major rev number of type lib\n    WORD m_wMinor;                            // Minor rev number of type lib\n    char m_szPath[_MAX_PATH];               // Stores the location of the Dll\n    IMCLEventMap* m_pEvents;                // event map\n    IMCLFeval* m_pFeval;\n};\n\n/*------------------------------------------------------------------------------\n  CMCLSingleModule class definition. The CMCLSingleModule class specializes\n  the CMCLModule class for the case of a singleton MCR instance.\n------------------------------------------------------------------------------*/\nclass CMCLSingleModule : public CMCLModule\n{\n/*--------------------------------------\n  Construction/destruction\n--------------------------------------*/\npublic:\n    CMCLSingleModule(bool with_events = false) : CMCLModule(new mclSingleEventMap(), with_events), m_mcrInstance(NULL)\n    {\n    }\n    CMCLSingleModule(MCLInitializeInstancePtr pInit, MCLTerminateInstancePtr pTerm, bool with_events = false)\n        : CMCLModule(pInit, pTerm, new mclSingleEventMap(), with_events), m_mcrInstance(NULL)\n    {\n    }\n    CMCLSingleModule(MCLInitializeInstanceExPtr pInit, MCLTerminateInstancePtr pTerm, bool with_events = false)\n        : CMCLModule(pInit, pTerm, new mclSingleEventMap(), with_events), m_mcrInstance(NULL)\n    {\n    }\n    virtual ~CMCLSingleModule()\n    {\n    }\n/*--------------------------------------\n  Methods\n--------------------------------------*/\npublic:\n    // Uninitializes the class\n    void Term()\n    {\n        if (!isInitialized())\n            return;\n        CMCLModule::Term();\n        ModuleLock lock;\n        if (m_mcrInstance)\n            m_mcrInstance = NULL;\n    }\n    // Initializes the MCR instance. Called by object constructors\n    bool InitializeComponentInstance(HMCRINSTANCE* inst)\n    {\n        if (!inst)\n            return false;\n        bool ret = false;\n        ModuleLock lock;\n        if (!m_mcrInstance)\n        {\n            if (!m_pInitialize)\n                return false;\n            ret = m_pInitialize(&m_mcrInstance, getPath());\n        }\n        *inst = m_mcrInstance;\n        return ret;\n    }\n    // Initializes the MCR instance with CTF embedded in resource file. \n    // Called by object constructors\n    bool InitializeComponentInstanceEx(HMCRINSTANCE* inst)\n    {\n        if (!inst)\n            return false;\n        bool ret = false;\n        ModuleLock lock;\n        if (!m_mcrInstance)\n        {\n            if (!m_pInitializeEx)\n                return false;\n            \n            DWORD ctfSize = 0;\n            char* ctfData = GetEmbeddedCtf(ctfSize);\n            if(ctfData == NULL || ctfSize <= 0)\n                return false;\n\n            mclCtfStream ctfStream = mclGetStreamFromArraySrc(ctfData, ctfSize);\n            ret = m_pInitializeEx(&m_mcrInstance, getPath(), ctfStream);\n            \n            if(ctfStream != NULL)\n            {\n                mclDestroyStream(ctfStream);         \n            }\n        }\n        *inst = m_mcrInstance;\n        return ret;\n    }\n    // Terminates an MCR instance. Called by object destructors.\n    bool TerminateInstance(HMCRINSTANCE* inst)\n    {\n        if (!inst)\n            return false;\n        *inst = NULL;\n        return true;\n    }\n/*--------------------------------------\n  Properties\n--------------------------------------*/\nprivate:\n    HMCRINSTANCE m_mcrInstance;             // Module-level MCR instance\n};\n\nclass mclmxarray_list {\n    int count;\n    mxArray **list;\npublic:\n    mclmxarray_list( int icount, mxArray **ilist ) : count(icount), list(ilist) { }\n    ~mclmxarray_list( ) {\n        for (int i =0; i<count; i++) {\n            mxDestroyArray( list[i] );\n        }\n    }\n};\n\nclass CMCLEnumConnectionPoints : public IEnumConnectionPoints\n{\npublic:\n/*--------------------------------------\n  Construction/destruction\n--------------------------------------*/\n    // CMCLEnumConnectionPoints default constructor\n    CMCLEnumConnectionPoints()\n    {\n        m_cRef = 1;\n        m_nIndex = 0;\n        m_pThis = NULL;\n        m_rgpcn = NULL;\n        m_cConnections = 0;\n    }\n    // CMCLEnumConnectionPoints constructor from container reference and array of connection points\n    CMCLEnumConnectionPoints(IUnknown* pThis, ULONG cConnections, IConnectionPoint** rgpcn)\n    {\n        m_cRef = 1;\n        m_nIndex = 0;\n        m_pThis = pThis;\n        m_rgpcn = NULL;\n        m_cConnections = 0;\n        if (cConnections > 0 && rgpcn != NULL)\n        {\n            m_cConnections = cConnections;\n            m_rgpcn = new IConnectionPoint*[m_cConnections];\n            if (m_rgpcn != NULL)\n            {\n                for(ULONG i=0;i<cConnections;i++)\n                {\n                    m_rgpcn[i] = NULL;\n                    if (rgpcn[i] != NULL)\n                        rgpcn[i]->QueryInterface(IID_IConnectionPoint, (void**)&m_rgpcn[i]);\n                }\n            }\n            else\n                m_cConnections = 0;\n        }\n    }\n    // CMCLEnumConnectionPoints destructor\n    virtual ~CMCLEnumConnectionPoints()\n    {\n        if (m_rgpcn != NULL)\n        {\n            for (size_t i=0;i<m_cConnections;i++)\n            {\n                if (m_rgpcn[i] != NULL)\n                    m_rgpcn[i]->Release();\n            }\n            delete [] m_rgpcn;\n        }\n    }\n/*--------------------------------------\n  IUnknown implementation\n--------------------------------------*/\npublic:\n    // IUnknown::AddRef implementation\n    ULONG __stdcall AddRef()\n    {\n        if (m_pThis != NULL)\n            m_pThis->AddRef();\n        return InterlockedIncrement(&m_cRef);\n    }\n    // IUnknown::Release implementation\n    ULONG __stdcall Release()\n    {\n        if (m_pThis != NULL)\n            m_pThis->Release();\n        ULONG cRef = InterlockedDecrement(&m_cRef);\n        if(cRef != 0)\n            return cRef;\n        delete this;\n        return 0;\n    }\n    // IUnknown::QueryInterface implementation\n    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv)\n    {\n        if(riid == IID_IEnumConnectionPoints)\n            *ppv = static_cast<IEnumConnectionPoints*>(this);\n        else if(riid == IID_IUnknown)\n            *ppv = static_cast<IUnknown*>(this);\n        else\n        {\n            *ppv = NULL;\n            return E_NOINTERFACE;\n        }\n        AddRef();\n        return S_OK;\n    }\n/*--------------------------------------\n  IEnumConnectionPoints implementation\n--------------------------------------*/\n    // IEnumConnectionPoints::Next implementation\n    HRESULT __stdcall Next(ULONG cConnections, IConnectionPoint** rgpcn, ULONG* pcFetched)\n    {\n        LONG nIndex = 0;\n        HRESULT hr = S_OK;\n\n        if(rgpcn == NULL || pcFetched == NULL)\n            return E_INVALIDARG;\n        *pcFetched = 0;\n        if (cConnections == 0)\n            return S_OK;\n        for (ULONG i=0;i<cConnections;i++)\n        {\n            InterlockedExchange(&nIndex, m_nIndex);\n            if (nIndex >= (LONG)m_cConnections)\n            {\n                hr = S_FALSE;\n                break;\n            }\n            rgpcn[i] = m_rgpcn[nIndex];\n            if(rgpcn[i] != NULL)\n                rgpcn[i]->AddRef();\n            (*pcFetched)++;\n            InterlockedIncrement(&m_nIndex);\n        }\n        return hr;\n    }\n    // IEnumConnectionPoints::Skip implementation\n    HRESULT __stdcall Skip(ULONG cConnections)\n    {\n        LONG nIndex = 0;\n        HRESULT hr = S_OK;\n\n        InterlockedExchange(&nIndex, m_nIndex);\n        if (nIndex >= (LONG)m_cConnections)\n            return S_FALSE;\n        for (ULONG i=0;i<cConnections;i++)\n        {\n            nIndex = InterlockedIncrement(&m_nIndex);\n            if (nIndex >= (LONG)m_cConnections)\n            {\n                hr = S_FALSE;\n                break;\n            }\n        }\n        return hr;\n    }\n    // IEnumConnectionPoints::Reset implementation\n    HRESULT __stdcall Reset()\n    {\n        InterlockedExchange(&m_nIndex, 0);\n        return S_OK;\n    }\n    // IEnumConnectionPoints::Clone implementation\n    HRESULT __stdcall Clone(IEnumConnectionPoints** ppEnum)\n    {\n        CMCLEnumConnectionPoints* pNew = NULL;\n        HRESULT hr = S_OK;\n\n        if(ppEnum == NULL)\n            return E_INVALIDARG;\n        *ppEnum = NULL;\n        pNew = new CMCLEnumConnectionPoints(m_pThis, (ULONG)m_cConnections, m_rgpcn);\n        if(pNew == NULL)\n            return E_OUTOFMEMORY;\n        pNew->m_nIndex = m_nIndex;\n        hr = pNew->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);\n        pNew->Release();\n        return hr;\n    }\n/*--------------------------------------\n  CMCLEnumConnectionPoints Properties\n--------------------------------------*/\nprivate:\n    long m_cRef;\n    IUnknown* m_pThis;          // Containing IUnknown for ref counting\n    long m_nIndex;              // Index of current element\n    IConnectionPoint** m_rgpcn; // Array of connection points\n    ULONG m_cConnections;        // Number of connection points in the array\n};\n\nclass CMCLEnumConnections : public IEnumConnections\n{\npublic:\n/*--------------------------------------\n  Construction/destruction\n--------------------------------------*/\n    // CMCLEnumConnections default constructor\n    CMCLEnumConnections()\n    {\n        m_cRef = 1;\n        m_nIndex = 0;\n        m_pThis = NULL;\n        m_rgpcd = NULL;\n        m_cConnections = 0;\n    }\n    // CMCLEnumConnections constructor from parent connection point reference and array of CONNECTDATA's\n    CMCLEnumConnections(IUnknown* pThis, ULONG cConnections, CONNECTDATA* rgpcd)\n    {\n        m_cRef = 1;\n        m_nIndex = 0;\n        m_pThis = pThis;\n        m_rgpcd = NULL;\n        m_cConnections = 0;\n        if (cConnections > 0 && rgpcd != NULL)\n        {\n            m_cConnections = cConnections;\n            m_rgpcd = new CONNECTDATA[m_cConnections];\n            if (m_rgpcd != NULL)\n            {\n                for(ULONG i=0;i<cConnections;i++)\n                {\n                    m_rgpcd[i] = rgpcd[i];\n                    if (m_rgpcd[i].pUnk != NULL)\n                        m_rgpcd[i].pUnk->AddRef();\n                }\n            }\n            else\n                m_cConnections = 0;\n        }\n    }\n    // CMCLEnumConnections constructor from parent connection point reference and vector class of CONNECTDATA's\n    CMCLEnumConnections(IUnknown* pThis, std::vector<CONNECTDATA*>& vecpcd)\n    {\n        std::vector<CONNECTDATA*>::iterator it;\n        CONNECTDATA* pConnData = NULL;\n        int i = 0;\n\n        m_cRef = 1;\n        m_nIndex = 0;\n        m_pThis = pThis;\n        m_rgpcd = NULL;\n        m_cConnections = 0;\n        if (vecpcd.size() > 0)\n        {\n            m_cConnections = (ULONG)vecpcd.size();\n            m_rgpcd = new CONNECTDATA[m_cConnections];\n            if (m_rgpcd != NULL)\n            {\n                for(it = vecpcd.begin(); it != vecpcd.end(); it++)\n                {\n                    pConnData = *it;\n                    if (pConnData != NULL)\n                    {\n                        m_rgpcd[i] = *pConnData;\n                        if (m_rgpcd[i].pUnk != NULL)\n                            m_rgpcd[i].pUnk->AddRef();\n                    }\n                    else\n                    {\n                        m_rgpcd[i].pUnk = NULL;\n                        m_rgpcd[i].dwCookie = 0;\n                    }\n                }\n                i++;\n            }\n            else\n                m_cConnections = 0;\n        }\n    }\n    // CMCLEnumConnections destructor\n    virtual ~CMCLEnumConnections()\n    {\n        if (m_rgpcd != NULL)\n        {\n            for (size_t i=0;i<m_cConnections;i++)\n            {\n                if (m_rgpcd[i].pUnk != NULL)\n                    m_rgpcd[i].pUnk->Release();\n            }\n            delete [] m_rgpcd;\n        }\n    }\n/*--------------------------------------\n  IUnknown implementation\n--------------------------------------*/\npublic:\n    // IUnknown::AddRef implementation\n    ULONG __stdcall AddRef()\n    {\n        if (m_pThis != NULL)\n            m_pThis->AddRef();\n        return InterlockedIncrement(&m_cRef);\n    }\n    // IUnknown::Release implementation\n    ULONG __stdcall Release()\n    {\n        if (m_pThis != NULL)\n        m_pThis->Release();\n        \n        ULONG cRef = InterlockedDecrement(&m_cRef);\n        \n        if(cRef != 0)\n            return cRef;\n        \n        delete this;\n        return 0;\n    }\n    // IUnknown::QueryInterface implementation\n    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv)\n    {\n        if(riid == IID_IEnumConnections)\n            *ppv = static_cast<IEnumConnections*>(this);\n        else if(riid == IID_IUnknown)\n            *ppv = static_cast<IUnknown*>(this);\n        else\n        {\n            *ppv = NULL;\n            return E_NOINTERFACE;\n        }\n        AddRef();\n        return S_OK;\n    }\n/*--------------------------------------\n  IEnumConnections implementation\n--------------------------------------*/\npublic:\n    // IEnumConnections::Next implementation\n    HRESULT __stdcall Next(ULONG cConnections, CONNECTDATA* rgpcd, ULONG* pcFetched)\n    {\n        LONG nIndex = 0;\n        HRESULT hr = S_OK;\n\n        if(rgpcd == NULL || pcFetched == NULL)\n            return E_INVALIDARG;\n        *pcFetched = 0;\n        if (cConnections == 0)\n            return S_OK;\n        for (ULONG i=0;i<cConnections;i++)\n        {\n            InterlockedExchange(&nIndex, m_nIndex);\n            if (nIndex >= (LONG)m_cConnections)\n            {\n                hr = S_FALSE;\n                break;\n            }\n            rgpcd[i] = m_rgpcd[nIndex];\n            if(rgpcd[i].pUnk != NULL)\n                rgpcd[i].pUnk->AddRef();\n            (*pcFetched)++;\n            InterlockedIncrement(&m_nIndex);\n        }\n        return hr;\n    }\n    // IEnumConnections::Skip implementation\n    HRESULT __stdcall Skip(ULONG cConnections)\n    {\n         LONG nIndex = 0;\n        HRESULT hr = S_OK;\n\n        InterlockedExchange(&nIndex, m_nIndex);\n        if (nIndex >= (LONG)m_cConnections)\n            return S_FALSE;\n        for (ULONG i=0;i<cConnections;i++)\n        {\n            nIndex = InterlockedIncrement(&m_nIndex);\n            if (nIndex >= (LONG)m_cConnections)\n            {\n                hr = S_FALSE;\n                break;\n            }\n        }\n        return hr;\n    }\n    // IEnumConnections::Reset implementation\n    HRESULT __stdcall Reset()\n    {\n        InterlockedExchange(&m_nIndex, 0);\n        return S_OK;\n    }\n    // IEnumConnections::Clone implementation\n    HRESULT __stdcall Clone(IEnumConnections** ppEnum)\n    {\n        CMCLEnumConnections* pNew = NULL;\n        HRESULT hr = S_OK;\n\n        if(ppEnum == NULL)\n            return E_INVALIDARG;\n        *ppEnum = NULL;\n        pNew = new CMCLEnumConnections(m_pThis,(ULONG) m_cConnections, m_rgpcd);\n        if(pNew == NULL)\n            return E_OUTOFMEMORY;\n        pNew->m_nIndex = m_nIndex;\n        hr = pNew->QueryInterface(IID_IEnumConnections, (void**)ppEnum);\n        pNew->Release();\n        return hr;\n    }\n/*--------------------------------------\n  CMCLEnumConnectionPoints Properties\n--------------------------------------*/\nprivate:\n    long m_cRef;\n    IUnknown* m_pThis;           // Containing IUnknown for ref counting\n    long m_nIndex;               // Index of current element\n    ULONG m_cConnections;         // Number of connections in the array\n    CONNECTDATA* m_rgpcd;        // Array of connections\n};\n\n// Globals\nextern CMCLModule* g_pModule;\n\ntemplate<const IID* piid>\nclass CMCLConnectionPointImpl : public IConnectionPoint\n{\n/*--------------------------------------\n  Construction/destruction\n--------------------------------------*/\npublic:\n    // CMCLConnectionPointImpl default constructor\n    CMCLConnectionPointImpl()\n    {\n        m_cRef = 1;\n        m_pCPC = NULL;\n        m_nNextCookie = 0;\n    }\n    // CMCLConnectionPointImpl constructor from container reference\n    CMCLConnectionPointImpl(IConnectionPointContainer* pCPC)\n    {\n        m_cRef = 1;\n        m_pCPC = NULL;\n        m_nNextCookie = 0;\n        m_pCPC = pCPC;\n    }\n    // CMCLConnectionPointImpl destructor\n    virtual ~CMCLConnectionPointImpl()\n    {\n        std::vector<CONNECTDATA*>::iterator it;\n        CONNECTDATA* pConnData = NULL;\n\n        for(it = m_vecpcd.begin(); it != m_vecpcd.end(); it++)\n        {\n            pConnData = *it;\n            if (pConnData != NULL)\n            {\n                if (pConnData->pUnk != NULL)\n                    pConnData->pUnk->Release();\n                delete pConnData;\n            }\n        }\n        m_vecpcd.clear();\n    }\n/*--------------------------------------\n  IUnknown implementation\n--------------------------------------*/\npublic:\n    // IUnknown::AddRef implementation\n    ULONG __stdcall AddRef()\n    {\n        return InterlockedIncrement(&m_cRef);\n    }\n    // IUnknown::Release implementation\n    ULONG __stdcall Release()\n    {\n        ULONG cRef = InterlockedDecrement(&m_cRef);\n        if(cRef != 0)\n            return cRef;\n        delete this;\n        return 0;\n    }\n    // IUnknown::QueryInterface implementation\n    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv)\n    {\n        if(riid == IID_IConnectionPoint)\n            *ppv = static_cast<IConnectionPoint*>(this);\n        else if(riid == IID_IUnknown)\n            *ppv = static_cast<IUnknown*>(this);\n        else\n        {\n            *ppv = NULL;\n            return E_NOINTERFACE;\n        }\n        AddRef();\n        return S_OK;\n    }\n\n/*--------------------------------------\n  IConnectionPoint implementation\n--------------------------------------*/\n    // IConnectionPoint::GetConnectionInterface implementation\n    HRESULT __stdcall GetConnectionInterface(IID *pIID)\n    {\n        if (pIID == NULL)\n            return E_INVALIDARG;\n        *pIID = *piid;\n        return S_OK;\n    }\n    // IConnectionPoint::GetConnectionPointContainer implementation\n    HRESULT __stdcall GetConnectionPointContainer(IConnectionPointContainer** ppCPC)\n    {\n        if (ppCPC == NULL)\n            return E_POINTER;\n        if (m_pCPC == NULL)\n            return E_UNEXPECTED;\n        *ppCPC = m_pCPC;\n        if (*ppCPC != NULL)\n            (*ppCPC)->AddRef();\n        return S_OK;\n    }\n    // IConnectionPoint::Advise implementation\n    HRESULT __stdcall Advise(IUnknown* pUnk, DWORD* pdwCookie)\n    {\n        IUnknown* pSink = NULL;\n        long nCookie = 0;\n        CONNECTDATA* pConnData = NULL;\n\n        ModuleLock lock;\n        if (pUnk == NULL || pdwCookie == NULL)\n            return E_POINTER;\n        *pdwCookie = 0;\n        if(FAILED(pUnk->QueryInterface(*piid, (void**)&pSink)))\n            return CONNECT_E_CANNOTCONNECT;\n        pConnData = new CONNECTDATA;\n        if (pConnData == NULL)\n            return E_OUTOFMEMORY;\n        nCookie = InterlockedIncrement(&m_nNextCookie);\n        pConnData->dwCookie = (DWORD)nCookie;\n        pConnData->pUnk = pUnk;\n        m_vecpcd.push_back(pConnData);\n        return S_OK;\n    }\n    // IConnectionPoint::Unadvise implementation\n    HRESULT __stdcall Unadvise(DWORD dwCookie)\n    {\n        std::vector<CONNECTDATA*>::iterator it;\n        CONNECTDATA* pConnData = NULL;\n        bool bFound = false;\n        \n        ModuleLock lock;\n        if(dwCookie == 0)\n            return CONNECT_E_NOCONNECTION;\n        for(it = m_vecpcd.begin(); it != m_vecpcd.end(); it++)\n        {\n            pConnData = *it;\n            if (pConnData != NULL)\n            {\n                if (pConnData->dwCookie == dwCookie)\n                {\n                    bFound = true;\n                    if (pConnData->pUnk != NULL)\n                        pConnData->pUnk->Release();\n                    delete pConnData;\n                    break;\n                }\n            }\n        }\n        if (bFound)\n        {\n            m_vecpcd.erase(it);\n            return S_OK;\n        }\n        return CONNECT_E_NOCONNECTION;\n    }\n    // IConnectionPoint::EnumConnections implementation\n    HRESULT __stdcall EnumConnections(IEnumConnections** ppEnum)\n    {\n        CMCLEnumConnections* pEnum = NULL;\n\n        ModuleLock lock;\n        if (ppEnum == NULL)\n            return E_POINTER;\n        *ppEnum = NULL;\n        pEnum = new CMCLEnumConnections(this, m_vecpcd);\n        if (pEnum == NULL)\n            return E_OUTOFMEMORY;\n        if (FAILED(pEnum->QueryInterface(IID_IEnumConnections, (void**)ppEnum)))\n            return E_UNEXPECTED;\n        return S_OK;\n    }\n/*--------------------------------------\n  CConnectionPoint Properties\n--------------------------------------*/\nprivate:\n    long m_cRef;                        // Reference count\n    IConnectionPointContainer* m_pCPC;  // Pointer to parent container\n    long m_nNextCookie;                 // Next available cookie value\n    std::vector<CONNECTDATA*> m_vecpcd; // Array of connections\n};\n\n/*------------------------------------------------------------------------------\n  Begin: Standard Class factory implementation.\n------------------------------------------------------------------------------*/\ntemplate<class T>\nclass CMCLFactoryImpl : public IClassFactory\n{\npublic:\n    // Construction/destruction\n    CMCLFactoryImpl() : m_cRef(1) { }\n    virtual ~CMCLFactoryImpl() { }\n\n    // IClassFactory::AddRef implementation\n    ULONG __stdcall AddRef()\n    {\n        return InterlockedIncrement(&m_cRef);\n    }\n    // IClassFactory::Release implementation\n    ULONG __stdcall Release()\n    {\n        ULONG cRef = InterlockedDecrement(&m_cRef);\n        if(cRef != 0)\n            return cRef;\n        delete this;\n        return 0;\n    }\n    // IClassFactory::QueryInterface implementation\n    HRESULT __stdcall QueryInterface(REFIID iid, void** ppv)\n    {\n        if((iid == IID_IUnknown) || (iid == IID_IClassFactory))\n            *ppv = (IClassFactory*)this;\n        else\n        {\n            *ppv = NULL;\n            return E_NOINTERFACE;\n        }\n        AddRef();\n        return S_OK;\n    }\n    // IClassFactory::CreateInstance implementation\n    virtual HRESULT __stdcall CreateInstance(IUnknown *pUnknownOuter, REFIID iid, void** ppv)\n    {\n        if(pUnknownOuter != NULL)\n            return CLASS_E_NOAGGREGATION;\n\n#if defined (mclcommain_h) || defined (mclxlmain_published_api_h)\n        if (!mclComCheckMWComUtil())\n        {\n            const char* mcrversion=NULL;\n            mclGetMCRVersion(&mcrversion);\n            std::string errmsg;\n            errmsg = \"MWComUtil \";\n            errmsg.append(mcrversion);\n            errmsg.append(\" could not be found in the registry. Please refer to MATLAB Compiler SDK documentation for instructions on how to install and register MWComUtil.\");\n            T::Error(errmsg.c_str());\n            return E_FAIL;\n        }\n#endif        \n\n        T* p = new T;\n\n        if(p == NULL)\n            return E_OUTOFMEMORY;\n\n        // Call the Init method to load the type information\n        if (!p->Init())\n        {\n            delete p;\n            return E_UNEXPECTED;\n        }\n\n        HRESULT hr = p->QueryInterface(iid, ppv);\n        p->Release();\n        return hr;\n    }\n    // IClassFactory::LockServer implementation\n    HRESULT __stdcall LockServer(BOOL bLock)\n    {\n        if(bLock)\n            g_pModule->Lock();\n        else\n            g_pModule->Unlock();\n        return S_OK;\n    }\nprivate:\n    long m_cRef;    // Ref count\n};\n\n/*------------------------------------------------------------------------------\n  End: Standard Class factory implementation.\n------------------------------------------------------------------------------*/\n\n// Add piidEvents so that Function Wizard works correctly (g1465604)\ntemplate<typename T, const IID* piid, typename T1, const CLSID* pclsid, const IID* piidEvents = nullptr>\nclass CMCLBaseImpl: public T, public ISupportErrorInfo, public IConnectionPointContainer\n{\n/*--------------------------------------\n  Construction/destruction\n--------------------------------------*/\npublic:\n    // CMCLBaseImpl constructor\n    CMCLBaseImpl()\n    {\n        m_cRef = 1;\n        m_pTypeInfo = NULL;\n        m_pEvents = NULL;\n        g_pModule->Lock();\n    }\n    // CMCLBaseImpl destructor\n    virtual ~CMCLBaseImpl()\n    {\n        if (m_pEvents != NULL)\n            m_pEvents->Release();\n        if (m_pTypeInfo != NULL)\n            m_pTypeInfo->Release();\n        g_pModule->Unlock();\n    }\n\n/*--------------------------------------\n  IUnknown implementation\n--------------------------------------*/\npublic:\n    // IUnknown::AddRef implementation\n    ULONG __stdcall AddRef()\n    {\n        return InterlockedIncrement(&m_cRef);\n    }\n    // IUnknown::Release implementation\n    ULONG __stdcall Release()\n    {\n        ULONG cRef = InterlockedDecrement(&m_cRef);\n        if(cRef != 0)\n            return cRef;\n        delete this;\n        return 0;\n    }\n    // IUnknown::QueryInterface implementation\n    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv)\n    {\n        if(riid == *piid)\n            *ppv = static_cast<T*>(this);\n        else if(riid == IID_IUnknown)\n            *ppv = reinterpret_cast<IUnknown*>(this);\n        else if(riid == IID_IDispatch)\n            *ppv = reinterpret_cast<IDispatch*>(this);\n        else if(riid == IID_ISupportErrorInfo)\n            *ppv = static_cast<ISupportErrorInfo*>(this);\n        else if (riid == IID_IConnectionPointContainer)\n            *ppv = static_cast<IConnectionPointContainer*>(this);\n        else \n        {\n            *ppv = NULL;\n            return E_NOINTERFACE;\n        }\n        AddRef();\n        return S_OK;\n    }\n/*--------------------------------------\n  IDispatch implementation\n--------------------------------------*/\n    // IDispatch::GetTypeInfoCount implementation\n    HRESULT __stdcall GetTypeInfoCount(UINT* pCountTypeInfo)\n    {\n        if (pCountTypeInfo != NULL)\n            *pCountTypeInfo = 1;\n        return S_OK;\n    }\n    // IDispatch::GetTypeInfo implementation\n    HRESULT __stdcall GetTypeInfo(UINT iTypeInfo, LCID lcid, ITypeInfo** ppITypeInfo)\n    {\n        if (ppITypeInfo != NULL)\n        {\n            *ppITypeInfo = NULL;\n            if(iTypeInfo != 0)\n                return DISP_E_BADINDEX;\n            if (m_pTypeInfo != NULL)\n                m_pTypeInfo->AddRef();\n            *ppITypeInfo = m_pTypeInfo;\n        }\n        return S_OK;\n    }\n    // IDispatch::GetIDsOfNames implementation\n    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames, \n                                    LCID lcid, DISPID* rgDispId)\n    {\n        if(riid != IID_NULL)\n            return DISP_E_UNKNOWNINTERFACE;\n        return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgDispId);\n    }\n    // IDispatch::Invoke implementation\n    HRESULT __stdcall Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, \n                             DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, \n                             UINT* puArgErr)\n    {\n        if(riid != IID_NULL)\n            return DISP_E_UNKNOWNINTERFACE;\n        return DispInvoke(this, m_pTypeInfo, dispIdMember, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr); \n    }\n/*--------------------------------------\n  ISupportErrorInfo implementation\n--------------------------------------*/\n    // ISupportErrorInfo::InterfaceSupportsErrorInfo implementation\n    HRESULT __stdcall InterfaceSupportsErrorInfo(REFIID riid)\n    {\n        if(riid == *piid)\n            return S_OK;\n        else\n            return S_FALSE;\n    }\n/*--------------------------------------\n  IConnectionPointContainer implementation\n--------------------------------------*/\n    // IConnectionPointContainer::EnumConnectionPoints implementation\n    HRESULT __stdcall EnumConnectionPoints(IEnumConnectionPoints** ppEnum)\n    {\n        HRESULT hr = S_OK;\n        ULONG cConnections = 0;\n        CMCLEnumConnectionPoints* pEnum = NULL;\n\n        if (ppEnum == NULL)\n            return E_POINTER;\n        if (m_pEvents != NULL)\n            cConnections = 1;\n        pEnum = new CMCLEnumConnectionPoints(reinterpret_cast<IUnknown*>(this), cConnections, &m_pEvents);\n        if (pEnum == NULL)\n            return E_OUTOFMEMORY;\n        hr = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);\n        pEnum->Release();\n        return hr;\n    }\n    // IConnectionPointContainer::FindConnectionPoint implementation\n    HRESULT __stdcall FindConnectionPoint(REFIID riid, IConnectionPoint** ppCP)\n    {\n        if (ppCP == NULL)\n            return E_POINTER;\n        if (piidEvents == NULL)\n            return CONNECT_E_NOCONNECTION;\n        if (riid == *piidEvents)\n        {\n            if (m_pEvents == NULL)\n                return CONNECT_E_NOCONNECTION;\n            *ppCP = m_pEvents;\n            (*ppCP)->AddRef();\n            return S_OK;\n        }\n        return CONNECT_E_NOCONNECTION;\n    }\n/*--------------------------------------\n  CMCLBaseImpl Methods\n--------------------------------------*/\n    // Initializes class, loads type info stuff and initializes connection point if necessary.\n    // Put any additional init stuff in here.\n    virtual bool Init(void)\n    {\n        HRESULT hr = S_OK;\n\n        hr = g_pModule->GetTypeInfo(*piid, &m_pTypeInfo);\n        \n        if(FAILED(hr))\n         return false;\n        \n        if (piidEvents != NULL)\n        {\n            CMCLConnectionPointImpl<piidEvents>* pEvents\n              = new CMCLConnectionPointImpl<piidEvents>(static_cast<IConnectionPointContainer*>(this));\n            if (pEvents == NULL)\n              return false;\n            \n            if (pEvents != NULL)\n            {\n                if (FAILED(pEvents->QueryInterface(IID_IConnectionPoint, (void**)&m_pEvents)))\n                    return false;\n                pEvents->Release();\n            }\n        }\n        return true;\n    }\n    // Registers the class\n    static HRESULT __stdcall RegisterClass(const GUID* plibid, unsigned short wMajor, unsigned short wMinor, const char* lpszFriendlyName, \n                                           const char* lpszVerIndProgID, const char* lpszProgID, const char* lpszModuleName)\n    {\n        return mclRegisterServer(lpszModuleName, *pclsid, *plibid, wMajor, wMinor, lpszFriendlyName,\n                                 lpszVerIndProgID, lpszProgID, \"Both\");\n    }\n    // Unregisters the class\n    static HRESULT __stdcall UnregisterClass(const char* lpszVerIndProgID, const char* lpszProgID)\n    {\n        return mclUnregisterServer(*pclsid, lpszVerIndProgID, lpszProgID);\n    }\n    // Called by COM framework to get IClassFactory pointer on which to create new instances of object\n    static HRESULT __stdcall GetClassObject(REFCLSID clsid, REFIID iid, void** ppv)\n    {    \n        if(clsid != *pclsid)\n            return CLASS_E_CLASSNOTAVAILABLE;\n\n        CMCLFactoryImpl<T1>* pFactory = new CMCLFactoryImpl<T1>;\n        if(pFactory == NULL)\n            return E_OUTOFMEMORY;\n\n        // QueryInterface for IClassFactory\n        HRESULT hr = pFactory->QueryInterface(iid, ppv);\n        pFactory->Release();\n        return hr;\n    }\n    // Method to report an error\n    static HRESULT __stdcall Error(const char* lpszMessage)\n    {\n        ICreateErrorInfo* pCreateErrorInfo = NULL;\n        IErrorInfo* pErrorInfo = NULL;\n        HRESULT hr = S_OK;\n        OLECHAR* lpwszMessage = NULL;\n        OLECHAR* lpwszSource = NULL;\n        const char* lpszSource = NULL;\n        int nLen = 0;\n\n        if (FAILED(hr = CreateErrorInfo(&pCreateErrorInfo)))\n            goto EXIT;\n        // Set message text\n        if (lpszMessage != NULL)\n        {\n                  pwcsStackPointer slpwszMessage = NULL;\n                  initializeWcsStackPointer(&slpwszMessage);\n                  if(mwMbstowcs(slpwszMessage, lpszMessage) < 0) {\n                    deleteWcsStackPointer(slpwszMessage);\n                    pCreateErrorInfo->SetDescription(L\"Error converting multibyte string to wide character string.\");\n                  } else {\n                    lpwszMessage = _wcsdup(reinterpret_cast<wchar_t*>(slpwszMessage->hPtr));\n                    deleteWcsStackPointer(slpwszMessage);\n                    pCreateErrorInfo->SetDescription(lpwszMessage);\n                  }\n                  \n        } \n        else\n                  pCreateErrorInfo->SetDescription(L\"\");\n        // Set IID\n        pCreateErrorInfo->SetGUID(*piid);\n        // Set error source\n        lpszSource = g_pModule->GetProgID(*pclsid);\n        if (lpszSource != NULL)\n        {\n                  pwcsStackPointer slpwszSource = NULL;\n                  initializeWcsStackPointer(&slpwszSource);\n                  if ( mwMbstowcs(slpwszSource, lpszSource) < 0){\n                    deleteWcsStackPointer( slpwszSource );\n                    pCreateErrorInfo->SetDescription(L\"Error converting multibyte string to wide character string\");\n                  } else {\n                    lpwszSource=_wcsdup(reinterpret_cast<wchar_t*>(slpwszSource->hPtr));\n                    deleteWcsStackPointer( slpwszSource );\n                    pCreateErrorInfo->SetSource(lpwszSource);\n                  }\n\n        }\n        else\n                  pCreateErrorInfo->SetSource(L\"\");\n        // Set error info\n        if (FAILED(hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))\n            goto EXIT;\n        hr = SetErrorInfo(0, pErrorInfo);\n    EXIT:\n        if (lpwszMessage != NULL)\n            delete lpwszMessage;\n        if (lpwszSource != NULL)\n            delete lpwszSource;\n        if (pErrorInfo != NULL)\n            pErrorInfo->Release();\n        if (pCreateErrorInfo != NULL)\n            pCreateErrorInfo->Release();\n        return hr;\n    }\n    // Method to report an error from an EXCEPINFO structure (note: does not use template *piid in SetGUID)\n    static HRESULT __stdcall Error(REFIID riid, EXCEPINFO* pExcepInfo)\n    {\n        ICreateErrorInfo* pCreateErrorInfo = NULL;\n        IErrorInfo* pErrorInfo = NULL;\n        HRESULT hr = S_OK;\n\n        if (pExcepInfo == NULL)\n            goto EXIT;\n        if (FAILED(hr = CreateErrorInfo(&pCreateErrorInfo)))\n            goto EXIT;\n        // Set message text\n        pCreateErrorInfo->SetDescription(pExcepInfo->bstrDescription);\n        // Set IID\n        pCreateErrorInfo->SetGUID(riid);\n        // Set error source\n        pCreateErrorInfo->SetSource(pExcepInfo->bstrSource);\n        // Set error info\n        if (FAILED(hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))\n            goto EXIT;\n        hr = SetErrorInfo(0, pErrorInfo);\n    EXIT:\n        if (pErrorInfo != NULL)\n            pErrorInfo->Release();\n        if (pCreateErrorInfo != NULL)\n            pCreateErrorInfo->Release();\n        return hr;\n    }\nprotected:\n    int RequestLocalLock()\n    {\n        mclAcquireMutex();\n        return 0;\n    }\n    int ReleaseLocalLock()\n    {\n        mclReleaseMutex();\n        return 0;\n    }\n/*--------------------------------------\n  CMCLBaseImpl Properties\n--------------------------------------*/\nprivate:\n    long m_cRef;                // Reference count\n    ITypeInfo* m_pTypeInfo;        // Type Info pointer\nprotected:\n    IConnectionPoint* m_pEvents;// Connection point for objects that implement an event interface\n};\n\ntemplate<class T>\nclass CMCLSingleFactoryImpl : public CMCLFactoryImpl<T>\n{\npublic:\n    // IClassFactory::CreateInstance implementation\n    HRESULT __stdcall CreateInstance(IUnknown *pUnknownOuter, REFIID iid, void** ppv)\n    {\n        ModuleLock lock;\n        if(pUnknownOuter != NULL)\n            return CLASS_E_NOAGGREGATION;\n        if (m_p == NULL)\n        {\n            m_p = new T;\n            if(m_p == NULL)\n            {\n                return E_OUTOFMEMORY;\n            }\n            if (!m_p->Init())\n            {\n                delete m_p;\n                m_p = NULL;\n                return E_UNEXPECTED;\n            }\n            m_p->AddRef();\n        }\n        HRESULT hr = m_p->QueryInterface(iid, ppv);\n        m_p->Release();\n        return hr;\n    }\nprivate:\n    long m_cRef;    // Ref count\n    static T* m_p;  // Static instance of T\n};\n\ntemplate<class T, const IID* piid, class T1, const CLSID* pclsid>\nclass CMCLSingleBaseImpl: public CMCLBaseImpl<T, piid, T1, pclsid>\n{\n/*--------------------------------------\n  Construction/destruction\n--------------------------------------*/\npublic:\n    // CMCLSingleBaseImpl constructor\n    CMCLSingleBaseImpl(){}\n    // CMCLSingleBaseImpl destructor\n    virtual ~CMCLSingleBaseImpl(){}\n/*--------------------------------------\n  IUnknown implementation\n--------------------------------------*/\npublic:\n    // IUnknown::AddRef implementation\n    ULONG __stdcall AddRef()\n    {\n        return 2;\n    }\n    // IUnknown::Release implementation\n    ULONG __stdcall Release()\n    {\n        return 1;\n    }\n    // Called by COM framework to get IClassFactory pointer on which to create new instances of object\n    static HRESULT __stdcall GetClassObject(REFCLSID clsid, REFIID iid, void** ppv)\n    {    \n        if(clsid != *pclsid)\n            return CLASS_E_CLASSNOTAVAILABLE;\n\n        CMCLSingleFactoryImpl<T1>* pFactory = new CMCLSingleFactoryImpl<T1>;\n        if(pFactory == NULL)\n            return E_OUTOFMEMORY;\n\n        // QueryInterface for IClassFactory\n        HRESULT hr = pFactory->QueryInterface(iid, ppv);\n        pFactory->Release();\n        return hr;\n    }\n};\n\ntemplate<class T, const IID* piid, class T1, const CLSID* pclsid>\nclass CMCLClassImpl: public CMCLBaseImpl<T, piid, T1, pclsid>, public IMCLEvent\n{\n/*--------------------------------------\n  Construction/destruction\n--------------------------------------*/\npublic:\n    // CMCLClassImpl constructor\n    CMCLClassImpl()\n    {\n            m_pFlags = NULL;\n            m_hinst = NULL;\n    }\n    // CMCLClassImpl destructor\n    virtual ~CMCLClassImpl()\n    {\n            if (m_pFlags != NULL)\n                m_pFlags->Release();\n    }\nprotected:\n    void RegisterListener()\n    {\n        g_pModule->getEventMap()->add(m_hinst, static_cast<IMCLEvent*>(this));\n    }\n    void UnregisterListener()\n    {\n        g_pModule->getEventMap()->remove(m_hinst, static_cast<IMCLEvent*>(this));\n    }\npublic:\n/*--------------------------------------\n  CMCLClassImpl Methods\n--------------------------------------*/\n    // Registers the class and adds it to the MatLab XL component catagory\n    static HRESULT __stdcall RegisterClass(const GUID* plibid, unsigned short wMajor, unsigned short wMinor, const char* lpszFriendlyName,\n                                           const char* lpszVerIndProgID, const char* lpszProgID, const char* lpszModuleName)\n    {\n        return mclRegisterMatLabComponent(lpszModuleName, pclsid, plibid, wMajor, wMinor, lpszFriendlyName, lpszVerIndProgID, lpszProgID);\n    }\n    // Unregisters the class and removes it from the MatLab XL component catagory\n    static HRESULT __stdcall UnregisterClass(const char* lpszVerIndProgID, const char* lpszProgID)\n    {\n        return mclUnRegisterMatLabComponent(pclsid, lpszVerIndProgID, lpszProgID);\n    }\n    // Returns a pointer to the contained MWFlags object\n    HRESULT __stdcall get_MWFlags(IMWFlags** ppFlags)\n    {\n        HRESULT hr = S_OK;       // Return code\n        ModuleLock lock;\n        if (ppFlags == NULL)\n            return E_INVALIDARG;\n        *ppFlags = NULL;\n        // If there is not one already allocated, creat a new one.\n        if (m_pFlags == NULL)\n        {\n            hr = CoCreateInstance(CLSID_MWFlags, NULL, CLSCTX_INPROC_SERVER, \n                                  IID_IMWFlags, (void**)&m_pFlags);\n            if (FAILED(hr))\n            {\n                return hr;\n            }\n        }\n        *ppFlags = m_pFlags;\n        m_pFlags->AddRef();\n        return hr;\n    }\n    // Sets the array-formatting-object\n    HRESULT __stdcall put_MWFlags(IMWFlags* pFlags)\n    {\n        HRESULT hr = S_OK;      // Return code\n        ModuleLock lock;\n        if (pFlags == NULL)\n            return E_INVALIDARG;\n        // Set internal object to new one. \n        if (m_pFlags != NULL)\n            m_pFlags->Release();\n        m_pFlags = pFlags;\n        m_pFlags->AddRef();\n        return hr;\n    }\n    // Call the MatLab mex funtion pointed to by mlxF\n    HRESULT CallComFcn(const char* name, int nargout, int fnout, int fnin, ...)\n    {\n        mxArray **plhs;\n        //int nargout:  comes in as ip param to this function\n        int alloc_nargout = (nargout == 0) ? 1: nargout;\n        mxArray **prhs;\n        int nargin = 0;\n\n        VARIANT **plvar;\n        const VARIANT **prvar;\n\n        bool bVarargout = fnout < 0;\n        bool bVarargin = fnin < 0;\n\n        mxArray *varargout = NULL;\n        mxArray *varargin = NULL;\n\n        int i;\n        int new_nargin;\n        va_list ap;\n        bool bFoundDefault = false;\n        HRESULT retval = S_OK;\n        _MCLCONVERSION_FLAGS flags;\n        IMWFlags* pFlags = NULL;\n        bool bRet = false;\n        int dc_status = 0;\n\n        // Check MCR instance\n        if (!m_hinst)\n        {\n            this->Error(\"MCR instance is not available\");\n            return E_FAIL;\n        }\n        // Get Conversion flags\n        if (FAILED(get_MWFlags(&pFlags)))\n        {\n            this->Error(\"Error getting data conversion flags\");\n            return E_FAIL;\n        }\n        if (FAILED(GetConversionFlags(pFlags, &flags)))\n        {\n            this->Error(\"Error getting data conversion flags\");\n            return E_FAIL;\n        }\n        pFlags->Release();\n        try \n        {    \n            // O/P from mclMlxFeval (lhs)\n            va_start( ap, fnin );\n            if (bVarargout) \n            {\n                fnout = -fnout;\n            }\n            plvar = (VARIANT **) _alloca( fnout * sizeof( VARIANT * ) );\n            for (i=0; i< fnout; i++) \n            {\n                plvar[i] = va_arg( ap, VARIANT *);\n            }\n            plhs = (mxArray **) _alloca( alloc_nargout * sizeof( mxArray * ));\n            for (i=0; i< alloc_nargout; i++) \n            {\n                plhs[i] = NULL;\n            }\n            // I/P to mclMlxFeval (rhs)\n            if (bVarargin) \n            {\n                fnin = -fnin;      \n            }\n            prvar = (const VARIANT **) _alloca( fnin * sizeof(VARIANT *));\n            for (i = 0; i< fnin; i++) \n            {\n                prvar[i] = va_arg( ap, VARIANT *);\n                if (IsVisualBasicDefault( prvar[i] )) \n                {\n                    bFoundDefault = true;\n                }\n                else \n                {\n                    if (bFoundDefault) \n                    {\n                        this->Error( \"Error: Arguments may only be defaulted at the end of an argument list\" );\n                        retval = E_FAIL;\n                        goto finish;\n                    }\n                    nargin++;\n                }\n            }\n            if (bVarargin && !bFoundDefault) \n            {\n                //g830130 - if there is only one varargin, and MCLUtil.MWPack() is not called, \n                //the varargin won't be passed in as an array. In this case, the conversion flag's \n                //nInputInd shoulnd't be incremented.\n                if (prvar[fnin-1]->vt == (VT_VARIANT|VT_BYREF))\n                {\n                    if ((prvar[fnin-1]->pvarVal != NULL) && (prvar[fnin-1]->pvarVal->vt & VT_ARRAY))\n                    {\n                        flags.nInputInd += 1;\n                    }\n                }\n                if ((dc_status = Variant2mxArray( prvar[fnin-1], &varargin, &flags)) < 0)\n                {\n                    mclSetLastErrIdAndMsg(\"\", GetCOMErrorMessage(dc_status));\n                    retval = E_FAIL;\n                    goto finish;\n                }\n                flags.nInputInd -= 1;\n                if (varargin == NULL)\n                    nargin -= 1;\n                /*Empty varargin should be passed to MATLAB as a empty cell array*/\n                else if(mxIsEmpty(varargin))\n                {\n                    varargin = NULL;\n                    nargin -= 1;\n                }\n                else if (mxGetClassID(varargin) == mxCELL_CLASS)\n                    nargin += static_cast<int>(mxGetN( varargin )) - 1;\n            }\n            prhs = (mxArray **) _alloca( nargin * sizeof(mxArray *));\n            for (i = 0; i< nargin; i++) \n                prhs[i] = NULL;\n            mclmxarray_list protect_plhs( nargout, plhs );\n            mclmxarray_list protect_prhs( nargin, prhs );\n            for (i = 0; i< nargin; i++) \n            {\n                if (i < fnin-1 || (!bVarargin && i == fnin-1))\n                {\n                    if ((dc_status = Variant2mxArray( prvar[i], &prhs[i], &flags)) < 0)\n                    {\n                        mclSetLastErrIdAndMsg(\"\", GetCOMErrorMessage(dc_status));\n                        retval = E_FAIL;\n                        goto finish;\n                    }\n                }\n                else\n                {\n                    if ( varargin != NULL && mxGetClassID(varargin) == mxCELL_CLASS )\n                        prhs[i] = mclCreateSharedCopy(((mxArray **)mxGetData(varargin))[i-fnin+1]);\n                    else\n                        prhs[i] = mclCreateSharedCopy(varargin);\n                }\n            }\n            bFoundDefault = false;\n            new_nargin = nargin;\n            for (i = 0; i< nargin; i++) \n            {\n                if (!bFoundDefault) {\n                    if (prhs[i] == NULL) {\n                        bFoundDefault = true;\n                        new_nargin = i;\n                     }\n                }\n                else {\n                    if (prhs[i] != NULL) {\n                        this->Error( \"Error: Arguments may only be defaulted at the end of an argument list\" );\n                        retval = E_FAIL;\n                    }\n                }\n            }\n            if (retval != E_FAIL) {\n                nargin = new_nargin;\n                // call mclMlxFeval\n                bRet = g_pModule->Feval(m_hinst, name, nargout, plhs, nargin, prhs);\n                if (!bRet)\n                    goto finish;\n                // translate o/p (lhs) of  mclMlxFeval back to variant\n                if (nargout == 0 && plhs[0] != NULL )\n                {\n                    mxDestroyArray( plhs[0] );\n                    plhs[0] = NULL;\n                }\n                if (bVarargout && nargout >= fnout) \n                {\n                    varargout = mclCreateCellArrayFromArrayList(nargout-fnout+1, &plhs[fnout-1]);\n                }\n                for (i = 0; i<fnout && i<nargout; i++) \n                {     \n                    if (i < fnout -1 || (!bVarargout && i == fnout-1 ))\n                    {\n                        if ((dc_status = mxArray2Variant( plhs[i], plvar[i], &flags)) < 0)\n                        {\n                            mclSetLastErrIdAndMsg(\"\", GetCOMErrorMessage(dc_status));\n                            retval = E_FAIL;\n                            goto finish;\n                        }\n                    }\n                    else\n                    {\n                        flags.nOutputInd += 1;\n                        flags.nTransposeInd += 1;\n                        if ((dc_status = mxArray2Variant( varargout, plvar[i], &flags)) < 0)\n                        {\n                            mclSetLastErrIdAndMsg(\"\", GetCOMErrorMessage(dc_status));\n                            retval = E_FAIL;\n                            goto finish;\n                        }\n                        flags.nOutputInd -= 1;\n                        flags.nTransposeInd -= 1;\n                    }\n                }\n            }\n        }\n        catch (...)\n        {\n            this->Error(\"Unexpected Error Thrown\");\n            retval = E_FAIL;       \n        }\n    finish:\n        if (varargin != NULL)\n            mxDestroyArray( varargin );\n        if (varargout != NULL)\n            mxDestroyArray( varargout );\n        if (!bRet)\n        {\n            const char* msg = g_pModule->getErrorMessage();\n            \n            //If there is no error message on the CMCLModule (which might \n            //  have run its work on a different thread), then check the \n            //  local thread for an error message.\n            if(!msg)\n            {\n                msg = mclGetLastErrorMessage();\n            }\n            //If the g_pModule has an error (the thread that actually called feval), \n            //  use that, otherwise see if this thread has an error, \n            //  if all else fails, give a generic message.  \n            this->Error((msg ? msg : \"Unspecified error\"));\n            retval = E_FAIL;\n        }\n        return(retval); \n    }\n    void mclRaiseEventA(const char* lpszName, DISPID dispid, int nargin, mxArray** prhs)\n    {\n        HRESULT hr = S_OK;              // Return code\n        IEnumConnections* pEnum = NULL; // Pointer to enum of all connections\n        CONNECTDATA ConnData = {0,0};   // CONNECTDATA structure for each connection\n        ULONG cFetched = 0;             // Number of connections fetched in a call\n        IDispatch* pDisp = NULL;        // IDispatch pointer to make call on\n        VARIANT varResult;              // Result from call\n        VARIANT* pvars = NULL;          // Varaibles to send into call\n        DISPPARAMS disp = {NULL,NULL,0,0};// Disparams used to make call\n        // DISPID dispid = 0;              // DISPID of method to invoke\n        OLECHAR* lpwszName = NULL;      // Temp buffer for method name\n        int nLen = 0;                   // Length of name string\n        int i = 0;                      // Loop counter\n        _MCLCONVERSION_FLAGS flags;     // Temp flags struct\n        IMWFlags* pFlags = NULL;        // Temp flags object\n\n        pwcsStackPointer slpwszName = NULL;\n        initializeWcsStackPointer(&slpwszName);\n\n        // If no connection point available or invalid name, return\n        if (this->m_pEvents == NULL || lpszName == NULL)\n            return;\n        if (nargin < 0 || (prhs == NULL && nargin > 0))\n            nargin = 0;\n        // Get Conversion flags\n        if (FAILED(get_MWFlags(&pFlags)))\n            InitConversionFlags(&flags);\n        else\n        {\n            if (FAILED(GetConversionFlags(pFlags, &flags)))\n                InitConversionFlags(&flags);\n            pFlags->Release();\n        }\n        // Enum all connections \n        hr = this->m_pEvents->EnumConnections(&pEnum);\n        if (FAILED(hr))\n            goto EXIT;\n        VariantInit(&varResult);\n        // Create Array of Variants for call\n        if (nargin > 0)\n        {\n            pvars = new VARIANT[nargin];\n            if (pvars == NULL)\n                goto EXIT;\n            for (i=0;i<nargin;i++)\n                VariantInit(&pvars[i]);\n            disp.rgvarg = pvars;\n            disp.cArgs = nargin;\n        }\n        for (i=0;i<nargin;i++)\n        {\n            if (prhs[i] != NULL)\n            {\n                if (mxArray2Variant(prhs[i], &pvars[nargin-i-1], &flags) < 0)\n                    goto EXIT;\n            }\n        }\n        // Get name\n        if (mwMbstowcs(slpwszName,lpszName) < 0) {\n          deleteWcsStackPointer(slpwszName);\n          goto EXIT;\n        }\n        lpwszName=_wcsdup(reinterpret_cast<wchar_t*>(slpwszName->hPtr));\n        deleteWcsStackPointer(slpwszName);\n\n        // Loop over all connections and call each one\n        pEnum->Reset();\n        for(;;)\n        {\n            hr = pEnum->Next(1, &ConnData, &cFetched);\n            if (cFetched == 0)\n                break;\n            if (ConnData.pUnk != NULL)\n            {\n                hr = ConnData.pUnk->QueryInterface(IID_IDispatch, (void**)&pDisp);\n                ConnData.pUnk->Release();\n                if (SUCCEEDED(hr) && pDisp != NULL)\n                {\n                    g_pModule->RaiseEvent(lpwszName, dispid, pDisp, &disp);\n                    pDisp->Release();\n                    pDisp = NULL;\n                }\n            }\n        }\n    EXIT:\n        if (pEnum != NULL)\n            pEnum->Release();\n        if (pDisp != NULL)\n            pDisp->Release();\n        if (lpwszName != NULL)\n            delete lpwszName;\n        if (pvars != NULL)\n        {\n            for (i=0;i<nargin;i++)\n                VariantClear(&pvars[i]);\n            delete [] pvars;\n        }\n    }\n    // Gets a property from the array\n    HRESULT GetProperty(const char* name, VARIANT* pvarValue)\n    {\n        _MCLCONVERSION_FLAGS flags;\n        HRESULT hr = S_OK;\n        IMWFlags* pFlags = NULL;\n        mxArray* px = NULL;\n        int dc_status = 0;\n        const char* msg = NULL;\n\n        mwLock lock;\n        // Check MCR instance\n        if (!m_hinst)\n        {\n            this->Error(\"MCR instance is not available\");\n            return E_FAIL;\n        }\n        if (pvarValue == NULL)\n            return E_INVALIDARG;\n        // Get Conversion flags\n        if (FAILED(get_MWFlags(&pFlags)))\n        {\n            this->Error(\"Error getting data conversion flags\");\n            return E_FAIL;\n        }\n        if (FAILED(GetConversionFlags(pFlags, &flags)))\n        {\n            this->Error(\"Error getting data conversion flags\");\n            return E_FAIL;\n        }\n        pFlags->Release();\n        try\n        {\n            if (!mclGetGlobal(m_hinst, name, &px))\n            {\n                const char* msg = mclGetLastErrorMessage();\n                this->Error((msg ? msg : \"Unspecified error\"));\n                hr = E_FAIL;\n            }\n            else\n            {\n                if (pvarValue->vt != VT_EMPTY)\n                    VariantClear(pvarValue);\n                if ((dc_status = mxArray2Variant(px, pvarValue, &flags)) < 0)\n                {\n                    msg = GetCOMErrorMessage(dc_status);\n                    this->Error((msg ? msg : \"Unspecified error\"));\n                    hr = E_FAIL;\n                }\n            }\n        }\n        catch (...)\n        {\n            this->Error(\"Unexpected Error Thrown\");\n            hr = E_FAIL;       \n        }\n        if (px)\n            mxDestroyArray(px);\n        return hr;\n    }\n    // Sets a property in the array\n    HRESULT PutProperty(const char* name, const VARIANT* pvarValue)\n    {\n        _MCLCONVERSION_FLAGS flags;\n        HRESULT hr = S_OK;\n        IMWFlags* pFlags = NULL;\n        mxArray* px = NULL;\n        int dc_status = 0;\n        const char* msg = NULL;\n\n        mwLock lock;\n        // Check MCR instance\n        if (!m_hinst)\n        {\n            this->Error(\"MCR instance is not available\");\n            return E_FAIL;\n        }\n        if (pvarValue == NULL)\n            return E_INVALIDARG;\n        // Get Conversion flags\n        if (FAILED(get_MWFlags(&pFlags)))\n        {\n            this->Error(\"Error getting data conversion flags\");\n            return E_FAIL;\n        }\n        if (FAILED(GetConversionFlags(pFlags, &flags)))\n        {\n            this->Error(\"Error getting data conversion flags\");\n            return E_FAIL;\n        }\n        pFlags->Release();\n        try\n        {\n            if ((dc_status = Variant2mxArray(pvarValue, &px, &flags)) < 0)\n            {\n                msg = GetCOMErrorMessage(dc_status);\n                this->Error((msg ? msg : \"Unspecified error\"));\n                hr = E_FAIL;\n            }\n            else if (!mclSetGlobal(m_hinst, name, px))\n            {\n                msg = mclGetLastErrorMessage();\n                this->Error((msg ? msg : \"Unspecified error\"));\n                hr = E_FAIL;\n            }\n        }\n        catch (...)\n        {\n            this->Error(\"Unexpected Error Thrown\");\n            hr = E_FAIL;       \n        }\n        if (px)\n            mxDestroyArray(px);\n        return hr;\n    }\n/*--------------------------------------\n  CMCLClassImpl Properties\n--------------------------------------*/\nprivate:\n    IMWFlags* m_pFlags;             // Pointer to a formatting/conversion-flags object\nprotected:\n    HMCRINSTANCE m_hinst;           // MCR instance\n};\n\ntemplate<class T, const IID* piid, class T1, const CLSID* pclsid>\nclass CMCLSingleImpl: public CMCLClassImpl<T, piid, T1, pclsid>\n{\n/*--------------------------------------\n  Construction/destruction\n--------------------------------------*/\npublic:\n    // CMCLSingleImpl constructor\n    CMCLSingleImpl(){}\n    // CMCLSingleImpl destructor\n    virtual ~CMCLSingleImpl(){}\n/*--------------------------------------\n  IUnknown implementation\n--------------------------------------*/\npublic:\n    // IUnknown::AddRef implementation\n    ULONG __stdcall AddRef()\n    {\n        return 2;\n    }\n    // IUnknown::Release implementation\n    ULONG __stdcall Release()\n    {\n        return 1;\n    }\n    // Called by COM framework to get IClassFactory pointer on which to create new instances of object\n    static HRESULT __stdcall GetClassObject(REFCLSID clsid, REFIID iid, void** ppv)\n    {    \n        if(clsid != *pclsid)\n            return CLASS_E_CLASSNOTAVAILABLE;\n\n        CMCLSingleFactoryImpl<T1>* pFactory = new CMCLSingleFactoryImpl<T1>;\n        if(pFactory == NULL)\n            return E_OUTOFMEMORY;\n\n        // QueryInterface for IClassFactory\n        HRESULT hr = pFactory->QueryInterface(iid, ppv);\n        pFactory->Release();\n        return hr;\n    }\n};\n\n/*------------------------------------------------------------------------------\n  Singleton Class factory implementation.\n------------------------------------------------------------------------------*/\n\n\n\ntemplate<typename Iterface>\nstruct MarshalHelperDelegate\n{\n    template<typename Derived>\n    static HRESULT copyMWFlags(MCLCONVERSION_FLAGS flags, void * receiver)\n    {\n        HRESULT hr;\n        Derived * derivedObject = static_cast<Derived*>(/*this*/receiver);\n        IMWFlags * mwflags = NULL;\n        if(FAILED(hr = derivedObject->get_MWFlags(&mwflags)))\n            goto EXIT;\n        HRESULT mclPutConversionFlags(IMWFlags* pFlags, MCLCONVERSION_FLAGS flags);\n        if(FAILED(hr = mclPutConversionFlags(mwflags, flags)))\n            goto EXIT;\n        if(FAILED(derivedObject->put_MWFlags(mwflags)))\n            goto EXIT;\nEXIT:\n        if(mwflags)\n            mwflags->Release();\n        return hr;\n    }\n};\n\ntemplate<>\nstruct MarshalHelperDelegate<IMWStruct>\n{\n    template<typename Derived>\n    static HRESULT copyMWFlags(MCLCONVERSION_FLAGS, void *)\n    {\n        return E_NOTIMPL;\n    }\n};\n\n\ntemplate<typename Interface, typename Derived>\nstruct MarshalHelper\n{\n    HRESULT copyMWFlags(MCLCONVERSION_FLAGS flags, void * receiver)\n    {\n        return MarshalHelperDelegate<Interface>::template copyMWFlags<Derived>(flags,receiver);\n    }\n};\n\ntemplate<typename T, const IID* piid, typename T1, const CLSID* pclsid>\nclass CMCLMarshalImpl: public CMCLBaseImpl<T, piid, T1, pclsid>, public IMarshal, public MarshalHelper<T, T1>\n{\npublic:\n    CMCLMarshalImpl()\n    {\n        m_serializedData = NULL;\n    }\n\n    // IUnknown\n    ULONG __stdcall AddRef()\n    {\n        return typename CMCLBaseImpl<T, piid, T1, pclsid>::AddRef();\n    }\n    ULONG __stdcall Release()\n    {\n        return typename CMCLBaseImpl<T, piid, T1, pclsid>::Release();\n    }\n    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv)\n    {\n        if(riid == IID_IMarshal)\n        {\n            *ppv = static_cast<IMarshal*>(this);\n            AddRef();\n            return S_OK;\n        }\n        else \n        return typename CMCLBaseImpl<T, piid, T1, pclsid>::QueryInterface(riid, ppv);\n    }\n\n    // IMarshal\n    HRESULT __stdcall GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext, void* pvDestContext, DWORD dwFlags, CLSID* pClsid)\n    {\n        if(dwDestContext == MSHCTX_DIFFERENTMACHINE || dwDestContext == MSHCTX_INPROC)\n        {\n            IMarshal* pMarshal;\n            CoGetStandardMarshal(riid, (T*)pv, dwDestContext, pvDestContext, dwFlags, &pMarshal);\n            HRESULT hr = pMarshal->GetUnmarshalClass(riid, pv, dwDestContext, pvDestContext, dwFlags, pClsid);\n            pMarshal->Release();\n            return hr;\n        }\n        *pClsid = *(const_cast<CLSID*>(pclsid));\n        return S_OK;\n    }\n\n    HRESULT __stdcall GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext, void* pvDestContext, DWORD dwFlags, DWORD* pSize)\n    {\n        if(dwDestContext == MSHCTX_DIFFERENTMACHINE || dwDestContext == MSHCTX_INPROC)\n        {\n            IMarshal* pMarshal;\n            CoGetStandardMarshal(riid, (T*)pv, dwDestContext, pvDestContext, dwFlags, &pMarshal);\n            HRESULT hr = pMarshal->GetMarshalSizeMax(riid, pv, dwDestContext, pvDestContext, dwFlags, pSize);\n            pMarshal->Release();\n            return hr;\n        }\n        //serialize the data the first time, this method is called twice during a marshalling operation\n        if(m_serializedData == NULL)\n        {\n            if(FAILED(Serialize(pv)))\n            {\n                return E_FAIL;\n            }\n        }\n        *pSize = static_cast<DWORD>(mxGetN(m_serializedData) + 4);\n        T1 * derivedObject = dynamic_cast<T1*>(this);\n        if(derivedObject->getCurrentMWFlags())\n        {\n            *pSize += sizeof(_MCLCONVERSION_FLAGS);\n        }\n        return S_OK;\n    }\n\n    HRESULT __stdcall MarshalInterface(IStream* pStream, REFIID riid, void* pv, DWORD dwDestContext, void* pvDestContext, DWORD dwFlags)\n    {\n        if(dwDestContext == MSHCTX_DIFFERENTMACHINE || dwDestContext == MSHCTX_INPROC)\n        {\n            IMarshal* pMarshal;\n            CoGetStandardMarshal(riid, (T*)pv, dwDestContext, pvDestContext, dwFlags, &pMarshal);\n            HRESULT hr = pMarshal->MarshalInterface(pStream, riid, pv, dwDestContext, pvDestContext, dwFlags);\n            pMarshal->Release();\n            return hr;\n        }\n        \n        HRESULT hr = S_OK;\n        DWORD sizeOfPacket = static_cast<DWORD>(mxGetN(m_serializedData));\n        unsigned long bytesWritten = 0;\n        if(FAILED(hr = pStream->Write(&sizeOfPacket, 4, &bytesWritten)) \n            || bytesWritten != 4)\n        {\n            this->Error(\"Unable to write the size of the packet during serialization.\");\n            return hr;\n        }\n        if(FAILED(hr = pStream->Write(mxGetData(m_serializedData), sizeOfPacket, &bytesWritten)) \n            || bytesWritten != sizeOfPacket) \n        {\n            this->Error(\"Unable to write the packet during serialization.\");\n            return hr;\n        }\n        T1 * derivedObject = dynamic_cast<T1*>(this);\n\n        IMWFlags * mwflags;\n        if((mwflags = static_cast<IMWFlags*>(derivedObject->getCurrentMWFlags())) != NULL)\n        {\n             HRESULT hr;   \n            _MCLCONVERSION_FLAGS flags;\n            if((hr = this->mclGetConversionFlags(mwflags,&flags)) != S_OK)\n                return hr;\n            if(FAILED(hr = pStream->Write(&flags, sizeof(_MCLCONVERSION_FLAGS), &bytesWritten)) \n                || bytesWritten != sizeof(_MCLCONVERSION_FLAGS))\n            {\n                this->Error(\"Unable to write the conversion flags during serialization.\");\n                return hr;\n            }\n        }\n        return hr;\n    }\n\n    HRESULT __stdcall DisconnectObject(DWORD dwReserved)\n    {\n        return E_NOTIMPL;\n    }\n    HRESULT __stdcall UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv)\n    {\n         HRESULT hr = S_OK; \n        DWORD sizeOfPacket = 0;\n        unsigned long bytesRead = 0;\n        if(FAILED(hr = pStream->Read(&sizeOfPacket, 4, &bytesRead)))\n        {\n            this->Error(\"Unable to read the size of the packet during deserialization.\");\n            return hr;\n        }\n        char * unmarshalledPacket = new char[sizeOfPacket];\n\n        if(FAILED(pStream->Read(unmarshalledPacket, sizeOfPacket, &bytesRead)))\n        {\n            this->Error(\"Unable to read the packet during deserialization.\");\n            delete [] unmarshalledPacket;\n            return hr;\n        }\n\n        mxArray * unmarshalledMxArray  = mclMxDeserialize(unmarshalledPacket, sizeOfPacket);\n        delete [] unmarshalledPacket;\n        \n        _MCLCONVERSION_FLAGS flags;\n        this->mclInitConversionFlags(&flags);\n        VARIANT out;\n        VariantInit(&out);\n        if(this->mclmxArray2Variant(unmarshalledMxArray, &out, &flags) < 0) \n        {\n            this->Error(\"Deserialization error\");\n            return E_FAIL;\n        }\n        if(unmarshalledMxArray != NULL)\n            mxDestroyArray(unmarshalledMxArray);\n        \n       \n        //Try to unmarshall MWFlags from pStream. This should only be true for data types \n        //which have a MWFlags and it was not NULL during marshalling. \n        hr = pStream->Read(&flags, sizeof(_MCLCONVERSION_FLAGS), &bytesRead);\n        if(!(hr == S_OK || hr == S_FALSE))\n        {\n            this->Error(\"Unable to read the conversion flags during deserialization.\");\n            return hr;\n        }\n\n        //if unmarshalledMxArray == NULL, it means that the Variant type was default constructed\n        //but no value was assigned. So we can simply assign the this pointer to *ppv\n        if(unmarshalledMxArray != NULL)\n        {\n             if(bytesRead == sizeof(_MCLCONVERSION_FLAGS))\n             {\n                this->copyMWFlags(&flags, out.pdispVal);\n             }\n             *ppv = static_cast<T*>(out.pdispVal);\n        }\n        else\n        {\n            if(bytesRead == sizeof(_MCLCONVERSION_FLAGS))\n            {\n                copyMWFlags(&flags, this);\n            }\n            return QueryInterface(*piid, ppv);\n        }\n\n        return hr;\n    }\n\n    HRESULT __stdcall ReleaseMarshalData(IStream* pStream)\n    {\n        if(m_serializedData != NULL)\n            mxDestroyArray(m_serializedData);\n        return S_OK;\n    }\n    \nprivate:\n\n    HRESULT __stdcall Serialize(void * pv)\n    {\n        VARIANT wrapper;\n        wrapper.vt = VT_DISPATCH;\n        wrapper.pdispVal = static_cast<IDispatch *>(pv);\n        mxArray * temp = NULL;\n        _MCLCONVERSION_FLAGS flags;\n        this->mclInitConversionFlags(&flags);\n        if(this->mclVariant2mxArray(&wrapper,&temp,&flags) < 0)\n        {\n            this->Error(\"Error in data conversion\");\n            return E_FAIL;\n        }\n        \n        m_serializedData = mclMxSerialize(temp);\n        if(temp != NULL)\n            mxDestroyArray(temp);\n\n        if(m_serializedData == NULL)\n        {\n            this->Error(\"Error in internal data serialization\");\n            return E_FAIL;\n        }\n        return S_OK;\n    }\n\nprivate:\n    mxArray * m_serializedData;\n};\n\n\n#endif //ifdef __cplusplus\n#endif //ifndef _MCLCOMCLASS_H_\n\n"},{"name":"mclcommain.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n* PUBLISHed header for libmclcommain, the mclcommain library.\n*\n* Copyright 1984-2012 The MathWorks, Inc.\n* All Rights Reserved.\n*/\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef mclcommain_h\n#define mclcommain_h\n\n\n#ifndef MCLCOMMAIN_API\n#  define MCLCOMMAIN_API \n#endif\n\n\n/* Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n\n#ifdef __cplusplus\n  #define EXTERN_C extern \"C\"\n#else\n  #define EXTERN_C extern\n#endif\n\n#endif\n\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\n\n/* Register a MatLab Excel Builder component */\nEXTERN_C MCLCOMMAIN_API HRESULT mclRegisterMatLabComponent(const char* szModuleName,     /* DLL module handle */\n                                const CLSID* clsid,           /* Class ID */\n                                const GUID* libid,            /* GUID of TypeLib */\n                                unsigned short wMajorRev,     /* Major rev of type lib */\n                                unsigned short wMinorRev,     /* Minor rev of type lib */\n                                const char* szFriendlyName,   /* Friendly Name */\n                                const char* szVerIndProgID,   /* Programmatic */\n                                const char* szProgID)         /* IDs */;\n\n\n/* Unregister a MatLab Excel Builder component */\nEXTERN_C MCLCOMMAIN_API HRESULT mclUnRegisterMatLabComponent(const CLSID* clsid,         /* Class ID */\n                                  const char* szVerIndProgID, /* Programmatic */\n                                  const char* szProgID)       /* IDs */;\n\n\n/* \n   Aquire global lock. Returns 0 for successful aquisition, -1 otherwise.\n   If the global mutex is not initialized, or if the wait function fails,\n   -1 is returned.\n*/\nEXTERN_C MCLCOMMAIN_API int RequestGlobalLock(void);\n\n\n/* \n   Release global lock. Returns 0. If the global mutex is not initialized,\n   -1 is returned.\n*/\nEXTERN_C MCLCOMMAIN_API int ReleaseGlobalLock(void);\n\n\nEXTERN_C MCLCOMMAIN_API HRESULT GetConversionFlags(IMWFlags* pFlags, MCLCONVERSION_FLAGS flags);\n\n\n/* Converts an mxArray to a Variant */\nEXTERN_C MCLCOMMAIN_API int mxArray2Variant(const mxArray* px, VARIANT* pvar, const MCLCONVERSION_FLAGS flags);\n\n\n/* Converts a Variant to an mxArray */\nEXTERN_C MCLCOMMAIN_API int Variant2mxArray(const VARIANT* pvar, mxArray** ppx, const MCLCONVERSION_FLAGS flags);\n\n\n/* \n   If input VARIANT is VT_ERROR && v->scode == DISP_E_PARAMNOTFOUND, returns true. \n   Returns false otherwise. If input variant is *|VT_BYREF and reference is NULL, returns true. \n   If input variant pointer is NULL, returns true.\n*/\nEXTERN_C MCLCOMMAIN_API bool IsVisualBasicDefault(const VARIANT *v);\n\n\nEXTERN_C MCLCOMMAIN_API void InitConversionFlags(MCLCONVERSION_FLAGS flags);\n\n\nEXTERN_C MCLCOMMAIN_API const char* GetCOMErrorMessage(int ret);\n\n\nEXTERN_C MCLCOMMAIN_API bool mclComCheckMWComUtil();\n\n\nEXTERN_C MCLCOMMAIN_API bool mclComCheckMWComMgr();\n\n\n#ifdef __cplusplus\n    }\t/* extern \"C\" */\n#endif\n\n#endif /* mclcommain_h */\n"},{"name":"mclcppclass.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2004-2021 The MathWorks, Inc.\n *\n * ATTENTION! ATTENTION! ATTENTION! \n *\n *   1. mwArray MAY NOT directly call any method (including public methods)\n *      of the array_ref class, despite the C++ compiler's willingness to\n *      allow this. Generally speaking, this is only a problem when a\n *      Compiler-generated application is compiled into a binary by a C++\n *      compiler different than the one used to build the MCR (i.e., when\n *      mbuild -setup has been used to choose a compiler other than \n *      MSVC on the PC).\n *\n *   2. If you add a method to the array_ref interface, make sure that you\n *      provide an extern \"C\" version of it, and that mwArray calls the\n *      extern \"C\" version rather than the method itself.\n *\n *   3. Before making any changes here, please read (and understand!) the\n *      \"MathWorks Deployment Team: Products and Processes\" document, esp.\n *      the mclmcrrt section.\n *\n */\n\n#ifndef _MCLCPPCLASS_H_\n#define _MCLCPPCLASS_H_\n\n#ifdef __cplusplus\n\n#include <string>\n#include <exception>\n#include <iostream>\n#include <vector>\n\n#include \"mclmcr.h\"\n\nclass mwArray;\n\n/**\n * An enum to facilitate the creation of MATLAB string array.\n * It is awkward to modify the existing constructors to accommodate the creation of \n * array of MATLAB string type. With this enum as a parameter in the constructors,\n * similar constructors can be adapted for MATLAB string type. It has one member as of now,\n * but the list can be expanded when the need arises. Use enum instead of enum class since\n * C++ 11 or later is not a requirement.\n */\nenum MWObjectType { MLString };\n\ntypedef std::basic_string<mxChar> mwUString;\n\nstatic const char* STRING_ONLY_METHOD_ERROR = \"Method can only be called on a MATLAB string.\";\n\ntemplate<class T>\nclass mwArraySharedCopy : public T\n{\nprivate:\n    mwArraySharedCopy(array_ref* p) : T(p) {\n    }\n\n    friend class mwArray;\n};\n\nclass mwArray\n{\n    friend void mclcppMlfFeval(HMCRINSTANCE inst, const char* name, int nargout, int fnout, int fnin, ...);\npublic:\n    mwArray() : m_pa(0)\n    {\n        if (mclGetEmptyArray((void**)&m_pa, mxDOUBLE_CLASS) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxClassID mxID) : m_pa(0)\n    {\n        if (mclGetEmptyArray((void**)&m_pa, mxID) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mwSize num_rows, mwSize num_cols, mxClassID mxID, mxComplexity cmplx = mxREAL) : m_pa(0)\n    {\n        if (mclGetMatrix((void**)&m_pa, num_rows, num_cols, mxID, cmplx) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    /**\n     * Constructor to create a MxN MATLAB string array.\n     * All elemenets are in the initial <missing> state.\n     */\n    mwArray(mwSize num_rows, mwSize num_cols, MWObjectType T) : m_pa(0)\n    {\n        mwSize dim[2] = { num_rows, num_cols };\n        if (mclGetMatlabStringArray((void**)&m_pa, 2, dim) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mwSize num_dims, const mwSize* dims, mxClassID mxID, mxComplexity cmplx = mxREAL) : m_pa(0)\n    {\n        if (mclGetArray((void**)&m_pa, num_dims, dims, mxID, cmplx) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    /**\n     * Constructor to create a N-dimensional MATLAB string array.\n     * All elements are in the initial <missing> state.\n     */\n    mwArray(mwSize num_dims, const mwSize* dims, MWObjectType T) : m_pa(0)\n    {\n        if (mclGetMatlabStringArray((void**)&m_pa, num_dims, dims) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    /**\n     * Constructor to create a one-element MATLAB string array from a string.\n     */\n    mwArray(const mxChar* ustr, MWObjectType T) : m_pa(0)\n    {\n        auto status = mclGetMatlabString((void**)&m_pa, 1, &ustr);\n        if (status == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    /**\n     * Constructor to create a 1xN MATLAB string array from a string array.\n     */\n    mwArray(mwSize num_strings, const mxChar** ustrs, MWObjectType T) : m_pa(0)\n    {\n        if (mclGetMatlabString((void**)&m_pa, num_strings, ustrs) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(const char* str) : m_pa(0)\n    {\n        if (mclGetString((void**)&m_pa, str) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mwSize num_strings, const char** str) : m_pa(0)\n    {\n        if (mclGetCharMatrixFromStrings((void**)&m_pa, num_strings, str) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mwSize num_rows, mwSize num_cols, int num_fields, const char** fieldnames) : m_pa(0)\n    {\n        if (mclGetStructMatrix((void**)&m_pa, num_rows, num_cols, num_fields, fieldnames) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mwSize num_dims, const mwSize* dims, int num_fields, const char** fieldnames) : m_pa(0)\n    {\n        if (mclGetStructArray((void**)&m_pa, num_dims, dims, num_fields, fieldnames) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxDouble re) : m_pa(0)\n    {\n        if (mclGetScalarDouble((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxDouble re, mxDouble im) : m_pa(0)\n    {\n        if (mclGetScalarDouble((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxSingle re) : m_pa(0)\n    {\n        if (mclGetScalarSingle((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxSingle re, mxSingle im) : m_pa(0)\n    {\n        if (mclGetScalarSingle((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxInt8 re) : m_pa(0)\n    {\n        if (mclGetScalarInt8((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxInt8 re, mxInt8 im) : m_pa(0)\n    {\n        if (mclGetScalarInt8((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxUint8 re) : m_pa(0)\n    {\n        if (mclGetScalarUint8((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxUint8 re, mxUint8 im) : m_pa(0)\n    {\n        if (mclGetScalarUint8((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxInt16 re) : m_pa(0)\n    {\n        if (mclGetScalarInt16((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxInt16 re, mxInt16 im) : m_pa(0)\n    {\n        if (mclGetScalarInt16((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxUint16 re) : m_pa(0)\n    {\n        if (mclGetScalarUint16((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxUint16 re, mxUint16 im) : m_pa(0)\n    {\n        if (mclGetScalarUint16((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxInt32 re) : m_pa(0)\n    {\n        if (mclGetScalarInt32((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxInt32 re, mxInt32 im) : m_pa(0)\n    {\n        if (mclGetScalarInt32((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxUint32 re) : m_pa(0)\n    {\n        if (mclGetScalarUint32((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxUint32 re, mxUint32 im) : m_pa(0)\n    {\n        if (mclGetScalarUint32((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxInt64 re) : m_pa(0)\n    {\n        if (mclGetScalarInt64((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxInt64 re, mxInt64 im) : m_pa(0)\n    {\n        if (mclGetScalarInt64((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    explicit mwArray(mxUint64 re) : m_pa(0)\n    {\n        if (mclGetScalarUint64((void**)&m_pa, re, 0, mxREAL) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n    mwArray(mxUint64 re, mxUint64 im) : m_pa(0)\n    {\n        if (mclGetScalarUint64((void**)&m_pa, re, im, mxCOMPLEX) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n#if !defined(__APPLE_CC__)\n    explicit mwArray(mxLogical re) : m_pa(0)\n    {\n        if (mclGetScalarLogical((void**)&m_pa, re) == MCLCPP_ERR)\n            mwException::raise_error();\n        validate();\n    }\n#endif\n    mwArray(const mwArray& arr) : m_pa(0)\n    {\n        m_pa = array_ref_deep_copy(arr.m_pa);\n        if (!m_pa)\n            mwException::raise_error();\n    }\n    mwArray(const mwArraySharedCopy<mwArray>& sharedCopy)\n    {\n        m_pa = array_ref_shared_copy(sharedCopy.m_pa);\n    }\n    virtual ~mwArray()\n    {\n        ref_count_obj_release(m_pa);\n    }\nprotected:\n    mwArray(array_ref* pa, bool incref = false) : m_pa(pa)\n    {\n        if (!m_pa)\n            throw mwException(\"Internal Error\");\n        if (incref)\n            ref_count_obj_addref(m_pa);\n    }\n    virtual void validate()\n    {\n        if (!m_pa)\n            throw mwException(\"Internal Error\");\n    }\n    array_ref* get_ptr() const\n    {\n        return m_pa;\n    }\n    void set_ptr(array_ref* pa)\n    {\n        if (!pa)\n            throw mwException(\"Null pointer\");\n        ref_count_obj_release(m_pa);\n        m_pa = pa;\n        ref_count_obj_addref(m_pa);\n    }\npublic:\n    mwArray Clone() const\n    {\n        array_ref* p = array_ref_deep_copy(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    mwArraySharedCopy<mwArray> SharedCopy() const\n    {\n        array_ref* p = array_ref_shared_copy(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArraySharedCopy<mwArray>(p);\n    }\n    mwArray Serialize() const\n    {\n        array_ref* p = array_ref_serialize(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    mxClassID ClassID() const\n    {\n        return array_ref_classID(m_pa);\n    }\n    size_t ElementSize() const\n    {\n        return array_ref_element_size(m_pa);\n    }\n    mwSize NumberOfElements() const\n    {\n        return array_ref_number_of_elements(m_pa);\n    }\n    mwSize NumberOfNonZeros() const\n    {\n        return array_ref_number_of_nonzeros(m_pa);\n    }\n    mwSize MaximumNonZeros() const\n    {\n        return array_ref_maximum_nonzeros(m_pa);\n    }\n    mwSize NumberOfDimensions() const\n    {\n        return array_ref_number_of_dimensions(m_pa);\n    }\n    int NumberOfFields() const\n    {\n        return array_ref_number_of_fields(m_pa);\n    }\n    mwString GetFieldName(int i)\n    {\n        char_buffer* p = array_ref_get_field_name(m_pa, i);\n        if (!p)\n            mwException::raise_error();\n        return mwString(p, false);\n    }\n    mwArray GetDimensions() const\n    {\n        array_ref* p = array_ref_get_dimensions(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    bool IsEmpty() const\n    {\n        return array_ref_is_empty(m_pa);\n    }\n    bool IsSparse() const\n    {\n        return array_ref_is_sparse(m_pa);\n    }\n    bool IsNumeric() const\n    {\n        return array_ref_is_numeric(m_pa);\n    }\n    bool IsComplex() const\n    {\n        return array_ref_is_complex(m_pa);\n    }\n    bool IsMatlabString() const\n    {\n        return array_ref_is_matlab_string(m_pa);\n    }\n    bool IsMissingElement(mwSize index = 1) const\n    {\n        return array_ref_is_missing_string_element(m_pa, index);\n    }\n    void SetStringData(const std::vector<mwUString>& data)\n    {\n        auto size = data.size();\n        if (size == 0)\n            return;\n        std::vector< const mxChar*> cdata(size);\n        for (std::size_t i = 0; i < size; ++i)\n            cdata[i] = data[i].c_str();\n        SetStringData(&cdata[0], size);\n    }\n    void SetStringData(const mxChar** data, mwSize array_size) \n    {\n        if (array_ref_set_matlab_string(m_pa, data, array_size) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetStringElement(mwSize index, const mwUString& str)\n    {\n        if (array_ref_set_string_element(m_pa, index, str.c_str()) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetStringElement(mwSize index, const mxChar* str)\n    {\n        if (array_ref_set_string_element(m_pa, index, str) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    bool Equals(const mwArray& arr) const\n    {\n        return array_ref_equals(m_pa, arr.m_pa);\n    }\n    int CompareTo(const mwArray& arr) const\n    {\n        return array_ref_compare_to(m_pa, arr.m_pa);\n    }\n    int HashCode() const\n    {\n        return array_ref_hash_code(m_pa);\n    }\n    mwString ToString() const\n    {\n        char_buffer* p = array_ref_to_string(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwString(p, false);\n    }\n    mwArray RowIndex() const\n    {\n        array_ref* p = array_ref_row_index(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    mwArray ColumnIndex() const\n    {\n        array_ref* p = array_ref_column_index(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    void MakeComplex()\n    {\n        if (array_ref_make_complex(m_pa) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n\n    bool operator==(const mwArray& arr) const\n    {\n        return Equals(arr);\n    }\n    bool operator!=(const mwArray& arr) const\n    {\n        return !Equals(arr);\n    }\n    bool operator<(const mwArray& arr) const\n    {\n        return (CompareTo(arr) < 0);\n    }\n    bool operator>(const mwArray& arr) const\n    {\n        return (CompareTo(arr) > 0);\n    }\n    bool operator<=(const mwArray& arr) const\n    {\n        return (CompareTo(arr) <= 0);\n    }\n    bool operator>=(const mwArray& arr) const\n    {\n        return (CompareTo(arr) >= 0);\n    }\n    friend std::ostream& operator<<(std::ostream& os, const mwArray& arr)\n    {\n        os << arr.ToString();\n        return os;\n    }\n    mwArray GetA(mwSize num_indices, const mwIndex* index)\n    {\n        array_ref* p = array_ref_get_int(m_pa, num_indices, index);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    const mwArray GetA(mwSize num_indices, const mwIndex* index) const\n    {\n        array_ref* p = array_ref_get_int(m_pa, num_indices, index);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    mwArray GetA(const char* name, mwIndex index)\n    {\n        array_ref* p = array_ref_get_const_char(m_pa, name, 1, &index);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    const mwArray GetA(const char* name, mwIndex index) const\n    {\n        array_ref* p = array_ref_get_const_char(m_pa, name, 1, &index);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    mwArray GetA(const char* name, mwSize num_indices, const mwIndex* index)\n    {\n        array_ref* p = array_ref_get_const_char(m_pa, name, num_indices,\n                        index);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    const mwArray GetA(const char* name, mwSize num_indices, const mwIndex* index) const\n    {\n        array_ref* p = array_ref_get_const_char(m_pa, name, num_indices,\n                        index);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    mwArray Get(mwSize num_indices, mwIndex i1)\n    {\n        return GetPromoted( 1, i1); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2)\n    {\n        return GetPromoted( 2, i1,  i2); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3)\n    {\n        return GetPromoted( 3, i1,  i2,  i3); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4)\n    {\n        return GetPromoted( 4, i1,  i2,  i3,  i4); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5)\n    { \n        return GetPromoted( 5, i1,  i2,  i3,  i4,  i5); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6)\n    {\n        return GetPromoted( 6, i1,  i2,  i3,  i4,  i5,  i6); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7)\n    {\n        return GetPromoted( 7, i1,  i2,  i3,  i4,  i5,  i6,  i7); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8)\n    {\n        return GetPromoted( 8, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9)\n    {\n        return GetPromoted( 9, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10)\n    {\n        return GetPromoted( 10, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11)\n    {\n        return GetPromoted( 11, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12)\n    {\n        return GetPromoted( 12, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13)\n    {\n        return GetPromoted( 13, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14)\n    {\n        return GetPromoted( 14, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15)\n    {\n        return GetPromoted( 15, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16)\n    {\n        return GetPromoted( 16, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17)\n    {\n        return GetPromoted( 17, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18)\n    {\n        return GetPromoted( 18, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19)\n    {\n        return GetPromoted( 19, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20)\n    {\n        return GetPromoted( 20, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21)\n    {\n        return GetPromoted( 21, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22)\n    {\n        return GetPromoted( 22, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23)\n    {\n        return GetPromoted( 23, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24)\n    {\n        return GetPromoted( 24, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25)\n    {\n        return GetPromoted( 25, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26)\n    {\n        return GetPromoted( 26, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27)\n    {\n        return GetPromoted( 27, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28)\n    {\n        return GetPromoted( 28, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29)\n    {\n        return GetPromoted( 29, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30)\n    {\n        return GetPromoted( 30, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31)\n    {\n        return GetPromoted( 31, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31); \n    }\n    mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31, mwIndex i32)\n    {\n        return GetPromoted( 32, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31, i32); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1) const\n    {\n        return GetPromoted( 1, i1); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2) const\n    {\n        return GetPromoted( 2, i1,  i2); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3) const\n    {\n        return GetPromoted( 3, i1,  i2,  i3); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4) const\n    {\n        return GetPromoted( 4, i1,  i2,  i3,  i4); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5) const\n    {\n        return GetPromoted( 5, i1,  i2,  i3,  i4,  i5); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6) const\n    {\n        return GetPromoted( 6, i1,  i2,  i3,  i4,  i5,  i6); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7) const\n    {\n        return GetPromoted( 7, i1,  i2,  i3,  i4,  i5,  i6,  i7); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8) const\n    {\n        return GetPromoted( 8, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9) const\n    {\n        return GetPromoted( 9, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10) const\n    {\n        return GetPromoted( 10, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11) const\n    {\n        return GetPromoted( 11, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12) const\n    {\n        return GetPromoted( 12, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13) const\n    {\n        return GetPromoted( 13, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14) const\n    {\n        return GetPromoted( 14, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15) const\n    {\n        return GetPromoted( 15, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16) const\n    {\n        return GetPromoted( 16, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17) const\n    {\n        return GetPromoted( 17, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18) const\n    {\n        return GetPromoted( 18, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19) const\n    {\n        return GetPromoted( 19, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20) const\n    {\n        return GetPromoted( 20, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21) const\n    {\n        return GetPromoted( 21, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22) const\n    {\n        return GetPromoted( 22, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23) const\n    {\n        return GetPromoted( 23, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24) const\n    {\n        return GetPromoted( 24, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25) const\n    {\n        return GetPromoted( 25, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26) const\n    {\n        return GetPromoted( 26, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27) const\n    {\n        return GetPromoted( 27, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28) const\n    {\n        return GetPromoted( 28, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29) const\n    {\n        return GetPromoted( 29, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30) const\n    {\n        return GetPromoted( 30, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31) const\n    {\n        return GetPromoted( 31, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31); \n    }\n    const mwArray Get(mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31, mwIndex i32) const\n    {\n        return GetPromoted( 32, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31, i32); \n    }\n    mwArray GetPromoted(mwSize num_indices, ...)\n    {\n        va_list vargs;\n        va_start(vargs, num_indices);\n        array_ref* p = array_ref_getV_int(m_pa, num_indices, vargs);\n        va_end(vargs);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    const mwArray GetPromoted(mwSize num_indices, ...) const\n    {\n        va_list vargs;\n        va_start(vargs, num_indices);\n        array_ref* p = array_ref_getV_int(m_pa, num_indices, vargs);\n        va_end(vargs);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    mwArray Get(const char* name, mwSize num_indices, mwIndex i1)\n    {\n        return GetPromoted( name, 1, i1); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2)\n    {\n        return GetPromoted( name, 2, i1,  i2); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3)\n    {\n        return GetPromoted( name, 3, i1,  i2,  i3); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4)\n    {\n        return GetPromoted( name, 4, i1,  i2,  i3,  i4); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5)\n    { \n        return GetPromoted( name, 5, i1,  i2,  i3,  i4,  i5); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6)\n    {\n        return GetPromoted( name, 6, i1,  i2,  i3,  i4,  i5,  i6); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7)\n    {\n        return GetPromoted( name, 7, i1,  i2,  i3,  i4,  i5,  i6,  i7); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8)\n    {\n        return GetPromoted( name, 8, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9)\n    {\n        return GetPromoted( name, 9, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10)\n    {\n        return GetPromoted( name, 10, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11)\n    {\n        return GetPromoted( name, 11, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12)\n    {\n        return GetPromoted( name, 12, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13)\n    {\n        return GetPromoted( name, 13, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14)\n    {\n        return GetPromoted( name, 14, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15)\n    {\n        return GetPromoted( name, 15, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16)\n    {\n        return GetPromoted( name, 16, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17)\n    {\n        return GetPromoted( name, 17, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18)\n    {\n        return GetPromoted( name, 18, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19)\n    {\n        return GetPromoted( name, 19, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20)\n    {\n        return GetPromoted( name, 20, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21)\n    {\n        return GetPromoted( name, 21, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22)\n    {\n        return GetPromoted( name, 22, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23)\n    {\n        return GetPromoted( name, 23, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24)\n    {\n        return GetPromoted( name, 24, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25)\n    {\n        return GetPromoted( name, 25, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26)\n    {\n        return GetPromoted( name, 26, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27)\n    {\n        return GetPromoted( name, 27, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28)\n    {\n        return GetPromoted( name, 28, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29)\n    {\n        return GetPromoted( name, 29, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30)\n    {\n        return GetPromoted( name, 30, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31)\n    {\n        return GetPromoted( name, 31, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31); \n    }\n    mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31, mwIndex i32)\n    {\n        return GetPromoted( name, 32, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31, i32); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1) const\n    {\n        return GetPromoted( name, 1, i1); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2) const\n    {\n        return GetPromoted( name, 2, i1,  i2); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3) const\n    {\n        return GetPromoted( name, 3, i1,  i2,  i3); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4) const\n    {\n        return GetPromoted( name, 4, i1,  i2,  i3,  i4); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5) const\n    {\n        return GetPromoted( name, 5, i1,  i2,  i3,  i4,  i5); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6) const\n    {\n        return GetPromoted( name, 6, i1,  i2,  i3,  i4,  i5,  i6); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7) const\n    {\n        return GetPromoted( name, 7, i1,  i2,  i3,  i4,  i5,  i6,  i7); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8) const\n    {\n        return GetPromoted( name, 8, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9) const\n    {\n        return GetPromoted( name, 9, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10) const\n    {\n        return GetPromoted( name, 10, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11) const\n    {\n        return GetPromoted( name, 11, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12) const\n    {\n        return GetPromoted( name, 12, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13) const\n    {\n        return GetPromoted( name, 13, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14) const\n    {\n        return GetPromoted( name, 14, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15) const\n    {\n        return GetPromoted( name, 15, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16) const\n    {\n        return GetPromoted( name, 16, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17) const\n    {\n        return GetPromoted( name, 17, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18) const\n    {\n        return GetPromoted( name, 18, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19) const\n    {\n        return GetPromoted( name, 19, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20) const\n    {\n        return GetPromoted( name, 20, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21) const\n    {\n        return GetPromoted( name, 21, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22) const\n    {\n        return GetPromoted( name, 22, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23) const\n    {\n        return GetPromoted( name, 23, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24) const\n    {\n        return GetPromoted( name, 24, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25) const\n    {\n        return GetPromoted( name, 25, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26) const\n    {\n        return GetPromoted( name, 26, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27) const\n    {\n        return GetPromoted( name, 27, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28) const\n    {\n        return GetPromoted( name, 28, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29) const\n    {\n        return GetPromoted( name, 29, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30) const\n    {\n        return GetPromoted( name, 30, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31) const\n    {\n        return GetPromoted( name, 31, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31); \n    }\n    const mwArray Get(const char *name, mwSize num_indices, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31, mwIndex i32) const\n    {\n        return GetPromoted( name, 32, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31, i32); \n    }\n    mwArray GetPromoted(const char* name, mwSize num_indices, ...)\n    {\n        va_list vargs;\n        va_start(vargs, num_indices);\n        array_ref* p = array_ref_getV_const_char(m_pa, name, num_indices,\n                         vargs);\n        va_end(vargs);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    const mwArray GetPromoted(const char* name, mwSize num_indices, ...) const\n    {\n        va_list vargs;\n        va_start(vargs, num_indices);\n        array_ref* p = array_ref_getV_const_char(m_pa, name, num_indices,\n                         vargs);\n        va_end(vargs);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    mwArray Real()\n    {\n        array_ref* p = array_ref_real(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    const mwArray Real() const\n    {\n        array_ref* p = array_ref_real(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    mwArray Imag()\n    {\n        array_ref* p = array_ref_imag(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    const mwArray Imag() const\n    {\n        array_ref* p = array_ref_imag(m_pa);\n        if (!p)\n            mwException::raise_error();\n        return mwArray(p);\n    }\n    void Set(const mwArray& arr)\n    {\n        if (array_ref_set(m_pa, arr.m_pa) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void Set(const mwArraySharedCopy<mwArray>& shared)\n    {\n        array_ref* pa_sharedCopy = array_ref_shared_copy(shared.m_pa);\n        if (NULL == pa_sharedCopy) {\n            mwException::raise_error();\n        }\n        ref_count_obj_release(m_pa);\n        m_pa = pa_sharedCopy;\n    }\n    void Set(const mwUString& str) \n    {\n        if (!IsMatlabString())\n            throw mwException(STRING_ONLY_METHOD_ERROR);\n        SetStringElement(1, str);\n    }\n    void Set(const mxChar* str)\n    {\n        if (!IsMatlabString())\n            throw mwException(STRING_ONLY_METHOD_ERROR);\n        SetStringElement(1, str);\n    }\n    void GetData(mxDouble* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxDouble(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetData(mxSingle* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxSingle(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetData(mxInt8* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxInt8(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetData(mxUint8* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxUint8(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetData(mxInt16* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxInt16(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetData(mxUint16* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxUint16(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetData(mxInt32* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxInt32(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetData(mxUint32* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxUint32(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetData(mxInt64* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxInt64(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetData(mxUint64* buffer, mwSize len) const\n    {\n        if (array_ref_get_numeric_mxUint64(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n#ifdef __APPLE__\n    void GetData(mwIndex* buffer, mwSize len) const\n    {\n#ifdef _LP64\n        if (array_ref_get_numeric_mxUint64(m_pa, static_cast<mxUint64 *>(static_cast<void *>(buffer)), len) == MCLCPP_ERR)\n            mwException::raise_error();\n#else\n        if (array_ref_get_numeric_mxUint32(m_pa, static_cast<mxUint32 *>(static_cast<void *>(buffer)), len) == MCLCPP_ERR)\n            mwException::raise_error();\n#endif\n    }\n#endif\n    void GetLogicalData(mxLogical* buffer, mwSize len) const\n    {\n        if (array_ref_get_logical(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetCharData(mxChar* buffer, mwSize len) const\n    {\n        if (array_ref_get_char(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void GetStringData(const mxChar** data, mwSize* array_size, mwSize* data_size) const\n    {\n        if (array_ref_get_matlab_string(m_pa, data, array_size, data_size) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    std::vector<mwUString> GetStringData() const\n    {\n        mwSize m = NumberOfElements();\n        std::vector<mwUString> ret(m);\n        if (m > 0) {\n            std::vector<const mxChar*> data(m);\n            if (array_ref_get_matlab_string(m_pa, (const mxChar**)&data[0], &m, nullptr) == MCLCPP_ERR)\n                mwException::raise_error();\n            for (mwSize i = 0; i < m; ++i) {\n                if (data[i])\n                    ret[i] = data[i];\n            }\n        }\n        return ret;\n    }\n    const mxChar* GetStringElement(mwSize index = 1) const\n    {\n        const mxChar* str = nullptr;\n        if (array_ref_get_string_element(m_pa, index, &str, nullptr) == MCLCPP_ERR)\n            mwException::raise_error();\n        return str;\n    }\n    void SetData(const mxDouble* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxDouble(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetData(const mxSingle* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxSingle(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetData(const mxInt8* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxInt8(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetData(const mxUint8* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxUint8(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetData(const mxInt16* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxInt16(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetData(const mxUint16* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxUint16(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetData(const mxInt32* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxInt32(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetData(const mxUint32* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxUint32(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetData(const mxInt64* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxInt64(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetData(const mxUint64* buffer, mwSize len)\n    {\n        if (array_ref_set_numeric_mxUint64(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n#ifdef __APPLE\n    void SetData(const mwIndex* buffer, mwSize len)\n    {\n#ifdef _LP64\n        if (array_ref_set_numeric_mxUint64(m_pa, static_cast<mxUint64 *>(static_cast<void *>(buffer))buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n#else\n        if (array_ref_set_numeric_mxUint32(m_pa, static_cast<mxUint32 *>(static_cast<void *>(buffer)), len) == MCLCPP_ERR)\n            mwException::raise_error();\n#endif\n    }\n#endif\n    void SetLogicalData(const mxLogical* buffer, mwSize len)\n    {\n        if (array_ref_set_logical(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    void SetCharData(const mxChar* buffer, mwSize len)\n    {\n        if (array_ref_set_char(m_pa, buffer, len) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    mwArray& operator=(const mwArray& arr)\n    {\n        if (&arr == const_cast<const mwArray*>(this)) {\n            return *this;\n        }\n        Set(arr);\n        return *this;\n    }\n    mwArray& operator=(const mwArraySharedCopy<mwArray>& arr)\n    {\n        if (static_cast<const mwArray*>(&arr) == const_cast<const mwArray*>(this)) {\n            return *this;\n        }\n        Set(arr);\n        return *this;\n    }\n    mwArray operator()(mwIndex i1)\n    {\n        return GetPromoted(1, i1);\n    }\n    const mwArray operator()(mwIndex i1) const\n    {\n        return GetPromoted(1, i1);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2)\n    {\n        return GetPromoted(2, i1, i2);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2) const\n    {\n        return GetPromoted(2, i1, i2);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3)\n    {\n        return GetPromoted(3, i1, i2, i3);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3) const\n    {\n        return GetPromoted(3, i1, i2, i3);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4)\n    {\n        return GetPromoted(4, i1, i2, i3, i4);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4) const\n    {\n        return GetPromoted(4, i1, i2, i3, i4);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5)\n    {\n        return GetPromoted(5, i1, i2, i3, i4, i5);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5) const\n    {\n        return GetPromoted(5, i1, i2, i3, i4, i5);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6)\n    {\n        return GetPromoted(6, i1, i2, i3, i4, i5, i6);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6) const\n    {\n        return GetPromoted(6, i1, i2, i3, i4, i5, i6);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7)\n    {\n        return GetPromoted(7, i1, i2, i3, i4, i5, i6, i7);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7) const\n    {\n        return GetPromoted(7, i1, i2, i3, i4, i5, i6, i7);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8)\n    {\n        return GetPromoted(8, i1, i2, i3, i4, i5, i6, i7, i8);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8) const\n    {\n        return GetPromoted(8, i1, i2, i3, i4, i5, i6, i7, i8);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9)\n    {\n        return GetPromoted(9, i1, i2, i3, i4, i5, i6, i7, i8, i9);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9) const\n    {\n        return GetPromoted(9, i1, i2, i3, i4, i5, i6, i7, i8, i9);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10)\n    {\n        return GetPromoted(10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10) const\n    {\n        return GetPromoted(10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11)\n    {\n        return GetPromoted(11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11) const\n    {\n        return GetPromoted(11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12)\n    {\n        return GetPromoted(12, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12) const\n    {\n        return GetPromoted(12, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13)\n    {\n        return GetPromoted(13, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13) const\n    {\n        return GetPromoted(13, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14)\n    {\n        return GetPromoted(14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14) const\n    {\n        return GetPromoted(14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15)\n    {\n        return GetPromoted(15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15) const\n    {\n        return GetPromoted(15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16)\n    {\n        return GetPromoted(16, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16) const\n    {\n        return GetPromoted(16, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17)\n    {\n        return GetPromoted(17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17) const\n    {\n        return GetPromoted(17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18)\n    {\n        return GetPromoted(18, i1, i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18) const\n    {\n        return GetPromoted(18, i1, i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19)\n    {\n        return GetPromoted(19, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19) const\n    {\n        return GetPromoted(19, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20)\n    {\n        return GetPromoted(20, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20) const\n    {\n        return GetPromoted(20, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21)\n    {\n        return GetPromoted(21, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21) const\n    {\n        return GetPromoted(21, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22)\n    {\n        return GetPromoted(22, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22) const\n    {\n        return GetPromoted(22, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23)\n    {\n        return GetPromoted(23, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23) const\n    {\n        return GetPromoted(23, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24)\n    {\n        return GetPromoted(24, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24) const\n    {\n        return GetPromoted(24, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25)\n    {\n        return GetPromoted(25, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25) const\n    {\n        return GetPromoted(25, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26)\n    {\n        return GetPromoted(26, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26) const\n    {\n        return GetPromoted(26, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27)\n    {\n        return GetPromoted(27, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27) const\n    {\n        return GetPromoted(27, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28)\n    {\n        return GetPromoted(28, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28) const\n    {\n        return GetPromoted(28, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29)\n    {\n        return GetPromoted(29, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29) const\n    {\n        return GetPromoted(29, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30)\n    {\n        return GetPromoted(30, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30) const\n    {\n        return GetPromoted(30, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31)\n    {\n        return GetPromoted(31, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31) const\n    {\n        return GetPromoted(31, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31);\n    }\n    mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31, mwIndex i32)\n    {\n        return GetPromoted(32, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31, i32);\n    }\n    const mwArray operator()(mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31, mwIndex i32) const\n    {\n        return GetPromoted(32, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31, i32);\n    }\n    mwArray operator()(const char* name, mwIndex i1)\n    {\n        return GetPromoted(name, 1, i1);\n    }\n    const mwArray operator()(const char* name, mwIndex i1) const\n    {\n        return GetPromoted(name, 1, i1);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2)\n    {\n        return GetPromoted(name, 2, i1, i2);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2) const\n    {\n        return GetPromoted(name, 2, i1, i2);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3)\n    {\n        return GetPromoted(name, 3, i1, i2, i3);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3) const\n    {\n        return GetPromoted(name, 3, i1, i2, i3);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4)\n    {\n        return GetPromoted(name, 4, i1, i2, i3, i4);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4) const\n    {\n        return GetPromoted(name, 4, i1, i2, i3, i4);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5)\n    {\n        return GetPromoted(name, 5, i1, i2, i3, i4, i5);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5) const\n    {\n        return GetPromoted(name, 5, i1, i2, i3, i4, i5);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6)\n    {\n        return GetPromoted(name, 6, i1, i2, i3, i4, i5, i6);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6) const\n    {\n        return GetPromoted(name, 6, i1, i2, i3, i4, i5, i6);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7)\n    {\n        return GetPromoted(name, 7, i1, i2, i3, i4, i5, i6, i7);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7) const\n    {\n        return GetPromoted(name, 7, i1, i2, i3, i4, i5, i6, i7);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8)\n    {\n        return GetPromoted(name, 8, i1, i2, i3, i4, i5, i6, i7, i8);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8) const\n    {\n        return GetPromoted(name, 8, i1, i2, i3, i4, i5, i6, i7, i8);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9)\n    {\n        return GetPromoted(name, 9, i1, i2, i3, i4, i5, i6, i7, i8, i9);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9) const\n    {\n        return GetPromoted(name, 9, i1, i2, i3, i4, i5, i6, i7, i8, i9);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10)\n    {\n        return GetPromoted(name, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10) const\n    {\n        return GetPromoted(name, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11)\n    {\n        return GetPromoted(name, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11) const\n    {\n        return GetPromoted(name, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12)\n    {\n        return GetPromoted(name, 12, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12) const\n    {\n        return GetPromoted(name, 12, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13)\n    {\n        return GetPromoted(name, 13, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13) const\n    {\n        return GetPromoted(name, 13, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14)\n    {\n        return GetPromoted(name, 14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14) const\n    {\n        return GetPromoted(name, 14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15)\n    {\n        return GetPromoted(name, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15) const\n    {\n        return GetPromoted(name, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16)\n    {\n        return GetPromoted(name, 16, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16) const\n    {\n        return GetPromoted(name, 16, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17)\n    {\n        return GetPromoted(name, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17) const\n    {\n        return GetPromoted(name, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18)\n    {\n        return GetPromoted(name, 18, i1, i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18) const\n    {\n        return GetPromoted(name, 18, i1, i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19)\n    {\n        return GetPromoted(name, 19, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19) const\n    {\n        return GetPromoted(name, 19, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20)\n    {\n        return GetPromoted(name, 20, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20) const\n    {\n        return GetPromoted(name, 20, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21)\n    {\n        return GetPromoted(name, 21, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21) const\n    {\n        return GetPromoted(name, 21, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22)\n    {\n        return GetPromoted(name, 22, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22) const\n    {\n        return GetPromoted(name, 22, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23)\n    {\n        return GetPromoted(name, 23, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23) const\n    {\n        return GetPromoted(name, 23, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24)\n    {\n        return GetPromoted(name, 24, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24) const\n    {\n        return GetPromoted(name, 24, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25)\n    {\n        return GetPromoted(name, 25, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25) const\n    {\n        return GetPromoted(name, 25, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26)\n    {\n        return GetPromoted(name, 26, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26) const\n    {\n        return GetPromoted(name, 26, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27)\n    {\n        return GetPromoted(name, 27, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27) const\n    {\n        return GetPromoted(name, 27, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28)\n    {\n        return GetPromoted(name, 28, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28) const\n    {\n        return GetPromoted(name, 28, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29)\n    {\n        return GetPromoted(name, 29, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29) const\n    {\n        return GetPromoted(name, 29, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30)\n    {\n        return GetPromoted(name, 30, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30) const\n    {\n        return GetPromoted(name, 30, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31)\n    {\n        return GetPromoted(name, 31, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31) const\n    {\n        return GetPromoted(name, 31, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31);\n    }\n    mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31, mwIndex i32)\n    {\n        return GetPromoted(name, 32, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31, i32);\n    }\n    const mwArray operator()(const char* name, mwIndex i1, mwIndex i2, mwIndex i3, mwIndex i4, mwIndex i5, mwIndex i6, mwIndex i7, mwIndex i8, mwIndex i9, mwIndex i10, mwIndex i11, mwIndex i12, mwIndex i13, mwIndex i14, mwIndex i15, mwIndex i16, mwIndex i17, mwIndex i18, mwIndex i19, mwIndex i20, mwIndex i21, mwIndex i22, mwIndex i23, mwIndex i24, mwIndex i25, mwIndex i26, mwIndex i27, mwIndex i28, mwIndex i29, mwIndex i30, mwIndex i31, mwIndex i32) const\n    {\n        return GetPromoted(name, 32, i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25,  i26, i27, i28, i29, i30, i31, i32);\n    }\n    mwArray& operator=(const mxDouble& x)\n    {\n        if (array_ref_set_numeric_mxDouble(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mxSingle& x)\n    {\n        if (array_ref_set_numeric_mxSingle(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mxInt8& x)\n    {\n        if (array_ref_set_numeric_mxInt8(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mxUint8& x)\n    {\n        if (array_ref_set_numeric_mxUint8(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mxInt16& x)\n    {\n        if (array_ref_set_numeric_mxInt16(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mxUint16& x)\n    {\n        if (array_ref_set_numeric_mxUint16(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mxInt32& x)\n    {\n        if (array_ref_set_numeric_mxInt32(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mxUint32& x)\n    {\n        if (array_ref_set_numeric_mxUint32(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mxInt64& x)\n    {\n        if (array_ref_set_numeric_mxInt64(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mxUint64& x)\n    {\n        if (array_ref_set_numeric_mxUint64(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n    mwArray& operator=(const mwUString& x)\n    {\n        if (!IsMatlabString())\n            throw mwException(STRING_ONLY_METHOD_ERROR);\n        SetStringElement(1, x);\n        return *this;\n    }\n    mwArray& operator=(const mxChar* x)\n    {\n        if (!IsMatlabString())\n            throw mwException(STRING_ONLY_METHOD_ERROR);\n        SetStringElement(1, x);\n        return *this;\n    }\n#if !defined(__APPLE_CC__)\n    mwArray& operator=(const mxLogical& x)\n    {\n        if (array_ref_set_logical(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return *this;\n    }\n#endif\n    operator mxDouble() const\n    {\n        mxDouble x;\n        if (array_ref_get_numeric_mxDouble(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator mxSingle() const\n    {\n        mxSingle x;\n        if (array_ref_get_numeric_mxSingle(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator mxInt8() const\n    {\n        mxInt8 x;\n        if (array_ref_get_numeric_mxInt8(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator mxUint8() const\n    {\n        mxUint8 x;\n        if (array_ref_get_numeric_mxUint8(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator mxInt16() const\n    {\n        mxInt16 x;\n        if (array_ref_get_numeric_mxInt16(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator mxUint16() const\n    {\n        mxUint16 x;\n        if (array_ref_get_numeric_mxUint16(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator mxInt32() const\n    {\n        mxInt32 x;\n        if (array_ref_get_numeric_mxInt32(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator mxUint32() const\n    {\n        mxUint32 x;\n        if (array_ref_get_numeric_mxUint32(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator mxInt64() const\n    {\n        mxInt64 x;\n        if (array_ref_get_numeric_mxInt64(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator mxUint64() const\n    {\n        mxUint64 x;\n        if (array_ref_get_numeric_mxUint64(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n    operator const mxChar*() const\n    {\n        return GetStringElement();\n    }\n#if !defined(__APPLE_CC__)\n    operator mxLogical() const\n    {\n        mxLogical x;\n        if (array_ref_get_logical(m_pa, &x, 1) == MCLCPP_ERR)\n            mwException::raise_error();\n        return x;\n    }\n#endif\n    static double GetNaN()\n    {\n        return mclGetNaN();\n    }\n    static double GetEps()\n    {\n        return mclGetEps();\n    } \n    static double GetInf()\n    {\n        return mclGetInf();\n    }\n    static bool IsFinite(double x)\n    {\n        return mclIsFinite(x);\n    }\n    static bool IsInf(double x)\n    {\n        return mclIsInf(x);\n    }\n    static bool IsNaN(double x)\n    {\n        return mclIsNaN(x);\n    }\n    static mwArray Deserialize(const mwArray& arrIn)\n    {\n        array_ref* pOut = NULL;\n        void * pvIn = static_cast<void *>(const_cast<array_ref *>(arrIn.m_pa));\n        if (mclDeserializeArray(reinterpret_cast<void **>(&pOut), &pvIn) == MCLCPP_ERR)\n            mwException::raise_error();\n        return mwArray(pOut);\n    }\n    static mwArray NewSparse(mwSize num_rows, mwSize num_cols, mwSize nzmax, mxClassID mxID, mxComplexity cmplx = mxREAL)\n    {\n        array_ref* p = 0;\n        int retval = 0;\n        if (mxID == mxLOGICAL_CLASS)\n        {\n            retval = mclGetLogicalSparse((void **)&p, 0, NULL, 0, NULL, 0, NULL, num_rows, num_cols, nzmax);\n        }\n        else\n        {\n            retval = mclGetNumericSparse((void**)&p, 0, NULL, 0, NULL, 0, NULL, NULL, num_rows, num_cols, nzmax, mxID, cmplx);\n        }\n        if (retval)\n        {\n            mwException::raise_error();\n        }\n        return mwArray(p);\n    }\n    static mwArray NewSparse(mwSize rowindex_size, const mwIndex* rowindex,\n                 mwSize colindex_size, const mwIndex* colindex, mwSize data_size, \n                 const mxDouble* rData, mwSize num_rows, mwSize num_cols, mwSize nzmax)\n    {\n        array_ref* p = 0;\n        if (mclGetNumericSparse((void **)&p, rowindex_size, rowindex, colindex_size, colindex, \n            data_size, rData, NULL, num_rows, num_cols, nzmax, mxDOUBLE_CLASS, mxREAL))\n                mwException::raise_error();\n        return mwArray(p);\n    }\n    static mwArray NewSparse(mwSize rowindex_size, const mwIndex* rowindex,\n                 mwSize colindex_size, const mwIndex* colindex, mwSize data_size, \n                 const mxDouble* rData, mwSize nzmax)\n    {\n        array_ref* p = 0;\n        if (mclGetNumericSparseInferRowsCols((void **)&p, rowindex_size, rowindex, colindex_size, colindex, \n            data_size, rData, NULL, nzmax, mxDOUBLE_CLASS, mxREAL))\n                mwException::raise_error();\n        return mwArray(p);\n    }\n    static mwArray NewSparse(mwSize rowindex_size, const mwIndex* rowindex,\n                 mwSize colindex_size, const mwIndex* colindex, mwSize data_size, \n                 const mxDouble* rData, const mxDouble* iData, mwSize num_rows, mwSize num_cols, mwSize nzmax)\n    {\n        array_ref* p = 0;\n        if (mclGetNumericSparse((void **)&p, rowindex_size, rowindex, colindex_size, colindex, \n            data_size, rData, iData, num_rows, num_cols, nzmax, mxDOUBLE_CLASS, mxCOMPLEX))\n                mwException::raise_error();\n        return mwArray(p);\n    }\n    static mwArray NewSparse(mwSize rowindex_size, const mwIndex* rowindex,\n                 mwSize colindex_size, const mwIndex* colindex, mwSize data_size, \n                 const mxDouble* rData, const mxDouble* iData, mwSize nzmax)\n    {\n        array_ref* p = 0;\n        if (mclGetNumericSparseInferRowsCols((void **)&p, rowindex_size, rowindex, colindex_size, colindex, \n            data_size, rData, iData, nzmax, mxDOUBLE_CLASS, mxCOMPLEX))\n                mwException::raise_error();\n        return mwArray(p);\n    }\n    static mwArray NewSparse(mwSize rowindex_size, const mwIndex* rowindex,\n                 mwSize colindex_size, const mwIndex* colindex, mwSize data_size, \n                 const mxLogical* rData, mwSize num_rows, mwSize num_cols, mwSize nzmax)\n    {\n        array_ref* p = 0;\n        if (mclGetLogicalSparse((void **)&p, rowindex_size, rowindex, colindex_size, colindex, \n            data_size, rData, num_rows, num_cols, nzmax))\n                mwException::raise_error();\n        return mwArray(p);\n    }\n    static mwArray NewSparse(mwSize rowindex_size, const mwIndex* rowindex,\n                 mwSize colindex_size, const mwIndex* colindex, mwSize data_size, \n                 const mxLogical* rData, mwSize nzmax)\n    {\n        array_ref* p = 0;\n        if (mclGetLogicalSparseInferRowsCols((void **)&p, rowindex_size, rowindex, colindex_size, colindex, \n            data_size, rData, nzmax))\n                mwException::raise_error();\n        return mwArray(p);\n    }\nprotected:\n    array_ref* m_pa;\nprivate:\n    /**\n     * Prevent this operator from being used by applications.\n     */\n    mwArray& operator=(const char*)\n    {\n        return *this;\n    }\n};\n\ninline void mclcppMlfFeval(HMCRINSTANCE inst, const char* name, int nargout,\n               int fnout, int fnin, ...)\n{\n    va_list ap;\n    mw_auto_ptr_t<array_buffer> rhs;\n    mw_auto_ptr_t<array_buffer> lhs;\n    bool bVarargout = fnout < 0;\n    bool bVarargin = fnin < 0;\n    int i = 0;\n    mwIndex ixIndx;\n\n    if (bVarargout) \n        fnout = -fnout;\n    if (bVarargin) \n        fnin = -fnin;\n    int nin = (bVarargin ? fnin-1 : fnin);\n    int nout = (bVarargout ? fnout-1 : fnout);\n\n    // Try to allocate an buffer for the right hand side (input) parameters.\n    if ((mclcppGetArrayBuffer((void**)&rhs, nin) == MCLCPP_ERR))\n        mwException::raise_error();\n    va_start(ap, fnin);\n\n    // Skip over the output arguments\n    for (i=0; i<fnout; i++)\n        va_arg(ap, mwArray*);\n\n    for (i=1; i<=nin; i++)\n    {\n        const mwArray* arr = va_arg(ap, const mwArray*);\n        if (array_buffer_set(rhs, i, arr->get_ptr()) == MCLCPP_ERR)\n            mwException::raise_error();\n    }\n    if (bVarargin)\n    {\n        const mwArray* varargin = va_arg(ap, const mwArray*);\n        if (varargin->ClassID() == mxCELL_CLASS)\n        {\n            for (ixIndx=1; ixIndx<=varargin->NumberOfElements(); ixIndx++)\n            {\n                if (array_buffer_add(rhs, varargin->Get(1, ixIndx).get_ptr())\n            == MCLCPP_ERR)\n                    mwException::raise_error();\n            }\n        }\n        else\n        {\n            if (array_buffer_add(rhs, varargin->get_ptr()) == MCLCPP_ERR)\n                mwException::raise_error();\n        }\n    }\n\n    va_end(ap);\n\n    // Execute function\n    if (mclcppFeval(inst, name, nargout, (void**)&lhs,\n            (void*)((array_buffer*)rhs)) == MCLCPP_ERR)\n        mwException::raise_error();\n    // Process outputs\n\n    va_start(ap, fnin);\n    for(i=1; i<=nout && i<=nargout; i++) \n    {\n        mwArray* arr = va_arg(ap, mwArray*);\n        array_ref* p = array_buffer_get(lhs, i);\n        if (!p)\n            mwException::raise_error();\n        arr->set_ptr(p);\n        ref_count_obj_release(p);\n    }\n    if (bVarargout && i<= nargout)\n    {\n        mwArray* varargout = va_arg(ap, mwArray*);\n        array_ref* p = array_buffer_to_cell(lhs, i, nargout-i+1);\n        if (!p)\n            mwException::raise_error();\n        varargout->set_ptr(p);\n        ref_count_obj_release(p);\n    }\n    va_end(ap);\n}\n\n#endif /* ifdef __cplusplus */\n\n#endif /* #ifndef _MCLCPPCLASS_H_ */\n\n"},{"name":"mclmcr.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * PUBLISHed header for libmclmcr, the mclmcr library.\n *\n * Copyright 1984-2020 The MathWorks, Inc.\n */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef mclmcr_published_api_hpp\n#define mclmcr_published_api_hpp\n\n\n#ifndef LIBMWMCLMCR_API_EXTERN_C\n#  ifdef __cplusplus\n#    define LIBMWMCLMCR_API_EXTERN_C extern \"C\"\n#  else\n#    define LIBMWMCLMCR_API_EXTERN_C extern\n#  endif\n#endif\n\n#ifndef LIBMWMCLMCR_API\n#  define LIBMWMCLMCR_API\n#endif\n\n#ifndef LIBMWMCLMCR_API_LIBMWMCLMCR_API_EXTERN_C\n#  define LIBMWMCLMCR_API_LIBMWMCLMCR_API_EXTERN_C LIBMWMCLMCR_API_EXTERN_C LIBMWMCLMCR_API\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    typedef int (*mclReadCtfStreamFcn)(char* s, int n);\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n/* All the types of components we can generate code for. These values\n * determine how the component initializes itself.\n */\ntypedef enum\n{\n    NoObjectType,\n    COMObject,\n    JavaObject,\n    DotNetObject\n} mccComponentType;\n\ntypedef enum\n{\n    ExeTarget,\n    LibTarget,\n    MexTarget,\n    SfunTarget,\n    AnyTarget\n} mccTargetType;\n\n\ntypedef struct mclCtfStream_tag\n{\n    /*This field is only here to prevent an\n      empty struct warning for some compilers. */\n    char unused;\n} mclCtfStream_tag;\n\ntypedef mclCtfStream_tag* mclCtfStream;\n#include <stddef.h>\n\n\nLIBMWMCLMCR_API_EXTERN_C mclCtfStream mclGetStreamFromArraySrc(char *buffer, int bufferSize);\n\n\nLIBMWMCLMCR_API_EXTERN_C void mclDestroyStream(mclCtfStream pStream);\n\n\nLIBMWMCLMCR_API_EXTERN_C mclCtfStream mclGetEmbeddedCtfStream(void* handle);\n\n\n#include \"mclbase.h\" /*for mclOutputHandler MCRInstanceProxy*/\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclInitializeComponentInstanceNonEmbeddedStandalone(HMCRINSTANCE* inst,\n                                                                                  const char* path_to_component,\n                                                                                  const char* component_name,\n                                                                                  mccTargetType ttype,\n                                                                                  mclOutputHandlerFcn error_handler,\n                                                                                  mclOutputHandlerFcn print_handler);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclInitializeInstanceWithoutComponent(HMCRINSTANCE* inst,\n                                                                    const char** options,\n                                                                    size_t count,\n                                                                    mclOutputHandlerFcn error_handler,\n                                                                    mclOutputHandlerFcn print_handler);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclInitializeComponentInstanceCtfFileToCache(HMCRINSTANCE* inst,\n                                                                           mclOutputHandlerFcn error_handler,\n                                                                           mclOutputHandlerFcn print_handler,\n                                                                           const char* ctfFileLocation);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclInitializeComponentInstanceEmbedded(HMCRINSTANCE* inst,\n                                                                     mclOutputHandlerFcn error_handler,\n                                                                     mclOutputHandlerFcn print_handler,\n                                                                     mclCtfStream ctfStream);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclInitializeComponentInstanceWithCallbk(HMCRINSTANCE* inst,\n                                                                       mclOutputHandlerFcn error_handler,\n                                                                       mclOutputHandlerFcn print_handler,\n                                                                       mclReadCtfStreamFcn readCtfStream_handler,\n                                                                       size_t ctfStreamSize);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclInitializeComponentInstanceFromExtractedComponent(HMCRINSTANCE* inst,\n                                                                                   mclOutputHandlerFcn error_handler,\n                                                                                   mclOutputHandlerFcn print_handler,\n                                                                                   const char* component_id);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclInitializeComponentInstanceFromExtractedLocation(HMCRINSTANCE* inst,\n                                                                                  mclOutputHandlerFcn error_handler,\n                                                                                  mclOutputHandlerFcn print_handler,\n                                                                                  const char* extractedLoc);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetDotNetComponentType(void);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetMCCTargetType(bool isLibrary);\n\n\nLIBMWMCLMCR_API_EXTERN_C const char * getStandaloneFileName(const char* path_to_ctf, const char* component_name);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclStandaloneGenericMain(size_t argc,\n                                                       const char ** argv,\n                                                       const char* ctfFileName,\n                                                       bool ExtractToComponentCache,\n                                                       void* ctfSettings);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclStandaloneCtfxMain(size_t argc,\n                                                    const char** argv);\n\n\nLIBMWMCLMCR_API_EXTERN_C void mclWaitForFiguresToDie(HMCRINSTANCE inst);\n\n\n#include \"matrix.h\"\n\n\n#ifdef __cplusplus\n\n/* Forward declarations */\nclass ref_count_obj;\nclass char_buffer;\nclass array_ref;\nclass array_buffer;\nclass error_info;\n\n/* Class declarations */\n\nclass ref_count_obj\n{\n  public:\n    /* Virtual destructor required to avoid compiler warnings. */\n    virtual ~ref_count_obj() {}\n    virtual int addref() = 0;\n    virtual int release() = 0;\n};\n\nclass char_buffer: public ref_count_obj\n{\n  public:\n    /* Virtual destructor required to avoid compiler warnings. */\n    virtual ~char_buffer() {}\n    virtual size_t size() = 0;\n    virtual const char* get_buffer() = 0;\n    virtual int set_buffer(const char* str) = 0;\n    virtual int compare_to(char_buffer* p) = 0;\n};\n\nclass array_ref: public ref_count_obj\n{\n  public:\n    /* Virtual destructor required to avoid compiler warnings. */\n    virtual ~array_ref() {}\n    virtual mxClassID classID() = 0;\n    virtual array_ref* deep_copy() = 0;\n    virtual void detach() = 0;\n    virtual array_ref* shared_copy() = 0;\n    virtual array_ref* serialize() = 0;\n    virtual size_t element_size() = 0;\n    virtual mwSize number_of_elements() = 0;\n    virtual mwSize number_of_nonzeros() = 0;\n    virtual mwSize maximum_nonzeros() = 0;\n    virtual mwSize number_of_dimensions() = 0;\n    virtual array_ref* get_dimensions() = 0;\n    virtual int number_of_fields() = 0;\n    virtual char_buffer* get_field_name(int i) = 0;\n    virtual bool is_empty() = 0;\n    virtual bool is_sparse() = 0;\n    virtual bool is_numeric() = 0;\n    virtual bool is_complex() = 0;\n    virtual bool is_string() = 0;\n    virtual bool is_missing_element(mwSize index) = 0;\n    virtual int make_complex() = 0;\n    virtual bool equals(array_ref* p) = 0;\n    virtual int compare_to(array_ref* p) = 0;\n    virtual int hash_code() = 0;\n    virtual char_buffer* to_string() = 0;\n    virtual array_ref* row_index() = 0;\n    virtual array_ref* column_index() = 0;\n    virtual array_ref* get(mwSize num_indices, const mwIndex* index) = 0;\n    virtual array_ref* get(const char* name, mwSize num_indices, const mwIndex* index) = 0;\n    virtual array_ref* getV(mwSize num_indices, va_list vargs) = 0;\n    virtual array_ref* getV(const char* name, mwSize num_indices, va_list vargs) = 0;\n    virtual int set(array_ref* p) = 0;\n    virtual array_ref* real() = 0;\n    virtual array_ref* imag() = 0;\n    /* Virtual member functions can't be templated. Thus, we need to declare all the ones we need. */\n    virtual int get_numeric(mxDouble* x, mwSize len) = 0;\n    virtual int get_numeric(mxSingle* x, mwSize len) = 0;\n    virtual int get_numeric(mxInt8* x, mwSize len) = 0;\n    virtual int get_numeric(mxUint8* x, mwSize len) = 0;\n    virtual int get_numeric(mxInt16* x, mwSize len) = 0;\n    virtual int get_numeric(mxUint16* x, mwSize len) = 0;\n    virtual int get_numeric(mxInt32* x, mwSize len) = 0;\n    virtual int get_numeric(mxUint32* x, mwSize len) = 0;\n    virtual int get_numeric(mxInt64* x, mwSize len) = 0;\n    virtual int get_numeric(mxUint64* x, mwSize len) = 0;\n    virtual int get_char(mxChar* x, mwSize len) = 0;\n    virtual int get_logical(mxLogical* x, mwSize len) = 0;\n    virtual int get_string_element(mwSize index, const mxChar** str, mwSize* len) = 0;\n    virtual int get_string_data(const mxChar** data, mwSize* array_size, mwSize *data_size) = 0;\n    virtual int set_numeric(const mxDouble* x, mwSize len) = 0;\n    virtual int set_numeric(const mxSingle* x, mwSize len) = 0;\n    virtual int set_numeric(const mxInt8* x, mwSize len) = 0;\n    virtual int set_numeric(const mxUint8* x, mwSize len) = 0;\n    virtual int set_numeric(const mxInt16* x, mwSize len) = 0;\n    virtual int set_numeric(const mxUint16* x, mwSize len) = 0;\n    virtual int set_numeric(const mxInt32* x, mwSize len) = 0;\n    virtual int set_numeric(const mxUint32* x, mwSize len) = 0;\n    virtual int set_numeric(const mxInt64* x, mwSize len) = 0;\n    virtual int set_numeric(const mxUint64* x, mwSize len) = 0;\n    virtual int set_char(const mxChar* x, mwSize len) = 0;\n    virtual int set_logical(const mxLogical* x, mwSize len) = 0;\n    virtual int set_string_element(mwSize index, const mxChar* x) = 0;\n    virtual int set_string_data(const mxChar** x, mwSize array_size) = 0;\n};\n\nclass array_buffer: public ref_count_obj\n{\n  public:\n    /* Virtual destructor required to avoid compiler warnings. */\n    virtual ~array_buffer() {}\n    virtual mwSize size() = 0;\n    virtual array_ref* get(mwIndex offset) = 0;\n    virtual int set(mwIndex offset, array_ref* p) = 0;\n    virtual int add(array_ref* pa) = 0;\n    virtual int remove(mwIndex offset) = 0;\n    virtual int clear() = 0;\n    virtual array_ref* to_cell(mwIndex offset, mwSize len) = 0;\n};\n\nclass error_info: public ref_count_obj\n{\n  public:\n    /* Virtual destructor required to avoid compiler warnings. */\n    virtual ~error_info() {}\n    virtual const char* get_message() = 0;\n    virtual size_t get_stack_trace(char*** stack) = 0;\n};\n\n#endif /* #ifdef __cplusplus */\n\n\n#include \"matrix.h\"\n\n\n#ifdef __cplusplus\n/* This is an extern \"C\" API exclusively for use by C++ programs. It\n * exists solely to work around binary incompatibilities between different\n * C++ compilers. For example, a Borland C++ program cannot invoke a method\n * on an array_ref object created by a library compiled with Microsoft Visual\n * C++. The mwArray API, therefore, invokes array_ref methods indirectly, by\n * passing the array_ref object to one of these extern \"C\" routines, which\n * are implemented in the MCLMCR module. Since this module is part of the\n * MCR, it can invoke array_ref methods with impunity.\n *\n * This API needs to be protected by #ifdef __cplusplus because some of the\n * input arguments to the functions it contains are pointers to objects.\n * Translating all of these to void *'s is overly complex and unnecessary,\n * as this API is always going to be called from a C++ program.\n */\n\n\n\n\nLIBMWMCLMCR_API_EXTERN_C int ref_count_obj_addref(ref_count_obj *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C int ref_count_obj_release(ref_count_obj *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C size_t char_buffer_size(char_buffer *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C const char* char_buffer_get_buffer(char_buffer *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C int char_buffer_set_buffer(char_buffer *obj, const char* str);\n\n\nLIBMWMCLMCR_API_EXTERN_C int char_buffer_compare_to(char_buffer *obj, char_buffer* p);\n\n\nLIBMWMCLMCR_API_EXTERN_C mxClassID array_ref_classID(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_deep_copy(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C void array_ref_detach(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_shared_copy(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_serialize(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C size_t array_ref_element_size(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C mwSize array_ref_number_of_elements(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C mwSize array_ref_number_of_nonzeros(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C mwSize array_ref_maximum_nonzeros(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C mwSize array_ref_number_of_dimensions(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_get_dimensions(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_number_of_fields(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C char_buffer* array_ref_get_field_name(array_ref *obj, int i);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_ref_is_empty(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_ref_is_sparse(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_ref_is_numeric(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_ref_is_complex(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_ref_is_matlab_string(array_ref* obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_ref_is_missing_string_element(array_ref* obj, mwSize index);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_make_complex(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_ref_equals(array_ref *obj, array_ref* p);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_compare_to(array_ref *obj, array_ref* p);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_hash_code(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C char_buffer* array_ref_to_string(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_row_index(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_column_index(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_get_int(array_ref *obj, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_get_const_char(array_ref *obj, const char* name, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_getV_int(array_ref *obj, mwSize num_indices, va_list vargs);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_getV_const_char(array_ref *obj, const char* name, mwSize num_indices, va_list vargs);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set(array_ref *obj, array_ref* p);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_real(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_ref_imag(array_ref *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxDouble(array_ref *obj, mxDouble* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxSingle(array_ref *obj, mxSingle* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxInt8(array_ref *obj, mxInt8* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxUint8(array_ref *obj, mxUint8* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxInt16(array_ref *obj, mxInt16* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxUint16(array_ref *obj, mxUint16* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxInt32(array_ref *obj, mxInt32* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxUint32(array_ref *obj, mxUint32* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxInt64(array_ref *obj, mxInt64* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_numeric_mxUint64(array_ref *obj, mxUint64* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_char(array_ref *obj, mxChar* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_string_element(array_ref *obj, mwSize index, const mxChar** str, mwSize* len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_matlab_string(array_ref *obj, const mxChar** data, mwSize* array_size, mwSize *data_size);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_get_logical(array_ref *obj, mxLogical* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxDouble(array_ref *obj, const mxDouble* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxSingle(array_ref *obj, const mxSingle* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxInt8(array_ref *obj, const mxInt8* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxUint8(array_ref *obj, const mxUint8* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxInt16(array_ref *obj, const mxInt16* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxUint16(array_ref *obj, const mxUint16* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxInt32(array_ref *obj, const mxInt32* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxUint32(array_ref *obj, const mxUint32* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxInt64(array_ref *obj, const mxInt64* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_numeric_mxUint64(array_ref *obj, const mxUint64* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_char(array_ref *obj, const mxChar* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_string_element(array_ref* obj, mwSize index, const mxChar* x);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_matlab_string(array_ref* obj, const mxChar** x, mwSize array_size);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_ref_set_logical(array_ref *obj, const mxLogical* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C mwSize array_buffer_size(array_buffer *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_buffer_get(array_buffer *obj, mwIndex offset);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_buffer_set(array_buffer *obj, mwIndex offset, array_ref* p);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_buffer_add(array_buffer *obj, array_ref* pa);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_buffer_remove(array_buffer *obj, mwIndex offset);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_buffer_clear(array_buffer *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_ref* array_buffer_to_cell(array_buffer *obj, mwIndex offset, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C const char* error_info_get_message(error_info *obj);\n\n\nLIBMWMCLMCR_API_EXTERN_C size_t error_info_get_stack_trace(error_info *obj, char*** stack);\n\n\n#endif /* #ifdef __cplusplus */\n\n\n#define MCLCPP_OK    0\n#define MCLCPP_ERR  -1\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclcppGetLastError(void** ppv);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclcppCreateError(void** ppv, const char* msg);\n\n\nLIBMWMCLMCR_API_EXTERN_C void mclcppSetLastError(const char* msg);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclcppErrorCheck(void);\n\n\nLIBMWMCLMCR_API_EXTERN_C const char* mclcppGetLastErrorMessage(void);\n\n#ifdef __cplusplus\n\n#include <iostream>\n#include <exception>\n\nclass mwException : public std::exception\n{\n  public:\n    mwException() : std::exception()\n    {\n        m_err = 0;\n        mclcppCreateError((void**)&m_err, \"Unspecified error\");\n    }\n    mwException(const char* msg) : std::exception()\n    {\n        m_err = 0;\n        mclcppCreateError((void**)&m_err, (msg ? msg : \"Unspecified error\"));\n    }\n    mwException(const mwException& e) : std::exception()\n    {\n        m_err = e.m_err;\n        if (m_err) {\n            ref_count_obj_addref(m_err);\n        }\n    }\n    mwException(error_info* pe)\n    {\n        m_err = 0;\n        if (pe) {\n            m_err = pe;\n            ref_count_obj_addref(m_err);\n        } else {\n            mclcppCreateError((void**)&m_err, \"Unspecified error\");\n        }\n    }\n    mwException(error_info* pe, bool bAddRef)\n    {\n        m_err = 0;\n        if (pe) {\n            m_err = pe;\n            if (bAddRef) {\n                ref_count_obj_addref(m_err);\n            }\n        } else {\n            mclcppCreateError((void**)&m_err, \"Unspecified error\");\n        }\n    }\n    mwException(const std::exception& e) : std::exception()\n    {\n        m_err = 0;\n        mclcppCreateError((void**)&m_err, e.what());\n    }\n    virtual ~mwException() throw()\n    {\n        if (m_err) {\n            ref_count_obj_release(m_err);\n        }\n    }\n    mwException& operator=(const std::exception& e)\n    {\n        if (m_err) {\n            ref_count_obj_release(m_err);\n        }\n        mclcppCreateError((void**)&m_err, e.what());\n        return *this;\n    }\n    mwException& operator=(const mwException& e)\n    {\n        if (m_err) {\n            ref_count_obj_release(m_err);\n        }\n        m_err = e.m_err;\n        if (m_err) {\n            ref_count_obj_addref(m_err);\n        }\n        return *this;\n    }\n    const char *what() const throw()\n    {\n        return (m_err ? error_info_get_message(m_err) : NULL);\n    }\n    static void raise_error()\n    {\n        error_info* pe = 0;\n        if (mclcppGetLastError((void**)&pe) == MCLCPP_ERR) {\n            throw mwException();\n        }\n        throw mwException(pe, false);\n    }\n    void print_stack_trace()\n    {\n        char** stack;\n        size_t stackDepth;\n\n        stackDepth = get_stack_trace(&stack);\n        if (stackDepth > 0) {\n            std::cerr << \"... Matlab M-code Stack Trace ...\" << std::endl;\n            for (size_t i=0; i<stackDepth; i++) {\n                std::cerr << stack[i] << std::endl;\n            }\n        }\n    }\n    static void check_raise_error()\n    {\n        if (!mclcppErrorCheck()) {\n            return;\n        }\n        mwException::raise_error();\n    }\n  protected:\n    error_info* m_err;\n\n  private:\n    size_t get_stack_trace(char*** stack)\n    {\n        return (m_err ? error_info_get_stack_trace(m_err, stack) : 0);\n    }\n};\n\n\n#endif\n\n\n\n\n#ifdef __cplusplus\n\ntemplate<typename T>\nclass mw_auto_ptr_t\n{\n  public:\n    mw_auto_ptr_t()\n    {\n        m_p = 0;\n    }\n    explicit mw_auto_ptr_t(T* p)\n    {\n        m_p = p;\n        addref();\n    }\n    mw_auto_ptr_t(T*p, bool bAddRef)\n    {\n        m_p = p;\n        if (bAddRef) {\n            addref();\n        }\n    }\n    virtual ~mw_auto_ptr_t()\n    {\n        if (m_p) {\n            ref_count_obj_release(m_p);\n        }\n    }\n    void addref()\n    {\n        if (m_p) {\n            ref_count_obj_addref(m_p);\n        }\n    }\n    void release()\n    {\n        if (m_p) {\n            ref_count_obj_release(m_p);\n            m_p = 0;\n        }\n    }\n    void attach(T* p, bool bAddRef)\n    {\n        release();\n        m_p = p;\n        if (bAddRef) {\n            addref();\n        }\n    }\n    T* detach()\n    {\n        T* p = m_p;\n        m_p = 0;\n        return p;\n    }\n    T* operator->(void) const\n    {\n        if (!m_p) {\n            throw mwException(\"Null pointer\");\n        }\n        return m_p;\n    }\n    T** operator&(void)\n    {\n        release();\n        return &m_p;\n    }\n    operator T*() const\n    {\n        return m_p;\n    }\n    mw_auto_ptr_t<T>& operator=(T* p)\n    {\n        release();\n        m_p = p;\n        addref();\n        return *this;\n    }\n    mw_auto_ptr_t<T>& operator=(const mw_auto_ptr_t<T>& ptr)\n    {\n        release();\n        m_p = ptr.m_p;\n        addref();\n        return *this;\n    }\n    bool operator!() const\n    {\n        return (m_p == 0);\n    }\n    operator bool() const\n    {\n        return (m_p != 0);\n    }\n    bool operator==(const mw_auto_ptr_t<T>& ptr)\n    {\n        return (m_p == (T*)ptr);\n    }\n    bool operator!=(const mw_auto_ptr_t<T>& ptr)\n    {\n        return (m_p != (T*)ptr);\n    }\n  protected:\n    T* m_p;\n};\n\n#endif /* ifdef  __cplusplus */\n\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclCreateCharBuffer(void** ppv, const char* str);\n\n\n\n#ifdef __cplusplus\n\n//#include <iostream>\n\n\nclass mwString\n{\n  public:\n    mwString()\n    {\n        if (mclCreateCharBuffer((void**)&m_str, \"\") == MCLCPP_ERR) {\n            mwException::raise_error();\n        }\n    }\n    mwString(const char* str)\n    {\n        if (mclCreateCharBuffer((void**)&m_str, str) == MCLCPP_ERR) {\n            mwException::raise_error();\n        }\n    }\n    mwString(char_buffer* buff, bool bAddref)\n    {\n        m_str.attach(buff, bAddref);\n    }\n    mwString(const mwString& str)\n    {\n        if (mclCreateCharBuffer((void**)&m_str, str) == MCLCPP_ERR) {\n            mwException::raise_error();\n        }\n        if (char_buffer_set_buffer(m_str, (const char*)str) == MCLCPP_ERR) {\n            mwException::raise_error();\n        }\n    }\n    virtual ~mwString() {}\n  public:\n    mwSize Length() const\n    {\n        return char_buffer_size(m_str);\n    }\n    operator const char* () const\n    {\n        return char_buffer_get_buffer(m_str);\n    }\n    mwString& operator=(const mwString& str)\n    {\n        if (&str == this) {\n            return *this;\n        }\n        if (char_buffer_set_buffer(m_str, (const char*)str) == MCLCPP_ERR) {\n            mwException::raise_error();\n        }\n        return *this;\n    }\n    mwString& operator=(const char* str)\n    {\n        if (char_buffer_set_buffer(m_str, str) == MCLCPP_ERR) {\n            mwException::raise_error();\n        }\n        return *this;\n    }\n    bool operator==(const mwString& str) const\n    {\n        return (char_buffer_compare_to(m_str, str.m_str) == 0);\n    }\n    bool operator!=(const mwString& str) const\n    {\n        return (char_buffer_compare_to(m_str, str.m_str) != 0);\n    }\n    bool operator<(const mwString& str) const\n    {\n        return (char_buffer_compare_to(m_str, str.m_str) < 0);\n    }\n    bool operator<=(const mwString& str) const\n    {\n        return (char_buffer_compare_to(m_str, str.m_str) <= 0);\n    }\n    bool operator>(const mwString& str) const\n    {\n        return (char_buffer_compare_to(m_str, str.m_str) > 0);\n    }\n    bool operator>=(const mwString& str) const\n    {\n        return (char_buffer_compare_to(m_str, str.m_str) >= 0);\n    }\n    friend std::ostream& operator<<(std::ostream& os, const mwString& str)\n    {\n        os << (const char*)str;\n        return os;\n    }\n  private:\n    mw_auto_ptr_t<char_buffer> m_str;\n};\n\n#endif\n\n\n\nLIBMWMCLMCR_API_EXTERN_C double mclGetEps(void);\n\n\nLIBMWMCLMCR_API_EXTERN_C double mclGetInf(void);\n\n\nLIBMWMCLMCR_API_EXTERN_C double mclGetNaN(void);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclIsFinite(double x);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclIsInf(double x);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclIsNaN(double x);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclIsIdentical(mxArray* pArray1, mxArray* pArray2);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetEmptyArray(void** ppv, mxClassID classid);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetMatrix(void** ppv, mwSize num_rows, mwSize num_cols, mxClassID classid, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetArray(void** ppv, mwSize num_dims, const mwSize* dims, mxClassID classid, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetNumericMatrix(void** ppv, mwSize num_rows, mwSize num_cols, mxClassID mxID, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetNumericArray(void** ppv, mwSize num_dims, const mwSize* dims, mxClassID mxID, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarDouble(void** ppv, mxDouble re, mxDouble im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarSingle(void** ppv, mxSingle re, mxSingle im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarInt8(void** ppv, mxInt8 re, mxInt8 im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarUint8(void** ppv, mxUint8 re, mxUint8 im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarInt16(void** ppv, mxInt16 re, mxInt16 im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarUint16(void** ppv, mxUint16 re, mxUint16 im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarInt32(void** ppv, mxInt32 re, mxInt32 im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarUint32(void** ppv, mxUint32 re, mxUint32 im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarInt64(void** ppv, mxInt64 re, mxInt64 im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarUint64(void** ppv, mxUint64 re, mxUint64 im, mxComplexity cmplx);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetCharMatrix(void** ppv, mwSize num_rows, mwSize num_cols);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetCharArray(void** ppv, mwSize num_dims, const mwSize* dims);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarChar(void** ppv, mxChar x);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetString(void** ppv, const char* str);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetCharMatrixFromStrings(void** ppv, mwSize m, const char** str);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclIsMatlabString(const mxArray* pa);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclIsMissingStringElement(const mxArray* pa, mwSize index);\n\n\nLIBMWMCLMCR_API_EXTERN_C mxArray* mclCreateMatlabString(mwSize m, const mxChar** strs);\n\n\nLIBMWMCLMCR_API_EXTERN_C mxArray *mclCreateMatlabStringArray(mwSize m, const mwSize* dims);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMatlabStringGetElement(const mxArray* src, mwSize index, const mxChar** str, mwSize* len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMatlabStringSetElement(mxArray* src, mwSize index, const mxChar* str);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMatlabStringGetData(const mxArray* src, const mxChar** data, mwSize* array_size, mwSize *data_size);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMatlabStringSetData(mxArray* src, const mxChar** data, mwSize array_size);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMatlabStringGetNumberOfDimensions(const mxArray* src, mwSize* num_dims);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMatlabStringGetDimensions(const mxArray* src, const mwSize** dims);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMatlabStringGetNumberOfElements(const mxArray* src, mwSize* num_elms);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetMatlabString(void** ppv, mwSize m, const mxChar** strs);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetMatlabStringArray(void** ppv, mwSize m, const mwSize* dims);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetLogicalMatrix(void** ppv, mwSize num_rows, mwSize num_cols);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetLogicalArray(void** ppv, mwSize num_dims, const mwSize* dims);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetScalarLogical(void** ppv, mxLogical x);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetCellMatrix(void** ppv, mwSize num_rows, mwSize num_cols);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetCellArray(void** ppv, mwSize num_dims, const mwSize* dims);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetStructMatrix(void** ppv, mwSize num_rows, mwSize num_cols, int nFields, const char** fieldnames);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetStructArray(void** ppv, mwSize num_dims, const mwSize* dims, int nFields, const char** fieldnames);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetNumericSparse(\n    void** ppv,\n    mwSize rowindex_size,\n    const mwSize* rowindex,\n    mwSize colindex_size,\n    const mwSize* colindex,\n    mwSize data_size,\n    const void* rData,\n    const void* iData,\n    mwSize num_rows,\n    mwSize num_cols,\n    mwSize nzmax,\n    mxClassID mxType,\n    mxComplexity cmplx\n    );\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetNumericSparseInferRowsCols(\n    void** ppv,\n    mwSize rowindex_size,\n    const mwSize* rowindex,\n    mwSize colindex_size,\n    const mwSize* colindex,\n    mwSize data_size,\n    const void* rData,\n    const void* iData,\n    mwSize nzmax,\n    mxClassID mxType,\n    mxComplexity cmplx\n    );\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetLogicalSparse(\n    void** ppv,\n    mwSize rowindex_size,\n    const mwIndex* rowindex,\n    mwSize colindex_size,\n    const mwIndex* colindex,\n    mwSize data_size,\n    const mxLogical* rData,\n    mwSize num_rows,\n    mwSize num_cols,\n    mwSize nzmax\n    );\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetLogicalSparseInferRowsCols(\n    void** ppv,\n    mwSize rowindex_size,\n    const mwIndex* rowindex,\n    mwSize colindex_size,\n    const mwIndex* colindex,\n    mwSize data_size,\n    const mxLogical* rData,\n    mwSize nzmax\n    );\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclDeserializeArray(void** ppv, void** ppa);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclcppGetArrayBuffer(void** ppv, mwSize size);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclcppFeval(HMCRINSTANCE inst, const char* name, int nargout, void** lhs, void* rhs);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclcppArrayToString(mxArray* parray, char** ppstr);\n\n\nLIBMWMCLMCR_API_EXTERN_C void mclcppFreeString(char* pstr);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclmxArray2ArrayHandle(void** pphArray, mxArray* pmxArray);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclArrayHandle2mxArray(mxArray** ppArrayImpl, void* phArray);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMXArrayGetIndexArrays(mxArray** ppRows, mxArray** ppColumns, mxArray* pSrcArray);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMXArrayGet(mxArray** ppSrcElem, mxArray* pSrcArray, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMXArrayGetReal(mxArray** ppSrcElem, mxArray* pSrcArray, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMXArrayGetImag(mxArray** ppSrcElem, mxArray* pSrcArray, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMXArraySet(mxArray* pTrgArray, mxArray* pSrcElem, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMXArraySetReal(mxArray* pTrgArray, mxArray* pSrcElem, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMXArraySetImag(mxArray* pTrgArray, mxArray* pSrcElem, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMXArraySetLogical(mxArray* pTrgArray, mxArray* pSrcElem, mwSize num_indices, const mwIndex* index);\n\nLIBMWMCLMCR_API_EXTERN_C void mclMxRefDestroyArray(mxArray* pa);\n\nLIBMWMCLMCR_API_EXTERN_C mxArray *mclMxRefSerialize(mxArray* pa);\n\nLIBMWMCLMCR_API_EXTERN_C mxArray *mclMxRefDeserialize(const void* pa,\n                                                      size_t len, size_t mvmNumber);\n\nLIBMWMCLMCR_API_EXTERN_C size_t mclMxRefMvmId(mxArray *pa);\n\nLIBMWMCLMCR_API_EXTERN_C size_t mclHashNBytes(size_t u, size_t n, const char * pb);\n\nLIBMWMCLMCR_API_EXTERN_C mwIndex mclCalcSingleSubscript(const mxArray *pa, mwSize num_dims, const mwIndex* index);\n\nLIBMWMCLMCR_API_EXTERN_C mxArray* mclCreateCharMatrixFromUTF16Strings(mwSize m, const mxChar** strs);\n\nLIBMWMCLMCR_API_EXTERN_C int mcl2DCharArrayToUTF16Strings(const mxArray* src, mxChar** data, mwSize* array_size);\n\n#include \"matrix.h\"\n\n\n#ifdef __cplusplus\n/* This public extern \"C\" API provides functions to create and manipulate\n * arrays. The API represents arrays as oqaque objects (void *'s, to be\n * precise).\n *\n * The MATLAB Compiler and related Builder products use this API to insulate\n * the generated code from changes in the underlying matrix data structure.\n */\n\n\n\n/* Opaque handle type definition. */\ntypedef void * array_handle;\n\n\nLIBMWMCLMCR_API_EXTERN_C mxClassID array_handle_classID(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_deep_copy(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C void array_handle_detach(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_shared_copy(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_serialize(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C size_t array_handle_element_size(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C mwSize array_handle_number_of_elements(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C mwSize array_handle_number_of_nonzeros(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C mwSize array_handle_maximum_nonzeros(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C mwSize array_handle_number_of_dimensions(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_get_dimensions(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_number_of_fields(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C char_buffer* array_handle_get_field_name(array_handle handle, int i);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_handle_is_empty(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_handle_is_sparse(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_handle_is_numeric(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_handle_is_complex(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_make_complex(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool array_handle_equals(array_handle handle, array_handle p);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_compare_to(array_handle handle, array_handle p);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_hash_code(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C char_buffer* array_handle_to_string(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_row_index(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_column_index(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_get_int(array_handle handle, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_get_const_char(array_handle handle, const char* name, mwSize num_indices, const mwIndex* index);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_getV_int(array_handle handle, mwSize num_indices, va_list vargs);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_getV_const_char(array_handle handle, const char* name, mwSize num_indices, va_list vargs);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set(array_handle handle, array_handle p);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_real(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C array_handle array_handle_imag(array_handle handle);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxDouble(array_handle handle, mxDouble* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxSingle(array_handle handle, mxSingle* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxInt8(array_handle handle, mxInt8* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxUint8(array_handle handle, mxUint8* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxInt16(array_handle handle, mxInt16* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxUint16(array_handle handle, mxUint16* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxInt32(array_handle handle, mxInt32* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxUint32(array_handle handle, mxUint32* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxInt64(array_handle handle, mxInt64* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_numeric_mxUint64(array_handle handle, mxUint64* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_char(array_handle handle, mxChar* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_get_logical(array_handle handle, mxLogical* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxDouble(array_handle handle, const mxDouble* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxSingle(array_handle handle, const mxSingle* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxInt8(array_handle handle, const mxInt8* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxUint8(array_handle handle, const mxUint8* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxInt16(array_handle handle, const mxInt16* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxUint16(array_handle handle, const mxUint16* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxInt32(array_handle handle, const mxInt32* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxUint32(array_handle handle, const mxUint32* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxInt64(array_handle handle, const mxInt64* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_numeric_mxUint64(array_handle handle, const mxUint64* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_char(array_handle handle, const mxChar* x, mwSize len);\n\n\nLIBMWMCLMCR_API_EXTERN_C int array_handle_set_logical(array_handle handle, const mxLogical* x, mwSize len);\n\n\n#endif /* #ifdef __cplusplus */\n\n\n#include <stdarg.h>\n#include <string.h>\n#include <wchar.h>\n\n\n#ifdef __cplusplus\nclass MclMcr {};\n#endif\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclWrite(int fd, const void *ptr, size_t count);\n\n\n\n/* define MW_CALL_CONV to __cdecl if building on windows */\n#ifndef MW_CALL_CONV\n#if defined( _MSC_VER) || defined(__BORLANDC__) || defined(__WATCOMC__) || defined(__LCC__)\n#define MW_CALL_CONV __cdecl\n#else\n#define MW_CALL_CONV\n#endif /* using some PC compiler */\n#endif /* MW_CALL_CONV */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    typedef void (*mclErrorCallbackFcnPtr)(void);\n#ifdef __cplusplus\n}\n#endif\n\n\nLIBMWMCLMCR_API_EXTERN_C void mclAddCanonicalPathMacro(const char* macro, const char* expansion);\n\nLIBMWMCLMCR_API_EXTERN_C bool mclFeval(HMCRINSTANCE inst, const char* name, int nlhs, mxArray** plhs, int nrhs, mxArray** prhs);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclGetMaxPathLen(void);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclmcrInitialize2(int primaryMode);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclmcrInitialize(void);\n\n\n\n/*\n * in LCC, int32_t is defined as a long since it does not\n * contain a definition for __int32, this is MSVC specific.\n */\n#ifdef _WIN32\n#ifdef __LCC__\ntypedef long int32_t;\n#else\ntypedef __int32 int32_t;\n#endif\n#endif\n\n#define MAX_FIELD_NAME_SIZE 1024\n\ntypedef struct _wcsStackPointer\n{\n    CHAR16_T * hPtr;\n    CHAR16_T   sPtr[MAX_FIELD_NAME_SIZE];\n    int32_t buffLen;\n} *pwcsStackPointer;\n\n\nLIBMWMCLMCR_API_EXTERN_C void deleteWcsStackPointer_hPtr(pwcsStackPointer ptr);\n\n\nLIBMWMCLMCR_API_EXTERN_C void initializeWcsStackPointer(pwcsStackPointer *ptr);\n\n\nLIBMWMCLMCR_API_EXTERN_C void deleteWcsStackPointer(pwcsStackPointer ptr);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool allocWcsStackPointer(pwcsStackPointer *ptr, int newLen);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mwMbstowcs(pwcsStackPointer sp, const char *sourceString);\n\n\nLIBMWMCLMCR_API_EXTERN_C void utf16_to_lcp_n_fcn(char * target, int32_t * targetSize,\n                                                 CHAR16_T const * source, int32_t sourceSize);\n\n\nLIBMWMCLMCR_API_EXTERN_C int32_t utf16_strlen_fcn(CHAR16_T const * s);\n\n\nLIBMWMCLMCR_API_EXTERN_C CHAR16_T * utf16_strncpy_fcn(CHAR16_T * dst, CHAR16_T const * src, int32_t n);\n\n\nLIBMWMCLMCR_API_EXTERN_C CHAR16_T * utf16_strdup_fcn(const CHAR16_T * sl);\n\n\n\n/* PATH_MAX is the maximum number of characters that can appear in a full\n * path specification. Define it, if it isn't already defined.\n */\n\n#if !defined(PATH_MAX) || (defined(PATH_MAX) && PATH_MAX<1024)\n#undef PATH_MAX\n\n/* _WIN32 is always defined, for both Win32 and Win64 platforms */\n#ifdef _WIN32\n#ifdef _MAX_PATH\n#define PATH_MAX _MAX_PATH\n#endif\n#endif\n\n/* Windows platforms on which _MAX_PATH is not defined, and all UNIX\n * platforms that don't define PATH_MAX. (Most UNIX platforms should\n * define PATH_MAX in <limits.h>)\n */\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n\n#endif\n\nLIBMWMCLMCR_API_EXTERN_C bool mclFeval(HMCRINSTANCE inst, const char* name, int nlhs, mxArray** plhs, int nrhs, mxArray** prhs);\n\nLIBMWMCLMCR_API_EXTERN_C bool mclSetGlobal(HMCRINSTANCE inst, const char* name, mxArray* px);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclIsStandaloneMode();\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclImpersonationFeval(HMCRINSTANCE inst, const char* name, int nlhs, mxArray** plhs, int nrhs, mxArray** prhs, void* impersonationToken);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclFeval(HMCRINSTANCE inst, const char* name, int nlhs, mxArray** plhs, int nrhs, mxArray** prhs);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclGetGlobal(HMCRINSTANCE inst, const char* name, mxArray** ppx);\n\n\nLIBMWMCLMCR_API_EXTERN_C long mclGetID(HMCRINSTANCE inst);\n\n\nLIBMWMCLMCR_API_EXTERN_C int mclMain(HMCRINSTANCE inst, int argc, const char* argv[],\n                                     const char* name, int nlhs);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclMlfVFeval(HMCRINSTANCE inst, const char* name, int nargout, int fnout, int fnin, va_list ap);\n\n\ntypedef void (*mclEventFunctionPtr)(void * context, int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclSetGlobal(HMCRINSTANCE inst, const char* name, mxArray* px);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclGetMCRVersion(const char **version);\n\n\nLIBMWMCLMCR_API_EXTERN_C size_t mclGetActiveID(void);\n\n\ntypedef int (*mclOutputFcnCpp)(const char *);\n\n\nLIBMWMCLMCR_API_EXTERN_C char* mclGetTempFileName(char* tempFileName);\n\n\nLIBMWMCLMCR_API_EXTERN_C bool mclTerminateInstance(HMCRINSTANCE* inst);\n\nLIBMWMCLMCR_API_EXTERN_C void stopImpersonationOnMCRThread(HMCRINSTANCE inst);\n\nLIBMWMCLMCR_API_EXTERN_C bool mclMxIsA(HMCRINSTANCE inst, mxArray* pa, const char *cname);\n\nLIBMWMCLMCR_API_EXTERN_C bool mclMxIsRef(mxArray* pa);\n\nLIBMWMCLMCR_API_EXTERN_C bool mclMxRefIsA(mxArray* pa,\n                                          const char *cname);\n\nLIBMWMCLMCR_API_EXTERN_C const char* mclMxRefGetRefClassName(const mxArray *pa);\n\nLIBMWMCLMCR_API_EXTERN_C \nmxArray *mclMxRefGetProperty(const mxArray *obj, mwIndex index,\n                             const char *propName);\n\nLIBMWMCLMCR_API_EXTERN_C \nvoid mclMxRefSetProperty(mxArray *obj, mwIndex index,\n                         const char *propName, const mxArray *propValue);\n\nLIBMWMCLMCR_API_EXTERN_C mxArray* mclMxReleaseRef(mxArray * pa);\n\nLIBMWMCLMCR_API_EXTERN_C MVMID_t mclMxRefLocalMvm(mxArray *pa);\n\nLIBMWMCLMCR_API_EXTERN_C void mclMxDestroyArray(HMCRINSTANCE inst, mxArray* pa );\n\nLIBMWMCLMCR_API_EXTERN_C void mclNonDefaultAppDomainInUse();\n\nLIBMWMCLMCR_API_EXTERN_C bool mclIsNonDefaultAppDomainInUse();\n\n#endif /* mclmcr_published_api_hpp */\n"},{"name":"mclmcrrt.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * @(#)mclmcrrt.h\n *\n *\t\t\t\tapiproxy.published\n *\t\t\t\tlibmat_proxy.cpp\n *\t\t\t\tlibmwmclbase_proxy.cpp\n *\t\t\t\tlibmwmclmcr_proxy.cpp\n *\t\t\t\tlibmx_proxy.cpp\n */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef mclmcrrt_h\n#define mclmcrrt_h\n\n\n/*\n * Copyright 1984-2021 The MathWorks, Inc.\n */\n\n\n\n/* Copyright 2003-2006 The MathWorks, Inc. */\n\n/* Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n\n#ifdef __cplusplus\n  #define EXTERN_C extern \"C\"\n#else\n  #define EXTERN_C extern\n#endif\n\n#endif\n\n\n\n#ifdef __LCC__\n/* Must undefine EXTERN_C here (and redefine it later) because LCC's version\n * of windows.h has its own definition of EXTERN_C.\n */\n#undef EXTERN_C\n#endif\n\n#ifdef _WIN32\n#include <windows.h>\n#endif\n\n#ifdef __LCC__\n#undef EXTERN_C\n#define EXTERN_C extern\n#endif\n\n#ifndef _WIN32\ntypedef const struct _GUID *REFCLSID, *REFGUID;\ntypedef long HRESULT;\n#endif\n\n\n\n#  if defined( linux ) || defined( __linux ) || defined( __linux__ )\n/* stdint.h must be included before sys/types.h or loadlibrary will fail.\n * Because matrix.h includes stdlib.h, which includes sys/types.h, stdint.h\n * must be included before any include of matrix.h (On Linux systems.)\n */\n#include <stdint.h> \n#endif\n\n/*#ifdef matrix_h\n#error \"mclmcrrt.h must be included before matrix.h. (Since mclmcrrt.h includes matrix.h, additional inclusion is redundant.)\"\n#endif */\n#include \"matrix.h\"\n\n#undef mclmcrInitialize2\n#define mclmcrInitialize2 mclmcrInitialize2_proxy\n\n\n#undef mclmcrInitialize\n#define mclmcrInitialize mclmcrInitialize_proxy\n\n\n#undef mclInitializeApplication\n#if !defined(TARGET_API_VERSION) || TARGET_API_VERSION >= 800\n#define mclInitializeApplication mclInitializeApplication_800_proxy\n#else\n#define mclInitializeApplication mclInitializeApplication_730_proxy\n#endif   /* !defined(TARGET_API_VERSION) || TARGET_API_VERSION >= 800 */\n\n\n#undef mclDisplayStartMessage\n#define mclDisplayStartMessage mclDisplayStartMessage_proxy\n\n\ntypedef void * MCREventHandlerArg;\ntypedef void (*MCREventHandlerFcn)(MCREventHandlerArg);\ntypedef enum\n{   MCRStartEvent,\n    MCRCompleteEvent\n} mcrInitializationEventType;\ntypedef void * MCREventData;\n\nEXTERN_C void mclDisplayStartMessage_proxy(mcrInitializationEventType eventType,MCREventHandlerFcn fcn,MCREventHandlerArg arg,MCREventData eventData);\n\n\n#undef mclGetComponentInfo\n#define mclGetComponentInfo mclGetComponentInfo_proxy\nEXTERN_C HRESULT mclGetComponentInfo_proxy(const char* lpszComponent, \n                                                      int nMajorRev, \n                                                      int nMinorRev, int nInfo, \n                                                      int nType, \n                                                      void** info);\n\n\n#undef mclGetLIBIDInfo\n#define mclGetLIBIDInfo mclGetLIBIDInfo_proxy\nEXTERN_C HRESULT mclGetLIBIDInfo_proxy(const char* lpszLIBID, \n                                                  int nMajorRev, int nMinorRev, \n                                                  int nInfo, void** info);\n\n\n#undef mclRegisterServer\n#define mclRegisterServer mclRegisterServer_proxy\nEXTERN_C HRESULT mclRegisterServer_proxy(const char* szModuleName,     \n                                                    REFCLSID clsid,               \n                                                    REFGUID libid,                \n                                                    unsigned short wMajorRev,     \n                                                    unsigned short wMinorRev,     \n                                                    const char* szFriendlyName,   \n                                                    const char* szVerIndProgID,   \n                                                    const char* szProgID,         \n                                                    const char* szThreadingModel);\n\n\n#undef mclGUIDFromString\n#define mclGUIDFromString mclGUIDFromString_proxy\nEXTERN_C int mclGUIDFromString_proxy(const char* lpszGUID, struct _GUID* pguid);\n\n\n#undef mclUnRegisterMatLabCOMComponent\n#define mclUnRegisterMatLabCOMComponent mclUnRegisterMatLabCOMComponent_proxy\nEXTERN_C HRESULT mclUnRegisterMatLabCOMComponent_proxy(REFCLSID clsid,            \n                                       const char* szVerIndProgID, \n                                       const char* szProgID);\n\n\n#undef mclRegisterMatLabXLComponent\n#define mclRegisterMatLabXLComponent mclRegisterMatLabXLComponent_proxy\nEXTERN_C HRESULT mclRegisterMatLabXLComponent_proxy(const char* szModuleName,    \n                                    REFCLSID clsid,               \n                                    REFGUID libid,                \n                                    unsigned short wMajorRev,     \n                                    unsigned short wMinorRev,     \n                                    const char* szFriendlyName,   \n                                    const char* szVerIndProgID,   \n                                    const char* szProgID);\n\n\n#undef mclGUIDtochar\n#define mclGUIDtochar mclGUIDtochar_proxy\nEXTERN_C void mclGUIDtochar_proxy(REFGUID guid, char* szGUID, int length);\n\n\n#undef mclUnregisterServer\n#define mclUnregisterServer mclUnregisterServer_proxy\nEXTERN_C HRESULT mclUnregisterServer_proxy(REFCLSID clsid,             \n                           const char* szVerIndProgID, \n                           const char* szProgID);\n\n\n#undef mclCLSIDtochar\n#define mclCLSIDtochar mclCLSIDtochar_proxy\nEXTERN_C void mclCLSIDtochar_proxy(REFCLSID clsid, char* szCLSID, int length);\n\n\n#undef mclFreeComponentInfo\n#define mclFreeComponentInfo mclFreeComponentInfo_proxy\nEXTERN_C void mclFreeComponentInfo_proxy(void** info);\n\n\n#undef mclUnRegisterMatLabXLComponent\n#define mclUnRegisterMatLabXLComponent mclUnRegisterMatLabXLComponent_proxy\nEXTERN_C HRESULT mclUnRegisterMatLabXLComponent_proxy(REFCLSID clsid,             \n                                      const char* szVerIndProgID, \n                                      const char* szProgID);\n\n\n#undef mclRegisterMatLabCOMComponent\n#define mclRegisterMatLabCOMComponent mclRegisterMatLabCOMComponent_proxy\nEXTERN_C HRESULT mclRegisterMatLabCOMComponent_proxy(const char* szModuleName,     \n                                     REFCLSID clsid,               \n                                     REFGUID libid,                \n                                     unsigned short wMajorRev,     \n                                     unsigned short wMinorRev,     \n                                     const char* szFriendlyName,   \n                                     const char* szVerIndProgID,   \n                                     const char* szProgID);\n\n#ifndef MW_CALL_CONV\n#  ifdef _WIN32 \n#      define MW_CALL_CONV __cdecl\n#  else\n#      define MW_CALL_CONV \n#  endif\n#endif\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matOpen\n#define matOpen matOpen_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matClose\n#define matClose matClose_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matGetErrno\n#define matGetErrno matGetErrno_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matGetFp\n#define matGetFp matGetFp_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matPutVariable\n#define matPutVariable matPutVariable_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matPutVariableAsGlobal\n#define matPutVariableAsGlobal matPutVariableAsGlobal_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matGetVariable\n#define matGetVariable matGetVariable_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matGetNextVariable\n#define matGetNextVariable matGetNextVariable_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matGetNextVariableInfo\n#define matGetNextVariableInfo matGetNextVariableInfo_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matGetVariableInfo\n#define matGetVariableInfo matGetVariableInfo_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matDeleteVariable\n#define matDeleteVariable matDeleteVariable_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef matGetDir\n#define matGetDir matGetDir_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matOpen_800\n#define matOpen_800 matOpen_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matClose_800\n#define matClose_800 matClose_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matGetErrno_800\n#define matGetErrno_800 matGetErrno_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matGetFp_800\n#define matGetFp_800 matGetFp_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matPutVariable_800\n#define matPutVariable_800 matPutVariable_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matPutVariableAsGlobal_800\n#define matPutVariableAsGlobal_800 matPutVariableAsGlobal_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matGetVariable_800\n#define matGetVariable_800 matGetVariable_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matGetNextVariable_800\n#define matGetNextVariable_800 matGetNextVariable_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matGetNextVariableInfo_800\n#define matGetNextVariableInfo_800 matGetNextVariableInfo_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matGetVariableInfo_800\n#define matGetVariableInfo_800 matGetVariableInfo_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matDeleteVariable_800\n#define matDeleteVariable_800 matDeleteVariable_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef matGetDir_800\n#define matGetDir_800 matGetDir_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n\n/*#ifdef mat_h\n#error \"mclmcrrt.h must be included before mat.h. (Since mclmcrrt.h includes mat.h, additional inclusion is redundant.)\"\n#endif */\n#define LIBMWMAT_API_EXTERN_C EXTERN_C\n#include \"mat.h\"\n\n/* Proxies for functions in mat.h */\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nMATFile * matOpen_proxy(const char *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmatError matClose_proxy(MATFile *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmatError matGetErrno_proxy(MATFile *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nFILE * matGetFp_proxy(MATFile *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmatError matPutVariable_proxy(MATFile *a0, const char *a1, \n    const mxArray *a2);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmatError matPutVariableAsGlobal_proxy(MATFile *a0, const char *a1, \n    const mxArray *a2);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * matGetVariable_proxy(MATFile *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * matGetNextVariable_proxy(MATFile *a0, const char **a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * matGetNextVariableInfo_proxy(MATFile *a0, const char **a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * matGetVariableInfo_proxy(MATFile *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmatError matDeleteVariable_proxy(MATFile *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nchar ** matGetDir_proxy(MATFile *a0, int *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nMATFile * matOpen_800_proxy(const char *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmatError matClose_800_proxy(MATFile *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmatError matGetErrno_800_proxy(MATFile *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nFILE * matGetFp_800_proxy(MATFile *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmatError matPutVariable_800_proxy(MATFile *a0, const char *a1, \n    const mxArray *a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmatError matPutVariableAsGlobal_800_proxy(MATFile *a0, const char *a1, \n    const mxArray *a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * matGetVariable_800_proxy(MATFile *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * matGetNextVariable_800_proxy(MATFile *a0, const char **a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * matGetNextVariableInfo_800_proxy(MATFile *a0, const char **a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * matGetVariableInfo_800_proxy(MATFile *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmatError matDeleteVariable_800_proxy(MATFile *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nchar ** matGetDir_800_proxy(MATFile *a0, int *a1);\n#endif\n\n\n\n#ifndef MW_CALL_CONV\n#  ifdef _WIN32 \n#      define MW_CALL_CONV __cdecl\n#  else\n#      define MW_CALL_CONV \n#  endif\n#endif\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclSetLastErrIdAndMsg\n#define mclSetLastErrIdAndMsg mclSetLastErrIdAndMsg_proxy\n\n\n\n/* Map original name to unique proxy layer name. */\n#undef mclGetLastErrorMessage\n#define mclGetLastErrorMessage mclGetLastErrorMessage_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetStackTrace\n#define mclGetStackTrace mclGetStackTrace_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclFreeStackTrace\n#define mclFreeStackTrace mclFreeStackTrace_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetLastExceptionType\n#define mclGetLastExceptionType mclGetLastExceptionType_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclAcquireMutex\n#define mclAcquireMutex mclAcquireMutex_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclReleaseMutex\n#define mclReleaseMutex mclReleaseMutex_proxy\n\n\n\n/* Map original name to unique proxy layer name. */\n#undef mclIsMCRInitialized\n#define mclIsMCRInitialized mclIsMCRInitialized_proxy\n\n\n\n/* Map original name to unique proxy layer name. */\n#undef mclIsJVMEnabled\n#define mclIsJVMEnabled mclIsJVMEnabled_proxy\n\n\n\n/* Map original name to unique proxy layer name. */\n#undef mclGetLogFileName\n#define mclGetLogFileName mclGetLogFileName_proxy\n\n\n\n/* Map original name to unique proxy layer name. */\n#undef mclIsNoDisplaySet\n#define mclIsNoDisplaySet mclIsNoDisplaySet_proxy\n\n\n\n/* Map original name to unique proxy layer name. */\n#undef mclInitializeApplicationInternal\n#define mclInitializeApplicationInternal mclInitializeApplicationInternal_proxy\n\n\n\n/* Map original name to unique proxy layer name. */\n#undef mclTerminateApplication\n#define mclTerminateApplication mclTerminateApplication_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsMcc\n#define mclIsMcc mclIsMcc_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef separatePathName\n#define separatePathName separatePathName_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclFreeStrArray\n#define mclFreeStrArray mclFreeStrArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclFreeArrayList\n#define mclFreeArrayList mclFreeArrayList_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCreateCellArrayFromArrayList\n#define mclCreateCellArrayFromArrayList mclCreateCellArrayFromArrayList_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCreateSharedCopy\n#define mclCreateSharedCopy mclCreateSharedCopy_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCreateEmptyArray\n#define mclCreateEmptyArray mclCreateEmptyArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCreateSimpleFunctionHandle\n#define mclCreateSimpleFunctionHandle mclCreateSimpleFunctionHandle_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxSerialize\n#define mclMxSerialize mclMxSerialize_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxDeserialize\n#define mclMxDeserialize mclMxDeserialize_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclSetInterleavedCompatibility\n#define mclSetInterleavedCompatibility mclSetInterleavedCompatibility_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsInterleavedCompatibility\n#define mclIsInterleavedCompatibility mclIsInterleavedCompatibility_proxy\n\n\n\n/* Map original name to unique proxy layer name. */\n#undef mclRunMain\n#define mclRunMain mclRunMain_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCFRunLoopRun\n#define mclCFRunLoopRun mclCFRunLoopRun_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCFRunLoopStop\n#define mclCFRunLoopStop mclCFRunLoopStop_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsCFRunLoopReady\n#define mclIsCFRunLoopReady mclIsCFRunLoopReady_proxy\n\n\n\n\n/*#ifdef mclbase_h\n#error \"mclmcrrt.h must be included before mclbase.h. (Since mclmcrrt.h includes mclbase.h, additional inclusion is redundant.)\"\n#endif */\n#define LIBMWMCLBASE_API_EXTERN_C EXTERN_C\n#include \"mclbase.h\"\n\n/* Proxies for functions in mclbase.h */\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclSetLastErrIdAndMsg_proxy(const char *a0, const char *a1);\n\nEXTERN_C\nconst char * mclGetLastErrorMessage_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetStackTrace_proxy(char ***a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclFreeStackTrace_proxy(char ***a0, int a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetLastExceptionType_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclAcquireMutex_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclReleaseMutex_proxy();\n\nEXTERN_C\nbool mclIsMCRInitialized_proxy();\n\nEXTERN_C\nbool mclIsJVMEnabled_proxy();\n\nEXTERN_C\nconst char * mclGetLogFileName_proxy();\n\nEXTERN_C\nbool mclIsNoDisplaySet_proxy();\n\nEXTERN_C\nbool mclInitializeApplicationInternal_proxy(const char **a0, size_t a1);\n\nEXTERN_C\nbool mclTerminateApplication_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsMcc_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid separatePathName_proxy(const char *a0, char *a1, size_t a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclFreeStrArray_proxy(char **a0, size_t a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclFreeArrayList_proxy(int a0, mxArray **a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclCreateCellArrayFromArrayList_proxy(int a0, mxArray **a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclCreateSharedCopy_proxy(mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclCreateEmptyArray_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclCreateSimpleFunctionHandle_proxy(mxFunctionPtr a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclMxSerialize_proxy(mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclMxDeserialize_proxy(const void *a0, size_t a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclSetInterleavedCompatibility_proxy(bool a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsInterleavedCompatibility_proxy();\n\nEXTERN_C\nint mclRunMain_proxy(mclMainFcnType a0, int a1, const char **a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclCFRunLoopRun_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclCFRunLoopStop_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsCFRunLoopReady_proxy();\n\n\n\n#ifndef MW_CALL_CONV\n#  ifdef _WIN32 \n#      define MW_CALL_CONV __cdecl\n#  else\n#      define MW_CALL_CONV \n#  endif\n#endif\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetStreamFromArraySrc\n#define mclGetStreamFromArraySrc mclGetStreamFromArraySrc_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclDestroyStream\n#define mclDestroyStream mclDestroyStream_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetEmbeddedCtfStream\n#define mclGetEmbeddedCtfStream mclGetEmbeddedCtfStream_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclInitializeComponentInstanceNonEmbeddedStandalone\n#define mclInitializeComponentInstanceNonEmbeddedStandalone mclInitializeComponentInstanceNonEmbeddedStandalone_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclInitializeInstanceWithoutComponent\n#define mclInitializeInstanceWithoutComponent mclInitializeInstanceWithoutComponent_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclInitializeComponentInstanceCtfFileToCache\n#define mclInitializeComponentInstanceCtfFileToCache mclInitializeComponentInstanceCtfFileToCache_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclInitializeComponentInstanceEmbedded\n#define mclInitializeComponentInstanceEmbedded mclInitializeComponentInstanceEmbedded_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclInitializeComponentInstanceWithCallbk\n#define mclInitializeComponentInstanceWithCallbk mclInitializeComponentInstanceWithCallbk_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclInitializeComponentInstanceFromExtractedComponent\n#define mclInitializeComponentInstanceFromExtractedComponent mclInitializeComponentInstanceFromExtractedComponent_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclInitializeComponentInstanceFromExtractedLocation\n#define mclInitializeComponentInstanceFromExtractedLocation mclInitializeComponentInstanceFromExtractedLocation_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetDotNetComponentType\n#define mclGetDotNetComponentType mclGetDotNetComponentType_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetMCCTargetType\n#define mclGetMCCTargetType mclGetMCCTargetType_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef getStandaloneFileName\n#define getStandaloneFileName getStandaloneFileName_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclStandaloneGenericMain\n#define mclStandaloneGenericMain mclStandaloneGenericMain_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclStandaloneCtfxMain\n#define mclStandaloneCtfxMain mclStandaloneCtfxMain_proxy\n\n\n\n/* Map original name to unique proxy layer name. */\n#undef mclWaitForFiguresToDie\n#define mclWaitForFiguresToDie mclWaitForFiguresToDie_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclcppGetLastError\n#define mclcppGetLastError mclcppGetLastError_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclcppCreateError\n#define mclcppCreateError mclcppCreateError_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclcppSetLastError\n#define mclcppSetLastError mclcppSetLastError_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclcppErrorCheck\n#define mclcppErrorCheck mclcppErrorCheck_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclcppGetLastErrorMessage\n#define mclcppGetLastErrorMessage mclcppGetLastErrorMessage_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCreateCharBuffer\n#define mclCreateCharBuffer mclCreateCharBuffer_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetEps\n#define mclGetEps mclGetEps_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetInf\n#define mclGetInf mclGetInf_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetNaN\n#define mclGetNaN mclGetNaN_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsFinite\n#define mclIsFinite mclIsFinite_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsInf\n#define mclIsInf mclIsInf_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsNaN\n#define mclIsNaN mclIsNaN_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsIdentical\n#define mclIsIdentical mclIsIdentical_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetEmptyArray\n#define mclGetEmptyArray mclGetEmptyArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetMatrix\n#define mclGetMatrix mclGetMatrix_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetArray\n#define mclGetArray mclGetArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetNumericMatrix\n#define mclGetNumericMatrix mclGetNumericMatrix_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetNumericArray\n#define mclGetNumericArray mclGetNumericArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarDouble\n#define mclGetScalarDouble mclGetScalarDouble_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarSingle\n#define mclGetScalarSingle mclGetScalarSingle_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarInt8\n#define mclGetScalarInt8 mclGetScalarInt8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarUint8\n#define mclGetScalarUint8 mclGetScalarUint8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarInt16\n#define mclGetScalarInt16 mclGetScalarInt16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarUint16\n#define mclGetScalarUint16 mclGetScalarUint16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarInt32\n#define mclGetScalarInt32 mclGetScalarInt32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarUint32\n#define mclGetScalarUint32 mclGetScalarUint32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarInt64\n#define mclGetScalarInt64 mclGetScalarInt64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarUint64\n#define mclGetScalarUint64 mclGetScalarUint64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetCharMatrix\n#define mclGetCharMatrix mclGetCharMatrix_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetCharArray\n#define mclGetCharArray mclGetCharArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarChar\n#define mclGetScalarChar mclGetScalarChar_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetString\n#define mclGetString mclGetString_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetCharMatrixFromStrings\n#define mclGetCharMatrixFromStrings mclGetCharMatrixFromStrings_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsMatlabString\n#define mclIsMatlabString mclIsMatlabString_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsMissingStringElement\n#define mclIsMissingStringElement mclIsMissingStringElement_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCreateMatlabString\n#define mclCreateMatlabString mclCreateMatlabString_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCreateMatlabStringArray\n#define mclCreateMatlabStringArray mclCreateMatlabStringArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMatlabStringGetElement\n#define mclMatlabStringGetElement mclMatlabStringGetElement_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMatlabStringSetElement\n#define mclMatlabStringSetElement mclMatlabStringSetElement_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMatlabStringGetData\n#define mclMatlabStringGetData mclMatlabStringGetData_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMatlabStringSetData\n#define mclMatlabStringSetData mclMatlabStringSetData_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMatlabStringGetNumberOfDimensions\n#define mclMatlabStringGetNumberOfDimensions mclMatlabStringGetNumberOfDimensions_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMatlabStringGetDimensions\n#define mclMatlabStringGetDimensions mclMatlabStringGetDimensions_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMatlabStringGetNumberOfElements\n#define mclMatlabStringGetNumberOfElements mclMatlabStringGetNumberOfElements_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetMatlabString\n#define mclGetMatlabString mclGetMatlabString_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetMatlabStringArray\n#define mclGetMatlabStringArray mclGetMatlabStringArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetLogicalMatrix\n#define mclGetLogicalMatrix mclGetLogicalMatrix_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetLogicalArray\n#define mclGetLogicalArray mclGetLogicalArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetScalarLogical\n#define mclGetScalarLogical mclGetScalarLogical_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetCellMatrix\n#define mclGetCellMatrix mclGetCellMatrix_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetCellArray\n#define mclGetCellArray mclGetCellArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetStructMatrix\n#define mclGetStructMatrix mclGetStructMatrix_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetStructArray\n#define mclGetStructArray mclGetStructArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetNumericSparse\n#define mclGetNumericSparse mclGetNumericSparse_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetNumericSparseInferRowsCols\n#define mclGetNumericSparseInferRowsCols mclGetNumericSparseInferRowsCols_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetLogicalSparse\n#define mclGetLogicalSparse mclGetLogicalSparse_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetLogicalSparseInferRowsCols\n#define mclGetLogicalSparseInferRowsCols mclGetLogicalSparseInferRowsCols_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclDeserializeArray\n#define mclDeserializeArray mclDeserializeArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclcppGetArrayBuffer\n#define mclcppGetArrayBuffer mclcppGetArrayBuffer_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclcppFeval\n#define mclcppFeval mclcppFeval_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclcppArrayToString\n#define mclcppArrayToString mclcppArrayToString_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclcppFreeString\n#define mclcppFreeString mclcppFreeString_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclmxArray2ArrayHandle\n#define mclmxArray2ArrayHandle mclmxArray2ArrayHandle_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclArrayHandle2mxArray\n#define mclArrayHandle2mxArray mclArrayHandle2mxArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMXArrayGetIndexArrays\n#define mclMXArrayGetIndexArrays mclMXArrayGetIndexArrays_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMXArrayGet\n#define mclMXArrayGet mclMXArrayGet_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMXArrayGetReal\n#define mclMXArrayGetReal mclMXArrayGetReal_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMXArrayGetImag\n#define mclMXArrayGetImag mclMXArrayGetImag_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMXArraySet\n#define mclMXArraySet mclMXArraySet_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMXArraySetReal\n#define mclMXArraySetReal mclMXArraySetReal_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMXArraySetImag\n#define mclMXArraySetImag mclMXArraySetImag_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMXArraySetLogical\n#define mclMXArraySetLogical mclMXArraySetLogical_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxRefDestroyArray\n#define mclMxRefDestroyArray mclMxRefDestroyArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxRefSerialize\n#define mclMxRefSerialize mclMxRefSerialize_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxRefDeserialize\n#define mclMxRefDeserialize mclMxRefDeserialize_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxRefMvmId\n#define mclMxRefMvmId mclMxRefMvmId_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclHashNBytes\n#define mclHashNBytes mclHashNBytes_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCalcSingleSubscript\n#define mclCalcSingleSubscript mclCalcSingleSubscript_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclCreateCharMatrixFromUTF16Strings\n#define mclCreateCharMatrixFromUTF16Strings mclCreateCharMatrixFromUTF16Strings_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mcl2DCharArrayToUTF16Strings\n#define mcl2DCharArrayToUTF16Strings mcl2DCharArrayToUTF16Strings_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclWrite\n#define mclWrite mclWrite_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclAddCanonicalPathMacro\n#define mclAddCanonicalPathMacro mclAddCanonicalPathMacro_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclFevalInternal\n#define mclFevalInternal mclFevalInternal_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetMaxPathLen\n#define mclGetMaxPathLen mclGetMaxPathLen_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclmcrInitializeInternal2\n#define mclmcrInitializeInternal2 mclmcrInitializeInternal2_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclmcrInitializeInternal\n#define mclmcrInitializeInternal mclmcrInitializeInternal_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef deleteWcsStackPointer_hPtr\n#define deleteWcsStackPointer_hPtr deleteWcsStackPointer_hPtr_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef initializeWcsStackPointer\n#define initializeWcsStackPointer initializeWcsStackPointer_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef deleteWcsStackPointer\n#define deleteWcsStackPointer deleteWcsStackPointer_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef allocWcsStackPointer\n#define allocWcsStackPointer allocWcsStackPointer_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mwMbstowcs\n#define mwMbstowcs mwMbstowcs_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef utf16_to_lcp_n_fcn\n#define utf16_to_lcp_n_fcn utf16_to_lcp_n_fcn_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef utf16_strlen_fcn\n#define utf16_strlen_fcn utf16_strlen_fcn_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef utf16_strncpy_fcn\n#define utf16_strncpy_fcn utf16_strncpy_fcn_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef utf16_strdup_fcn\n#define utf16_strdup_fcn utf16_strdup_fcn_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclSetGlobal\n#define mclSetGlobal mclSetGlobal_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsStandaloneMode\n#define mclIsStandaloneMode mclIsStandaloneMode_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclImpersonationFeval\n#define mclImpersonationFeval mclImpersonationFeval_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetGlobal\n#define mclGetGlobal mclGetGlobal_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetID\n#define mclGetID mclGetID_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMain\n#define mclMain mclMain_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMlfVFevalInternal\n#define mclMlfVFevalInternal mclMlfVFevalInternal_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetMCRVersion\n#define mclGetMCRVersion mclGetMCRVersion_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetActiveID\n#define mclGetActiveID mclGetActiveID_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclGetTempFileName\n#define mclGetTempFileName mclGetTempFileName_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclTerminateInstance\n#define mclTerminateInstance mclTerminateInstance_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef stopImpersonationOnMCRThread\n#define stopImpersonationOnMCRThread stopImpersonationOnMCRThread_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxIsA\n#define mclMxIsA mclMxIsA_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxIsRef\n#define mclMxIsRef mclMxIsRef_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxRefIsA\n#define mclMxRefIsA mclMxRefIsA_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxRefGetRefClassName\n#define mclMxRefGetRefClassName mclMxRefGetRefClassName_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxRefGetProperty\n#define mclMxRefGetProperty mclMxRefGetProperty_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxRefSetProperty\n#define mclMxRefSetProperty mclMxRefSetProperty_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxReleaseRef\n#define mclMxReleaseRef mclMxReleaseRef_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxRefLocalMvm\n#define mclMxRefLocalMvm mclMxRefLocalMvm_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclMxDestroyArray\n#define mclMxDestroyArray mclMxDestroyArray_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclNonDefaultAppDomainInUse\n#define mclNonDefaultAppDomainInUse mclNonDefaultAppDomainInUse_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef mclIsNonDefaultAppDomainInUse\n#define mclIsNonDefaultAppDomainInUse mclIsNonDefaultAppDomainInUse_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef ref_count_obj_addref\n#define ref_count_obj_addref ref_count_obj_addref_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef ref_count_obj_release\n#define ref_count_obj_release ref_count_obj_release_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef char_buffer_size\n#define char_buffer_size char_buffer_size_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef char_buffer_get_buffer\n#define char_buffer_get_buffer char_buffer_get_buffer_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef char_buffer_set_buffer\n#define char_buffer_set_buffer char_buffer_set_buffer_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef char_buffer_compare_to\n#define char_buffer_compare_to char_buffer_compare_to_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_classID\n#define array_ref_classID array_ref_classID_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_deep_copy\n#define array_ref_deep_copy array_ref_deep_copy_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_detach\n#define array_ref_detach array_ref_detach_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_shared_copy\n#define array_ref_shared_copy array_ref_shared_copy_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_serialize\n#define array_ref_serialize array_ref_serialize_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_element_size\n#define array_ref_element_size array_ref_element_size_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_number_of_elements\n#define array_ref_number_of_elements array_ref_number_of_elements_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_number_of_nonzeros\n#define array_ref_number_of_nonzeros array_ref_number_of_nonzeros_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_maximum_nonzeros\n#define array_ref_maximum_nonzeros array_ref_maximum_nonzeros_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_number_of_dimensions\n#define array_ref_number_of_dimensions array_ref_number_of_dimensions_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_dimensions\n#define array_ref_get_dimensions array_ref_get_dimensions_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_number_of_fields\n#define array_ref_number_of_fields array_ref_number_of_fields_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_field_name\n#define array_ref_get_field_name array_ref_get_field_name_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_is_empty\n#define array_ref_is_empty array_ref_is_empty_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_is_sparse\n#define array_ref_is_sparse array_ref_is_sparse_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_is_numeric\n#define array_ref_is_numeric array_ref_is_numeric_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_is_complex\n#define array_ref_is_complex array_ref_is_complex_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_is_matlab_string\n#define array_ref_is_matlab_string array_ref_is_matlab_string_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_is_missing_string_element\n#define array_ref_is_missing_string_element array_ref_is_missing_string_element_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_make_complex\n#define array_ref_make_complex array_ref_make_complex_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_equals\n#define array_ref_equals array_ref_equals_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_compare_to\n#define array_ref_compare_to array_ref_compare_to_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_hash_code\n#define array_ref_hash_code array_ref_hash_code_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_to_string\n#define array_ref_to_string array_ref_to_string_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_row_index\n#define array_ref_row_index array_ref_row_index_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_column_index\n#define array_ref_column_index array_ref_column_index_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_int\n#define array_ref_get_int array_ref_get_int_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_const_char\n#define array_ref_get_const_char array_ref_get_const_char_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_getV_int\n#define array_ref_getV_int array_ref_getV_int_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_getV_const_char\n#define array_ref_getV_const_char array_ref_getV_const_char_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set\n#define array_ref_set array_ref_set_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_real\n#define array_ref_real array_ref_real_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_imag\n#define array_ref_imag array_ref_imag_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxDouble\n#define array_ref_get_numeric_mxDouble array_ref_get_numeric_mxDouble_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxSingle\n#define array_ref_get_numeric_mxSingle array_ref_get_numeric_mxSingle_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxInt8\n#define array_ref_get_numeric_mxInt8 array_ref_get_numeric_mxInt8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxUint8\n#define array_ref_get_numeric_mxUint8 array_ref_get_numeric_mxUint8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxInt16\n#define array_ref_get_numeric_mxInt16 array_ref_get_numeric_mxInt16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxUint16\n#define array_ref_get_numeric_mxUint16 array_ref_get_numeric_mxUint16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxInt32\n#define array_ref_get_numeric_mxInt32 array_ref_get_numeric_mxInt32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxUint32\n#define array_ref_get_numeric_mxUint32 array_ref_get_numeric_mxUint32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxInt64\n#define array_ref_get_numeric_mxInt64 array_ref_get_numeric_mxInt64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_numeric_mxUint64\n#define array_ref_get_numeric_mxUint64 array_ref_get_numeric_mxUint64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_char\n#define array_ref_get_char array_ref_get_char_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_string_element\n#define array_ref_get_string_element array_ref_get_string_element_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_matlab_string\n#define array_ref_get_matlab_string array_ref_get_matlab_string_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_get_logical\n#define array_ref_get_logical array_ref_get_logical_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxDouble\n#define array_ref_set_numeric_mxDouble array_ref_set_numeric_mxDouble_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxSingle\n#define array_ref_set_numeric_mxSingle array_ref_set_numeric_mxSingle_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxInt8\n#define array_ref_set_numeric_mxInt8 array_ref_set_numeric_mxInt8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxUint8\n#define array_ref_set_numeric_mxUint8 array_ref_set_numeric_mxUint8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxInt16\n#define array_ref_set_numeric_mxInt16 array_ref_set_numeric_mxInt16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxUint16\n#define array_ref_set_numeric_mxUint16 array_ref_set_numeric_mxUint16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxInt32\n#define array_ref_set_numeric_mxInt32 array_ref_set_numeric_mxInt32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxUint32\n#define array_ref_set_numeric_mxUint32 array_ref_set_numeric_mxUint32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxInt64\n#define array_ref_set_numeric_mxInt64 array_ref_set_numeric_mxInt64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_numeric_mxUint64\n#define array_ref_set_numeric_mxUint64 array_ref_set_numeric_mxUint64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_char\n#define array_ref_set_char array_ref_set_char_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_string_element\n#define array_ref_set_string_element array_ref_set_string_element_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_matlab_string\n#define array_ref_set_matlab_string array_ref_set_matlab_string_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_ref_set_logical\n#define array_ref_set_logical array_ref_set_logical_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_buffer_size\n#define array_buffer_size array_buffer_size_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_buffer_get\n#define array_buffer_get array_buffer_get_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_buffer_set\n#define array_buffer_set array_buffer_set_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_buffer_add\n#define array_buffer_add array_buffer_add_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_buffer_remove\n#define array_buffer_remove array_buffer_remove_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_buffer_clear\n#define array_buffer_clear array_buffer_clear_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_buffer_to_cell\n#define array_buffer_to_cell array_buffer_to_cell_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef error_info_get_message\n#define error_info_get_message error_info_get_message_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef error_info_get_stack_trace\n#define error_info_get_stack_trace error_info_get_stack_trace_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_classID\n#define array_handle_classID array_handle_classID_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_deep_copy\n#define array_handle_deep_copy array_handle_deep_copy_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_detach\n#define array_handle_detach array_handle_detach_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_shared_copy\n#define array_handle_shared_copy array_handle_shared_copy_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_serialize\n#define array_handle_serialize array_handle_serialize_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_element_size\n#define array_handle_element_size array_handle_element_size_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_number_of_elements\n#define array_handle_number_of_elements array_handle_number_of_elements_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_number_of_nonzeros\n#define array_handle_number_of_nonzeros array_handle_number_of_nonzeros_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_maximum_nonzeros\n#define array_handle_maximum_nonzeros array_handle_maximum_nonzeros_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_number_of_dimensions\n#define array_handle_number_of_dimensions array_handle_number_of_dimensions_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_dimensions\n#define array_handle_get_dimensions array_handle_get_dimensions_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_number_of_fields\n#define array_handle_number_of_fields array_handle_number_of_fields_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_field_name\n#define array_handle_get_field_name array_handle_get_field_name_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_is_empty\n#define array_handle_is_empty array_handle_is_empty_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_is_sparse\n#define array_handle_is_sparse array_handle_is_sparse_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_is_numeric\n#define array_handle_is_numeric array_handle_is_numeric_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_is_complex\n#define array_handle_is_complex array_handle_is_complex_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_make_complex\n#define array_handle_make_complex array_handle_make_complex_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_equals\n#define array_handle_equals array_handle_equals_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_compare_to\n#define array_handle_compare_to array_handle_compare_to_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_hash_code\n#define array_handle_hash_code array_handle_hash_code_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_to_string\n#define array_handle_to_string array_handle_to_string_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_row_index\n#define array_handle_row_index array_handle_row_index_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_column_index\n#define array_handle_column_index array_handle_column_index_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_int\n#define array_handle_get_int array_handle_get_int_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_const_char\n#define array_handle_get_const_char array_handle_get_const_char_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_getV_int\n#define array_handle_getV_int array_handle_getV_int_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_getV_const_char\n#define array_handle_getV_const_char array_handle_getV_const_char_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set\n#define array_handle_set array_handle_set_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_real\n#define array_handle_real array_handle_real_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_imag\n#define array_handle_imag array_handle_imag_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxDouble\n#define array_handle_get_numeric_mxDouble array_handle_get_numeric_mxDouble_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxSingle\n#define array_handle_get_numeric_mxSingle array_handle_get_numeric_mxSingle_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxInt8\n#define array_handle_get_numeric_mxInt8 array_handle_get_numeric_mxInt8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxUint8\n#define array_handle_get_numeric_mxUint8 array_handle_get_numeric_mxUint8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxInt16\n#define array_handle_get_numeric_mxInt16 array_handle_get_numeric_mxInt16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxUint16\n#define array_handle_get_numeric_mxUint16 array_handle_get_numeric_mxUint16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxInt32\n#define array_handle_get_numeric_mxInt32 array_handle_get_numeric_mxInt32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxUint32\n#define array_handle_get_numeric_mxUint32 array_handle_get_numeric_mxUint32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxInt64\n#define array_handle_get_numeric_mxInt64 array_handle_get_numeric_mxInt64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_numeric_mxUint64\n#define array_handle_get_numeric_mxUint64 array_handle_get_numeric_mxUint64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_char\n#define array_handle_get_char array_handle_get_char_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_get_logical\n#define array_handle_get_logical array_handle_get_logical_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxDouble\n#define array_handle_set_numeric_mxDouble array_handle_set_numeric_mxDouble_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxSingle\n#define array_handle_set_numeric_mxSingle array_handle_set_numeric_mxSingle_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxInt8\n#define array_handle_set_numeric_mxInt8 array_handle_set_numeric_mxInt8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxUint8\n#define array_handle_set_numeric_mxUint8 array_handle_set_numeric_mxUint8_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxInt16\n#define array_handle_set_numeric_mxInt16 array_handle_set_numeric_mxInt16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxUint16\n#define array_handle_set_numeric_mxUint16 array_handle_set_numeric_mxUint16_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxInt32\n#define array_handle_set_numeric_mxInt32 array_handle_set_numeric_mxInt32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxUint32\n#define array_handle_set_numeric_mxUint32 array_handle_set_numeric_mxUint32_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxInt64\n#define array_handle_set_numeric_mxInt64 array_handle_set_numeric_mxInt64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_numeric_mxUint64\n#define array_handle_set_numeric_mxUint64 array_handle_set_numeric_mxUint64_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_char\n#define array_handle_set_char array_handle_set_char_proxy\n\n\n\n/**This function is for INTERNAL USE ONLY.**/\n/* Map original name to unique proxy layer name. */\n#undef array_handle_set_logical\n#define array_handle_set_logical array_handle_set_logical_proxy\n\n\n\n\n/*#ifdef mclmcr_h\n#error \"mclmcrrt.h must be included before mclmcr.h. (Since mclmcrrt.h includes mclmcr.h, additional inclusion is redundant.)\"\n#endif */\n#define LIBMWMCLMCR_API_EXTERN_C EXTERN_C\n#include \"mclmcr.h\"\n\n/* Proxies for functions in mclmcr.h */\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmclCtfStream mclGetStreamFromArraySrc_proxy(char *a0, int a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclDestroyStream_proxy(mclCtfStream a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmclCtfStream mclGetEmbeddedCtfStream_proxy(void *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclInitializeComponentInstanceNonEmbeddedStandalone_proxy(\n    HMCRINSTANCE *a0, const char *a1, const char *a2, mccTargetType a3, \n    mclOutputHandlerFcn a4, mclOutputHandlerFcn a5);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclInitializeInstanceWithoutComponent_proxy(HMCRINSTANCE *a0, \n    const char **a1, size_t a2, mclOutputHandlerFcn a3, \n    mclOutputHandlerFcn a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclInitializeComponentInstanceCtfFileToCache_proxy(HMCRINSTANCE *a0, \n    mclOutputHandlerFcn a1, mclOutputHandlerFcn a2, const char *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclInitializeComponentInstanceEmbedded_proxy(HMCRINSTANCE *a0, \n    mclOutputHandlerFcn a1, mclOutputHandlerFcn a2, mclCtfStream a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclInitializeComponentInstanceWithCallbk_proxy(HMCRINSTANCE *a0, \n    mclOutputHandlerFcn a1, mclOutputHandlerFcn a2, \n    mclReadCtfStreamFcn a3, size_t a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclInitializeComponentInstanceFromExtractedComponent_proxy(\n    HMCRINSTANCE *a0, mclOutputHandlerFcn a1, mclOutputHandlerFcn a2, \n    const char *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclInitializeComponentInstanceFromExtractedLocation_proxy(\n    HMCRINSTANCE *a0, mclOutputHandlerFcn a1, mclOutputHandlerFcn a2, \n    const char *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetDotNetComponentType_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetMCCTargetType_proxy(bool a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nconst char * getStandaloneFileName_proxy(const char *a0, const char *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclStandaloneGenericMain_proxy(size_t a0, const char **a1, \n    const char *a2, bool a3, void *a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclStandaloneCtfxMain_proxy(size_t a0, const char **a1);\n\nEXTERN_C\nvoid mclWaitForFiguresToDie_proxy(HMCRINSTANCE a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclcppGetLastError_proxy(void **a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclcppCreateError_proxy(void **a0, const char *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclcppSetLastError_proxy(const char *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclcppErrorCheck_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nconst char * mclcppGetLastErrorMessage_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclCreateCharBuffer_proxy(void **a0, const char *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\ndouble mclGetEps_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\ndouble mclGetInf_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\ndouble mclGetNaN_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsFinite_proxy(double a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsInf_proxy(double a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsNaN_proxy(double a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsIdentical_proxy(mxArray *a0, mxArray *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetEmptyArray_proxy(void **a0, mxClassID a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetMatrix_proxy(void **a0, mwSize a1, mwSize a2, mxClassID a3, \n    mxComplexity a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetArray_proxy(void **a0, mwSize a1, const mwSize *a2, \n    mxClassID a3, mxComplexity a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetNumericMatrix_proxy(void **a0, mwSize a1, mwSize a2, \n    mxClassID a3, mxComplexity a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetNumericArray_proxy(void **a0, mwSize a1, const mwSize *a2, \n    mxClassID a3, mxComplexity a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarDouble_proxy(void **a0, mxDouble a1, mxDouble a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarSingle_proxy(void **a0, mxSingle a1, mxSingle a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarInt8_proxy(void **a0, mxInt8 a1, mxInt8 a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarUint8_proxy(void **a0, mxUint8 a1, mxUint8 a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarInt16_proxy(void **a0, mxInt16 a1, mxInt16 a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarUint16_proxy(void **a0, mxUint16 a1, mxUint16 a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarInt32_proxy(void **a0, mxInt32 a1, mxInt32 a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarUint32_proxy(void **a0, mxUint32 a1, mxUint32 a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarInt64_proxy(void **a0, mxInt64 a1, mxInt64 a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarUint64_proxy(void **a0, mxUint64 a1, mxUint64 a2, \n    mxComplexity a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetCharMatrix_proxy(void **a0, mwSize a1, mwSize a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetCharArray_proxy(void **a0, mwSize a1, const mwSize *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarChar_proxy(void **a0, mxChar a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetString_proxy(void **a0, const char *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetCharMatrixFromStrings_proxy(void **a0, mwSize a1, \n    const char **a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsMatlabString_proxy(const mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsMissingStringElement_proxy(const mxArray *a0, mwSize a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclCreateMatlabString_proxy(mwSize a0, const mxChar **a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclCreateMatlabStringArray_proxy(mwSize a0, const mwSize *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMatlabStringGetElement_proxy(const mxArray *a0, mwSize a1, \n    const mxChar **a2, mwSize *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMatlabStringSetElement_proxy(mxArray *a0, mwSize a1, \n    const mxChar *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMatlabStringGetData_proxy(const mxArray *a0, const mxChar **a1, \n    mwSize *a2, mwSize *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMatlabStringSetData_proxy(mxArray *a0, const mxChar **a1, \n    mwSize a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMatlabStringGetNumberOfDimensions_proxy(const mxArray *a0, \n    mwSize *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMatlabStringGetDimensions_proxy(const mxArray *a0, \n    const mwSize **a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMatlabStringGetNumberOfElements_proxy(const mxArray *a0, \n    mwSize *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetMatlabString_proxy(void **a0, mwSize a1, const mxChar **a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetMatlabStringArray_proxy(void **a0, mwSize a1, const mwSize *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetLogicalMatrix_proxy(void **a0, mwSize a1, mwSize a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetLogicalArray_proxy(void **a0, mwSize a1, const mwSize *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetScalarLogical_proxy(void **a0, mxLogical a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetCellMatrix_proxy(void **a0, mwSize a1, mwSize a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetCellArray_proxy(void **a0, mwSize a1, const mwSize *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetStructMatrix_proxy(void **a0, mwSize a1, mwSize a2, int a3, \n    const char **a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetStructArray_proxy(void **a0, mwSize a1, const mwSize *a2, \n    int a3, const char **a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetNumericSparse_proxy(void **a0, mwSize a1, const mwSize *a2, \n    mwSize a3, const mwSize *a4, mwSize a5, const void *a6, \n    const void *a7, mwSize a8, mwSize a9, mwSize a10, mxClassID a11, \n    mxComplexity a12);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetNumericSparseInferRowsCols_proxy(void **a0, mwSize a1, \n    const mwSize *a2, mwSize a3, const mwSize *a4, mwSize a5, \n    const void *a6, const void *a7, mwSize a8, mxClassID a9, \n    mxComplexity a10);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetLogicalSparse_proxy(void **a0, mwSize a1, const mwIndex *a2, \n    mwSize a3, const mwIndex *a4, mwSize a5, const mxLogical *a6, \n    mwSize a7, mwSize a8, mwSize a9);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetLogicalSparseInferRowsCols_proxy(void **a0, mwSize a1, \n    const mwIndex *a2, mwSize a3, const mwIndex *a4, mwSize a5, \n    const mxLogical *a6, mwSize a7);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclDeserializeArray_proxy(void **a0, void **a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclcppGetArrayBuffer_proxy(void **a0, mwSize a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclcppFeval_proxy(HMCRINSTANCE a0, const char *a1, int a2, void **a3, \n    void *a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclcppArrayToString_proxy(mxArray *a0, char **a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclcppFreeString_proxy(char *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclmxArray2ArrayHandle_proxy(void **a0, mxArray *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclArrayHandle2mxArray_proxy(mxArray **a0, void *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMXArrayGetIndexArrays_proxy(mxArray **a0, mxArray **a1, \n    mxArray *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMXArrayGet_proxy(mxArray **a0, mxArray *a1, mwSize a2, \n    const mwIndex *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMXArrayGetReal_proxy(mxArray **a0, mxArray *a1, mwSize a2, \n    const mwIndex *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMXArrayGetImag_proxy(mxArray **a0, mxArray *a1, mwSize a2, \n    const mwIndex *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMXArraySet_proxy(mxArray *a0, mxArray *a1, mwSize a2, \n    const mwIndex *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMXArraySetReal_proxy(mxArray *a0, mxArray *a1, mwSize a2, \n    const mwIndex *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMXArraySetImag_proxy(mxArray *a0, mxArray *a1, mwSize a2, \n    const mwIndex *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMXArraySetLogical_proxy(mxArray *a0, mxArray *a1, mwSize a2, \n    const mwIndex *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclMxRefDestroyArray_proxy(mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclMxRefSerialize_proxy(mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclMxRefDeserialize_proxy(const void *a0, size_t a1, size_t a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nsize_t mclMxRefMvmId_proxy(mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nsize_t mclHashNBytes_proxy(size_t a0, size_t a1, const char *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwIndex mclCalcSingleSubscript_proxy(const mxArray *a0, mwSize a1, \n    const mwIndex *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclCreateCharMatrixFromUTF16Strings_proxy(mwSize a0, \n    const mxChar **a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mcl2DCharArrayToUTF16Strings_proxy(const mxArray *a0, mxChar **a1, \n    mwSize *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclWrite_proxy(int a0, const void *a1, size_t a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclAddCanonicalPathMacro_proxy(const char *a0, const char *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclFevalInternal_proxy(HMCRINSTANCE a0, const char *a1, int a2, \n    mxArray **a3, int a4, mxArray **a5);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclGetMaxPathLen_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclmcrInitializeInternal2_proxy(int a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclmcrInitializeInternal_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid deleteWcsStackPointer_hPtr_proxy(pwcsStackPointer a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid initializeWcsStackPointer_proxy(pwcsStackPointer *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid deleteWcsStackPointer_proxy(pwcsStackPointer a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool allocWcsStackPointer_proxy(pwcsStackPointer *a0, int a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mwMbstowcs_proxy(pwcsStackPointer a0, const char *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid utf16_to_lcp_n_fcn_proxy(char *a0, int32_t *a1, const CHAR16_T *a2, \n    int32_t a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint32_t utf16_strlen_fcn_proxy(const CHAR16_T *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nCHAR16_T * utf16_strncpy_fcn_proxy(CHAR16_T *a0, const CHAR16_T *a1, \n    int32_t a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nCHAR16_T * utf16_strdup_fcn_proxy(const CHAR16_T *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclSetGlobal_proxy(HMCRINSTANCE a0, const char *a1, mxArray *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsStandaloneMode_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclImpersonationFeval_proxy(HMCRINSTANCE a0, const char *a1, int a2, \n    mxArray **a3, int a4, mxArray **a5, void *a6);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclGetGlobal_proxy(HMCRINSTANCE a0, const char *a1, mxArray **a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nlong int mclGetID_proxy(HMCRINSTANCE a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint mclMain_proxy(HMCRINSTANCE a0, int a1, const char **a2, \n    const char *a3, int a4);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclMlfVFevalInternal_proxy(HMCRINSTANCE a0, const char *a1, int a2, \n    int a3, int a4, va_list a5);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclGetMCRVersion_proxy(const char **a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nsize_t mclGetActiveID_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nchar * mclGetTempFileName_proxy(char *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclTerminateInstance_proxy(HMCRINSTANCE *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid stopImpersonationOnMCRThread_proxy(HMCRINSTANCE a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclMxIsA_proxy(HMCRINSTANCE a0, mxArray *a1, const char *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclMxIsRef_proxy(mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclMxRefIsA_proxy(mxArray *a0, const char *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nconst char * mclMxRefGetRefClassName_proxy(const mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclMxRefGetProperty_proxy(const mxArray *a0, mwIndex a1, \n    const char *a2);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclMxRefSetProperty_proxy(mxArray *a0, mwIndex a1, const char *a2, \n    const mxArray *a3);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxArray * mclMxReleaseRef_proxy(mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nMVMID_t mclMxRefLocalMvm_proxy(mxArray *a0);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclMxDestroyArray_proxy(HMCRINSTANCE a0, mxArray *a1);\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid mclNonDefaultAppDomainInUse_proxy();\n\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool mclIsNonDefaultAppDomainInUse_proxy();\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint ref_count_obj_addref_proxy(class ref_count_obj *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint ref_count_obj_release_proxy(class ref_count_obj *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nsize_t char_buffer_size_proxy(class char_buffer *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nconst char * char_buffer_get_buffer_proxy(class char_buffer *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint char_buffer_set_buffer_proxy(class char_buffer *a0, const char *a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint char_buffer_compare_to_proxy(class char_buffer *a0, \n    class char_buffer *a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxClassID array_ref_classID_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_deep_copy_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid array_ref_detach_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_shared_copy_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_serialize_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nsize_t array_ref_element_size_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwSize array_ref_number_of_elements_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwSize array_ref_number_of_nonzeros_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwSize array_ref_maximum_nonzeros_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwSize array_ref_number_of_dimensions_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_get_dimensions_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_number_of_fields_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass char_buffer * array_ref_get_field_name_proxy(class array_ref *a0, \n    int a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_ref_is_empty_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_ref_is_sparse_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_ref_is_numeric_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_ref_is_complex_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_ref_is_matlab_string_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_ref_is_missing_string_element_proxy(class array_ref *a0, \n    mwSize a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_make_complex_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_ref_equals_proxy(class array_ref *a0, class array_ref *a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_compare_to_proxy(class array_ref *a0, class array_ref *a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_hash_code_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass char_buffer * array_ref_to_string_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_row_index_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_column_index_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_get_int_proxy(class array_ref *a0, mwSize a1, \n    const mwIndex *a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_get_const_char_proxy(class array_ref *a0, \n    const char *a1, mwSize a2, const mwIndex *a3);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_getV_int_proxy(class array_ref *a0, \n    mwSize a1, va_list a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_getV_const_char_proxy(class array_ref *a0, \n    const char *a1, mwSize a2, va_list a3);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_proxy(class array_ref *a0, class array_ref *a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_real_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_ref_imag_proxy(class array_ref *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxDouble_proxy(class array_ref *a0, \n    mxDouble *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxSingle_proxy(class array_ref *a0, \n    mxSingle *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxInt8_proxy(class array_ref *a0, mxInt8 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxUint8_proxy(class array_ref *a0, mxUint8 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxInt16_proxy(class array_ref *a0, mxInt16 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxUint16_proxy(class array_ref *a0, \n    mxUint16 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxInt32_proxy(class array_ref *a0, mxInt32 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxUint32_proxy(class array_ref *a0, \n    mxUint32 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxInt64_proxy(class array_ref *a0, mxInt64 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_numeric_mxUint64_proxy(class array_ref *a0, \n    mxUint64 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_char_proxy(class array_ref *a0, mxChar *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_string_element_proxy(class array_ref *a0, mwSize a1, \n    const mxChar **a2, mwSize *a3);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_matlab_string_proxy(class array_ref *a0, \n    const mxChar **a1, mwSize *a2, mwSize *a3);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_get_logical_proxy(class array_ref *a0, mxLogical *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxDouble_proxy(class array_ref *a0, \n    const mxDouble *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxSingle_proxy(class array_ref *a0, \n    const mxSingle *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxInt8_proxy(class array_ref *a0, \n    const mxInt8 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxUint8_proxy(class array_ref *a0, \n    const mxUint8 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxInt16_proxy(class array_ref *a0, \n    const mxInt16 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxUint16_proxy(class array_ref *a0, \n    const mxUint16 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxInt32_proxy(class array_ref *a0, \n    const mxInt32 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxUint32_proxy(class array_ref *a0, \n    const mxUint32 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxInt64_proxy(class array_ref *a0, \n    const mxInt64 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_numeric_mxUint64_proxy(class array_ref *a0, \n    const mxUint64 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_char_proxy(class array_ref *a0, const mxChar *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_string_element_proxy(class array_ref *a0, mwSize a1, \n    const mxChar *a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_matlab_string_proxy(class array_ref *a0, \n    const mxChar **a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_ref_set_logical_proxy(class array_ref *a0, const mxLogical *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwSize array_buffer_size_proxy(class array_buffer *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_buffer_get_proxy(class array_buffer *a0, \n    mwIndex a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_buffer_set_proxy(class array_buffer *a0, mwIndex a1, \n    class array_ref *a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_buffer_add_proxy(class array_buffer *a0, class array_ref *a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_buffer_remove_proxy(class array_buffer *a0, mwIndex a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_buffer_clear_proxy(class array_buffer *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass array_ref * array_buffer_to_cell_proxy(class array_buffer *a0, \n    mwIndex a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nconst char * error_info_get_message_proxy(class error_info *a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nsize_t error_info_get_stack_trace_proxy(class error_info *a0, char ***a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmxClassID array_handle_classID_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_deep_copy_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nvoid array_handle_detach_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_shared_copy_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_serialize_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nsize_t array_handle_element_size_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwSize array_handle_number_of_elements_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwSize array_handle_number_of_nonzeros_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwSize array_handle_maximum_nonzeros_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nmwSize array_handle_number_of_dimensions_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_get_dimensions_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_number_of_fields_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass char_buffer * array_handle_get_field_name_proxy(array_handle a0, \n    int a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_handle_is_empty_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_handle_is_sparse_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_handle_is_numeric_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_handle_is_complex_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_make_complex_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nbool array_handle_equals_proxy(array_handle a0, array_handle a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_compare_to_proxy(array_handle a0, array_handle a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_hash_code_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nclass char_buffer * array_handle_to_string_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_row_index_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_column_index_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_get_int_proxy(array_handle a0, mwSize a1, \n    const mwIndex *a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_get_const_char_proxy(array_handle a0, \n    const char *a1, mwSize a2, const mwIndex *a3);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_getV_int_proxy(array_handle a0, mwSize a1, \n    va_list a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_getV_const_char_proxy(array_handle a0, \n    const char *a1, mwSize a2, va_list a3);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_proxy(array_handle a0, array_handle a1);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_real_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\narray_handle array_handle_imag_proxy(array_handle a0);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxDouble_proxy(array_handle a0, \n    mxDouble *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxSingle_proxy(array_handle a0, \n    mxSingle *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxInt8_proxy(array_handle a0, mxInt8 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxUint8_proxy(array_handle a0, mxUint8 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxInt16_proxy(array_handle a0, mxInt16 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxUint16_proxy(array_handle a0, \n    mxUint16 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxInt32_proxy(array_handle a0, mxInt32 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxUint32_proxy(array_handle a0, \n    mxUint32 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxInt64_proxy(array_handle a0, mxInt64 *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_numeric_mxUint64_proxy(array_handle a0, \n    mxUint64 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_char_proxy(array_handle a0, mxChar *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_get_logical_proxy(array_handle a0, mxLogical *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxDouble_proxy(array_handle a0, \n    const mxDouble *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxSingle_proxy(array_handle a0, \n    const mxSingle *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxInt8_proxy(array_handle a0, \n    const mxInt8 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxUint8_proxy(array_handle a0, \n    const mxUint8 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxInt16_proxy(array_handle a0, \n    const mxInt16 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxUint16_proxy(array_handle a0, \n    const mxUint16 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxInt32_proxy(array_handle a0, \n    const mxInt32 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxUint32_proxy(array_handle a0, \n    const mxUint32 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxInt64_proxy(array_handle a0, \n    const mxInt64 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_numeric_mxUint64_proxy(array_handle a0, \n    const mxUint64 *a1, mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_char_proxy(array_handle a0, const mxChar *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n#ifdef __cplusplus /* Only available in C++ */\n/**This function is for INTERNAL USE ONLY.**/\nEXTERN_C\nint array_handle_set_logical_proxy(array_handle a0, const mxLogical *a1, \n    mwSize a2);\n#endif /* __cplusplus */\n\n\n#if !defined(MW_BUILD_ARCHIVES)\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n\n#undef mclMlfVFeval\n#define mclMlfVFeval mclMlfVFeval_proxy\n\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n\n#if !defined(MW_BUILD_ARCHIVES)\n#undef mclFeval\n#define mclFeval mclFeval_proxy\n#endif\n\n\nEXTERN_C\nbool MW_CALL_CONV mclFeval_proxy(HMCRINSTANCE a0, const char *a1, int a2,\n                                 mxArray **a3, int a4, mxArray **a5);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n\n#if !defined(MW_BUILD_ARCHIVES)\n#undef mclMlfFeval\n#define mclMlfFeval mclMlfFeval_proxy\n#endif\n\n\nEXTERN_C\nbool MW_CALL_CONV mclMlfFeval_proxy(HMCRINSTANCE a0, const char *a1,\n\t\t  \t            int a2, int a3, int a4, ...);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#ifndef MW_CALL_CONV\n#  ifdef _WIN32 \n#      define MW_CALL_CONV __cdecl\n#  else\n#      define MW_CALL_CONV \n#  endif\n#endif\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetNumberOfDimensions_700\n#define mxGetNumberOfDimensions_700 mxGetNumberOfDimensions_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetDimensions_700\n#define mxGetDimensions_700 mxGetDimensions_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetIr_700\n#define mxGetIr_700 mxGetIr_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetJc_700\n#define mxGetJc_700 mxGetJc_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetNzmax_700\n#define mxGetNzmax_700 mxGetNzmax_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxSetNzmax_700\n#define mxSetNzmax_700 mxSetNzmax_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetFieldByNumber_700\n#define mxGetFieldByNumber_700 mxGetFieldByNumber_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetCell_700\n#define mxGetCell_700 mxGetCell_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxSetM_700\n#define mxSetM_700 mxSetM_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxSetIr_700\n#define mxSetIr_700 mxSetIr_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxSetJc_700\n#define mxSetJc_700 mxSetJc_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCalcSingleSubscript_700\n#define mxCalcSingleSubscript_700 mxCalcSingleSubscript_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxSetCell_700\n#define mxSetCell_700 mxSetCell_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxSetFieldByNumber_700\n#define mxSetFieldByNumber_700 mxSetFieldByNumber_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetField_700\n#define mxGetField_700 mxGetField_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxSetField_700\n#define mxSetField_700 mxSetField_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateNumericMatrix_700\n#define mxCreateNumericMatrix_700 mxCreateNumericMatrix_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxSetN_700\n#define mxSetN_700 mxSetN_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxSetDimensions_700\n#define mxSetDimensions_700 mxSetDimensions_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateNumericArray_700\n#define mxCreateNumericArray_700 mxCreateNumericArray_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCharArray_700\n#define mxCreateCharArray_700 mxCreateCharArray_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateDoubleMatrix_700\n#define mxCreateDoubleMatrix_700 mxCreateDoubleMatrix_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateLogicalArray_700\n#define mxCreateLogicalArray_700 mxCreateLogicalArray_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateLogicalMatrix_700\n#define mxCreateLogicalMatrix_700 mxCreateLogicalMatrix_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateSparse_700\n#define mxCreateSparse_700 mxCreateSparse_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateSparseLogicalMatrix_700\n#define mxCreateSparseLogicalMatrix_700 mxCreateSparseLogicalMatrix_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetNChars_700\n#define mxGetNChars_700 mxGetNChars_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxGetString_700\n#define mxGetString_700 mxGetString_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateStringFromNChars_700\n#define mxCreateStringFromNChars_700 mxCreateStringFromNChars_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCharMatrixFromStrings_700\n#define mxCreateCharMatrixFromStrings_700 mxCreateCharMatrixFromStrings_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCellMatrix_700\n#define mxCreateCellMatrix_700 mxCreateCellMatrix_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCellArray_700\n#define mxCreateCellArray_700 mxCreateCellArray_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateStructMatrix_700\n#define mxCreateStructMatrix_700 mxCreateStructMatrix_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if defined(MX_COMPAT_32)\n/* Map original name to unique proxy layer name. */\n#undef mxCreateStructArray_700\n#define mxCreateStructArray_700 mxCreateStructArray_700_proxy\n#endif   /* defined(MX_COMPAT_32) */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxMalloc\n#define mxMalloc mxMalloc_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCalloc\n#define mxCalloc mxCalloc_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxFree\n#define mxFree mxFree_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxRealloc\n#define mxRealloc mxRealloc_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNumberOfDimensions_730\n#define mxGetNumberOfDimensions_730 mxGetNumberOfDimensions_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetDimensions_730\n#define mxGetDimensions_730 mxGetDimensions_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetM\n#define mxGetM mxGetM_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetIr_730\n#define mxGetIr_730 mxGetIr_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetJc_730\n#define mxGetJc_730 mxGetJc_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNzmax_730\n#define mxGetNzmax_730 mxGetNzmax_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetNzmax_730\n#define mxSetNzmax_730 mxSetNzmax_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetFieldNameByNumber\n#define mxGetFieldNameByNumber mxGetFieldNameByNumber_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetFieldByNumber_730\n#define mxGetFieldByNumber_730 mxGetFieldByNumber_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetCell_730\n#define mxGetCell_730 mxGetCell_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetClassID\n#define mxGetClassID mxGetClassID_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetData\n#define mxGetData mxGetData_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetData\n#define mxSetData mxSetData_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsNumeric\n#define mxIsNumeric mxIsNumeric_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsCell\n#define mxIsCell mxIsCell_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsLogical\n#define mxIsLogical mxIsLogical_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsScalar\n#define mxIsScalar mxIsScalar_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsChar\n#define mxIsChar mxIsChar_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsStruct\n#define mxIsStruct mxIsStruct_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsOpaque\n#define mxIsOpaque mxIsOpaque_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsFunctionHandle\n#define mxIsFunctionHandle mxIsFunctionHandle_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsObject\n#define mxIsObject mxIsObject_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetImagData\n#define mxGetImagData mxGetImagData_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetImagData\n#define mxSetImagData mxSetImagData_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsComplex\n#define mxIsComplex mxIsComplex_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsSparse\n#define mxIsSparse mxIsSparse_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsDouble\n#define mxIsDouble mxIsDouble_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsSingle\n#define mxIsSingle mxIsSingle_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInt8\n#define mxIsInt8 mxIsInt8_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsUint8\n#define mxIsUint8 mxIsUint8_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInt16\n#define mxIsInt16 mxIsInt16_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsUint16\n#define mxIsUint16 mxIsUint16_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInt32\n#define mxIsInt32 mxIsInt32_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsUint32\n#define mxIsUint32 mxIsUint32_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInt64\n#define mxIsInt64 mxIsInt64_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsUint64\n#define mxIsUint64 mxIsUint64_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNumberOfElements\n#define mxGetNumberOfElements mxGetNumberOfElements_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetPi\n#define mxGetPi mxGetPi_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetPi\n#define mxSetPi mxSetPi_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetChars\n#define mxGetChars mxGetChars_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetUserBits\n#define mxGetUserBits mxGetUserBits_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetUserBits\n#define mxSetUserBits mxSetUserBits_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetScalar\n#define mxGetScalar mxGetScalar_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsFromGlobalWS\n#define mxIsFromGlobalWS mxIsFromGlobalWS_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetFromGlobalWS\n#define mxSetFromGlobalWS mxSetFromGlobalWS_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetM_730\n#define mxSetM_730 mxSetM_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetN\n#define mxGetN mxGetN_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsEmpty\n#define mxIsEmpty mxIsEmpty_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetFieldNumber\n#define mxGetFieldNumber mxGetFieldNumber_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetIr_730\n#define mxSetIr_730 mxSetIr_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetJc_730\n#define mxSetJc_730 mxSetJc_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetPr\n#define mxGetPr mxGetPr_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetPr\n#define mxSetPr mxSetPr_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetElementSize\n#define mxGetElementSize mxGetElementSize_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCalcSingleSubscript_730\n#define mxCalcSingleSubscript_730 mxCalcSingleSubscript_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNumberOfFields\n#define mxGetNumberOfFields mxGetNumberOfFields_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetCell_730\n#define mxSetCell_730 mxSetCell_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetFieldByNumber_730\n#define mxSetFieldByNumber_730 mxSetFieldByNumber_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetField_730\n#define mxGetField_730 mxGetField_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetField_730\n#define mxSetField_730 mxSetField_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsClass\n#define mxIsClass mxIsClass_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateNumericMatrix_730\n#define mxCreateNumericMatrix_730 mxCreateNumericMatrix_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateUninitNumericMatrix\n#define mxCreateUninitNumericMatrix mxCreateUninitNumericMatrix_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateUninitNumericArray\n#define mxCreateUninitNumericArray mxCreateUninitNumericArray_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetN_730\n#define mxSetN_730 mxSetN_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetDimensions_730\n#define mxSetDimensions_730 mxSetDimensions_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxDestroyArray\n#define mxDestroyArray mxDestroyArray_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateNumericArray_730\n#define mxCreateNumericArray_730 mxCreateNumericArray_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCharArray_730\n#define mxCreateCharArray_730 mxCreateCharArray_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateDoubleMatrix_730\n#define mxCreateDoubleMatrix_730 mxCreateDoubleMatrix_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetLogicals\n#define mxGetLogicals mxGetLogicals_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateLogicalArray_730\n#define mxCreateLogicalArray_730 mxCreateLogicalArray_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateLogicalMatrix_730\n#define mxCreateLogicalMatrix_730 mxCreateLogicalMatrix_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateLogicalScalar\n#define mxCreateLogicalScalar mxCreateLogicalScalar_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsLogicalScalar\n#define mxIsLogicalScalar mxIsLogicalScalar_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsLogicalScalarTrue\n#define mxIsLogicalScalarTrue mxIsLogicalScalarTrue_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateDoubleScalar\n#define mxCreateDoubleScalar mxCreateDoubleScalar_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateSparse_730\n#define mxCreateSparse_730 mxCreateSparse_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateSparseLogicalMatrix_730\n#define mxCreateSparseLogicalMatrix_730 mxCreateSparseLogicalMatrix_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNChars_730\n#define mxGetNChars_730 mxGetNChars_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetString_730\n#define mxGetString_730 mxGetString_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxArrayToString\n#define mxArrayToString mxArrayToString_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxArrayToUTF8String\n#define mxArrayToUTF8String mxArrayToUTF8String_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateStringFromNChars_730\n#define mxCreateStringFromNChars_730 mxCreateStringFromNChars_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateString\n#define mxCreateString mxCreateString_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCharMatrixFromStrings_730\n#define mxCreateCharMatrixFromStrings_730 mxCreateCharMatrixFromStrings_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCellMatrix_730\n#define mxCreateCellMatrix_730 mxCreateCellMatrix_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCellArray_730\n#define mxCreateCellArray_730 mxCreateCellArray_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateStructMatrix_730\n#define mxCreateStructMatrix_730 mxCreateStructMatrix_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateStructArray_730\n#define mxCreateStructArray_730 mxCreateStructArray_730_proxy\n#endif   /* !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxDuplicateArray\n#define mxDuplicateArray mxDuplicateArray_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetClassName\n#define mxSetClassName mxSetClassName_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxAddField\n#define mxAddField mxAddField_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxRemoveField\n#define mxRemoveField mxRemoveField_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetEps\n#define mxGetEps mxGetEps_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetInf\n#define mxGetInf mxGetInf_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNaN\n#define mxGetNaN mxGetNaN_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsFinite\n#define mxIsFinite mxIsFinite_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInf\n#define mxIsInf mxIsInf_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsNaN\n#define mxIsNaN mxIsNaN_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateSharedDataCopy\n#define mxCreateSharedDataCopy mxCreateSharedDataCopy_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateUninitDoubleMatrix\n#define mxCreateUninitDoubleMatrix mxCreateUninitDoubleMatrix_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxFastZeros\n#define mxFastZeros mxFastZeros_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxUnreference\n#define mxUnreference mxUnreference_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION < 800\n/* Map original name to unique proxy layer name. */\n#undef mxUnshareArray\n#define mxUnshareArray mxUnshareArray_proxy\n#endif   /* TARGET_API_VERSION < 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxMalloc_800\n#define mxMalloc_800 mxMalloc_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCalloc_800\n#define mxCalloc_800 mxCalloc_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxFree_800\n#define mxFree_800 mxFree_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxRealloc_800\n#define mxRealloc_800 mxRealloc_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNumberOfDimensions_800\n#define mxGetNumberOfDimensions_800 mxGetNumberOfDimensions_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetDimensions_800\n#define mxGetDimensions_800 mxGetDimensions_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetM_800\n#define mxGetM_800 mxGetM_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetIr_800\n#define mxGetIr_800 mxGetIr_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetJc_800\n#define mxGetJc_800 mxGetJc_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNzmax_800\n#define mxGetNzmax_800 mxGetNzmax_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetNzmax_800\n#define mxSetNzmax_800 mxSetNzmax_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetFieldNameByNumber_800\n#define mxGetFieldNameByNumber_800 mxGetFieldNameByNumber_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetFieldByNumber_800\n#define mxGetFieldByNumber_800 mxGetFieldByNumber_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetCell_800\n#define mxGetCell_800 mxGetCell_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetClassID_800\n#define mxGetClassID_800 mxGetClassID_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetData_800\n#define mxGetData_800 mxGetData_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetData_800\n#define mxSetData_800 mxSetData_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsNumeric_800\n#define mxIsNumeric_800 mxIsNumeric_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsCell_800\n#define mxIsCell_800 mxIsCell_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsLogical_800\n#define mxIsLogical_800 mxIsLogical_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsScalar_800\n#define mxIsScalar_800 mxIsScalar_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsChar_800\n#define mxIsChar_800 mxIsChar_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsStruct_800\n#define mxIsStruct_800 mxIsStruct_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsOpaque_800\n#define mxIsOpaque_800 mxIsOpaque_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsFunctionHandle_800\n#define mxIsFunctionHandle_800 mxIsFunctionHandle_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsObject_800\n#define mxIsObject_800 mxIsObject_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsComplex_800\n#define mxIsComplex_800 mxIsComplex_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsSparse_800\n#define mxIsSparse_800 mxIsSparse_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsDouble_800\n#define mxIsDouble_800 mxIsDouble_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsSingle_800\n#define mxIsSingle_800 mxIsSingle_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInt8_800\n#define mxIsInt8_800 mxIsInt8_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsUint8_800\n#define mxIsUint8_800 mxIsUint8_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInt16_800\n#define mxIsInt16_800 mxIsInt16_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsUint16_800\n#define mxIsUint16_800 mxIsUint16_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInt32_800\n#define mxIsInt32_800 mxIsInt32_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsUint32_800\n#define mxIsUint32_800 mxIsUint32_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInt64_800\n#define mxIsInt64_800 mxIsInt64_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsUint64_800\n#define mxIsUint64_800 mxIsUint64_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNumberOfElements_800\n#define mxGetNumberOfElements_800 mxGetNumberOfElements_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetChars_800\n#define mxGetChars_800 mxGetChars_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetUserBits_800\n#define mxGetUserBits_800 mxGetUserBits_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetUserBits_800\n#define mxSetUserBits_800 mxSetUserBits_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetScalar_800\n#define mxGetScalar_800 mxGetScalar_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsFromGlobalWS_800\n#define mxIsFromGlobalWS_800 mxIsFromGlobalWS_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetFromGlobalWS_800\n#define mxSetFromGlobalWS_800 mxSetFromGlobalWS_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetM_800\n#define mxSetM_800 mxSetM_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetN_800\n#define mxGetN_800 mxGetN_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsEmpty_800\n#define mxIsEmpty_800 mxIsEmpty_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetFieldNumber_800\n#define mxGetFieldNumber_800 mxGetFieldNumber_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetIr_800\n#define mxSetIr_800 mxSetIr_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetJc_800\n#define mxSetJc_800 mxSetJc_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetPr_800\n#define mxGetPr_800 mxGetPr_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetPr_800\n#define mxSetPr_800 mxSetPr_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetElementSize_800\n#define mxGetElementSize_800 mxGetElementSize_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCalcSingleSubscript_800\n#define mxCalcSingleSubscript_800 mxCalcSingleSubscript_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNumberOfFields_800\n#define mxGetNumberOfFields_800 mxGetNumberOfFields_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetCell_800\n#define mxSetCell_800 mxSetCell_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetFieldByNumber_800\n#define mxSetFieldByNumber_800 mxSetFieldByNumber_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetField_800\n#define mxGetField_800 mxGetField_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetField_800\n#define mxSetField_800 mxSetField_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsClass_800\n#define mxIsClass_800 mxIsClass_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateNumericMatrix_800\n#define mxCreateNumericMatrix_800 mxCreateNumericMatrix_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateUninitNumericMatrix_800\n#define mxCreateUninitNumericMatrix_800 mxCreateUninitNumericMatrix_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateUninitNumericArray_800\n#define mxCreateUninitNumericArray_800 mxCreateUninitNumericArray_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetN_800\n#define mxSetN_800 mxSetN_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetDimensions_800\n#define mxSetDimensions_800 mxSetDimensions_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxDestroyArray_800\n#define mxDestroyArray_800 mxDestroyArray_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateNumericArray_800\n#define mxCreateNumericArray_800 mxCreateNumericArray_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCharArray_800\n#define mxCreateCharArray_800 mxCreateCharArray_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateDoubleMatrix_800\n#define mxCreateDoubleMatrix_800 mxCreateDoubleMatrix_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetLogicals_800\n#define mxGetLogicals_800 mxGetLogicals_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateLogicalArray_800\n#define mxCreateLogicalArray_800 mxCreateLogicalArray_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateLogicalMatrix_800\n#define mxCreateLogicalMatrix_800 mxCreateLogicalMatrix_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateLogicalScalar_800\n#define mxCreateLogicalScalar_800 mxCreateLogicalScalar_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsLogicalScalar_800\n#define mxIsLogicalScalar_800 mxIsLogicalScalar_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsLogicalScalarTrue_800\n#define mxIsLogicalScalarTrue_800 mxIsLogicalScalarTrue_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateDoubleScalar_800\n#define mxCreateDoubleScalar_800 mxCreateDoubleScalar_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateSparse_800\n#define mxCreateSparse_800 mxCreateSparse_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateSparseLogicalMatrix_800\n#define mxCreateSparseLogicalMatrix_800 mxCreateSparseLogicalMatrix_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNChars_800\n#define mxGetNChars_800 mxGetNChars_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetString_800\n#define mxGetString_800 mxGetString_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxArrayToString_800\n#define mxArrayToString_800 mxArrayToString_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxArrayToUTF8String_800\n#define mxArrayToUTF8String_800 mxArrayToUTF8String_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateStringFromNChars_800\n#define mxCreateStringFromNChars_800 mxCreateStringFromNChars_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateString_800\n#define mxCreateString_800 mxCreateString_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCharMatrixFromStrings_800\n#define mxCreateCharMatrixFromStrings_800 mxCreateCharMatrixFromStrings_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCellMatrix_800\n#define mxCreateCellMatrix_800 mxCreateCellMatrix_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateCellArray_800\n#define mxCreateCellArray_800 mxCreateCellArray_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateStructMatrix_800\n#define mxCreateStructMatrix_800 mxCreateStructMatrix_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxCreateStructArray_800\n#define mxCreateStructArray_800 mxCreateStructArray_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxDuplicateArray_800\n#define mxDuplicateArray_800 mxDuplicateArray_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetClassName_800\n#define mxSetClassName_800 mxSetClassName_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxAddField_800\n#define mxAddField_800 mxAddField_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxRemoveField_800\n#define mxRemoveField_800 mxRemoveField_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetEps_800\n#define mxGetEps_800 mxGetEps_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetInf_800\n#define mxGetInf_800 mxGetInf_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetNaN_800\n#define mxGetNaN_800 mxGetNaN_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsFinite_800\n#define mxIsFinite_800 mxIsFinite_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsInf_800\n#define mxIsInf_800 mxIsInf_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxIsNaN_800\n#define mxIsNaN_800 mxIsNaN_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetDoubles_800\n#define mxGetDoubles_800 mxGetDoubles_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetDoubles_800\n#define mxSetDoubles_800 mxSetDoubles_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexDoubles_800\n#define mxGetComplexDoubles_800 mxGetComplexDoubles_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexDoubles_800\n#define mxSetComplexDoubles_800 mxSetComplexDoubles_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetSingles_800\n#define mxGetSingles_800 mxGetSingles_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetSingles_800\n#define mxSetSingles_800 mxSetSingles_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexSingles_800\n#define mxGetComplexSingles_800 mxGetComplexSingles_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexSingles_800\n#define mxSetComplexSingles_800 mxSetComplexSingles_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetInt8s_800\n#define mxGetInt8s_800 mxGetInt8s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetInt8s_800\n#define mxSetInt8s_800 mxSetInt8s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexInt8s_800\n#define mxGetComplexInt8s_800 mxGetComplexInt8s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexInt8s_800\n#define mxSetComplexInt8s_800 mxSetComplexInt8s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetUint8s_800\n#define mxGetUint8s_800 mxGetUint8s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetUint8s_800\n#define mxSetUint8s_800 mxSetUint8s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexUint8s_800\n#define mxGetComplexUint8s_800 mxGetComplexUint8s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexUint8s_800\n#define mxSetComplexUint8s_800 mxSetComplexUint8s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetInt16s_800\n#define mxGetInt16s_800 mxGetInt16s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetInt16s_800\n#define mxSetInt16s_800 mxSetInt16s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexInt16s_800\n#define mxGetComplexInt16s_800 mxGetComplexInt16s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexInt16s_800\n#define mxSetComplexInt16s_800 mxSetComplexInt16s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetUint16s_800\n#define mxGetUint16s_800 mxGetUint16s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetUint16s_800\n#define mxSetUint16s_800 mxSetUint16s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexUint16s_800\n#define mxGetComplexUint16s_800 mxGetComplexUint16s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexUint16s_800\n#define mxSetComplexUint16s_800 mxSetComplexUint16s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetInt32s_800\n#define mxGetInt32s_800 mxGetInt32s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetInt32s_800\n#define mxSetInt32s_800 mxSetInt32s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexInt32s_800\n#define mxGetComplexInt32s_800 mxGetComplexInt32s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexInt32s_800\n#define mxSetComplexInt32s_800 mxSetComplexInt32s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetUint32s_800\n#define mxGetUint32s_800 mxGetUint32s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetUint32s_800\n#define mxSetUint32s_800 mxSetUint32s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexUint32s_800\n#define mxGetComplexUint32s_800 mxGetComplexUint32s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexUint32s_800\n#define mxSetComplexUint32s_800 mxSetComplexUint32s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetInt64s_800\n#define mxGetInt64s_800 mxGetInt64s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetInt64s_800\n#define mxSetInt64s_800 mxSetInt64s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexInt64s_800\n#define mxGetComplexInt64s_800 mxGetComplexInt64s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexInt64s_800\n#define mxSetComplexInt64s_800 mxSetComplexInt64s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetUint64s_800\n#define mxGetUint64s_800 mxGetUint64s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetUint64s_800\n#define mxSetUint64s_800 mxSetUint64s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxGetComplexUint64s_800\n#define mxGetComplexUint64s_800 mxGetComplexUint64s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxSetComplexUint64s_800\n#define mxSetComplexUint64s_800 mxSetComplexUint64s_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxMakeArrayReal_800\n#define mxMakeArrayReal_800 mxMakeArrayReal_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n#if TARGET_API_VERSION >= 800\n/* Map original name to unique proxy layer name. */\n#undef mxMakeArrayComplex_800\n#define mxMakeArrayComplex_800 mxMakeArrayComplex_800_proxy\n#endif   /* TARGET_API_VERSION >= 800 */\n\n\n\n\n#define LIBMWMATRIX_API_EXTERN_C EXTERN_C\n\n/* Proxies for functions in matrix.h */\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmwSize mxGetNumberOfDimensions_700_proxy(const mxArray *a0);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nconst mwSize * mxGetDimensions_700_proxy(const mxArray *a0);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmwIndex * mxGetIr_700_proxy(const mxArray *a0);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmwIndex * mxGetJc_700_proxy(const mxArray *a0);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmwSize mxGetNzmax_700_proxy(const mxArray *a0);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nvoid mxSetNzmax_700_proxy(mxArray *a0, mwSize a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxGetFieldByNumber_700_proxy(const mxArray *a0, mwIndex a1, \n    int a2);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxGetCell_700_proxy(const mxArray *a0, mwIndex a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nvoid mxSetM_700_proxy(mxArray *a0, mwSize a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nvoid mxSetIr_700_proxy(mxArray *a0, mwIndex *a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nvoid mxSetJc_700_proxy(mxArray *a0, mwIndex *a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmwIndex mxCalcSingleSubscript_700_proxy(const mxArray *a0, mwSize a1, \n    const mwIndex *a2);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nvoid mxSetCell_700_proxy(mxArray *a0, mwIndex a1, mxArray *a2);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nvoid mxSetFieldByNumber_700_proxy(mxArray *a0, mwIndex a1, int a2, \n    mxArray *a3);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxGetField_700_proxy(const mxArray *a0, mwIndex a1, \n    const char *a2);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nvoid mxSetField_700_proxy(mxArray *a0, mwIndex a1, const char *a2, \n    mxArray *a3);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateNumericMatrix_700_proxy(mwSize a0, mwSize a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nvoid mxSetN_700_proxy(mxArray *a0, mwSize a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nint mxSetDimensions_700_proxy(mxArray *a0, const mwSize *a1, mwSize a2);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateNumericArray_700_proxy(mwSize a0, const mwSize *a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateCharArray_700_proxy(mwSize a0, const mwSize *a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateDoubleMatrix_700_proxy(mwSize a0, mwSize a1, \n    mxComplexity a2);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateLogicalArray_700_proxy(mwSize a0, const mwSize *a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateLogicalMatrix_700_proxy(mwSize a0, mwSize a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateSparse_700_proxy(mwSize a0, mwSize a1, mwSize a2, \n    mxComplexity a3);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateSparseLogicalMatrix_700_proxy(mwSize a0, mwSize a1, \n    mwSize a2);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nvoid mxGetNChars_700_proxy(const mxArray *a0, char *a1, mwSize a2);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nint mxGetString_700_proxy(const mxArray *a0, char *a1, mwSize a2);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateStringFromNChars_700_proxy(const char *a0, mwSize a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateCharMatrixFromStrings_700_proxy(mwSize a0, \n    const char **a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateCellMatrix_700_proxy(mwSize a0, mwSize a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateCellArray_700_proxy(mwSize a0, const mwSize *a1);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateStructMatrix_700_proxy(mwSize a0, mwSize a1, int a2, \n    const char **a3);\n#endif\n\n#if defined(MX_COMPAT_32)\nEXTERN_C\nmxArray * mxCreateStructArray_700_proxy(mwSize a0, const mwSize *a1, \n    int a2, const char **a3);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid * mxMalloc_proxy(size_t a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid * mxCalloc_proxy(size_t a0, size_t a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxFree_proxy(void *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid * mxRealloc_proxy(void *a0, size_t a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmwSize mxGetNumberOfDimensions_730_proxy(const mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nconst mwSize * mxGetDimensions_730_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nsize_t mxGetM_proxy(const mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmwIndex * mxGetIr_730_proxy(const mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmwIndex * mxGetJc_730_proxy(const mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmwSize mxGetNzmax_730_proxy(const mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetNzmax_730_proxy(mxArray *a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nconst char * mxGetFieldNameByNumber_proxy(const mxArray *a0, int a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxGetFieldByNumber_730_proxy(const mxArray *a0, mwIndex a1, \n    int a2);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxGetCell_730_proxy(const mxArray *a0, mwIndex a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxClassID mxGetClassID_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid * mxGetData_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetData_proxy(mxArray *a0, void *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsNumeric_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsCell_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsLogical_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsScalar_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsChar_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsStruct_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsOpaque_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsFunctionHandle_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsObject_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid * mxGetImagData_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetImagData_proxy(mxArray *a0, void *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsComplex_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsSparse_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsDouble_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsSingle_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsInt8_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsUint8_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsInt16_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsUint16_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsInt32_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsUint32_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsInt64_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsUint64_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nsize_t mxGetNumberOfElements_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\ndouble * mxGetPi_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetPi_proxy(mxArray *a0, double *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxChar * mxGetChars_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nint mxGetUserBits_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetUserBits_proxy(mxArray *a0, int a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\ndouble mxGetScalar_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsFromGlobalWS_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetFromGlobalWS_proxy(mxArray *a0, bool a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetM_730_proxy(mxArray *a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nsize_t mxGetN_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsEmpty_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nint mxGetFieldNumber_proxy(const mxArray *a0, const char *a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetIr_730_proxy(mxArray *a0, mwIndex *a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetJc_730_proxy(mxArray *a0, mwIndex *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\ndouble * mxGetPr_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetPr_proxy(mxArray *a0, double *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nsize_t mxGetElementSize_proxy(const mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmwIndex mxCalcSingleSubscript_730_proxy(const mxArray *a0, mwSize a1, \n    const mwIndex *a2);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nint mxGetNumberOfFields_proxy(const mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetCell_730_proxy(mxArray *a0, mwIndex a1, mxArray *a2);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetFieldByNumber_730_proxy(mxArray *a0, mwIndex a1, int a2, \n    mxArray *a3);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxGetField_730_proxy(const mxArray *a0, mwIndex a1, \n    const char *a2);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetField_730_proxy(mxArray *a0, mwIndex a1, const char *a2, \n    mxArray *a3);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsClass_proxy(const mxArray *a0, const char *a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateNumericMatrix_730_proxy(mwSize a0, mwSize a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateUninitNumericMatrix_proxy(size_t a0, size_t a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateUninitNumericArray_proxy(size_t a0, size_t *a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxSetN_730_proxy(mxArray *a0, mwSize a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nint mxSetDimensions_730_proxy(mxArray *a0, const mwSize *a1, mwSize a2);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxDestroyArray_proxy(mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateNumericArray_730_proxy(mwSize a0, const mwSize *a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateCharArray_730_proxy(mwSize a0, const mwSize *a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateDoubleMatrix_730_proxy(mwSize a0, mwSize a1, \n    mxComplexity a2);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxLogical * mxGetLogicals_proxy(const mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateLogicalArray_730_proxy(mwSize a0, const mwSize *a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateLogicalMatrix_730_proxy(mwSize a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateLogicalScalar_proxy(bool a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsLogicalScalar_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsLogicalScalarTrue_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateDoubleScalar_proxy(double a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateSparse_730_proxy(mwSize a0, mwSize a1, mwSize a2, \n    mxComplexity a3);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateSparseLogicalMatrix_730_proxy(mwSize a0, mwSize a1, \n    mwSize a2);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxGetNChars_730_proxy(const mxArray *a0, char *a1, mwSize a2);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nint mxGetString_730_proxy(const mxArray *a0, char *a1, mwSize a2);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nchar * mxArrayToString_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nchar * mxArrayToUTF8String_proxy(const mxArray *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateStringFromNChars_730_proxy(const char *a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateString_proxy(const char *a0);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateCharMatrixFromStrings_730_proxy(mwSize a0, \n    const char **a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateCellMatrix_730_proxy(mwSize a0, mwSize a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateCellArray_730_proxy(mwSize a0, const mwSize *a1);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateStructMatrix_730_proxy(mwSize a0, mwSize a1, int a2, \n    const char **a3);\n#endif\n\n#if !defined(MX_COMPAT_32) && TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateStructArray_730_proxy(mwSize a0, const mwSize *a1, \n    int a2, const char **a3);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxDuplicateArray_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nint mxSetClassName_proxy(mxArray *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nint mxAddField_proxy(mxArray *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nvoid mxRemoveField_proxy(mxArray *a0, int a1);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\ndouble mxGetEps_proxy();\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\ndouble mxGetInf_proxy();\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\ndouble mxGetNaN_proxy();\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsFinite_proxy(double a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsInf_proxy(double a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nbool mxIsNaN_proxy(double a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateSharedDataCopy_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxCreateUninitDoubleMatrix_proxy(int a0, size_t a1, size_t a2);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxFastZeros_proxy(int a0, int a1, int a2);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nmxArray * mxUnreference_proxy(mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION < 800\nEXTERN_C\nint mxUnshareArray_proxy(mxArray *a0, int a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid * mxMalloc_800_proxy(size_t a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid * mxCalloc_800_proxy(size_t a0, size_t a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxFree_800_proxy(void *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid * mxRealloc_800_proxy(void *a0, size_t a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmwSize mxGetNumberOfDimensions_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nconst mwSize * mxGetDimensions_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nsize_t mxGetM_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmwIndex * mxGetIr_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmwIndex * mxGetJc_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmwSize mxGetNzmax_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetNzmax_800_proxy(mxArray *a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nconst char * mxGetFieldNameByNumber_800_proxy(const mxArray *a0, int a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxGetFieldByNumber_800_proxy(const mxArray *a0, mwIndex a1, \n    int a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxGetCell_800_proxy(const mxArray *a0, mwIndex a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxClassID mxGetClassID_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid * mxGetData_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetData_800_proxy(mxArray *a0, void *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsNumeric_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsCell_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsLogical_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsScalar_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsChar_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsStruct_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsOpaque_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsFunctionHandle_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsObject_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsComplex_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsSparse_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsDouble_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsSingle_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsInt8_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsUint8_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsInt16_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsUint16_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsInt32_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsUint32_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsInt64_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsUint64_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nsize_t mxGetNumberOfElements_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxChar * mxGetChars_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxGetUserBits_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetUserBits_800_proxy(mxArray *a0, int a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\ndouble mxGetScalar_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsFromGlobalWS_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetFromGlobalWS_800_proxy(mxArray *a0, bool a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetM_800_proxy(mxArray *a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nsize_t mxGetN_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsEmpty_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxGetFieldNumber_800_proxy(const mxArray *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetIr_800_proxy(mxArray *a0, mwIndex *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetJc_800_proxy(mxArray *a0, mwIndex *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\ndouble * mxGetPr_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetPr_800_proxy(mxArray *a0, double *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nsize_t mxGetElementSize_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmwIndex mxCalcSingleSubscript_800_proxy(const mxArray *a0, mwSize a1, \n    const mwIndex *a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxGetNumberOfFields_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetCell_800_proxy(mxArray *a0, mwIndex a1, mxArray *a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetFieldByNumber_800_proxy(mxArray *a0, mwIndex a1, int a2, \n    mxArray *a3);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxGetField_800_proxy(const mxArray *a0, mwIndex a1, \n    const char *a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetField_800_proxy(mxArray *a0, mwIndex a1, const char *a2, \n    mxArray *a3);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsClass_800_proxy(const mxArray *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateNumericMatrix_800_proxy(mwSize a0, mwSize a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateUninitNumericMatrix_800_proxy(size_t a0, size_t a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateUninitNumericArray_800_proxy(size_t a0, size_t *a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxSetN_800_proxy(mxArray *a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetDimensions_800_proxy(mxArray *a0, const mwSize *a1, mwSize a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxDestroyArray_800_proxy(mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateNumericArray_800_proxy(mwSize a0, const mwSize *a1, \n    mxClassID a2, mxComplexity a3);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateCharArray_800_proxy(mwSize a0, const mwSize *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateDoubleMatrix_800_proxy(mwSize a0, mwSize a1, \n    mxComplexity a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxLogical * mxGetLogicals_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateLogicalArray_800_proxy(mwSize a0, const mwSize *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateLogicalMatrix_800_proxy(mwSize a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateLogicalScalar_800_proxy(bool a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsLogicalScalar_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsLogicalScalarTrue_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateDoubleScalar_800_proxy(double a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateSparse_800_proxy(mwSize a0, mwSize a1, mwSize a2, \n    mxComplexity a3);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateSparseLogicalMatrix_800_proxy(mwSize a0, mwSize a1, \n    mwSize a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxGetNChars_800_proxy(const mxArray *a0, char *a1, mwSize a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxGetString_800_proxy(const mxArray *a0, char *a1, mwSize a2);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nchar * mxArrayToString_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nchar * mxArrayToUTF8String_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateStringFromNChars_800_proxy(const char *a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateString_800_proxy(const char *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateCharMatrixFromStrings_800_proxy(mwSize a0, \n    const char **a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateCellMatrix_800_proxy(mwSize a0, mwSize a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateCellArray_800_proxy(mwSize a0, const mwSize *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateStructMatrix_800_proxy(mwSize a0, mwSize a1, int a2, \n    const char **a3);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxCreateStructArray_800_proxy(mwSize a0, const mwSize *a1, \n    int a2, const char **a3);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxArray * mxDuplicateArray_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetClassName_800_proxy(mxArray *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxAddField_800_proxy(mxArray *a0, const char *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nvoid mxRemoveField_800_proxy(mxArray *a0, int a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\ndouble mxGetEps_800_proxy();\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\ndouble mxGetInf_800_proxy();\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\ndouble mxGetNaN_800_proxy();\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsFinite_800_proxy(double a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsInf_800_proxy(double a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nbool mxIsNaN_800_proxy(double a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxDouble * mxGetDoubles_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetDoubles_800_proxy(mxArray *a0, mxDouble *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexDouble * mxGetComplexDoubles_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexDoubles_800_proxy(mxArray *a0, mxComplexDouble *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxSingle * mxGetSingles_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetSingles_800_proxy(mxArray *a0, mxSingle *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexSingle * mxGetComplexSingles_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexSingles_800_proxy(mxArray *a0, mxComplexSingle *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxInt8 * mxGetInt8s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetInt8s_800_proxy(mxArray *a0, mxInt8 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexInt8 * mxGetComplexInt8s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexInt8s_800_proxy(mxArray *a0, mxComplexInt8 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxUint8 * mxGetUint8s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetUint8s_800_proxy(mxArray *a0, mxUint8 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexUint8 * mxGetComplexUint8s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexUint8s_800_proxy(mxArray *a0, mxComplexUint8 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxInt16 * mxGetInt16s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetInt16s_800_proxy(mxArray *a0, mxInt16 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexInt16 * mxGetComplexInt16s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexInt16s_800_proxy(mxArray *a0, mxComplexInt16 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxUint16 * mxGetUint16s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetUint16s_800_proxy(mxArray *a0, mxUint16 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexUint16 * mxGetComplexUint16s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexUint16s_800_proxy(mxArray *a0, mxComplexUint16 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxInt32 * mxGetInt32s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetInt32s_800_proxy(mxArray *a0, mxInt32 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexInt32 * mxGetComplexInt32s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexInt32s_800_proxy(mxArray *a0, mxComplexInt32 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxUint32 * mxGetUint32s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetUint32s_800_proxy(mxArray *a0, mxUint32 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexUint32 * mxGetComplexUint32s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexUint32s_800_proxy(mxArray *a0, mxComplexUint32 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxInt64 * mxGetInt64s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetInt64s_800_proxy(mxArray *a0, mxInt64 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexInt64 * mxGetComplexInt64s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexInt64s_800_proxy(mxArray *a0, mxComplexInt64 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxUint64 * mxGetUint64s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetUint64s_800_proxy(mxArray *a0, mxUint64 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nmxComplexUint64 * mxGetComplexUint64s_800_proxy(const mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxSetComplexUint64s_800_proxy(mxArray *a0, mxComplexUint64 *a1);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxMakeArrayReal_800_proxy(mxArray *a0);\n#endif\n\n#if TARGET_API_VERSION >= 800\nEXTERN_C\nint mxMakeArrayComplex_800_proxy(mxArray *a0);\n#endif\n\n\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* Standard proxy prolog. Undefine any preprocessor definitions associated\n * with the functions we are proxying, so that we can define a new one. We\n * map the user-called name to the new, internal name.\n */\n#ifdef mxGetClassName\n#undef mxGetClassName\n#endif\n#define mxGetClassName mxGetClassNameDeployed\n\n#ifdef mxGetProperty\n#undef mxGetProperty\n#endif\n#define mxGetProperty mxGetPropertyDeployed\n\n#ifdef mxSetProperty\n#undef mxSetProperty\n#endif\n#define mxSetProperty mxSetPropertyDeployed\n\n\n/* Use EXTERN_C on these declarations because they are not seen when building\n * the proxy layer. User client code includes the publish header. Therefore\n * the symbols should be declared appropriately for import rather than export.\n */\n#if !defined(MW_BUILD_ARCHIVES)\nEXTERN_C\nconst char * mxGetClassNameDeployed(mxArray const * const data);\n\nEXTERN_C\nmxArray *mxGetPropertyDeployed(const mxArray *obj, mwIndex index,\n                               const char *propName);\n\nEXTERN_C\nvoid mxSetPropertyDeployed(mxArray *obj, mwIndex index,\n                           const char *propName, const mxArray *propValue);\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n#endif /* mclmcrrt_h */\n"},{"name":"mclxlmain.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n* PUBLISHed header for libmclxlmain, the mclxlmain library.\n*\n* Copyright 1984-2012 The MathWorks, Inc.\n* All Rights Reserved.\n*/\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef mclxlmain_published_api_h\n#define mclxlmain_published_api_h\n\n#ifndef LIBMCLXLMAIN_API\n#  define LIBMCLXLMAIN_API\n#endif\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\n\n/* Register a MatLab Excel Builder component */\nLIBMCLXLMAIN_API HRESULT mclRegisterMatLabComponent(const char* szModuleName,     /* DLL module handle */\n                                const CLSID* clsid,           /* Class ID */\n                                const GUID* libid,            /* GUID of TypeLib */\n                                unsigned short wMajorRev,     /* Major rev of type lib */\n                                unsigned short wMinorRev,     /* Minor rev of type lib */\n                                const char* szFriendlyName,   /* Friendly Name */\n                                const char* szVerIndProgID,   /* Programmatic */\n                                const char* szProgID)         /* IDs */;\n\n\n/* Unregister a MatLab Excel Builder component */\nLIBMCLXLMAIN_API HRESULT mclUnRegisterMatLabComponent(const CLSID* clsid,            /* Class ID */\n                                     const char* szVerIndProgID, /* Programmatic */\n                                     const char* szProgID)       /* IDs */;\n\n\n/* \n   Aquire global lock. Returns 0 for successful aquisition, -1 otherwise.\n   If the global mutex is not initialized, or if the wait function fails,\n   -1 is returned.\n*/\nLIBMCLXLMAIN_API int RequestGlobalLock(void);\n\n\n/* \n   Release global lock. Returns 0. If the global mutex is not initialized,\n   -1 is returned.\n*/\nLIBMCLXLMAIN_API int ReleaseGlobalLock(void);\n\n\nLIBMCLXLMAIN_API HRESULT GetConversionFlags(IMWFlags* pFlags, MCLCONVERSION_FLAGS flags);\n\n\n/* Converts an mxArray to a Variant */\nLIBMCLXLMAIN_API int mxArray2Variant(const mxArray* px, VARIANT* pvar, const MCLCONVERSION_FLAGS flags);\n\n\n/* Converts a Variant to an mxArray */\nLIBMCLXLMAIN_API int Variant2mxArray(const VARIANT* pvar, mxArray** ppx, const MCLCONVERSION_FLAGS flags);\n\n\n/* \n   If input VARIANT is VT_EMPTY or VT_ERROR && v->scode == DISP_E_PARAMNOTFOUND, returns true.\n   Returns false otherwise. If input variant is *|VT_BYREF and reference is NULL, returns true.\n   If input variant pointer is NULL, returns true.\n*/\nLIBMCLXLMAIN_API bool IsVisualBasicDefault(const VARIANT *v);\n\n\nLIBMCLXLMAIN_API void InitConversionFlags(MCLCONVERSION_FLAGS flags);\n\n\nLIBMCLXLMAIN_API const char* GetCOMErrorMessage(int ret);\n\n\nLIBMCLXLMAIN_API bool mclComCheckMWComUtil();\n\n\nLIBMCLXLMAIN_API bool mclComCheckMWComMgr();\n\n\n#ifdef __cplusplus\n    }\t/* extern \"C\" */\n#endif\n\n#endif /* mclxlmain_h */\n"},{"name":"mcr.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* DEPRECATED.  Intentionally empty. */\n"},{"name":"mdl_info.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2014 The MathWorks, Inc.\n *\n * File: mdl_info.h     \n *\n * Abstract:\n *   Model tuning information.  Use the provided structure access methods\n *   whenever possible.\n *\n *   For details about these structures see MATLAB/rtw/c/src/pt_readme.txt\n *   and the Real-Time Workshop User's guide.\n */\n\n#ifndef __MDL_INFO__\n#define __MDL_INFO__\n\n#include <pt_info.h>\n#include <bio_sig.h>\n\ntypedef struct ModelMappingInfo_tag {\n  /* block signal monitoring */\n  struct {\n    BlockIOSignals const *blockIOSignals;    /* Block signals map             */\n    uint_T               numBlockIOSignals;  /* Num signals in map            */\n  } Signals;\n\n  /* parameter tuning */\n  struct {\n    BlockTuning const    *blockTuning;       /* Block parameters map          */\n    VariableTuning const *variableTuning;    /* Variable parameters map       */\n    void * const         *parametersMap;     /* Parameter index map           */\n    uint_T const         *dimensionsMap;     /* Dimensions index map          */\n    uint_T                numBlockTuning;    /* Num block parameters in map   */\n    uint_T                numVariableTuning; /* Num variable parameter in map */\n  } Parameters;\n} ModelMappingInfo;\n\n#define mmiGetBlockIOSignals(MMI)    (MMI)->Signals.blockIOSignals\n#define mmiGetNumBlockIOSignals(MMI) (MMI)->Signals.numBlockIOSignals\n\n#define mmiGetBlockTuning(MMI)       (MMI)->Parameters.blockTuning\n#define mmiGetVariableTuning(MMI)    (MMI)->Parameters.variableTuning\n#define mmiGetParametersMap(MMI)     (MMI)->Parameters.parametersMap\n#define mmiGetDimensionsMap(MMI)     (MMI)->Parameters.dimensionsMap\n#define mmiGetNumBlockParams(MMI)    (MMI)->Parameters.numBlockTuning\n#define mmiGetNumVariableParams(MMI) (MMI)->Parameters.numVariableTuning\n\n#define mmiGetBlockTuningBlockName(MMI,i)  (MMI)->Parameters.blockTuning[i].blockName\n#define mmiGetBlockTuningParamName(MMI,i)  (MMI)->Parameters.blockTuning[i].paramName\n#define mmiGetBlockTuningParamInfo(MMI,i)  (&((MMI)->Parameters.blockTuning[i].ptRec))\n\n#define mmiGetVariableTuningVarName(MMI,i) (MMI)->Parameters.variableTuning[i].varName\n#define mmiGetVariableTuningVarInfo(MMI,i) (&((MMI)->Parameters.variableTuning[i].ptRec))\n\n#endif  /* __MDL_INFO__ */\n"},{"name":"mem_mgr.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2002 The MathWorks, Inc.\n *\n * File: mem_mgr.h     \n *\n * Abstract:\n */\n\n#ifndef __MEM_MGR__\n#define __MEM_MGR__\n\nstruct MemBufHdr {\n    struct MemBufHdr *memBufNext;\n    struct MemBufHdr *memBufPrev;\n    char   *MemBuf;\n    int    size;\n};\n\ntypedef struct MemBufHdr MemBufHdr;\n\nextern void ExtModeFree(void *mem);\n\nextern void *ExtModeMalloc(uint32_T size);\n\nextern void *ExtModeCalloc(uint32_T number, uint32_T size);\n\n#endif /* __MEM_MGR__ */\n\n/* [EOF] mem_mgr.h */\n"},{"name":"mex.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* Published header for libmex, the mex library.\n   Copyright 1984-2018 The MathWorks, Inc.\n   This file containes types, macros, and declarations necessary to\n   interface mex files with the current version of MATLAB.\n   \n   See the release notes for information on supporting earlier versions. */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef mex_h\n#define mex_h\n\n#ifdef __cplusplus\n# define LIBMWMEX_API_EXTERN_C extern \"C\"\n#else\n# define LIBMWMEX_API_EXTERN_C extern\n#endif\n\n#ifdef _MSC_VER\n# define MWMEX_EXPORT_SYM __declspec(dllexport)\n#elif __GNUC__ >= 4\n# define MWMEX_EXPORT_SYM __attribute__ ((visibility(\"default\")))\n#else\n# define MWMEX_EXPORT_SYM\n#endif\n\n#ifdef MW_NEEDS_VERSION_H\n# define MEXFUNCTION_LINKAGE LIBMWMEX_API_EXTERN_C MWMEX_EXPORT_SYM\n#else\n# define MEXFUNCTION_LINKAGE LIBMWMEX_API_EXTERN_C\n#endif\n\n#include <stdio.h>\n\n\ntypedef struct impl_info_tag *MEX_impl_info;\n\n#include \"matrix.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif \ntypedef void (*mex_exit_fn)(void);\n#ifdef __cplusplus\n}\n#endif\n\ntypedef struct mexGlobalTableEntry_Tag\n{\n    const char *name;             /* The name of the global */\n    mxArray    **variable;        /* A pointer to the variable */ \n} mexGlobalTableEntry, *mexGlobalTable;\n\n#ifdef _WIN32\n#define cicompare(s1,s2) utStrcmpi((s1),(s2))\n#else\n#define cicompare(s1,s2) strcmp((s1),(s2))\n#endif\n#define cscompare(s1,s2) strcmp((s1),(s2))\n\ntypedef struct mexFunctionTableEntry_tag {\n  const char *  name;\n  mxFunctionPtr f;\n  int           nargin;\n  int           nargout;\n  struct _mexLocalFunctionTable *local_function_table;\n} mexFunctionTableEntry, *mexFunctionTable;\n\ntypedef struct _mexLocalFunctionTable {\n  size_t           length;\n  mexFunctionTable entries;\n} _mexLocalFunctionTable, *mexLocalFunctionTable;\n\ntypedef struct {\n  void (*initialize)(void);\n  void (*terminate)(void);\n} _mexInitTermTableEntry, *mexInitTermTableEntry;\n\n#define MEX_INFORMATION_VERSION 1\n\ntypedef void (*fn_clean_up_after_error)(void);\ntypedef const char *(*fn_simple_function_to_string)(mxFunctionPtr f);\n\ntypedef mexLocalFunctionTable (*fn_mex_get_local_function_table)(void);\ntypedef mexLocalFunctionTable (*fn_mex_set_local_function_table)(mexLocalFunctionTable);\n\n\n#if defined(TARGET_API_VERSION)\n#if !(TARGET_API_VERSION == 700 || TARGET_API_VERSION == 800)\n#error invalid TARGET_VERSION_API definition\n#elif defined(MEX_DOUBLE_HANDLE) && TARGET_API_VERSION != 700\n#error It is illegal to use MEX_DOUBLE_HANDLE with linear versioning\n#elif defined(MX_COMPAT_32) && TARGET_API_VERSION != 700\n#error It is illegal to use MX_COMPAT_32 with linear versioning\n#endif\n#endif\n\n\n#if !defined(TARGET_API_VERSION) || TARGET_API_VERSION == 700\n#ifndef MEX_DOUBLE_HANDLE\n#define mexCallMATLAB mexCallMATLABWithObject\n#define mexCallMATLABWithTrap mexCallMATLABWithTrapWithObject\n#define mexGetVariable mexGetVariableWithObject\n#define mexGet(a,b) \\\nNULL;do{mexGetIsDeprecated x;}while(0)\n#define mexSet(a,b,c) \\\n0;do{mexSetIsDeprecated x;}while(0)\n#endif /* MEX_DOUBLE_HANDLE */\n#define mexSetTrapFlag(a) \\\n0;do{mexSetTrapFlagIsDeprecated x;}while(0)\n\n\n#elif TARGET_API_VERSION == 800\n\n#define mexCallMATLAB mexCallMATLAB_800\n#define mexCallMATLABWithTrap mexCallMATLABWithTrap_800\n#define mexEvalString mexEvalString_800\n#define mexEvalStringWithTrap mexEvalStringWithTrap_800\n#define mexGet mexGetIsDeprecated\n#define mexSet mexSetIsDeprecated\n#define mexGetVariable mexGetVariable_800\n#define mexGetVariablePtr mexGetVariablePtr_800\n#define mexPutVariable mexPutVariable_800\n#define mexPrintf mexPrintf_800\n#define mexSetTrapFlag mexSetTrapFlagIsDeprecated\n#define mexErrMsgIdAndTxt mexErrMsgIdAndTxt_800\n#define mexWarnMsgIdAndTxt mexWarnMsgIdAndTxt_800\n#define mexErrMsgTxt mexErrMsgTxt_800\n#define mexWarnMsgTxt mexWarnMsgTxt_800\n#define mexIsLocked mexIsLocked_800\n#define mexLock mexLock_800\n#define mexUnlock mexUnlock_800\n#define mexMakeArrayPersistent mexMakeArrayPersistent_800\n#define mexMakeMemoryPersistent mexMakeMemoryPersistent_800\n#define mexPrintAssertion mexPrintAssertion_800\n#define mexIsGlobal mexIsGlobal_800\n#define mexFunctionName mexFunctionName_800\n#define mexAtExit mexAtExit_800\n\n#endif /* TARGET_API_VERSION */\n/*\n * Issue error message and return to MATLAB prompt\n */\nLIBMWMEX_API_EXTERN_C void mexErrMsgTxt(\n    const char\t*error_msg\t/* string with error message */\n    );\n\n\n/*\n * Issue formatted error message with corresponding error identifier and return to MATLAB\n * prompt.\n */\nLIBMWMEX_API_EXTERN_C void mexErrMsgIdAndTxt(\n    const char * identifier, /* string with error message identifier */\n    const char * err_msg,    /* string with error message printf-style format */\n    ...                      /* any additional arguments */\n    );\n\n\n/*\n * Invoke an unidentified warning. Such warnings can only be affected by the M-code\n * 'warning * all', since they have no specific identifier. See also mexWarnMsgIdAndTxt.\n */\nLIBMWMEX_API_EXTERN_C void mexWarnMsgTxt(\n    const char\t*warn_msg\t/* string with warning message */\n    );\n\n\n/*\n * Invoke a warning with message identifier 'identifier' and message derived from 'fmt' and\n * subsequent arguments. The warning may either get printed as is (if it is set to 'on'), or\n * not actually get printed (if set to 'off'). See 'help warning' in MATLAB for more\n * details.\n */\nLIBMWMEX_API_EXTERN_C void mexWarnMsgIdAndTxt(\n    const char * identifier,    /* string with warning message identifer */\n    const char * warn_msg,\t/* string with warning message printf-style format */\n    ...                         /* any additional arguments */\n    );\n\n\n/*\n * mex equivalent to MATLAB's \"disp\" function\n */\nLIBMWMEX_API_EXTERN_C int mexPrintf(\n    const char\t*fmt,\t/* printf style format */\n    ...\t\t\t\t/* any additional arguments */\n    );\n\n\n#define printf mexPrintf\n\n\n/*\n * Remove all components of an array plus the array header itself\n * from MATLAB's memory allocation list.  The array will now\n * persist between calls to the mex function.  To destroy this\n * array, you will need to explicitly call mxDestroyArray().\n */\nLIBMWMEX_API_EXTERN_C void mexMakeArrayPersistent(\n    mxArray *pa              /* pointer to array */\n    );\n\n\n/*\n * Remove memory previously allocated via mxCalloc from MATLAB's\n * memory allocation list.  To free this memory, you will need to\n * explicitly call mxFree().\n */\nLIBMWMEX_API_EXTERN_C void mexMakeMemoryPersistent(void *ptr);\n\n\n/*\n * call MATLAB function\n */\nLIBMWMEX_API_EXTERN_C int mexCallMATLAB(\n    int\t\tnlhs,\t\t\t/* number of expected outputs */\n    mxArray\t*plhs[],\t\t/* pointer array to outputs */\n    int\t\tnrhs,\t\t\t/* number of inputs */\n    mxArray\t*prhs[],\t\t/* pointer array to inputs */\n    const char\t*fcn_name\t\t/* name of function to execute */\n    );\n\n\n/*\n * call MATLAB function with Trap\n */\nLIBMWMEX_API_EXTERN_C mxArray\t*mexCallMATLABWithTrap(\n    int         nlhs,       /* number of expected outputs */\n    mxArray     *plhs[],    /* pointer array to outputs */\n    int         nrhs,       /* number of inputs */\n    mxArray     *prhs[],    /* pointer array to inputs */\n    const char  *fcn_name   /* name of function to execute */\n    );\n\n\n/*\n * Print an assertion-style error message and return control to the\n * MATLAB command line.\n */\nLIBMWMEX_API_EXTERN_C void mexPrintAssertion(\n    const char *test,\n    const char *fname,\n    int linenum,\n    const char *message);\n\n\n/*\n * This function is deprecated and always return false.\n */\nLIBMWMEX_API_EXTERN_C bool mexIsGlobal(const mxArray *pA);\n\n\n/*\n * Place a copy of the array value into the specified workspace with the\n * specified name\n */\nLIBMWMEX_API_EXTERN_C int mexPutVariable(\n    const char *workspace,\n    const char *name,\n    const mxArray *parray\t\t/* matrix to copy */\n    );\n\n\n/*\n * return a pointer to the array value with the specified variable\n * name in the specified workspace\n */\nLIBMWMEX_API_EXTERN_C const mxArray *mexGetVariablePtr(\n    const char *workspace,\n    const char *name\t\t/* name of symbol */\n    );\n\n\n/*\n * return a copy of the array value with the specified variable\n * name in the specified workspace\n */\nLIBMWMEX_API_EXTERN_C mxArray *mexGetVariable(\n    const char\t*workspace,\n    const char  *name                /* name of variable in question */\n    );\n\n\n/*\n * Lock a MEX-function so that it cannot be cleared from memory.\n */\nLIBMWMEX_API_EXTERN_C void mexLock(void);\n\n\n/*\n * Unlock a locked MEX-function so that it can be cleared from memory.\n */\nLIBMWMEX_API_EXTERN_C void mexUnlock(void);\n\n\n/*\n * Return true if the MEX-function is currently locked, false otherwise.\n */\nLIBMWMEX_API_EXTERN_C bool mexIsLocked(void);\n\n\n/*\n * Return the name of a the MEXfunction currently executing.\n */\nLIBMWMEX_API_EXTERN_C const char *mexFunctionName(void);\n\n\n/*\n * Parse and execute MATLAB syntax in string.  Returns zero if successful,\n * and a non zero value if an error occurs.\n */\nLIBMWMEX_API_EXTERN_C int mexEvalString(\n    const char *str\t   /* matlab command string */\n    );\n\n\n/*\n * Parse and execute MATLAB syntax in string.  Returns NULL if successful,\n * and an MException if an error occurs.\n */\nLIBMWMEX_API_EXTERN_C mxArray* mexEvalStringWithTrap(\n    const char *str\t   /* matlab command string */\n    );\n\n\n/*\n * Register Mex-file's At-Exit function (accessed via MEX callback)\n */\nLIBMWMEX_API_EXTERN_C int mexAtExit(mex_exit_fn exit_fcn);\n#ifdef MEX_DOUBLE_HANDLE\n\n/* API interface which mimics the \"get\" function */\nLIBMWMEX_API_EXTERN_C const mxArray *mexGet(double handle, const char *property);\n\n\n/*\n * mex equivalent to MATLAB's \"set\" function\n */ \nLIBMWMEX_API_EXTERN_C int mexSet(double handle, const char *property, mxArray *value);\n\n#endif\n\n\nMEXFUNCTION_LINKAGE\n/*\n * mexFunction is the user-defined C routine that is called upon invocation\n * of a MEX-function.\n */\nvoid mexFunction(\n    int           nlhs,           /* number of expected outputs */\n    mxArray       *plhs[],        /* array of pointers to output arguments */\n    int           nrhs,           /* number of inputs */\n    const mxArray *prhs[]         /* array of pointers to input arguments */\n    );\n\n#endif /* mex_h */\n"},{"name":"mwmathutil.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"#if defined(_MSC_VER) || __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3)\n#pragma once\n#endif\n\n#ifndef mwmathutil_h\n#define mwmathutil_h\n\n/* Copyright 2003-2016 The MathWorks, Inc. */\n\n/* Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n\n#ifdef __cplusplus\n  #define EXTERN_C extern \"C\"\n#else\n  #define EXTERN_C extern\n#endif\n\n#endif\n\n#include \"tmwtypes.h\"\n\n\n/* abs(a) */\nEXTERN_C double muDoubleScalarAbs(double a);\n\n\n/* ceil(a) */\nEXTERN_C double muDoubleScalarCeil(double a);\n\n\n/* floor(a) */\nEXTERN_C double muDoubleScalarFloor(double a);\n\n\n/* round(a) */\nEXTERN_C double muDoubleScalarRound(double a);\n\n\n/* fix(a) */\nEXTERN_C double muDoubleScalarFix(double xr);\n\n\n/* acos(a) */\nEXTERN_C double muDoubleScalarAcos(double a);\n\n\n/* acosh(a) */\nEXTERN_C double muDoubleScalarAcosh(double a);\n\n\n/* asin(a) */\nEXTERN_C double muDoubleScalarAsin(double a);\n\n\n/* asinh(a) */\nEXTERN_C double muDoubleScalarAsinh(double a);\n\n\n/* atan(a) */\nEXTERN_C double muDoubleScalarAtan(double a);\n\n\n/* atanh(a) */\nEXTERN_C double muDoubleScalarAtanh(double a);\n\n\n/* cos(a) */\nEXTERN_C double muDoubleScalarCos(double a);\n\n/* cosh(a) */\nEXTERN_C double muDoubleScalarCosh(double a);\n\n\n/* exp(a) */\t\nEXTERN_C double muDoubleScalarExp(double a);\n\n\n/* log */\n/*A warning 'Log of zero' should be issued by users for a = 0 */\nEXTERN_C double muDoubleScalarLog(double a);\n\n\n/* log10 */\n/*A warning 'Log of zero' should be issued by users for a = 0 */\nEXTERN_C double muDoubleScalarLog10(double a);\n\n\n/* atan2(a,b) */\nEXTERN_C double muDoubleScalarAtan2(double a, double b);\n\n\n/* max(a,b) */\nEXTERN_C double muDoubleScalarMax(double a, double b);\n\n\n/* min(a,b) */\nEXTERN_C double muDoubleScalarMin(double a, double b);\n\n\n/* power(a,b) */\nEXTERN_C double muDoubleScalarPower(double a, double b);\n\n\n/* sin(a) */\nEXTERN_C double muDoubleScalarSin(double a);\n\n\n/* [s,c] = sincos(a) */\nEXTERN_C void muDoubleScalarSinCos(double a, double* s, double* c);\n\n\n/* sign(a) */\nEXTERN_C double muDoubleScalarSign(double a);\n\n\n/* sinh(a) */\nEXTERN_C double muDoubleScalarSinh(double a);\n\n\n/* sqrt(a) */\nEXTERN_C double muDoubleScalarSqrt(double a);\n\n\n/* tan(a) */\nEXTERN_C double muDoubleScalarTan(double a);\n\n\n/* tanh(a) */\nEXTERN_C double muDoubleScalarTanh(double a);\n\n\n/* mod(a,b) */\nEXTERN_C double muDoubleScalarMod(double a, double b);\n\n\n/* rem(a,b) */\nEXTERN_C double muDoubleScalarRem(double a, double b);\n\n\n/* hypot(a,b) */\nEXTERN_C double muDoubleScalarHypot(double a,double b);\n\n/* frexp(a,b) */\nEXTERN_C double muDoubleScalarFrexp(double x, int *eptr);\n\n\n/* abs(cmplx a) */\nEXTERN_C double muDoubleComplexScalarAbs(double xr, double xi);\n\n/* [br, bi] = exp(ar, ai) */\nEXTERN_C void muDoubleComplexScalarExp(double *pyr, double *pyi, double xr, double xi);\n\n/* hypot(ar, ai) */\nEXTERN_C double muDoubleComplexScalarHypot(double ar, double ai, double br, double bi);\n\n/* [br, bi] = log(ar, ai) */\nEXTERN_C void muDoubleComplexScalarLog(double *pyr, double *pyi, double xr, double xi);\n\n/* [cr, ci] = power(ar, ai, br, bi) */\nEXTERN_C void muDoubleComplexScalarPower(double *cr, double *ci, double ar, double ai, double br, double bi);\n\n/* [br, bi] = sqrt(ar, ai) */\nEXTERN_C void muDoubleComplexScalarSqrt(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = sign(ar, ai) */\nEXTERN_C void muDoubleComplexScalarSign(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = sin(ar, ai) */\nEXTERN_C void muDoubleComplexScalarSin(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = cos(ar, ai) */\nEXTERN_C void muDoubleComplexScalarCos(double *br, double *bi, double ar, double ai);\n\n/* y = cos(x) */\nEXTERN_C void muDoubleComplexScalarCos2(creal_T* y, creal_T* x);\n\n/* [Sr, Si, Cr, Ci] = sincos(ar, ai) */\nEXTERN_C void muDoubleComplexScalarSinCos(double *pySr, double *pySi, double *pyCr, double *pyCi,\n                                          double xr, double xi);\n\n/* [br, bi] = tan(ar, ai) */\nEXTERN_C void muDoubleComplexScalarTan(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = atan(ar, ai) */\nEXTERN_C void muDoubleComplexScalarAtan(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = asin(ar, ai) */\nEXTERN_C void muDoubleComplexScalarAsin(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = acos(ar, ai) */\nEXTERN_C void muDoubleComplexScalarAcos(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = sinh(ar, ai) */\nEXTERN_C void muDoubleComplexScalarSinh(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = cosh(ar, ai) */\nEXTERN_C void muDoubleComplexScalarCosh(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = tanh(ar, ai) */\nEXTERN_C void muDoubleComplexScalarTanh(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = asinh(ar, ai) */\nEXTERN_C void muDoubleComplexScalarAsinh(double *br, double *bi, double ar, double ai);\n\n/* [br, bi] = acosh(ar, ai) */\nEXTERN_C void muDoubleComplexScalarAcosh(double *br, double *bi, double ar, double ai);\n\n/* y = complexmultiply(u1, u2) */\nEXTERN_C void muDoubleComplexScalarMultiply(creal_T *y, const creal_T *u1, const creal_T *u2); \n\n\n/* Single-precision functions */\n\n\n/* abs(a) */\nEXTERN_C float muSingleScalarAbs(float a);\n\n\n/* ceil(a) */\nEXTERN_C float muSingleScalarCeil(float a);\n\n\n/* floor(a) */\nEXTERN_C float muSingleScalarFloor(float a);\n\n\n/* round(a) */\nEXTERN_C float muSingleScalarRound(float a);\n\n\n/* fix(a) */\nEXTERN_C float muSingleScalarFix(float xr);\n\n\n/* acos(a) */\nEXTERN_C float muSingleScalarAcos(float a);\n\n\n/* acosh(a) */\nEXTERN_C float muSingleScalarAcosh(float a);\n\n\n/* asin(a) */\nEXTERN_C float muSingleScalarAsin(float a);\n\n\n/* asinh(a) */\nEXTERN_C float muSingleScalarAsinh(float a);\n\n\n/* atan(a) */\nEXTERN_C float muSingleScalarAtan(float a);\n\n\n/* atanh(a) */\nEXTERN_C float muSingleScalarAtanh(float a);\n\n\n/* cos(a) */\nEXTERN_C float muSingleScalarCos(float a);\n\n\n/* cosh(a) */\nEXTERN_C float muSingleScalarCosh(float a);\n\n\n/* exp(a) */\t\nEXTERN_C float muSingleScalarExp(float a);\n\n\n/* log */\n/*A warning 'Log of zero' should be issued by users for a = 0 */\nEXTERN_C float muSingleScalarLog(float a);\n\n\n/* log10 */\n/*A warning 'Log of zero' should be issued by users for a = 0 */\nEXTERN_C float muSingleScalarLog10(float a);\n\n\n/* atan2(a,b) */\nEXTERN_C float muSingleScalarAtan2(float a, float b);\n\n\n/* max(a,b) */\nEXTERN_C float muSingleScalarMax(float a, float b);\n\n\n/* min(a,b) */\nEXTERN_C float muSingleScalarMin(float a, float b);\n\n\n/* power(a,b) */\nEXTERN_C float muSingleScalarPower(float a, float b);\n\n\n/* sin(a) */\nEXTERN_C float muSingleScalarSin(float a);\n\n\n/* [s,c] = sincos(a) */\nEXTERN_C void muSingleScalarSinCos(float a, float* s, float* c);\n\n\n/* sign(a) */\nEXTERN_C float muSingleScalarSign(float a);\n\n\n/* sinh(a) */\nEXTERN_C float muSingleScalarSinh(float a);\n\n\n/* sqrt(a) */\nEXTERN_C float muSingleScalarSqrt(float a);\n\n\n/* tan(a) */\nEXTERN_C float muSingleScalarTan(float a);\n\n\n/* tanh(a) */\nEXTERN_C float muSingleScalarTanh(float a);\n\n\n/* mod(a,b) */\nEXTERN_C float muSingleScalarMod(float a, float b);\n\n\n/* rem(a,b) */\nEXTERN_C float muSingleScalarRem(float a, float b);\n\n\n/* hypot(a,b) */\nEXTERN_C float muSingleScalarHypot(float a,float b);\n\n/* frexp(a,b) */\nEXTERN_C float muSingleScalarFrexp(float x, int *eptr);\n\n/* abs(cmplx a) */\nEXTERN_C float muSingleComplexScalarAbs(float xr, float xi);\n\n/* [br, bi] = exp(ar, ai) */\nEXTERN_C void muSingleComplexScalarExp(float *pyr, float *pyi, float xr, float xi);\n\n/* hypot(ar, ai) */\nEXTERN_C float muSingleComplexScalarHypot(float ar, float ai, float br, float bi);\n\n/* [br, bi] = log(ar, ai) */\nEXTERN_C void muSingleComplexScalarLog(float *pyr, float *pyi, float xr, float xi);\n\n/* [cr, ci] = power(ar, ai, br, bi) */\nEXTERN_C void muSingleComplexScalarPower(float *cr, float *ci, float ar, float ai, float br, float bi);\n\n/* [br, bi] = sqrt(ar, ai) */\nEXTERN_C void muSingleComplexScalarSqrt(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = sign(ar, ai) */\nEXTERN_C void muSingleComplexScalarSign(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = sin(ar, ai) */\nEXTERN_C void muSingleComplexScalarSin(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = cos(ar, ai) */\nEXTERN_C void muSingleComplexScalarCos(float *br, float *bi, float ar, float ai);\n\n/* y = cos(x) */\nEXTERN_C void muSingleComplexScalarCos2(creal32_T* y, creal32_T* x);\n\n/* [Sr, Si, Cr, Ci] = sincos(ar, ai) */\nEXTERN_C void muSingleComplexScalarSinCos(float *pySr, float *pySi, float *pyCr, float *pyCi,\n                                          float xr, float xi);\n\n/* [br, bi] = tan(ar, ai) */\nEXTERN_C void muSingleComplexScalarTan(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = atan(ar, ai) */\nEXTERN_C void muSingleComplexScalarAtan(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = asin(ar, ai) */\nEXTERN_C void muSingleComplexScalarAsin(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = acos(ar, ai) */\nEXTERN_C void muSingleComplexScalarAcos(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = sinh(ar, ai) */\nEXTERN_C void muSingleComplexScalarSinh(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = cosh(ar, ai) */\nEXTERN_C void muSingleComplexScalarCosh(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = tanh(ar, ai) */\nEXTERN_C void muSingleComplexScalarTanh(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = asinh(ar, ai) */\nEXTERN_C void muSingleComplexScalarAsinh(float *br, float *bi, float ar, float ai);\n\n/* [br, bi] = acosh(ar, ai) */\nEXTERN_C void muSingleComplexScalarAcosh(float *br, float *bi, float ar, float ai);\n\n/* y = complexmultiply(u1, u2) */\nEXTERN_C void muSingleComplexScalarMultiply(creal32_T *y, const creal32_T *u1, const creal32_T *u2);\n\n#ifdef __WATCOMC__\n#pragma aux muDoubleScalarAbs value [8087];\n#pragma aux muDoubleScalarCeil value [8087];\n#pragma aux muDoubleScalarFloor value [8087];\n#pragma aux muDoubleScalarRound value [8087];\n#pragma aux muDoubleScalarAcos value [8087];\n#pragma aux muDoubleScalarAcosh value [8087];\n#pragma aux muDoubleScalarAsin value [8087];\n#pragma aux muDoubleScalarAsinh value [8087];\n#pragma aux muDoubleScalarAtan value [8087];\n#pragma aux muDoubleScalarAtanh value [8087];\n#pragma aux muDoubleScalarCos value [8087];\n#pragma aux muDoubleScalarCosh value [8087];\n#pragma aux muDoubleScalarExp value [8087];\n#pragma aux muDoubleScalarLog value [8087];\n#pragma aux muDoubleScalarLog10 value [8087];\n#pragma aux muDoubleScalarAtan2 value [8087]\n#pragma aux muDoubleScalarMax value [8087]\n#pragma aux muDoubleScalarMin value [8087]\n#pragma aux muDoubleScalarPower value [8087]\n#pragma aux muDoubleScalarSin value [8087];\n#pragma aux muDoubleScalarSinCos value [8087];\n#pragma aux muDoubleScalarSign value [8087];\n#pragma aux muDoubleScalarSinh value [8087];\n#pragma aux muDoubleScalarSqrt value [8087];\n#pragma aux muDoubleScalarTan value [8087];\n#pragma aux muDoubleScalarTanh value [8087];\n#pragma aux muDoubleScalarMod value [8087]\n#pragma aux muDoubleScalarRem value [8087]\n#pragma aux muDoubleScalarHypot value [8087];\n#pragma aux muDoubleScalarFix value [8087];\n#pragma aux muDoubleScalarFrexp value [8087];\n#pragma aux muDoubleComplexScalarAbs value [8087];\n#pragma aux muDoubleComplexScalarExp value [8087];\n#pragma aux muDoubleComplexScalarHypot value [8087];\n#pragma aux muDoubleComplexScalarLog value [8087];\n#pragma aux muDoubleComplexScalarPower value [8087];\n#pragma aux muDoubleComplexScalarSqrt value [8087];\n#pragma aux muDoubleComplexScalarSign value [8087];\n#pragma aux muDoubleComplexScalarSin value [8087];\n#pragma aux muDoubleComplexScalarCos value [8087];\n#pragma aux muDoubleComplexScalarSinCos value [8087];\n#pragma aux muDoubleComplexScalarTan value [8087];\n#pragma aux muDoubleComplexScalarAtan value [8087];\n#pragma aux muDoubleComplexScalarAsin value [8087];\n#pragma aux muDoubleComplexScalarAcos value [8087];\n#pragma aux muDoubleComplexScalarSinh value [8087];\n#pragma aux muDoubleComplexScalarCosh value [8087];\n#pragma aux muDoubleComplexScalarTanh value [8087];\n#pragma aux muDoubleComplexScalarAsinh value [8087];\n#pragma aux muDoubleComplexScalarAcosh value [8087];\n#pragma aux muSingleScalarAbs value [8087];\n#pragma aux muSingleScalarCeil value [8087];\n#pragma aux muSingleScalarFloor value [8087];\n#pragma aux muSingleScalarRound value [8087];\n#pragma aux muSingleScalarAcos value [8087];\n#pragma aux muSingleScalarAcosh value [8087];\n#pragma aux muSingleScalarAsin value [8087];\n#pragma aux muSingleScalarAsinh value [8087];\n#pragma aux muSingleScalarAtan value [8087];\n#pragma aux muSingleScalarAtanh value [8087];\n#pragma aux muSingleScalarCos value [8087];\n#pragma aux muSingleScalarCosh value [8087];\n#pragma aux muSingleScalarExp value [8087];\n#pragma aux muSingleScalarLog value [8087];\n#pragma aux muSingleScalarLog10 value [8087];\n#pragma aux muSingleScalarAtan2 value [8087]\n#pragma aux muSingleScalarMax value [8087]\n#pragma aux muSingleScalarMin value [8087]\n#pragma aux muSingleScalarPower value [8087]\n#pragma aux muSingleScalarSin value [8087];\n#pragma aux muSingleScalarSinCos value [8087];\n#pragma aux muSingleScalarSign value [8087];\n#pragma aux muSingleScalarSinh value [8087];\n#pragma aux muSingleScalarSqrt value [8087];\n#pragma aux muSingleScalarTan value [8087];\n#pragma aux muSingleScalarTanh value [8087];\n#pragma aux muSingleScalarMod value [8087]\n#pragma aux muSingleScalarRem value [8087]\n#pragma aux muSingleScalarHypot value [8087];\n#pragma aux muSingleScalarFix value [8087];\n#pragma aux muSingleScalarFrexp value [8087];\n#pragma aux muSingleComplexScalarAbs value [8087];\n#pragma aux muSingleComplexScalarExp value [8087];\n#pragma aux muSingleComplexScalarHypot value [8087];\n#pragma aux muSingleComplexScalarLog value [8087];\n#pragma aux muSingleComplexScalarPower value [8087];\n#pragma aux muSingleComplexScalarSqrt value [8087];\n#pragma aux muSingleComplexScalarSign value [8087];\n#pragma aux muSingleComplexScalarSin value [8087];\n#pragma aux muSingleComplexScalarCos value [8087];\n#pragma aux muSingleComplexScalarSinCos value [8087];\n#pragma aux muSingleComplexScalarTan value [8087];\n#pragma aux muSingleComplexScalarAtan value [8087];\n#pragma aux muSingleComplexScalarAsin value [8087];\n#pragma aux muSingleComplexScalarAcos value [8087];\n#pragma aux muSingleComplexScalarSinh value [8087];\n#pragma aux muSingleComplexScalarCosh value [8087];\n#pragma aux muSingleComplexScalarTanh value [8087];\n#pragma aux muSingleComplexScalarAsinh value [8087];\n#pragma aux muSingleComplexScalarAcosh value [8087];\n#endif\n\n/* Integer Scalar functions. */\n/* Integer Abs Family. */\nEXTERN_C uint8_T muIntScalarAbs_uint8(uint8_T a);\n\nEXTERN_C int8_T muIntScalarAbs_sint8(int8_T a);\n\nEXTERN_C uint16_T muIntScalarAbs_uint16(uint16_T a);\n\nEXTERN_C int16_T muIntScalarAbs_sint16(int16_T a);\n\nEXTERN_C uint32_T muIntScalarAbs_uint32(uint32_T a);\n\nEXTERN_C int32_T muIntScalarAbs_sint32(int32_T a);\n\n/* Integer Max Family. */\nEXTERN_C uint8_T muIntScalarMax_uint8(uint8_T a, uint8_T b);\n\nEXTERN_C int8_T muIntScalarMax_sint8(int8_T a, int8_T b);\n\nEXTERN_C uint16_T muIntScalarMax_uint16(uint16_T a, uint16_T b);\n\nEXTERN_C int16_T muIntScalarMax_sint16(int16_T a, int16_T b);\n\nEXTERN_C uint32_T muIntScalarMax_uint32(uint32_T a, uint32_T b);\n\nEXTERN_C int32_T muIntScalarMax_sint32(int32_T a, int32_T b);\n\n/* Integer Min Family. */\nEXTERN_C uint8_T muIntScalarMin_uint8(uint8_T a, uint8_T b);\n\nEXTERN_C int8_T muIntScalarMin_sint8(int8_T a, int8_T b);\n\nEXTERN_C uint16_T muIntScalarMin_uint16(uint16_T a, uint16_T b);\n\nEXTERN_C int16_T muIntScalarMin_sint16(int16_T a, int16_T b);\n\nEXTERN_C uint32_T muIntScalarMin_uint32(uint32_T a, uint32_T b);\n\nEXTERN_C int32_T muIntScalarMin_sint32(int32_T a, int32_T b);\n\n/* Integer Mod Family. */\nEXTERN_C uint8_T muIntScalarMod_uint8(uint8_T a, uint8_T b);\n\nEXTERN_C int8_T muIntScalarMod_sint8(int8_T a, int8_T b);\n\nEXTERN_C uint16_T muIntScalarMod_uint16(uint16_T a, uint16_T b);\n\nEXTERN_C int16_T muIntScalarMod_sint16(int16_T a, int16_T b);\n\nEXTERN_C uint32_T muIntScalarMod_uint32(uint32_T a, uint32_T b);\n\nEXTERN_C int32_T muIntScalarMod_sint32(int32_T a, int32_T b);\n\n/* Integer Rem Family. */\nEXTERN_C uint8_T muIntScalarRem_uint8(uint8_T a, uint8_T b);\n\nEXTERN_C int8_T muIntScalarRem_sint8(int8_T a, int8_T b);\n\nEXTERN_C uint16_T muIntScalarRem_uint16(uint16_T a, uint16_T b);\n\nEXTERN_C int16_T muIntScalarRem_sint16(int16_T a, int16_T b);\n\nEXTERN_C uint32_T muIntScalarRem_uint32(uint32_T a, uint32_T b);\n\nEXTERN_C int32_T muIntScalarRem_sint32(int32_T a, int32_T b);\n\n/* Integer Sign Family. */\nEXTERN_C uint8_T muIntScalarSign_uint8(uint8_T a);\n\nEXTERN_C int8_T muIntScalarSign_sint8(int8_T a);\n\nEXTERN_C uint16_T muIntScalarSign_uint16(uint16_T a);\n\nEXTERN_C int16_T muIntScalarSign_sint16(int16_T a);\n\nEXTERN_C uint32_T muIntScalarSign_uint32(uint32_T a);\n\nEXTERN_C int32_T muIntScalarSign_sint32(int32_T a);\n\n/* isFinite(a) */\nEXTERN_C boolean_T muDoubleScalarIsFinite(double a);\n\n/* isNaN(a) */\nEXTERN_C boolean_T muDoubleScalarIsNaN(double a);\n\n/* isInf(a) */\nEXTERN_C boolean_T muDoubleScalarIsInf(double a);\n\n/* isFinite(ar, ai) */\nEXTERN_C boolean_T muDoubleComplexScalarIsFinite(double ar, double ai);\n\n/* isNaN(a) */\nEXTERN_C boolean_T muDoubleComplexScalarIsNaN(double ar, double ai);\n\n/* isInf(ar, ai) */\nEXTERN_C boolean_T muDoubleComplexScalarIsInf(double ar, double ai);\n\n\n/* Single-precision functions */\n\n/* isFinite(a) */\nEXTERN_C boolean_T muSingleScalarIsFinite(float a);\n\n/* isNaN(a) */\nEXTERN_C boolean_T muSingleScalarIsNaN(float a);\n\n/* isInf(a) */\nEXTERN_C boolean_T muSingleScalarIsInf(float a);\n\n/* isFinite(ar, ai) */\nEXTERN_C boolean_T muSingleComplexScalarIsFinite(float ar, float ai);\n\n/* isNaN(a) */\nEXTERN_C boolean_T muSingleComplexScalarIsNaN(float ar, float ai);\n\n/* isInf(ar, ai) */\nEXTERN_C boolean_T muSingleComplexScalarIsInf(float ar, float ai);\n\n\n#endif /* mwmathutil_h */\n"},{"name":"mwservices.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/* DEPRECATED.  Intentionally empty. */\n"},{"name":"mwslpointerutil.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"#if defined(_MSC_VER) || __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3)\n#pragma once\n#endif\n\n#ifndef mwslpointerutil_published_h\n#define mwslpointerutil_published_h\n\n/* Copyright 2020-2021 The MathWorks, Inc. */\n\n/* Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n#define EXTERN_C extern\n#endif\n\n// ParamTuningAppSvc can be compiled with either tmwtypes or rtwtypes\n#ifdef IS_RAPID_ACCEL\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\nEXTERN_C void storeArrayInPointerPool(void* dst, const void* src, int32_T numBytes);\n\n#endif /* mwslpointerutil_published_h */\n"},{"name":"mwstringutil.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"#if defined(_MSC_VER) || __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3)\n#pragma once\n#endif\n\n#ifndef mwstringutil_published_h\n#define mwstringutil_published_h\n\n/* Copyright 2003-2017 The MathWorks, Inc. */\n\n/* Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n#endif\n\n#ifdef __cplusplus\n#include <cstdarg>\n#else\n#include <stdarg.h>\n#endif\n\n#include \"tmwtypes.h\"\n#include \"matrix.h\"\n\nEXTERN_C void suAsciiToStr(void* outstr, const uint8_T* in, int32_T n);\nEXTERN_C void suStrToAscii(uint8_T* out, int32_T n, const void* instr);\n\nEXTERN_C int32_T suStrcmp(const void* str1, const void* str2);\nEXTERN_C int32_T suStrcmpi(const void* str1, const void* str2);\nEXTERN_C int32_T suStrncmp(const void* str1, const void* str2, int32_T n);\nEXTERN_C int32_T suStrncmpi(const void* str1, const void* str2, int32_T n);\nEXTERN_C int32_T suCStrcmp(const void* str, const char* cstr);\n\nEXTERN_C int32_T suStrlen(const void* instr);\nEXTERN_C int32_T suStrfind(const void* text, const void* pattern);\nEXTERN_C void suSubstr(void* outstr, const void* instr, int32_T pos, int32_T len);\nEXTERN_C void suSubstrToEnd(void* outstr, const void* instr, int32_T pos);\nEXTERN_C void suStrcat(void* outstr, int32_T n, ...);\n\nEXTERN_C void suNumericToString_bool(void* outstr, bool x);\nEXTERN_C void suNumericToString_int8(void* outstr, int8_T x);\nEXTERN_C void suNumericToString_int16(void* outstr, int16_T x);\nEXTERN_C void suNumericToString_int32(void* outstr, int32_T x);\nEXTERN_C void suNumericToString_int64(void* outstr, int64_T x);\nEXTERN_C void suNumericToString_uint8(void* outstr, uint8_T x);\nEXTERN_C void suNumericToString_uint16(void* outstr, uint16_T x);\nEXTERN_C void suNumericToString_uint32(void* outstr, uint32_T x);\nEXTERN_C void suNumericToString_uint64(void* outstr, uint64_T x);\nEXTERN_C void suNumericToString_float(void* outstr, float x);\nEXTERN_C void suNumericToString_double(void* outstr, double x);\n\nEXTERN_C void suNumericToString_cint8(void* outstr, int8_T xr, int8_T xi);\nEXTERN_C void suNumericToString_cint16(void* outstr, int16_T xr, int16_T xi);\nEXTERN_C void suNumericToString_cint32(void* outstr, int32_T xr, int32_T xi);\nEXTERN_C void suNumericToString_cint64(void* outstr, int64_T xr, int64_T xi);\nEXTERN_C void suNumericToString_cuint8(void* outstr, uint8_T xr, uint8_T xi);\nEXTERN_C void suNumericToString_cuint16(void* outstr, uint16_T xr, uint16_T xi);\nEXTERN_C void suNumericToString_cuint32(void* outstr, uint32_T xr, uint32_T xi);\nEXTERN_C void suNumericToString_cuint64(void* outstr, uint64_T xr, uint64_T xi);\nEXTERN_C void suNumericToString_cfloat(void* outstr, float xr, float xi);\nEXTERN_C void suNumericToString_cdouble(void* outstr, double xr, double xi);\n\nEXTERN_C void suFromCStr(void* outstr, const char* incstr);\nEXTERN_C char* suToCStr(const void* instr);\n\nEXTERN_C void suSprintf_int8(void* outstr, const void* format, int8_T x);\nEXTERN_C void suSprintf_int16(void* outstr, const void* format, int16_T x);\nEXTERN_C void suSprintf_int32(void* outstr, const void* format, int32_T x);\nEXTERN_C void suSprintf_int64(void* outstr, const void* format, int64_T x);\nEXTERN_C void suSprintf_uint8(void* outstr, const void* format, uint8_T x);\nEXTERN_C void suSprintf_uint16(void* outstr, const void* format, uint16_T x);\nEXTERN_C void suSprintf_uint32(void* outstr, const void* format, uint32_T x);\nEXTERN_C void suSprintf_uint64(void* outstr, const void* format, uint64_T x);\nEXTERN_C void suSprintf_float(void* outstr, const void* format, float x);\nEXTERN_C void suSprintf_double(void* outstr, const void* format, double x);\nEXTERN_C void suSprintf_str(void* outstr, const void* format, const void* x);\n\nEXTERN_C int32_T suSscanf(const void* outstr, const void* format, ...);\n\nEXTERN_C void suResizeToOtherSizeAndZero(void* str, const void* str_other);\nEXTERN_C void suResizeToOtherSizePlusOne(void* str, const void* str_other);\nEXTERN_C void* suPointerToBuffer(void* str);\nEXTERN_C void suClipStrAtFirstNull(void* str);\n\nEXTERN_C void* suAddStackString(const char* initial);\nEXTERN_C int32_T suStringStackSize(void);\nEXTERN_C void suSetStringStackSize(int32_T);\nEXTERN_C void* suMoveReturnedStringToTopOfCallerStack(void* str, int32_T size);\nEXTERN_C void suMoveReturnedStringsToTopOfCallerStack(int32_T size, int32_T n, ...);\n\nEXTERN_C void suMoveString(void* dst_str, void* src_str);\nEXTERN_C void suCopyString(void* dst_str, const void* src_str);\nEXTERN_C void suTruncate(void* str, int32_T size);\n\n\nEXTERN_C void suInitializeSILStringOutput(void* dst);\nEXTERN_C void suWriteSILStringInput(char* sil_in, int32_T size, const void* src);\nEXTERN_C void suWriteSILStringOutput(void* dst, const char* sil_out, int32_T size);\n\nEXTERN_C void suInitializeString(void* dst, const char* initial);\nEXTERN_C void suInitializeStringFromMx(void* dst, const mxArray* initial);\n\nEXTERN_C int32_T suCount(const void* str1, const void* str2);\nEXTERN_C int32_T suCountI(const void* str1, const void* str2);\nEXTERN_C int32_T suContains(const void* str1, const void* str2);\nEXTERN_C int32_T suContainsI(const void* str1, const void* str2);\nEXTERN_C int32_T suStartsWith(const void* str1, const void* str2);\nEXTERN_C int32_T suStartsWithI(const void* str1, const void* str2);\nEXTERN_C int32_T suEndsWith(const void* str1, const void* str2);\nEXTERN_C int32_T suEndsWithI(const void* str1, const void* str2);\nEXTERN_C void suStripBoth(void* outstr, const void* str, char ch);\nEXTERN_C void suStripLeft(void* outstr, const void* str, char ch);\nEXTERN_C void suStripRight(void* outstr, const void* str, char ch);\nEXTERN_C void suReplace(void* outstr, void* str1, void* str2, void* str3);\nEXTERN_C void suReplaceBetweenIdxInclusive(void* outstr,\n                                           const void* str,\n                                           int32_T left,\n                                           int32_T right,\n                                           const void* newStr);\nEXTERN_C void suReplaceBetweenIdxExclusive(void* outstr,\n                                           const void* str,\n                                           int32_T left,\n                                           int32_T right,\n                                           const void* newStr);\nEXTERN_C void suReplaceBetweenSubstrExclusive(void* outstr,\n                                              const void* str,\n                                              const void* startStr,\n                                              const void* endStr,\n                                              const void* newStr);\nEXTERN_C void suReplaceBetweenSubstrInclusive(void* outstr,\n                                              const void* str,\n                                              const void* startStr,\n                                              const void* endStr,\n                                              const void* newStr);\n\n\n#endif /* mwstringutil_published_h */\n"},{"name":"odesup.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2008 The MathWorks, Inc.\n *\n * File: odesup.h     \n *\n * Abstract:\n *   \n */\n\n#ifndef __ODE_SUP__\n#define __ODE_SUP__\n\n#include <math.h>\n#include <stddef.h> /* needed for NULL */\n\n#include \"tmwtypes.h\"\n\n#ifdef RT_MALLOC\n# include <stdlib.h>\n#endif\n\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n\n#ifndef RT_MALLOC\n# ifndef NCSTATES\n#  error \"must define NCSTATES\"\n# endif\n#endif\n\nextern const char *RT_MEMORY_ALLOCATION_ERROR;\n\n#ifdef RT_MALLOC\n# define DERIVATIVES(si) rtmiDerivatives(*rtsiGetModelMethodsPtr(si))\n# define PROJECTION(si)  rtmiProjection(*rtsiGetModelMethodsPtr(si))\n# define OUTPUTS(si,tid) rtmiOutputs(*rtsiGetModelMethodsPtr(si),tid)\n#else\n# define DERIVATIVES(si) MdlDerivatives()\n# define OUTPUTS(si,tid) MdlOutputs(tid)\n# define PROJECTION(si)  MdlProjection()\n  extern void MdlDerivatives(void);\n  extern void MdlOutputs(int_T tid);\n  extern void MdlProjection(void);\n#endif\n\nvoid rt_ODEStateReduction(real_T* x, int_T* p, int_T n, real_T* r) {\n    int_T i, j;\n\n    for (i = 0, j = 0; i < n; ++i, ++j) {\n        int_T k = p[i];\n        real_T lb = r[j++];\n        real_T xk = x[k]-lb;\n        real_T rk = r[j]-lb;\n        int_T q = (int_T) floor(xk/rk);\n        if (q) {\n            x[k] = xk-q*rk+lb;\n        }\n    }\n}\n\n#define REDUCTION(si) if (rtsiGetNumPeriodicContStates(si) > 0)                     \\\n                          rt_ODEStateReduction(rtsiGetContStates(si),               \\\n                                               rtsiGetPeriodicContStateIndices(si), \\\n                                               rtsiGetNumPeriodicContStates(si),    \\\n                                               rtsiGetPeriodicContStateRanges(si))\n\n#ifndef USE_RTMODEL\n\nvoid rt_ODECreateIntegrationData(RTWSolverInfo *si);\nvoid rt_ODEDestroyIntegrationData(RTWSolverInfo *si);\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si);\n\nvoid rt_ODECacheDataIntoSolverInfo(SimStruct *S)\n{\n    RTWSolverInfo *si = ssGetRTWSolverInfo(S);\n    \n    if (si != NULL) {\n        rtsiSetSolverStopTime(si, ssGetSolverStopTime(S));\n        rtsiSetSolverName(si, ssGetSolverName(S));\n        rtsiSetSolverData(si, ssGetSolverData(S));\n    }\n}\n\nvoid rt_ODERetrieveDataFromSolverInfo(SimStruct *S)\n{\n    RTWSolverInfo *si = ssGetRTWSolverInfo(S);\n    \n    if (si != NULL) {\n        ssSetSolverStopTime(S, rtsiGetSolverStopTime(si));\n        ssSetSolverData(S, rtsiGetSolverData(si));\n        ssSetSolverName(S, rtsiGetSolverName(si));\n    }\n}\n\nconst char_T *rt_ODECreateSolverInfo(SimStruct *S)\n{\n    const char_T          *errStatus = NULL;\n    RTWSolverInfo         *si        = NULL;\n    RTWRTModelMethodsInfo *mmi       = NULL;\n    \n#ifndef RT_MALLOC\n    static RTWSolverInfo _si;\n    static RTWRTModelMethodsInfo _mdlMths;\n\n    si  = &_si;\n    mmi = &_mdlMths;\n#else\n    si = (RTWSolverInfo *)malloc(sizeof(RTWSolverInfo));\n    if (si == NULL) {\n        errStatus = RT_MEMORY_ALLOCATION_ERROR;\n        ssSetErrorStatus(S, RT_MEMORY_ALLOCATION_ERROR);\n        goto EXIT_POINT;\n    }\n\n    mmi = (RTWRTModelMethodsInfo *)malloc(sizeof(RTWRTModelMethodsInfo));\n    if (mmi == NULL) {\n        errStatus = RT_MEMORY_ALLOCATION_ERROR;\n        ssSetErrorStatus(S, RT_MEMORY_ALLOCATION_ERROR);\n        goto EXIT_POINT;\n    }\n#endif\n\n    rtsiSetModelMethodsPtr(si, mmi);\n    rtsiSetRTModelPtr(si, (void *)S);\n    rtmiSetRTModelPtr(*mmi, (void *)S);\n\n    ssSetRTWSolverInfo(S, si);\n    \n    /* \n     * The fields below need to be copied over at setup\n     * and copied back into the SimStruct at the end\n     */\n    rt_ODECacheDataIntoSolverInfo(S);\n    \n    /*\n     * The fields below only need to be setup. They are\n     * pointer fields and updating them will automatically\n     * update the owner SimStruct\n     */\n\n    /* Copy over a pointer to StepSize */\n    rtsiSetStepSizePtr(si, &ssGetStepSize(S));\n\n    /* Copy over a pointer to SimTimeStep */\n    rtsiSetSimTimeStepPtr(si, &ssGetSimTimeStep(S));\n\n    /* Copy over a pointer to the time pointer */\n    rtsiSetTPtr(si, &ssGetTPtr(S));\n\n    /* Copy over a pointer to the location of the derivs */\n    rtsiSetdXPtr(si, &ssGetdX(S));\n\n    /* Copy over a pointer to the location of the cont states */\n    rtsiSetContStatesPtr(si, &ssGetContStates(S));\n\n    /* Copy over a pointer to the location of the number of cont states */\n    rtsiSetNumContStatesPtr(si, ssGetNumContStatesPtr(S));\n\n    /* Copy over a pointer to the location of the wrapped cont states */\n    rtsiSetPeriodicContStateIndicesPtr(si, &ssGetPeriodicContStateIndices(S));\n    rtsiSetPeriodicContStateRangesPtr(si, &ssGetPeriodicContStateRanges(S));\n\n    /* Copy over a pointer to the location of the number of wrapped cont states */\n    rtsiSetNumPeriodicContStatesPtr(si, &ssGetNumPeriodicContStates(S));\n\n    /* Copy over a pointer to the location of the error status */\n    rtsiSetErrorStatusPtr(si, &ssGetErrorStatus(S));\n\n    /* Copy over the order of extrapolation method */\n    rtsiSetSolverExtrapolationOrder(si, ssGetSolverExtrapolationOrder(S));\n\n    /* Copy over the number of Newton iterations */\n    rtsiSetSolverNumberNewtonIterations(si, ssGetSolverNumberNewtonIterations(S));\n\n#ifdef RT_MALLOC\n  EXIT_POINT:\n#endif\n    return(errStatus);\n}\n\nvoid rt_CreateIntegrationData(SimStruct *S)\n{\n    if (rt_ODECreateSolverInfo(S) != NULL) {\n        return;\n    }\n\n    rt_ODECreateIntegrationData(ssGetRTWSolverInfo(S));\n    \n    rt_ODERetrieveDataFromSolverInfo(S);\n}\n\n#ifdef RT_MALLOC\nvoid rt_DestroyIntegrationData(SimStruct *S)\n{\n    RTWSolverInfo *si = NULL;\n    \n    rt_ODECacheDataIntoSolverInfo(S);\n\n    si = ssGetRTWSolverInfo(S);\n    \n    if (si != NULL) {\n        rt_ODEDestroyIntegrationData(si);\n        free(rtsiGetModelMethodsPtr(si));\n        free(si);\n        ssSetRTWSolverInfo(S, NULL);\n    }\n}\n#endif\n\nvoid rt_UpdateContinuousStates(SimStruct *S)\n{\n    rt_ODECacheDataIntoSolverInfo(S);\n    rt_ODEUpdateContinuousStates(ssGetRTWSolverInfo(S));\n    rt_ODERetrieveDataFromSolverInfo(S);\n}\n\n#endif\n#endif /* __ODE_SUP__ */\n"},{"name":"polygonBoolean.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * CONFIDENTIAL AND CONTAINING PROPRIETARY TRADE SECRETS\n * Copyright 2015-2017 The MathWorks, Inc.\n * The source code contained in this listing contains proprietary and\n * confidential trade secrets of The MathWorks, Inc.   The use, modification,\n * or development of derivative work based on the code or ideas obtained\n * from the code is prohibited without the express written permission of The\n * MathWorks, Inc.  The disclosure of this code to any party not authorized\n * by The MathWorks, Inc. is strictly forbidden.\n * CONFIDENTIAL AND CONTAINING PROPRIETARY TRADE SECRETS\n */\n\n#ifndef POLYFUN_POLYGON_BOOLEAN_H\n#define POLYFUN_POLYGON_BOOLEAN_H\n\n/**\n * This file is to support codegen, copied from emlrt.h\n * This file is published to (matlabroot)/extern/include\n */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n/*\n * Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n\n#endif\n\n#ifndef POLYFUN_MODULE_API\n#define POLYFUN_MODULE_API\n#endif\n\nEXTERN_C POLYFUN_MODULE_API \nvoid polyBoolean_c(double *x1, double *y1, int *size1,\n                   double *x2, double *y2, int *size2,\n                   double *input_scale_p, int *op_type,\n                   double *rx, double *ry, int *rn,\n                   double *pPgon, double *pCon, double *pIdx);\n#endif\n"},{"name":"pt_info.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2014 The MathWorks, Inc.\n *\n * File: pt_info.h     \n *\n * Abstract:\n *   Parameter tuning information.  For details about these structures\n *   see MATLAB/rtw/c/src/pt_readme.txt.\n */\n\n#ifndef __PT_INFO__\n#define __PT_INFO__\n\n#include \"rtwtypes.h\"\n\ntypedef enum {\n    rt_SCALAR,\n    rt_VECTOR,\n    rt_MATRIX_ROW_MAJOR,\n    rt_MATRIX_COL_MAJOR,\n    rt_MATRIX_COL_MAJOR_ND\n} ParamClass;\n\ntypedef enum {\n    rt_SL_PARAM,\n    rt_SF_PARAM,\n    rt_SHARED_PARAM\n} ParamSource;\n\ntypedef struct ParameterTuning_tag {\n    ParamClass  paramClass;   /* Class of parameter               */\n    int_T       nRows;        /* Number of rows                   */\n    int_T       nCols;        /* Number of columns                */\n    int_T       nDims;        /* Number of dimensions             */\n    int_T       dimsOffset;   /* Offset into dimensions vector    */\n    ParamSource source;       /* Source of parameter              */\n    uint_T      dataType;     /* data type enumeration            */\n    uint_T      numInstances; /* Number of parameter instances    */\n    int_T       mapOffset;    /* Offset into map vector           */\n} ParameterTuning;\n\ntypedef struct BlockTuning_tag {\n    const char_T      *blockName;   /* Block name                       */\n    const char_T      *paramName;   /* Parameter name                   */\n    ParameterTuning    ptRec;       /* Parameter tuning record          */\n} BlockTuning;\n\ntypedef struct VariableTuning_tag {\n    const char_T *varName;    /* Variable name                    */\n    ParameterTuning ptRec;    /* Parameter tuning record          */\n} VariableTuning;\n\n#define ptinfoGetClass(pt)            (pt)->paramClass\n#define ptinfoGetNumRows(pt)          (pt)->nRows\n#define ptinfoGetNumCols(pt)          (pt)->nCols\n#define ptinfoGetNumDimensions(pt)    (pt)->nDims\n#define ptinfoGetSource(pt)           (pt)->source\n#define ptinfoGetDataTypeEnum(pt)     (pt)->dataType\n#define ptinfoGetNumInstances(pt)     (pt)->numInstances\n#define ptinfoGetParametersOffset(pt) (pt)->mapOffset\n#define ptinfoGetDimensionsOffset(pt) (pt)->dimsOffset\n\n#endif  /* __PT_INFO__ */\n"},{"name":"rt_logging.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012-2020 The MathWorks, Inc. */\n\n#ifndef rt_logging_h\n#define rt_logging_h\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rtwtypes.h\"\n#include \"builtin_typeid_types.h\"\n#include \"multiword_types.h\"\n#ifdef IS_RAPID_ACCEL\n#include \"matrix.h\"\n#else\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n\n/*=========*\n * Defines *\n *=========*/\n\n/*\n * Logging related functions and data structures\n */\ntypedef double MatReal;                /* \"real\" data type used in model.mat  */\ntypedef struct LogVar_Tag LogVar;\ntypedef struct StructLogVar_Tag StructLogVar;\n\ntypedef struct MatrixData_Tag {\n  char_T         name[mxMAXNAM];     /* Name of the variable                  */\n  int_T          nRows;              /* number of rows                        */\n  int_T          nCols;              /* number of columns                     */\n  int_T          nDims;              /* number of dimensions                  */\n  int_T          _dims[2];           /* most cases, dimensions are 2          */\n  int_T          *dims;              /* dimensions of the log variable we \n                                        write to at each simulation time step.\n                                        E.g: (1) Non-frame data - \n                                                 Signal dimension = [2 X 3]\n                                                 numDims = 2\n                                                 dims[0] = 2, dims[1] = 3\n                                             (2) Frame data - \n                                                 Signal dimension = [2 X 3]\n                                                 numDims = 1\n                                                 dims[0] = 3                  */\n  void           *re;                /* pointer to real part of the data      */\n  void           *im;                /* pointer to imaginary part, if complex */\n  DTypeId        dTypeID;            /* data type id                          */\n  size_t         elSize;             /* element size in bytes                 */\n\n  RTWLogDataTypeConvert dataTypeConvertInfo;\n\n  mxClassID      mxID;               /* mxId corresponding to this dTypeID    */\n  uint32_T       logical;            /* is this a logical array ?             */\n  uint32_T       complex;            /* is this a complex matrix?             */\n  uint32_T       frameData;          /* is this data frame based?             */\n  uint32_T       frameSize;          /* is this data frame based?             */\n} MatrixData;\n\ntypedef struct ValDimsData_Tag {\n  char_T         name[mxMAXNAM];     /* Name of the variable                  */\n  int_T          nRows;              /* number of rows                        */\n  int_T          nCols;              /* number of columns                     */\n  void           **currSigDims;      /* dimensions of current output          */\n  int_T          *currSigDimsSize;   /* size in bytes of current sig dims     */\n  real_T         *dimsData;          /* pointer to the value of dimension     */\n} ValDimsData;\n\nstruct LogVar_Tag {\n    MatrixData  data;                 /* Container for name, data etc.,       */\n    ValDimsData *valDims;             /* field of valueDimensions\n                                       1. If all logging signals are fixed-size,\n                                          then we set this field to NULL;\n                                       2. If any logging signal is variable-size,\n                                          then this field will be needed:\n                                         1) For fixed-size signal, this field is\n                                            an empty matrix;\n                                         2) Otherwise, it contains the dimension\n                                            information of the logging signal.\n                                      */\n    int_T      rowIdx;                /* current row index                    */\n    int_T      wrapped;               /* number of times the circular buffer\n                                       * has wrapped around                   */\n    int_T     nDataPoints;            /* total number of data points logged   */\n    int_T     usingDefaultBufSize;    /* used to print a message at end       */\n    int_T     okayToRealloc;          /* reallocate during sim?               */\n    int_T     decimation;             /* decimation factor                    */\n    int_T     numHits;                /* decimation hit count                 */\n\n    int_T     *coords;\n    int_T     *strides;\n    int_T     *currStrides;           /* coords, strides and currStrides will be\n                                         needed when logging variable-size \n                                         signal to calculate whether the \n                                         currently logging value is in the range.\n                                         If the current signal is fixed-size,\n                                         these pointers will be set to NULLs;\n                                         otherwise, we allocate memory for them.\n                                         (the size will be nDims in this case)\n                                      */\n\n    LogVar    *next;\n};\n\ntypedef struct SignalsStruct_Tag {\n    int_T        numActiveFields;   /* number of active fields                */\n    const char_T *fieldNames;\n    int_T        numSignals;\n    LogVar       *values;\n    MatrixData   *dimensions;\n    MatrixData   *labels;\n    MatrixData   *plotStyles;\n    MatrixData   *titles;\n    MatrixData   *blockNames;\n    MatrixData   *stateNames;\n    MatrixData   *crossMdlRef;\n\n    boolean_T    logValueDimensions; /* If there's any variable-size signal \n                                         we also should log 'valueDimensions'\n                                         field                                 */\n    boolean_T    *isVarDims;         /* is this signal a variable-size signal? */\n\n} SignalsStruct;\n\nstruct StructLogVar_Tag {\n    char_T        name[mxMAXNAM];    /* Name of the ML Struct variable         */\n    int_T         numActiveFields;   /* number of active fields                */\n    boolean_T     logTime;\n    void          *time;\n    SignalsStruct signals;\n    MatrixData    *blockName;\n\n    StructLogVar  *next;\n};\n\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n/* status of logging \"valueDimensions\" field */\n/* \n  NO_LOGVALDIMS: \n                 No need to log valueDimensions: \n                 All signals are fixed-sized.\n\n  LOGVALDIMS_EMPTYMX: \n                 Signals with mixed dimension modes,\n                 and the signal logged currently\n                 is fixed-sized. So set valueDimensions\n                 field to an empty matrix.\n\n  LOGVALDIMS_VARDIMS:\n                 Signal logged currently is variable-sized.\n*/\ntypedef enum {\n    NO_LOGVALDIMS,      \n    LOGVALDIMS_EMPTYMX,\n    LOGVALDIMS_VARDIMS\n} LogValDimsStat;\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern mxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID);\n\nextern mxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID);\n\nextern LogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList);\n\n\nextern LogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList);\n\nextern StructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName);\n\n\nextern const char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus);\n\nextern const char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus);\n\nextern void rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims);\n\nextern void rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data);\n\nextern const char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr);\nextern const char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY);\n\nextern void rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel);\n\nextern void rt_StopDataLogging(const char_T *file, RTWLogInfo *li);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li); /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#endif /* rt_logging_h */\n\n/* LocalWords:  curr LOGVALDIMS EMPTYMX VARDIMS\n */\n"},{"name":"rt_logging_mmi.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2014 The MathWorks, Inc.\n *\n * File: rt_logging_mmi.h\n *\n * Abstract:\n */\n\n#ifndef rt_logging_mmi_h\n#define rt_logging_mmi_h\n\n#include <stdlib.h>\n#include \"rtwtypes.h\"\n#include \"builtin_typeid_types.h\"\n#ifdef IS_SIM_TARGET\n#include \"rtw_matlogging_simtarget.h\"\n#include \"rtw_modelmap_simtarget.h\"\n#else\n#include \"rtw_matlogging.h\"\n#include \"rtw_modelmap.h\"\n#endif\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nconst char_T * rt_FillStateSigInfoFromMMI(RTWLogInfo   *li,\n                                          const char_T **errStatus);\n\nvoid rt_CleanUpForStateLogWithMMI(RTWLogInfo *li);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*  rt_logging_mmi_h */\n"},{"name":"rt_logging_simtarget.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012-2021 The MathWorks, Inc. */\n\n#ifndef rt_logging_simtarget_h\n#define rt_logging_simtarget_h\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rtwtypes.h\"\n#include \"builtin_typeid_types.h\"\n#include \"multiword_types.h\"\n#ifdef IS_RAPID_ACCEL\n#include \"matrix.h\"\n#else\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging_simtarget.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n\n/*=========*\n * Defines *\n *=========*/\n\n/*\n * Logging related functions and data structures\n */\ntypedef double MatReal;                /* \"real\" data type used in model.mat  */\ntypedef struct LogVar_Tag LogVar;\ntypedef struct StructLogVar_Tag StructLogVar;\n\ntypedef struct MatrixData_Tag {\n  char_T         name[mxMAXNAM];     /* Name of the variable                  */\n  int_T          nRows;              /* number of rows                        */\n  int_T          nCols;              /* number of columns                     */\n  int_T          nDims;              /* number of dimensions                  */\n  int_T          _dims[2];           /* most cases, dimensions are 2          */\n  int_T          *dims;              /* dimensions of the log variable we \n                                        write to at each simulation time step.\n                                        E.g: (1) Non-frame data - \n                                                 Signal dimension = [2 X 3]\n                                                 numDims = 2\n                                                 dims[0] = 2, dims[1] = 3\n                                             (2) Frame data - \n                                                 Signal dimension = [2 X 3]\n                                                 numDims = 1\n                                                 dims[0] = 3                  */\n  void           *re;                /* pointer to real part of the data      */\n  void           *im;                /* pointer to imaginary part, if complex */\n  DTypeId        dTypeID;            /* data type id                          */\n  size_t         elSize;             /* element size in bytes                 */\n\n  RTWLogDataTypeConvert dataTypeConvertInfo;\n\n  mxClassID      mxID;               /* mxId corresponding to this dTypeID    */\n  uint32_T       logical;            /* is this a logical array ?             */\n  uint32_T       complex;            /* is this a complex matrix?             */\n  uint32_T       frameData;          /* is this data frame based?             */\n  uint32_T       frameSize;          /* is this data frame based?             */\n} MatrixData;\n\ntypedef struct ValDimsData_Tag {\n  char_T         name[mxMAXNAM];     /* Name of the variable                  */\n  int_T          nRows;              /* number of rows                        */\n  int_T          nCols;              /* number of columns                     */\n  void           **currSigDims;      /* dimensions of current output          */\n  int_T          *currSigDimsSize;   /* size in bytes of current sig dims     */\n  real_T         *dimsData;          /* pointer to the value of dimension     */\n} ValDimsData;\n\nstruct LogVar_Tag {\n    MatrixData  data;                 /* Container for name, data etc.,       */\n    ValDimsData *valDims;             /* field of valueDimensions\n                                       1. If all logging signals are fixed-size,\n                                          then we set this field to NULL;\n                                       2. If any logging signal is variable-size,\n                                          then this field will be needed:\n                                         1) For fixed-size signal, this field is\n                                            an empty matrix;\n                                         2) Otherwise, it contains the dimension\n                                            information of the logging signal.\n                                      */\n    int_T      rowIdx;                /* current row index                    */\n    int_T      wrapped;               /* number of times the circular buffer\n                                       * has wrapped around                   */\n    int_T     nDataPoints;            /* total number of data points logged   */\n    int_T     usingDefaultBufSize;    /* used to print a message at end       */\n    int_T     okayToRealloc;          /* reallocate during sim?               */\n    int_T     decimation;             /* decimation factor                    */\n    int_T     numHits;                /* decimation hit count                 */\n\n    int_T     *coords;\n    int_T     *strides;\n    int_T     *currStrides;           /* coords, strides and currStrides will be\n                                         needed when logging variable-size \n                                         signal to calculate whether the \n                                         currently logging value is in the range.\n                                         If the current signal is fixed-size,\n                                         these pointers will be set to NULLs;\n                                         otherwise, we allocate memory for them.\n                                         (the size will be nDims in this case)\n                                      */\n\n    LogVar    *next;\n};\n\ntypedef struct SignalsStruct_Tag {\n    int_T        numActiveFields;   /* number of active fields                */\n    const char_T *fieldNames;\n    int_T        numSignals;\n    LogVar       *values;\n    MatrixData   *dimensions;\n    MatrixData   *labels;\n    MatrixData   *plotStyles;\n    MatrixData   *titles;\n    MatrixData   *blockNames;\n    MatrixData   *stateNames;\n    MatrixData   *crossMdlRef;\n\n    boolean_T    logValueDimensions; /* If there's any variable-size signal \n                                         we also should log 'valueDimensions'\n                                         field                                 */\n    boolean_T    *isVarDims;         /* is this signal a variable-size signal? */\n\n    MatrixData   *stateIdxList;\n\n} SignalsStruct;\n\nstruct StructLogVar_Tag {\n    char_T        name[mxMAXNAM];    /* Name of the ML Struct variable         */\n    int_T         numActiveFields;   /* number of active fields                */\n    boolean_T     logTime;\n    void          *time;\n    SignalsStruct signals;\n    MatrixData    *blockName;\n\n    StructLogVar  *next;\n};\n\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n/* status of logging \"valueDimensions\" field */\n/* \n  NO_LOGVALDIMS: \n                 No need to log valueDimensions: \n                 All signals are fixed-sized.\n\n  LOGVALDIMS_EMPTYMX: \n                 Signals with mixed dimension modes,\n                 and the signal logged currently\n                 is fixed-sized. So set valueDimensions\n                 field to an empty matrix.\n\n  LOGVALDIMS_VARDIMS:\n                 Signal logged currently is variable-sized.\n*/\ntypedef enum {\n    NO_LOGVALDIMS,      \n    LOGVALDIMS_EMPTYMX,\n    LOGVALDIMS_VARDIMS\n} LogValDimsStat;\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern mxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID);\n\nextern mxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID);\n\nextern LogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList);\n\n\nextern LogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList);\n\nextern StructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName);\n\n\nextern const char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus);\n\nextern const char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus);\n\nextern void rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims);\n\nextern void rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data);\n\nextern const char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr);\nextern const char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY);\n\nextern void rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel, boolean_T cleanUp);\n\nextern void rt_StopDataLogging(const char_T *file, RTWLogInfo *li);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li); /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#endif /* rt_logging_simtarget_h */\n\n/* LocalWords:  curr LOGVALDIMS EMPTYMX VARDIMS\n */\n"},{"name":"rt_main.c","type":"source","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\common","tag":"","groupDisplay":"Other files","code":"/* \n * Copyright 2012-2018 The MathWorks, Inc.\n *\n * File: rt_main.c\n *\n * Abstract:\n *\n *   A real-time main that runs generated Simulink Coder code under most \n *   operating systems.  Based on the definition of MULTITASKING, a single-task \n *   or multitask step function is employed.\n *\n *   This file is a useful starting point for creating a custom main when \n *   targeting a custom floating point processor or integer micro-controller.\n *\n *   Alternatively for ERT targets, you can generate a sample ert_main.c file \n *   with the generated code by selecting the \"Generate an example main program\"\n *   option.  In this case, ert_main.c is precisely customized to the\n *   model requirements.  \n *\n * Required Defines:\n *\n *   MODEL - Model name\n *   NUMST - Number of sample times\n *\n */\n\n/*==================*\n * Required defines *\n *==================*/\n\n#ifndef MODEL\n# error Must specify a model name.  Define MODEL=name.\n#else\n/* create generic macros that work with any model */\n# define EXPAND_CONCAT(name1,name2) name1 ## name2\n# define CONCAT(name1,name2) EXPAND_CONCAT(name1,name2)\n# define MODEL_INITIALIZE CONCAT(MODEL,_initialize)\n# define MODEL_STEP       CONCAT(MODEL,_step)\n# define MODEL_TERMINATE  CONCAT(MODEL,_terminate)\n# define RT_MDL           CONCAT(MODEL,_M)\n#endif\n\n#ifndef NUMST\n# error Must specify the number of sample times.  Define NUMST=number.\n#endif\n\n#if CLASSIC_INTERFACE == 1\n# error \"Classic call interface is not supported by rt_main.c.\"\n#endif\n\n#if ONESTEPFCN==0\n#error Separate output and update functions are not supported by rt_main.c. \\\nYou must update rt_main.c  to suit your application needs, or select \\\nthe 'Single output/update function' option.\n#endif\n\n#if TERMFCN==0\n#error The terminate function is required by rt_main.c. \\\nSelect model configuration parameter 'Terminate function required' \\\nor 'Generate an example main program' or modify rt_main.c to \\\nmeet your application requirements.\n#endif\n\n#if MULTI_INSTANCE_CODE==1\n#error The static version of rt_main.c does not support reusable \\\ncode generation.  Either deselect ERT option 'Generate reusable code', \\\nselect option 'Generate an example main program', or modify rt_main.c for \\\nyour application needs.\n#endif\n\n#ifndef SAVEFILE\n# define MATFILE2(file) #file \".mat\"\n# define MATFILE1(file) MATFILE2(file)\n# define MATFILE MATFILE1(MODEL)\n#else\n# define QUOTE1(name) #name\n# define QUOTE(name) QUOTE1(name)    /* need to expand name    */\n# define MATFILE QUOTE(SAVEFILE)\n#endif\n\n/*==========*\n * Includes *\n *==========*/\n\n#include \"rtwtypes.h\"\n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n# include <stdio.h>    /* optional for printf */\n#else\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n  extern int printf(const char *, ...); \n  extern int fflush(void *);\n#ifdef __cplusplus\n}\n#endif\n#endif\n#include <string.h>  /* optional for strcmp */\n#include \"rtmodel.h\" /* optional for automated builds */\n\n#include \"rt_logging.h\"\n#ifdef UseMMIDataLogging\n#include \"rt_logging_mmi.h\"\n#endif\n\n#include \"ext_work.h\"\n\n#ifdef MODEL_STEP_FCN_CONTROL_USED\n#error The static version of rt_main.c does not support model step function prototype control.\n#endif\n\n/*========================* \n * Setup for multitasking * \n *========================*/\n\n/* \n * Let MT be synonym for MULTITASKING (to shorten command line for DOS) \n */\n#if defined(MT)\n# if MT == 0\n# undef MT\n# else\n# define MULTITASKING 1\n# endif\n#endif\n\n#if defined(MULTITASKING) /* multitask */\n#if defined(TID01EQ) && TID01EQ == 1\n#define FIRST_TID 1\n#else \n#define FIRST_TID 0\n#endif\n#endif\n\n\n/*==================================*\n * Global data local to this module *\n *==================================*/\n#ifndef MULTITASKING\nstatic boolean_T OverrunFlags[1];    /* ISR overrun flags */\nstatic boolean_T eventFlags[1];      /* necessary for overlapping preemption */\n#else\nstatic boolean_T OverrunFlags[NUMST];\nstatic boolean_T eventFlags[NUMST]; \n#endif\n\n/*===================*\n * Visible functions *\n *===================*/\n\n#if !defined(MULTITASKING) /* single task */\n\n/* Function: rtOneStep ========================================================\n *\n * Abstract:\n *   Perform one step of the model.  This function is modeled such that\n *   it could be called from an interrupt service routine (ISR) with minor\n *   modifications.\n */\nstatic void rt_OneStep(void)\n{\n    /* Disable interrupts here */\n\n    /***********************************************\n     * Check and see if base step time is too fast *\n     ***********************************************/\n    if (OverrunFlags[0]++) {\n        rtmSetErrorStatus(RT_MDL, \"Overrun\");\n    }\n\n    /*************************************************\n     * Check and see if an error status has been set *\n     * by an overrun or by the generated code.       *\n     *************************************************/\n    if (rtmGetErrorStatus(RT_MDL) != NULL) {\n        return;\n    }\n\n    /* Save FPU context here (if necessary) */\n    /* Reenable interrupts here */\n    /* Set model inputs here */\n\n    /**************\n     * Step model *\n     **************/\n    MODEL_STEP();\n\n    /* Get model outputs here */\n\n    /**************************\n     * Decrement overrun flag *\n     **************************/\n    OverrunFlags[0]--;\n\n    rtExtModeCheckEndTrigger();\n\n    /* Disable interrupts here */\n    /* Restore FPU context here (if necessary) */\n    /* Reenable interrupts here */\n\n} /* end rtOneStep */\n\n#else /* multitask */\n\n/* Function: rtOneStep ========================================================\n *\n * Abstract:\n *   Perform one step of the model.  This function is modeled such that\n *   it could be called from an interrupt service routine (ISR) with minor\n *   modifications.\n *\n *   Note that error checking is only necessary when this routine is\n *   attached to an interrupt.\n *\n *   Also, you may wish to unroll any or all of for and while loops to\n *   improve the real-time performance of this function.\n */\nstatic void rt_OneStep(void)\n{\n    int_T i;\n\n    /* Disable interrupts here */\n\n    /***********************************************\n     * Check and see if base step time is too fast *\n     ***********************************************/\n    if (OverrunFlags[0]++) {\n        rtmSetErrorStatus(RT_MDL, \"Overrun\");\n    }\n\n    /*************************************************\n     * Check and see if an error status has been set *\n     * by an overrun or by the generated code.       *\n     *************************************************/\n    if (rtmGetErrorStatus(RT_MDL) != NULL) {\n        return;\n    }\n\n    /* Save FPU context here (if necessary) */\n    /* Reenable interrupts here */\n    \n    /*************************************************\n     * Update EventFlags and check subrate overrun   *\n     *************************************************/\n    for (i = FIRST_TID+1; i < NUMST; i++) {\n        if (rtmStepTask(RT_MDL,i) && eventFlags[i]++) {\n            OverrunFlags[0]--;\n            OverrunFlags[i]++;\n            /* Sampling too fast */\n            rtmSetErrorStatus(RT_MDL, \"Overrun\");\n            return;\n        }\n        if (++rtmTaskCounter(RT_MDL,i) == rtmCounterLimit(RT_MDL,i))\n            rtmTaskCounter(RT_MDL, i) = 0;\n    }\n\n    /* Set model inputs associated with base rate here */\n\n    /*******************************************\n     * Step the model for the base sample time *\n     *******************************************/\n    MODEL_STEP(0);\n\n    /* Get model outputs associated with base rate here */\n\n    /************************************************************************\n     * Model step complete for base sample time, now it is okay to          *\n     * re-interrupt this ISR.                                               *\n     ************************************************************************/\n    OverrunFlags[0]--;\n\n    /*********************************************************\n     * Step the model for any other sample times (subrates) *\n     *********************************************************/\n    for (i = FIRST_TID+1; i < NUMST; i++) {\n        /*************************************************************\n         * If task \"i\" is running, don't run any lower priority task *\n         *************************************************************/\n        if (OverrunFlags[i]) return; \n\n        if (eventFlags[i]) {\n            OverrunFlags[i]++;\n\n            /* Set model inputs associated with subrate here */\n\n            /******************************************\n             * Step the model for sample time \"i\" *\n             ******************************************/\n            MODEL_STEP(i);\n\n            /* Get model outputs associated with subrate here */\n            \n            /**********************************************\n             * Indicate task complete for sample time \"i\" *\n             **********************************************/\n            OverrunFlags[i]--;\n            eventFlags[i]--;\n        }\n    }\n\n    rtExtModeCheckEndTrigger();\n    /* Disable interrupts here */\n    /* Restore FPU context here (if necessary) */\n    /* Enable interrupts here */\n\n} /* end rtOneStep */\n\n#endif /* MULTITASKING */\n\n/* Function: rt_InitModel ====================================================\n * \n * Abstract: \n *   Initialized the model and the overrun flags\n *\n */\nstatic void rt_InitModel(void)\n{\n#if defined(MULTITASKING)\n    int i;\n    for(i=0; i < NUMST; i++) {\n        OverrunFlags[i] = 0;\n        eventFlags[i] = 0;\n    }\n#else\n    OverrunFlags[0] = 0;\n    eventFlags[0] = 0;\n#endif\n\n    /************************\n     * Initialize the model *\n     ************************/\n    MODEL_INITIALIZE();\n}\n\n/* Function: rt_TermModel ====================================================\n * \n * Abstract:\n *   Terminates the model and prints the error status\n *\n */\nstatic int_T rt_TermModel(void)\n{\n    MODEL_TERMINATE();\n    \n    {\n        const char_T *errStatus = (const char_T *) (rtmGetErrorStatus(RT_MDL));\n        int_T i = 0;\n        \n        if (errStatus != NULL && strcmp(errStatus, \"Simulation finished\")) {\n            (void)printf(\"%s\\n\", errStatus);\n#if defined(MULTITASKING)\n            for (i = 0; i < NUMST; i++) {\n                if (OverrunFlags[i]) {\n                    (void)printf(\"ISR overrun - sampling rate too\"\n                                 \"fast for sample time index %d.\\n\", i);\n                }\n            }\n#else\n           if (OverrunFlags[i]) { \n               (void)printf(\"ISR overrun - base sampling rate too fast.\\n\");\n           }\n#endif\n            return(1);\n        }\n    }\n    \n    return(0);\n}\n\n/* Function: main =============================================================\n *\n * Abstract:\n *   Execute model on a generic target such as a workstation.\n */\nint_T main(int_T argc, const char *argv[])\n{\n    int_T ret;\n\n    /* External mode */\n    rtParseArgsForExtMode(argc, argv);\n \n    /*******************************************\n     * warn if the model will run indefinitely *\n     *******************************************/\n#ifndef EXT_MODE\n# define EXT_MODE 0\n#endif\n    \n#if MAT_FILE==0 && EXT_MODE==0\n    printf(\"warning: the simulation will run with no stop time; \"\n           \"to change this behavior select the 'MAT-file logging' option\\n\");\n    fflush(NULL);\n#endif\n\n    /************************\n     * Initialize the model *\n     ************************/\n    rt_InitModel();\n\n    /* External mode */\n    rtSetTFinalForExtMode(&rtmGetTFinal(RT_MDL));\n    rtExtModeCheckInit(NUMST);\n    rtExtModeWaitForStartPkt(rtmGetRTWExtModeInfo(RT_MDL),\n                             NUMST,\n                             (boolean_T *)&rtmGetStopRequested(RT_MDL));\n\n    (void)printf(\"\\n** starting the model **\\n\");\n\n    /***********************************************************************\n     * Execute (step) the model.  You may also attach rtOneStep to an ISR, *\n     * in which case you replace the call to rtOneStep with a call to a    *\n     * background task.  Note that the generated code sets error status    *\n     * to \"Simulation finished\" when MatFileLogging is specified in TLC.   *\n     ***********************************************************************/\n    while (rtmGetErrorStatus(RT_MDL) == NULL &&\n           !rtmGetStopRequested(RT_MDL)) {\n\n        rtExtModePauseIfNeeded(rtmGetRTWExtModeInfo(RT_MDL),\n                               NUMST,\n                               (boolean_T *)&rtmGetStopRequested(RT_MDL));\n\n#if MAT_FILE || EXT_MODE\n        if (rtmGetStopRequested(RT_MDL)) break;\n#endif\n\n        /* external mode */\n        rtExtModeOneStep(rtmGetRTWExtModeInfo(RT_MDL),\n                         NUMST,\n                         (boolean_T *)&rtmGetStopRequested(RT_MDL));\n        \n        rt_OneStep();\n    }\n\n    /*******************************\n     * Cleanup and exit (optional) *\n     *******************************/\n\n#ifdef UseMMIDataLogging\n    rt_CleanUpForStateLogWithMMI(rtmGetRTWLogInfo(RT_MDL));\n#endif\n    rt_StopDataLogging(MATFILE,rtmGetRTWLogInfo(RT_MDL));\n\n    ret = rt_TermModel();\n\n    rtExtModeShutdown(NUMST);\n\n    return ret;\n}\n\n/* [EOF] rt_main.c */\n"},{"name":"rt_math.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2010 The MathWorks, Inc. */\n#ifndef RTW_HEADER_rt_math_h_\n#define RTW_HEADER_rt_math_h_\n\n#define rt_MAXf_snf(a, b)              (( ((a) >= (b)) || rtIsNaNF(b) ) ? (a) : (b))\n#define rt_MAXd_snf(a, b)              (( ((a) >= (b)) || rtIsNaN(b) ) ? (a) : (b))\n#define rt_MAXf(a, b)                  (((a) >= (b)) ? (a) : (b))\n#define rt_MAXd(a, b)                  (((a) >= (b)) ? (a) : (b))\n#define rt_MAX(a, b)                   (((a) >= (b)) ? (a) : (b))\n\n#define rt_MINf_snf(a, b)              (( ((a) <= (b)) || rtIsNaNF(b) ) ? (a) : (b))\n#define rt_MINd_snf(a, b)              (( ((a) <= (b)) || rtIsNaN(b) ) ? (a) : (b))\n#define rt_MINf(a, b)                  (((a) <= (b)) ? (a) : (b))\n#define rt_MINd(a, b)                  (((a) <= (b)) ? (a) : (b))\n#define rt_MIN(a, b)                   (((a) <= (b)) ? (a) : (b))\n\n#define rt_SIGNf_snf(a)                ( ((a) < 0.0F) ? -1.0F : ((a) > 0.0F) ? 1.0F : ((a) == 0.0F) ? 0.0F : (rtNaNF) )\n#define rt_SIGNd_snf(a)                ( ((a) < 0.0) ? -1.0 : ((a) > 0.0) ? 1.0 : ((a) == 0.0) ? 0.0 : (rtNaN) )\n#define rt_SIGNf(a)                    ( ((a) < 0.0F) ? -1.0F : ((a) > 0.0F) ? 1.0F : 0.0F )\n#define rt_SIGNd(a)                    ( ((a) < 0.0) ? -1.0 : ((a) > 0.0) ? 1.0 : 0.0 )\n#define rt_SGN(a)                      ( ((a) < 0) ? -1 : ((a) > 0) ? 1 : 0 )\n#define rt_UNSGN(a)                    ( ((a) > 0U) ? 1U : 0U )\n\n#define rt_SATURATE(sig,ll,ul)         (((sig) >= (ul)) ? (ul) : (((sig) <= (ll)) ? (ll) : (sig)) )\n\n#define rt_ABS(a)                      ( ((a) >= 0) ? (a) : -(a) )\n\n#endif                                 /* RTW_HEADER_rt_math_h_ */\n"},{"name":"rt_matrx.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"\n#ifndef rt_matrx_h\n#define rt_matrx_h\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n\n/*\n * Copyright 1994-2020 The MathWorks, Inc.\n */\n\n/*==========*\n * Includes *\n *==========*/\n\n#if defined(MATLAB_MEX_FILE)\n# error \"rt_matrix cannot be used within a mex file. It is for codegen only.\"\n#endif\n\n#include <stdlib.h>    /* needed for malloc, calloc, free, realloc */\n#include <string.h>    /* needed for strlen                        */\n#include \"rtwtypes.h\"  /* needed for real_T                        */\n#include \"rt_mxclassid.h\" /* needed for mxClassID                     */\n\n\n\n/*==========*\n * Typedefs *\n *==========*/\n\n#ifndef rt_typedefs_h\n#define rt_typedefs_h\n\n#if !defined(TYPEDEF_MX_ARRAY)\n# define TYPEDEF_MX_ARRAY\n  typedef real_T mxArray;\n#endif\n\ntypedef real_T mxChar;\n\n#if !defined(TMW_NAME_LENGTH_MAX)\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n\ntypedef enum {\n    mxREAL,\n    mxCOMPLEX\n} mxComplexity;\n\n#endif /* rt_typedefs_h */\n\n/*==================*\n * Extern variables *\n *==================*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\n\n/*=======================================*\n * Defines for mx Routines and constants *\n *=======================================*/\n\n\n#define mxCalloc(n,size) \\\n        calloc(n,size)\n\n#define mxCreateCharArray(ndim, dims) \\\n        mxCreateNumericArray(ndim, dims, mxCHAR_CLASS);\n\n#define mxDestroyArray(pa) \\\n        if (pa) free(pa)\n\n/* NOTE: You cannot mxFree(mxGetPr(pa)) !!! */\n#define mxFree(ptr) \\\n        if(ptr)free(ptr)\n\n#define mxGetClassID(pa) \\\n        mxDOUBLE_CLASS\n\n/* NOTE: mxGetClassName(pa) returns \"double\" even on a character array */\n#define mxGetClassName(pa) \\\n        \"double\"\n\n#define mxGetData(pa) \\\n        ((void *)(&((pa)[2])))\n\n#define mxGetElementSize(pa) \\\n        (sizeof(real_T))\n\n#define mxGetInf() \\\n        rtInf\n\n#define mxGetM(pa) \\\n        ((size_t) ((pa)[0]))\n#define mxGetN(pa) \\\n        ((size_t) ((pa)[1]))\n\n#define mxGetNaN() \\\n        rtNaN\n\n#define mxGetNumberOfDimensions(pa) \\\n        (2)\n#define mxGetNumberOfElements(pa) \\\n        (mxGetM(pa)*mxGetN(pa))\n\n/* NOTE: mxGetPr() of an empty matrix does NOT return NULL */\n#define mxGetPr(pa) \\\n        ( &((pa)[2]) )\n\n/* NOTE: mxGetDoubles() of an empty matrix does NOT return NULL */\n#define mxGetDoubles(pa) \\\n        ( &((pa)[2]) )\n\n#define mxGetScalar(pa) \\\n        ((pa)[2])\n\n#define mxIsComplex(pa) \\\n        false\n\n#define mxIsDouble(pa) \\\n        true\n\n#define mxIsEmpty(pa) \\\n        (mxGetM(pa)==0 || mxGetN(pa)==0)\n\n#define mxIsFinite(r) \\\n        ((r)>rtMinusInf && (r)<rtInf)\n\n#define mxIsInf(r) \\\n        ((r)==rtInf || (r)==rtMinusInf)\n\n#define mxIsInt16(pa) \\\n        false\n\n#define mxIsInt32(pa) \\\n        false\n\n#define mxIsInt8(pa) \\\n        false\n\n#define mxIsLogical(pa) \\\n        false\n\n#define mxIsNumeric(pa) \\\n        true\n\n#define mxIsSingle(pa) \\\n        false\n\n#define mxIsSparse(pa) \\\n        false\n\n#define mxIsStruct(pa) \\\n        false\n\n#define mxIsUint16(pa) \\\n        false\n\n#define mxIsUint32(pa) \\\n        false\n\n#define mxIsUint8(pa) \\\n        false\n\n#define mxMalloc(n) \\\n        malloc(n)\n\n#define mxRealloc(p,n) \\\n        realloc(p,n)\n\n\n\n\n\n/*==========================*\n * Visible/extern functions *\n *=========================*/\n\n\nextern mxArray *rt_mxCreateCharMatrixFromStrings(int_T m, const char_T **str);\n\nextern mxArray *rt_mxCreateString(const char *str);\n\nextern mxArray *rt_mxCreateDoubleMatrix(int m, int n, mxComplexity flag);\n\nextern mxArray *rt_mxCreateNumericArray(int_T ndims, const mwSize *dims, \n                                        mxClassID classid, mxComplexity flag);\n\n\nextern mxArray *rt_mxDuplicateArray(const mxArray *pa);\n\n\n\nextern const mwSize *rt_mxGetDimensions(const mxArray *pa);\n\nextern real_T rt_mxGetEps(void);\n\nextern int_T rt_mxGetString(const mxArray *pa, char_T *buf, int_T buflen);\n\n#ifdef __cplusplus\n}\n#endif\n\n#define mxCreateCharMatrixFromStrings(m, str) \\\n        rt_mxCreateCharMatrixFromStrings(m, str)\n\n#define mxCreateString(str) \\\n        rt_mxCreateString(str) \n\n#define mxCreateDoubleMatrix(m, n, flag) \\\n        rt_mxCreateDoubleMatrix(m, n, flag)\n\n#define mxCreateNumericArray(ndims, dims, classid, flag) \\\n        rt_mxCreateNumericArray(ndims, dims, classid, flag)\n\n#define mxDuplicateArray(pa) \\\n        rt_mxDuplicateArray(pa)\n\n#define mxGetDimensions(pa) \\\n        rt_mxGetDimensions(pa)\n\n#define mxGetEps() \\\n        rt_mxGetEps()\n\n#define mxGetString(pa, buf, buflen) \\\n        rt_mxGetString(pa, buf, buflen)\n\n/*=========================*\n * Unsupported mx Routines *\n *=========================*/\n\n#define mxCalcSingleSubscript(pa,nsubs,subs) \\\n        mxCalcSingleSubscript_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellArray(ndim,dims) \\\n        mxCreateCellArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellMatrix(m,n) \\\n        mxCreateCellMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxCreateSparse(pm,pn,pnzmax,pcmplx_flg) \\\n        mxCreateSparse_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructArray(ndim,dims,nfields,fieldnames) \\\n        mxCreateStructArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructMatrix(m,n,nfields,fieldnames) \\\n        mxCreateStructMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxGetCell(pa,i) \\\n        mxGetCell_is_not_supported_in_Simulink_Coder\n\n#define mxGetField(pa,i,fieldname) \\\n        mxGetField_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldByNumber(s,i,fieldnum) \\\n        mxGetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNameByNumber(pa,n) \\\n        mxGetFieldNameByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNumber(pa,fieldname) \\\n        mxGetFieldNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetImagData(pa) \\\n        mxGetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxGetIr(ppa) \\\n        mxGetIr_is_not_supported_in_Simulink_Coder\n\n#define mxGetJc(ppa) \\\n        mxGetJc_is_not_supported_in_Simulink_Coder\n\n#define mxGetNumberOfFields(pa) \\\n        mxGetNumberOfFields_is_not_supported_in_Simulink_Coder\n\n#define mxGetNzmax(pa) \\\n        mxGetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxGetPi(pa) \\\n        mxGetPi_is_not_supported_in_Simulink_Coder\n\n#define mxIsFromGlobalWS(pa) \\\n        mxIsFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxIsNaN(r) \\\n        mxIsNaN_is_not_supported_in_Simulink_Coder\n\n#define mxIsChar(pa) \\\n        mxIsChar_is_not_supported_in_Simulink_Coder\n\n#define mxIsClass(pa,class) \\\n        mxIsClass_is_not_supported_in_Simulink_Coder\n\n#define mxIsCell(pa) \\\n        mxIsCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetCell(pa,i,value) \\\n        mxSetCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetClassName(pa,classname) \\\n        mxSetClassName_is_not_supported_in_Simulink_Coder\n\n#define mxSetData(pa,pr) \\\n        mxSetData_is_not_supported_in_Simulink_Coder\n\n#define mxSetDimensions(pa, size, ndims) \\\n        mxSetDimensions_is_not_supported_in_Simulink_Coder\n\n#define mxSetField(pa,i,fieldname,value) \\\n        mxSetField_is_not_supported_in_Simulink_Coder\n\n#define mxSetFieldByNumber(pa, index, fieldnum, value) \\\n        mxSetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxSetFromGlobalWS(pa,global) \\\n        mxSetFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxSetImagData(pa,pv) \\\n        mxSetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxSetIr(ppa,ir) \\\n        mxSetIr_is_not_supported_in_Simulink_Coder\n\n#define mxSetJc(ppa,jc) \\\n        mxSetJc_is_not_supported_in_Simulink_Coder\n\n#define mxSetM(pa, m) \\\n        mxSetM_is_not_supported_in_Simulink_Coder\n\n#define mxSetN(pa, m) \\\n        mxSetN_is_not_supported_in_Simulink_Coder\n\n#define mxSetPr(pa,pr) \\\n        mxSetPr_is_not_supported_in_Simulink_Coder\n\n#define mxSetNzmax(pa,nzmax) \\\n        mxSetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxSetPi(pa,pv) \\\n        mxSetPi_is_not_supported_in_Simulink_Coder\n\n\n\n/*==========================*\n * Unsupported mex routines *\n *==========================*/\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexEvalString(str) \\\n        mexEvalString_is_not_supported_by_Simulink_Coder\n\n#define mexErrMsgTxt(str) \\\n        mexErrMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexWarnMsgTxt(warning_msg) \\\n        mexWarnMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexPrintf \\\n        mexPrintf_is_not_supported_by_Simulink_Coder\n\n#define mexMakeArrayPersistent(pa) \\\n        mexMakeArrayPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexMakeMemoryPersistent(ptr) \\\n        mexMakeMemoryPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexLock() \\\n        mexLock_is_not_supported_by_Simulink_Coder\n\n#define mexUnlock() \\\n        mexUnlock_is_not_supported_by_Simulink_Coder\n\n#define mexFunctionName() \\\n        mexFunctionName_is_not_supported_by_Simulink_Coder\n\n#define mexIsLocked() \\\n        mexIsLocked_is_not_supported_by_Simulink_Coder\n\n#define mexGetFunctionHandle() \\\n        mexGetFunctionHandle_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLABFunction() \\\n        mexCallMATLABFunction_is_not_supported_by_Simulink_Coder\n\n#define mexRegisterFunction() \\\n        mexRegisterFunction_is_not_supported_by_Simulink_Coder\n\n#define mexSet(handle,property,value) \\\n        mexSet_is_not_supported_by_Simulink_Coder\n\n#define mexGet(handle,property) \\\n        mexGet_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLAB(nlhs,plhs,nrhs,prhs,fcn) \\\n        mexCallMATLAB_is_not_supported_by_Simulink_Coder\n\n#define mexSetTrapFlag(flag) \\\n        mexSetTrapFlag_is_not_supported_by_Simulink_Coder\n\n#define mexUnlink(a) \\\n        mexUnlink_is_not_supported_by_Simulink_Coderw\n\n#define mexSubsAssign(plhs,sub,nsubs,prhs) \\\n        mexSubsAssign_is_not_supported_by_Simulink_Coder\n\n#define mexSubsReference(prhs,subs,nsubs) \\\n        mexSubsReference_is_not_supported_by_Simulink_Coder\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexAddFlops(count) \\\n        mexAddFlops_is_not_supported_by_Simulink_Coder\n\n#define mexIsGlobal(pa) \\\n        mexIsGlobal_is_not_supported_by_Simulink_Coder\n\n#define mexAtExit(fcn) \\\n        mexAtExit_is_not_supported_by_Simulink_Coder\n\n\n#endif /* rt_matrx_h */\n"},{"name":"rt_mxclassid.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2004 The MathWorks, Inc.\n *\n * File    : rt_mxclassid.h\n * Abstract:\n *   Definition of enum mxClassID\n *\n */\n\n\n#ifndef __rt_mxclassid_h__\n#define __rt_mxclassid_h__\n\ntypedef enum {\n\tmxUNKNOWN_CLASS = 0,\n\tmxCELL_CLASS = 1,\n\tmxSTRUCT_CLASS,\n\tmxLOGICAL_CLASS,\n\tmxCHAR_CLASS,\n\tmxRESERVED5_CLASS, /* mxVOID_CLASS */\n\tmxDOUBLE_CLASS,\n\tmxSINGLE_CLASS,\n\tmxINT8_CLASS,\n\tmxUINT8_CLASS,\n\tmxINT16_CLASS,\n\tmxUINT16_CLASS,\n\tmxINT32_CLASS,\n\tmxUINT32_CLASS,\n\tmxINT64_CLASS,\t\t/* place holder - future enhancements */\n\tmxUINT64_CLASS,\t\t/* place holder - future enhancements */\n\tmxRESERVED16_CLASS, /* mxFUNCTION_CLASS */\n\tmxRESERVED17_CLASS, /* mxOPAQUE_CLASS */\n\tmxOBJECT_CLASS\n} mxClassID;\n\n#endif /* __rt_mxclassid_h__ */\n\n/* [EOF] rt_mxclass_id.h */\n"},{"name":"rt_sim.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: rt_sim.h     \n *\n * Abstract:\n *\tFunction prototypes for routines which perform one time step of\n *\ta real-time single tasking or multitasking system.\n */\n\n#ifndef __RT_SIM__\n#define __RT_SIM__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Functions that do not require the SimStruct as an arg\n */\n#define rttiSetTaskTime(tPtr,sti,time) (tPtr)[sti]=(time)\n\n#define rttiSetSampleHitInTask(perTaskSampHits,numSampTimes,task_j,task_i,hit) \\\n    (perTaskSampHits)[(task_j) + ((task_i) * (numSampTimes))] = (hit)\n\nextern const char *rt_SimInitTimingEngine(int_T       rtmNumSampTimes,\n                                          real_T      rtmStepSize,\n                                          real_T      *rtmSampleTimePtr,\n                                          real_T      *rtmOffsetTimePtr,\n                                          int_T       *rtmSampleHitPtr,\n                                          int_T       *rtmSampleTimeTaskIDPtr,\n                                          real_T      rtmTStart,\n                                          SimTimeStep *rtmSimTimeStepPtr,\n                                          void        **rtmTimingDataPtr);\n#ifdef RT_MALLOC\nextern void rt_SimDestroyTimingEngine(void *rtmTimingData);\n#endif\n\n#if !defined(MULTITASKING)\n  extern void  rt_SimUpdateDiscreteTaskSampleHits(int_T  rtmNumSampTimes,\n                                                  void   *rtmTimingData,\n                                                  int_T  *rtmSampleHitPtr,\n                                                  real_T *rtmTPtr);\n#  ifndef RT_MALLOC\n     extern time_T rt_SimGetNextSampleHit(void);\n#  else\n     extern time_T rt_SimGetNextSampleHit(void   *rtmTimingData,\n                                          int_T rtmNumSampTimes);\n#  endif\n#else\n#  ifndef USE_RTMODEL\n     extern time_T rt_SimUpdateDiscreteEvents(int_T  rtmNumSampTimes,\n                                              void   *rtmTimingData,\n                                              int_T  *rtmSampleHitPtr,\n                                              int_T  *rtmPerTaskSampleHits);\n#  endif\n  extern void   rt_SimUpdateDiscreteTaskTime(real_T *rtmTPtr,\n                                             void   *rtmTimingData,\n                                             int    tid);\n#endif\n\n/*\n * Functions maintained for backwards compatibility\n */\n#ifndef USE_RTMODEL\n  extern const char *rt_InitTimingEngine(SimStruct *S);\n# ifdef RT_MALLOC\n    extern void   rt_DestroyTimingEngine(SimStruct *S);\n# endif\n\n# if !defined(MULTITASKING)\n    extern void   rt_UpdateDiscreteTaskSampleHits(SimStruct *S);\n#   ifndef RT_MALLOC\n      extern time_T rt_GetNextSampleHit(void);\n#   else\n      extern time_T rt_GetNextSampleHit(SimStruct *S);\n#   endif\n\n# else\n    extern time_T rt_UpdateDiscreteEvents(SimStruct *S);\n    extern void   rt_UpdateDiscreteTaskTime(SimStruct *S, int tid);\n# endif\n#endif /* !(USE_RTMODEL) */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __RT_SIM__ */\n"},{"name":"rtmcmacros.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2002 The MathWorks, Inc.\n *\n * File: rtmcmacros.h     \n *\n * Abstract:\n * API glue for calling rt_OneStep.  These macros are used to create\n * a structure with the elements in the rtModel structure that are \n * required to be passed to rt_OneStep.\n */\n\n#ifndef _RTW_HEADER_rtmcmacros_h_\n# define _RTW_HEADER_rtmcmacros_h_\n\n/* Real-time Model Common Data Structure */\ntypedef struct {\n  const char            **errorStatus;\n  RTWLogInfo            **rtwLogInfo;\n  RTWExtModeInfo        **extModeInfo;\n  RTWRTModelMethodsInfo *modelMethodsInfo;\n  RTWSolverInfo         **solverInfo;\n  int_T                  *numSampTimes;\n  time_T                **t;\n  void                  **timingData;\n  SimTimeStep            *simTimeStep;\n  int_T                 **sampleHits;\n  int_T                 **perTaskSampleHitsPtr;\n  boolean_T              *stopRequested;\n  time_T                **sampleTimes;\n  int_T                 **sampleTimeTaskIDPtr;\n} rtModelCommon;\n\n#define rtmcsetCommon(MC, M)                                  \\\n    MC.errorStatus         = &rtmGetErrorStatus(M);           \\\n    MC.rtwLogInfo          = &rtmGetRTWLogInfo(M);            \\\n    MC.extModeInfo         = &rtmGetRTWExtModeInfo(M);        \\\n    MC.modelMethodsInfo     = &rtmGetRTWRTModelMethodsInfo(M); \\\n    MC.solverInfo           = &rtmGetRTWSolverInfo(M);         \\\n    MC.numSampTimes         = &rtmGetNumSampleTimes(M);        \\\n    MC.t                    = &rtmGetTPtr(M);                  \\\n    MC.timingData           = &rtmGetTimingData(M);            \\\n    MC.simTimeStep          = &rtmGetSimTimeStep(M);           \\\n    MC.sampleHits           = &rtmGetSampleHitPtr(M);          \\\n    MC.perTaskSampleHitsPtr = &rtmGetPerTaskSampleHitsPtr(M);  \\\n    MC.stopRequested        = &rtmGetStopRequested(M);         \\\n    MC.sampleTimes          = &rtmGetSampleTimePtr(M);         \\\n    MC.sampleTimeTaskIDPtr  = &rtmGetSampleTimeTaskIDPtr(M);\n\n# define rtmcGetErrorStatus(rtmc)   (*rtmc->errorStatus)\n# define rtmcGetRTWLogInfo(rtmc)   (*rtmc->rtwLogInfo)\n# define rtmcGetRTWExtModeInfo(rtmc) (*rtmc->extModeInfo)\n# define rtmcGetRTWRTModelMethodsInfo(rtmc) (*rtmc->modelMethodsInfo)\n# define rtmcGetRTWSolverInfo(rtmc) (*rtmc->solverInfo)\n# define rtmcGetNumSampleTimes(rtmc) (*rtmc->numSampTimes)\n# define rtmcGetTPtr(rtmc) (*rtmc->t)\n# define rtmcGetTimingData(rtmc) (*rtmc->timingData)\n# define rtmcGetSimTimeStep(rtmc) (*rtmc->simTimeStep)\n# define rtmcGetSampleHitPtr(rtmc) (*rtmc->sampleHits)\n# define rtmcGetPerTaskSampleHitsPtr(rtmc) (*rtmc->perTaskSampleHitsPtr)\n# define rtmcGetStopRequested(rtmc) (*rtmc->stopRequested)\n# define rtmcGetSampleTimePtr(rtmc) (*rtmc->sampleTimes)\n# define rtmcGetSampleTimeTaskIDPtr(rtmc) (*rtmc->sampleTimeTaskIDPtr)\n\n# define rtmcGetSampleTime(rtmc,sti) (*rtmc->sampleTimes[sti])\n\n#define rtmcGetTaskTime(rtmc,sti) \\\n    rtmcGetTPtr(rtmc)[rtmcGetSampleTimeTaskIDPtr(rtmc)[sti]]\n\n/* Only used in SINGLETASKING section of main routine */\n#define rtmcIsSampleHit(rtmc,sti,unused) \\\n    ((rtmcGetSimTimeStep(rtmc) == MAJOR_TIME_STEP) && \\\n      rtmcGetSampleHitPtr(rtmc)[rtmcGetSampleTimeTaskIDPtr(rtmc)[sti]])\n\n#endif                                  /* _RTW_HEADER_rtmcmacros_h_ */\n\n/* [EOF] rtmcmacros.h */\n"},{"name":"rtmmacros.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: rtmmacros.h     \n *\n * Abstract:\n * All our real-time simulation wrappers are setup to handle rtModel\n * objects. For targets that still use the SimStruct, this file \n * provides a mapping from the rtModel to the SimStruct. When all targets\n * use the rtModel, this file can be eliminated.\n */\n\n#ifndef _RTW_HEADER_rtmmacros_h_\n# define _RTW_HEADER_rtmmacros_h_\n\n#define rtmGetBlkStateChange            ssGetBlkStateChange\n#define rtmSetBlkStateChange            ssSetBlkStateChange\n#define rtmGetChecksum0                 ssGetChecksum0\n#define rtmSetChecksum0                 ssSetChecksum0\n#define rtmGetChecksum1                 ssGetChecksum1\n#define rtmSetChecksum1                 ssSetChecksum1\n#define rtmGetChecksum2                 ssGetChecksum2\n#define rtmSetChecksum2                 ssSetChecksum2\n#define rtmGetChecksum3                 ssGetChecksum3\n#define rtmSetChecksum3                 ssSetChecksum3\n#define rtmGetNumSampleTimes            ssGetNumSampleTimes\n#define rtmGetNumContStates             ssGetNumContStates\n#define rtmGetContStates                ssGetContStates\n#define rtmSetContStates                ssSetContStates\n#define rtmIsContinuousTask             ssIsContinuousTask\n#define rtmGetDerivCacheNeedsReset      ssGetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset      ssSetDerivCacheNeedsReset\n#define rtmGetDiscStates                ssGetDiscStates\n#define rtmSetDiscStates                ssSetDiscStates\n#define rtmGetErrorStatus               ssGetErrorStatus\n#define rtmSetErrorStatus               ssSetErrorStatus\n#define rtmGetFixedStepSize             ssGetFixedStepSize\n#define rtmSetFixedStepSize             ssSetFixedStepSize\n#define rtmGetRTWLogInfo                ssGetRTWLogInfo\n#define rtmSetRTWLogInfo                ssSetRTWLogInfo\n#define rtmGetRTWExtModeInfo            ssGetRTWExtModeInfo\n#define rtmSetRTWExtModeInfo            ssSetRTWExtModeInfo\n#define rtmGetMaxNumMinSteps            ssGetMaxNumMinSteps\n#define rtmSetMaxNumMinSteps            ssSetMaxNumMinSteps\n#define rtmGetMaxStepSize               ssGetMaxStepSize\n#define rtmSetMaxStepSize               ssSetMaxStepSize\n#define rtmGetMinStepSize               ssGetMinStepSize\n#define rtmSetMinStepSize               ssSetMinStepSize\n#define rtmGetSolverMaxConsecutiveMinStep   ssGetSolverMaxConsecutiveMinStep\n#define rtmSetSolverMaxConsecutiveMinStep   ssSetSolverMaxConsecutiveMinStep\n#define rtmGetSolverZcThreshold         ssGetSolverZcThreshold\n#define rtmSetSolverZcThreshold         ssSetSolverZcThreshold\n#define rtmGetSolverConsecutiveZCsError     ssGetSolverConsecutiveZCsError\n#define rtmSetSolverConsecutiveZCsError     ssSetSolverConsecutiveZCsError\n#define rtmGetSolverShapePreserveControl   ssGetSolverShapePreserveControl\n#define rtmSetSolverShapePreserveControl   ssSetSolverShapePreserveControl\n#define rtmGetModelMappingInfo          ssGetModelMappingInfo\n#define rtmSetModelMappingInfo          ssSetModelMappingInfo\n#define rtmGetOffsetTimePtr             ssGetOffsetTimePtr\n#define rtmSetOffsetTimePtr             ssSetOffsetTimePtr\n#define rtmGetPerTaskSampleHitsPtr      ssGetPerTaskSampleHitsPtr\n#define rtmSetPerTaskSampleHitsPtr      ssSetPerTaskSampleHitsPtr\n#define rtmIsSampleHit                  ssIsSampleHit\n#define rtmSetSampleHitInTask           ssSetSampleHitInTask\n#define rtmGetSampleHitPtr              ssGetSampleHitPtr\n#define rtmSetSampleHitPtr              ssSetSampleHitPtr\n#define rtmGetSampleTime                ssGetSampleTime\n#define rtmSetSampleTime                ssSetSampleTime\n#define rtmGetSampleTimePtr             ssGetSampleTimePtr\n#define rtmSetSampleTimePtr             ssSetSampleTimePtr\n#define rtmGetSampleTimeTaskIDPtr       ssGetSampleTimeTaskIDPtr\n#define rtmSetSampleTimeTaskIDPtr       ssSetSampleTimeTaskIDPtr\n#define rtmGetSimMode                   ssGetSimMode\n#define rtmSetSimMode                   ssSetSimMode\n#define rtmGetSimTimeStep               ssGetSimTimeStep\n#define rtmSetSimTimeStep               ssSetSimTimeStep\n#define rtmGetSolverAbsTol              ssGetSolverAbsTol\n#define rtmSetSolverAbsTol              ssSetSolverAbsTol\n#define rtmGetSolverData                ssGetSolverData\n#define rtmSetSolverData                ssSetSolverData\n#define rtmGetSolverMaxOrder            ssGetSolverMaxOrder\n#define rtmSetSolverMaxOrder            ssSetSolverMaxOrder\n#define rtmGetSolverConsecutiveZCsStepRelTol   ssGetSolverConsecutiveZCsStepRelTol\n#define rtmSetSolverConsecutiveZCsStepRelTol   ssSetSolverConsecutiveZCsStepRelTol\n#define rtmGetSolverMaxConsecutiveZCs   ssGetSolverMaxConsecutiveZCs\n#define rtmSetSolverMaxConsecutiveZCs   ssSetSolverMaxConsecutiveZCs\n#define rtmGetSolverExtrapolationOrder  ssGetSolverExtrapolationOrder\n#define rtmSetSolverExtrapolationOrder  ssSetSolverExtrapolationOrder\n#define rtmGetSolverNumberNewtonIterations   ssGetSolverNumberNewtonIterations\n#define rtmSetSolverNumberNewtonIterations   ssSetSolverNumberNewtonIterations\n#define rtmGetSolverMode                ssGetSolverMode\n#define rtmSetSolverMode                ssSetSolverMode\n#define rtmGetSolverName                ssGetSolverName\n#define rtmSetSolverName                ssSetSolverName\n#define rtmGetSolverNeedsReset          ssGetSolverNeedsReset\n#define rtmSetSolverNeedsReset          ssSetSolverNeedsReset\n#define rtmGetSolverRefineFactor        ssGetSolverRefineFactor\n#define rtmSetSolverRefineFactor        ssSetSolverRefineFactor\n#define rtmGetSolverRelTol              ssGetSolverRelTol\n#define rtmSetSolverRelTol              ssSetSolverRelTol\n#define rtmGetSolverStopTime            ssGetSolverStopTime\n#define rtmSetSolverStopTime            ssSetSolverStopTime\n#define rtmGetSolverRobustResetMethod   ssGetSolverRobustResetMethod\n#define rtmSetSolverRobustResetMethod   ssSetSolverRobustResetMethod\n#define rtmIsSpecialSampleHit           ssIsSpecialSampleHit\n#define rtmGetStepSize                  ssGetStepSize\n#define rtmSetStepSize                  ssSetStepSize\n#define rtmGetStopRequested             ssGetStopRequested\n#define rtmSetStopRequested             ssSetStopRequested\n#define rtmGetT                         ssGetT\n#define rtmSetT                         ssSetT\n#define rtmGetTFinal                    ssGetTFinal\n#define rtmSetTFinal                    ssSetTFinal\n#define rtmGetTPtr                      ssGetTPtr\n#define rtmSetTPtr                      ssSetTPtr\n#define rtmGetTStart                    ssGetTStart\n#define rtmSetTStart                    ssSetTStart\n#define rtmGetTaskTime                  ssGetTaskTime\n#define rtmSetTaskTime                  ssSetTaskTime\n#define rtmGetTimeOfLastOutput          ssGetTimeOfLastOutput\n#define rtmSetTimeOfLastOutput          ssSetTimeOfLastOutput\n#define rtmGetTimingData                ssGetTimingData\n#define rtmSetTimingData                ssSetTimingData\n#define rtmGetU                         ssGetU\n#define rtmSetU                         ssSetU\n#define rtmGetVariableStepSolver        ssGetVariableStepSolver\n#define rtmSetVariableStepSolver        ssSetVariableStepSolver\n#define rtmGetY                         ssGetY\n#define rtmSetY                         ssSetY\n#define rtmGetZCCacheNeedsReset         ssGetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset         ssSetZCCacheNeedsReset\n#define rtmGetdX                        ssGetdX\n#define rtmSetdX                        ssSetdX\n#define rtmOutputs                      sfcnOutputs\n#define rtmTerminate                    sfcnTerminate\n#define rtmInitializeSampleTimes        sfcnInitializeSampleTimes\n#define rtmInitializeSizes              sfcnInitializeSizes\n#define rtmUpdate                       sfcnUpdate\n#define rtmDerivatives                  sfcnDerivatives\n#define rtmStart                        sfcnStart\n#endif                                  /* _RTW_HEADER_rtmmacros_h_ */\n\n/* [EOF] rtmmacros.h */\n"},{"name":"rtsplntypes.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"#ifndef RTSPLNTYPES_H\n#define RTSPLNTYPES_H\n\n/* \n * File: rtsplntypes.h\n * \n * Abstract: \n *\n *   Typedefs for spline lookup table algorithms.\n *\n *   Copyright 1994-2007 The MathWorks, Inc.\n *\n *\n */\n\n#include \"rtwtypes.h\"\n\n/***************************************************************\n *                n-D Table Work Data Structures               *\n ***************************************************************/\n\ntypedef struct rt_LUTnWork_tag \n{\n    const uint32_T *m_dimSizes;\n    void           *m_tableData;\n    void           **m_bpDataSet;\n    uint32_T       *m_bpIndex;\n    void           *m_bpLambda;\n    const uint32_T *m_maxIndex;\n} rt_LUTnWork;\n\ntypedef struct rt_LUTSplineWork_tag \n{\n    rt_LUTnWork    *m_TWork;\n    void           *m_yyA;\n    void           *m_yyB;\n    void           *m_yy2;\n    void           *m_up;\n    void           *m_y2;\n    const uint32_T *m_numYWorkElts;\n    uint8_T        *m_reCalc; \n    void           *m_preBp0AndTable;\n} rt_LUTSplineWork;\n\n#endif  /* RTSPLNTYPES_H */\n"},{"name":"rtw_capi.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2016 The MathWorks, Inc. */\n\n/*\n * File: rtw_capi.h\n *\n * Abstract:\n *   Provides structure types and constants generated by CAPI.\n *   Macros for accessing the fields of the structures are also provided.\n *   This header file is included in MODEL_capi.c\n *\n */\n\n#ifndef _RTW_CAPI_H_  \n# define _RTW_CAPI_H_\n\n#ifdef SL_INTERNAL\n# include \"simstruct/simstruc_types.h\"\n#else\n#ifdef HOST_CAPI_BUILD\n#include \"simstruc_types.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n#endif\n\n#define SS_ENUM_TYPE (((uint8_T)(255U))-1)\n#define SS_STRUCT    (((uint8_T)(255U)))\n#define rt_offsetof(s,el) ((uint32_T)((char_T *)&((s *)0)->el - (char_T *)(s *)0))\n\n/* Enumeration for fixed point scaling type*/\ntypedef enum {\n  rtwCAPI_FIX_UNIFORM_SCALING,\n  rtwCAPI_FIX_NONUNIFORM_SCALING,\n  rtwCAPI_FIX_RESERVED\n} rtwCAPI_FixPtScalingType;\n\n/* Enumeration for data orientation */\ntypedef enum {\n  rtwCAPI_SCALAR,\n  rtwCAPI_VECTOR,\n  rtwCAPI_MATRIX_ROW_MAJOR,\n  rtwCAPI_MATRIX_COL_MAJOR,\n  rtwCAPI_MATRIX_COL_MAJOR_ND,\n  rtwCAPI_MATRIX_ROW_MAJOR_ND\n} rtwCAPI_Orientation;\n\n/* function pointers for matfile logging */\ntypedef void(*RTWLoggingFcnPtr)(void*, const void*);\n\n/* Signals Structure */\n/* Fields of this structure can be used to monitor block output signals*/\ntypedef struct rtwCAPI_Signals_tag {\n  uint_T    addrMapIndex;  /* index into the data address map                */\n  uint_T    sysNum;        /* system identification number, where 0 = root   */\n  const char_T *blockPath; /* block's full path name (RTW mangled version)   */\n  const char_T *signalName;/* signal label (unmangled, NULL if not present)  */\n  uint16_T  portNumber;    /* port number  (starts at 0)                     */\n  uint16_T  dataTypeIndex; /* index into DataTypeMap, gives signal data type */\n  uint16_T  dimIndex;      /* index into DimensionMap, gives signal dimension*/\n  uint16_T  fxpIndex;      /* index into FixPtMap, gives Fixed point info    */\n  uint8_T   sTimeIndex;    /* index into SampleTimeMap, gives Task info      */  \n} rtwCAPI_Signals;\n\n/* Macros for accessing Signals structure fields */\n/* bio is a pointer to array of Signals structures */\n#define rtwCAPI_GetSignalAddrIdx(bio, i)       ((bio)[(i)].addrMapIndex)\n#define rtwCAPI_GetSignalBlockPath(bio, i)     ((bio)[(i)].blockPath)\n#define rtwCAPI_GetSignalName(bio, i)          ((bio)[(i)].signalName)\n#define rtwCAPI_GetSignalPortNumber(bio, i)    ((bio)[(i)].portNumber)\n#define rtwCAPI_GetSignalDataTypeIdx(bio, i)   ((bio)[(i)].dataTypeIndex)\n#define rtwCAPI_GetSignalDimensionIdx(bio, i)  ((bio)[(i)].dimIndex)\n#define rtwCAPI_GetSignalFixPtIdx(bio, i)      ((bio)[(i)].fxpIndex)\n#define rtwCAPI_GetSignalSampleTimeIdx(bio, i) ((bio)[(i)].sTimeIndex)\n#define rtwCAPI_GetSignalSysNum(bio, i)        ((bio)[(i)].sysNum)\n\n/* BlockParameters Structure */\n/* Fields of this structure can be used to monitor/modify block parameters */\ntypedef struct rtwCAPI_BlockParameters_tag {\n  uint_T    addrMapIndex;  /* index into the data address map                */\n  const char_T *blockPath; /* block's full path name (RTW mangled version)   */\n  const char_T *paramName; /* parameter name                                 */\n  uint16_T  dataTypeIndex; /* index into DataTypeMap, gives param data type  */\n  uint16_T  dimIndex;      /* index into DimensionMap, gives param dimensions*/\n  uint16_T  fxpIndex;      /* index into FixPtMap, gives Fixed point info    */\n} rtwCAPI_BlockParameters;\n\n/* Macros for accessing BlockParameter structure fields */\n/* prm is a pointer to array of BlockParameter structures */\n#define rtwCAPI_GetBlockParameterAddrIdx(prm, i)      ((prm)[(i)].addrMapIndex)\n#define rtwCAPI_GetBlockParameterBlockPath(prm, i)    ((prm)[(i)].blockPath)\n#define rtwCAPI_GetBlockParameterName(prm, i)         ((prm)[(i)].paramName)\n#define rtwCAPI_GetBlockParameterDataTypeIdx(prm, i)  ((prm)[(i)].dataTypeIndex)\n#define rtwCAPI_GetBlockParameterDimensionIdx(prm, i) ((prm)[(i)].dimIndex)\n#define rtwCAPI_GetBlockParameterFixPtIdx(prm, i)     ((prm)[(i)].fxpIndex)\n\n/* ModelParameter Structure */\n/* Fields of this structure can be used to monitor/modify model parameters   *\n * When Inline Parameters is on, you can configure tunable block parameters  *\n * as model parameters.                                                      */\ntypedef struct rtwCAPI_ModelParameters_tag {\n  uint_T    addrMapIndex;  /* index into the data address map                */\n  const char_T   *varName; /* variable  name                                 */\n  uint16_T  dataTypeIndex; /* index into DataTypeMap, gives param data type  */\n  uint16_T  dimIndex;      /* index into DimensionMap, gives param dimensions*/\n  uint16_T  fxpIndex;      /* index into FixPtMap, gives Fixed point info    */\n} rtwCAPI_ModelParameters;\n\n/* Macros for accessing ModelParameter structure fields */\n/* prm is a pointer to array of ModelParameter structures */\n#define rtwCAPI_GetModelParameterAddrIdx(prm, i)      ((prm)[(i)].addrMapIndex)\n#define rtwCAPI_GetModelParameterName(prm, i)         ((prm)[(i)].varName)\n#define rtwCAPI_GetModelParameterDataTypeIdx(prm, i)  ((prm)[(i)].dataTypeIndex)\n#define rtwCAPI_GetModelParameterDimensionIdx(prm, i) ((prm)[(i)].dimIndex)\n#define rtwCAPI_GetModelParameterFixPtIdx(prm, i)     ((prm)[(i)].fxpIndex)\n\n/* rtwCAPI_States Structure */\n/* Fields of this structure can be used to monitor block States */\ntypedef struct rtwCAPI_States_tag {\n  uint_T addrMapIndex;     /* index into the data address map                 */\n  int_T  contStateStartIndex; /* starting index in the model's continuous     * \n                               * state and state derivative vectors. This is  *\n                               * set to -1 for discrete states                */\n  const char_T *blockPath; /* block's full path name (RTW mangled version)    */\n  const char_T *stateName; /* state name, Default:DWork/Cont State Identifier */\n  const char_T *pathAlias; /* Alias block path */\n  uint16_T  dWorkIndex;    /* Index into the Block DWork, 0 for cont. states  */\n  uint16_T  dataTypeIndex; /* index into DataTypeMap, gives state data type   */\n  uint16_T  dimIndex;      /* index into DimensionMap, gives state dimensions */\n  uint16_T  fxpIndex;      /* index into FixPtMap, gives Fixed point info     */\n  uint8_T   sTimeIndex;    /* index into SampleTimeMap, gives Task info       */\n  uint8_T   isContinuous;  /* if the state is a Continuous state*/\n  int_T   hierInfoIdx;   /* the hierInfo associated with this state, -1 if no hierInfo */\n  uint_T  flatElemIdx;   /* flat element index in hierarchy */\n} rtwCAPI_States;\n\n/* Macros for accessing States structure fields */\n/* bState is a pointer to array of States structures */\n#define rtwCAPI_GetStateAddrIdx(bState, i)       ((bState)[(i)].addrMapIndex)\n#define rtwCAPI_GetContStateStartIndex(bState, i) \\\n        ((bState)[(i)].contStateStartIndex)\n#define rtwCAPI_GetStateBlockPath(bState, i)     ((bState)[(i)].blockPath)\n#define rtwCAPI_GetStateName(bState, i)          ((bState)[(i)].stateName)\n#define rtwCAPI_GetStatePathAlias(bState, i)     ((bState)[(i)].pathAlias)\n#define rtwCAPI_GetStateDWorkIdx(bState, i)      ((bState)[(i)].dWorkIndex)\n#define rtwCAPI_GetStateDataTypeIdx(bState, i)   ((bState)[(i)].dataTypeIndex)\n#define rtwCAPI_GetStateDimensionIdx(bState, i)  ((bState)[(i)].dimIndex)\n#define rtwCAPI_GetStateFixPtIndex(bState, i)    ((bState)[(i)].fxpIndex)\n#define rtwCAPI_GetStateSampleTimeIdx(bState, i) ((bState)[(i)].sTimeIndex)\n#define rtwCAPI_IsAContinuousState(bState, i)    ((bState)[(i)].isContinuous == 1)\n#define rtwCAPI_GetStateHierInfoIdx(bState, i)   ((bState)[(i)].hierInfoIdx)\n#define rtwCAPI_GetStateFlatElemIdx(bState, i)   ((bState)[(i)].flatElemIdx)\n\n/* DataTypeMap structure */\n/* Members provide data type information of a signal or parameter */ \ntypedef struct rtwCAPI_DataTypeMap_tag {\n  const char_T *cDataName;   /* C language data type name                    */\n  const char_T *mwDataName;  /* MathWorks data type, typedef in rtwtypes.h   */\n  uint16_T      numElements; /* number of elements, 0 for non-structure data */\n  uint16_T      elemMapIndex;/* index into the ElementMap, gives Bus Info    */\n  uint16_T      dataSize;    /* data size in Bytes                           */\n  uint8_T       slDataId;    /* enumerated data type from simstruc_types.h   */\n  unsigned int  isComplex:1; /* is the data type complex (1=Complex, 0=Real) */\n  unsigned int  isPointer:1; /* is data accessed Via Pointer (1=yes, 0= no)  */\n  uint8_T       enumStorageType; /* storage type for enum data types         */    \n} rtwCAPI_DataTypeMap;\n\n/* Notes on rtwCAPI_DataTypeMap:\n * cDataName  - The ANSI C equivalent data type. \n *              For fixed point data\n *                  cDataName = the native integer equivalent\n *              For Complex data or non-virtual structures, \n *                  cDataName = \"struct\" \n * mwDataName - RTW defined data type. Typedef can be found in rtwtypes.h\n *              For fixed point data, \n *                  mwDataName = the integer type in which the data is stored.\n *                  Use rtwCAPI_FixPtMap to get slope & bias of the data.\n * numElements - Number of elements/members in the data type. If the data type \n *              represents a non-virtual structure (for e.g, bus structure),\n *              this field gives the number of elements in the structure. \n *              For non-structure data type, the default value is 0\n *              Complex data types are treated as non-structures\n * elemMapIndex - Index into the rtwCAPI_ElementMap which maps each of the\n *              element/member of a structure data type.\n * slDataId   - Enumerated Simulink Data type defined in simstruc_types.h.\n *              The enumerations are\n *                 o SS_DOUBLE\n *                 o SS_SINGLE\n *                 o SS_INT8\n *                 o SS_UINT8\n *                 o SS_INT16\n *                 o SS_UINT16\n *                 o SS_INT32\n *                 o SS_UINT32\n *                 o SS_BOOLEAN\n *                 o SS_ENUM_TYPE  (for enumerated data types)\n *                 o SS_STRUCT     (for non-virtual structures)\n *              For fixed point data: \n *                  slDataId = enumeration corresponding to the integer type \n *                             in which the data is stored\n *              For Complex data: \n *                  slDataId = enumeration corresponding to the data type of \n *                             the real part.\n * isComplex  - is the data type complex (1=Complex, 0=Real) \n * isPointer  - is data accessed Via Pointer (1=yes, 0= no)\n */\n\n/* Macros for accessing DataTypeMap fields/members */\n#define rtwCAPI_GetDataTypeCName(dTypeMap, i)       ((dTypeMap)[(i)].cDataName)\n#define rtwCAPI_GetDataTypeMWName(dTypeMap, i)      ((dTypeMap)[(i)].mwDataName)\n#define rtwCAPI_GetDataTypeNumElements(dTypeMap, i) ((dTypeMap)[(i)].numElements)\n#define rtwCAPI_GetDataTypeElemMapIndex(dTypeMap,i) ((dTypeMap)[(i)].elemMapIndex)\n#define rtwCAPI_GetDataTypeSLId(dTypeMap, i)        ((dTypeMap)[(i)].slDataId)\n#define rtwCAPI_GetDataTypeSize(dTypeMap, i)        ((dTypeMap)[(i)].dataSize)\n#define rtwCAPI_GetDataIsComplex(dTypeMap, i)       ((dTypeMap)[(i)].isComplex)\n#define rtwCAPI_GetDataIsPointer(dTypeMap, i)       ((dTypeMap)[(i)].isPointer)\n#define rtwCAPI_GetDataIsEnum(dTypeMap, i)          ((dTypeMap)[(i)].slDataId == SS_ENUM_TYPE)\n#define rtwCAPI_GetDataEnumStorageType(dTypeMap, i) ((dTypeMap)[(i)].enumStorageType)\n\n/* Macros for determining whether signals/states support MAT-File logging */\n#define rtwCAPI_CanLogSignalToMATFile(dTypeMap, bio, i) \\\n    (rtwCAPI_GetDataTypeSLId(dTypeMap, rtwCAPI_GetSignalDataTypeIdx(bio, i))   < SS_NUM_BUILT_IN_DTYPE)\n#define rtwCAPI_CanLogStateToMATFile(dTypeMap, bState, i) \\\n    (rtwCAPI_GetDataTypeSLId(dTypeMap, rtwCAPI_GetStateDataTypeIdx(bState, i)) < SS_NUM_BUILT_IN_DTYPE)\n\n/* ElementMap structure */\n/* Fields provide information on elements (fields) in Simulink Bus structure */\ntypedef struct rtwCAPI_ElementMap_tag {\n  const char_T   *elementName;   /* name of the element                      */\n  uint32_T  elementOffset; /* offset of the structure element in bytes       */\n  uint16_T  dataTypeIndex; /* index into DataTypeMap, datatype of the element*/\n  uint16_T  dimIndex;      /* index into DimensionMap, element's dimensions  */\n  uint16_T  fxpIndex;      /* index into fixPtMap, fixed point information   */\n} rtwCAPI_ElementMap;\n\n/* Macros for accessing ElementMap fields */\n#define rtwCAPI_GetElementName(elemMap, i)         ((elemMap)[(i)].elementName)\n#define rtwCAPI_GetElementOffset(elemMap, i)       ((elemMap)[(i)].elementOffset)\n#define rtwCAPI_GetElementDataTypeIdx(elemMap, i)  ((elemMap)[(i)].dataTypeIndex)\n#define rtwCAPI_GetElementDimensionIdx(elemMap, i) ((elemMap)[(i)].dimIndex)\n#define rtwCAPI_GetElementFixPtIdx(elemMap, i)     ((elemMap)[(i)].fxpIndex)\n\n/* DimensionMap structure */\n/* Fields provide dimensions of a signal or a parameter */\ntypedef struct rtwCAPI_DimensionMap_tag {\n  rtwCAPI_Orientation orientation;   \n                                 /* orientation of data -scalar/vector/matrix/ND */\n  uint_T    dimArrayIndex;       /* index into dimension array                   */\n  uint8_T   numDims;             /* number of dimensions                         */\n  uint_T    vardimsIndex;        /* index into vardims address array             */\n} rtwCAPI_DimensionMap;\n\n/* Macros for accessing DimensionMap fields */\n#define rtwCAPI_GetOrientation(dimMap, i)    ((dimMap)[(i)].orientation)\n#define rtwCAPI_GetDimArrayIndex(dimMap, i)  ((dimMap)[(i)].dimArrayIndex)\n#define rtwCAPI_GetNumDims(dimMap, i)        ((dimMap)[(i)].numDims)\n#define rtwCAPI_GetDimsIsVariable(vardimsAddrMap, dimMap, i) (vardimsAddrMap[(dimMap)[(i)].vardimsIndex] != NULL)\n\n/* FixPtMap Structure */\n/* Fields provide fixed point information of a signal or parameter */\ntypedef struct rtwCAPI_FixPtMap_tag {\n  const void*       fracSlopePtr;   /* pointer to fractional slope value        */\n  const void*       biasPtr;        /* pointer to bias value                    */\n  rtwCAPI_FixPtScalingType scaleType;      \n                              /* scaling type - uniform/non-uniform       */\n  uint8_T     wordLength;     /* number of bits required to store value   *\n                               * In MATLAB, word length of the fi object  */\n  int8_T      exponent;       /* exponent                                 */\n  boolean_T   isSigned;       /* 1 = signed data, 0 = unsigned data       */\n} rtwCAPI_FixPtMap;\n\n/* Macros for accessing FixPtMap fields */\n#define rtwCAPI_GetFxpFracSlopePtr(fxpMap, i) ((fxpMap)[(i)].fracSlopePtr)\n#define rtwCAPI_GetFxpBiasPtr(fxpMap, i)      ((fxpMap)[(i)].biasPtr)\n#define rtwCAPI_GetFxpScaling(fxpMap, i)      ((fxpMap)[(i)].scaleType)\n#define rtwCAPI_GetFxpWordLength(fxpMap, i)   ((fxpMap)[(i)].wordLength)\n#define rtwCAPI_GetFxpExponent(fxpMap, i)     ((fxpMap)[(i)].exponent)\n#define rtwCAPI_GetFxpIsSigned(fxpMap, i)     ((fxpMap)[(i)].isSigned)\n\n/* Macros to get the slope and bias values casted to DOUBLE */\n#define rtwCAPI_GetFxpFracSlope(fxpMap, i) (*((real_T*) rtwCAPI_GetFxpFracSlopePtr(fxpMap,i)))\n#define rtwCAPI_GetFxpBias(fxpMap, i)      (*((real_T*) rtwCAPI_GetFxpBiasPtr(fxpMap, i))) \n\n/* SampleTimeMap Structure */\ntypedef struct rtwCAPI_SampleTimeMap_tag {\n  const void*     samplePeriodPtr;  /* pointer to sample time period value       */\n  const void*     sampleOffsetPtr;  /* pointer to sample time Offset value       */\n  int8_T    tid;              /* task identifier                           */\n  uint8_T   samplingMode;     /* 1 = FrameBased, 0 = SampleBased           */\n} rtwCAPI_SampleTimeMap;\n\n/* Macros for accessing SampleTimeMap fields */\n\n#define rtwCAPI_GetSamplePeriodPtr(sampTimeMap, i) ((sampTimeMap)[(i)].samplePeriodPtr)\n#define rtwCAPI_GetSampleOffsetPtr(sampTimeMap, i) ((sampTimeMap)[(i)].sampleOffsetPtr)\n#define rtwCAPI_GetSampleTimeTID(sampTimeMap, i)   ((sampTimeMap)[(i)].tid)\n#define rtwCAPI_GetSamplingMode(sampTimeMap, i)    ((sampTimeMap)[(i)].samplingMode)\n\n/* Macros to get sample period and offset casted to DOUBLE */\n/* if sample period is -3.0 and offset is 1.0, then it represents an initialize function,\n   if sample period is -3.0 and offset is 2.0, then it represents a terminate function,\n   if sample period is -3.0 and offset > 2.0, then it represents a reset function.\n*/\n#define rtwCAPI_GetSamplePeriod(sampTimeMap, i) (*((real_T *) rtwCAPI_GetSamplePeriodPtr(sampTimeMap, i)))\n#define rtwCAPI_GetSampleOffset(sampTimeMap, i) (*((real_T *) rtwCAPI_GetSampleOffsetPtr(sampTimeMap, i)))\n\n/* Macro to get the actual data address */\n#define rtwCAPI_GetDataAddress(dataAddrMap,addrIdx) ((dataAddrMap)[(addrIdx)])\n\n/* Macro to get the actual var dims address */\n#define rtwCAPI_GetCurrentDimsAddr(vardimsAddrMap,dimMap,addrIdx) ((vardimsAddrMap)[(dimMap)[(addrIdx)].vardimsIndex])\n\n#endif /* _RTW_CAPI_H_ */\n\n/* EOF - rtw_capi.h */\n"},{"name":"rtw_capi_examples.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2004-2014 The MathWorks, Inc.\n *\n * File: rtw_capi_examples.h     \n *\n * Abstract:\n *   Provides utility functions to traverse and access RTW generated C-API\n *   structures. The C-API structure types are provided in following 2 files.\n *\n *       matlabroot/rtw/c/src/rtw_capi.h & rtw_modelmap.h\n *\n *   The actual data structures are generated by code generator in \n *   <MODEL>_capi.c, where <MODEL> is the name of the model.\n * \n *   The functions provided in this file are\n *       capi_PrintModelParameter - Prints a model parameter value to STDOUT\n */\n\n#ifndef __RTW_CAPI_EXAMPLES_H__\n# define __RTW_CAPI_EXAMPLES_H__\n\n#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n#include \"builtin_typeid_types.h\"\n#include \"rtw_modelmap.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern void capi_PrintModelParameter(rtwCAPI_ModelMappingInfo* capiMap,  \n                                     uint_T                    paramIdx);\n \nextern void capi_PrintParameter(const char_T*  paramName,\n                                void*          paramAddress,\n                                uint8_T        slDataId,\n                                unsigned short isComplex,\n                                uint_T*        actDims,\n                                uint_T         numDims,\n                                real_T         slope,\n                                real_T         bias);\n\nextern int_T capi_ModifyModelParameter(rtwCAPI_ModelMappingInfo* capiMap,\n                                       uint_T                    paramIdx,\n                                       void*                     newParam);\n\nextern int_T capi_ModifyParameter(void                 *_param,\n                                  void                 *_newParam,\n                                  rtwCAPI_Orientation  orientation,\n                                  uint_T               *dims,\n                                  uint8_T              nDims,\n                                  uint8_T              slDataType,\n                                  unsigned short       isComplex);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n/* EOF - rtw_capi_example.h */\n\n"},{"name":"rtw_continuous.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/*\n * File: rtw_continuous.h\n *\n * Abstract:\n *   Type definitions for continuous-time support.\n *\n */\n\n#ifndef RTW_CONTINUOUS_H__\n#define RTW_CONTINUOUS_H__\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* For models registering MassMatrix */\ntypedef enum {\n    SS_MATRIX_NONE,\n    SS_MATRIX_CONSTANT,\n    SS_MATRIX_TIMEDEP,\n    SS_MATRIX_STATEDEP\n} ssMatrixType;\n\ntypedef enum {\n    SOLVER_MODE_AUTO, /* only occurs in\n                         mdlInitializeSizes/mdlInitializeSampleTimes */\n    SOLVER_MODE_SINGLETASKING,\n    SOLVER_MODE_MULTITASKING\n} SolverMode;\n\ntypedef enum { MINOR_TIME_STEP, MAJOR_TIME_STEP } SimTimeStep;\n\n/* =============================================================================\n * Model methods object\n * =============================================================================\n */\ntypedef void (*rtMdlInitializeSizesFcn)(void* rtModel);\ntypedef void (*rtMdlInitializeSampleTimesFcn)(void* rtModel);\ntypedef void (*rtMdlStartFcn)(void* rtModel);\ntypedef void (*rtMdlOutputsFcn)(void* rtModel, int_T tid);\ntypedef void (*rtMdlUpdateFcn)(void* rtModel, int_T tid);\ntypedef void (*rtMdlDerivativesFcn)(void* rtModel);\ntypedef void (*rtMdlProjectionFcn)(void* rtModel);\ntypedef void (*rtMdlMassMatrixFcn)(void* rtModel);\ntypedef void (*rtMdlForcingFunctionFcn)(void* rtModel);\ntypedef void (*rtMdlTerminateFcn)(void* rtModel);\n#ifdef RT_MALLOC\ntypedef real_T (*rtMdlDiscreteEventsFcn)(void* pModel,\n                                         int_T rtmNumSampTimes,\n                                         void* rtmTimingData,\n                                         int_T* rtmSampleHitPtr,\n                                         int_T* rtmPerTaskSampleHits);\n#endif\n\ntypedef struct _RTWRTModelMethodsInfo_tag {\n    void* rtModelPtr;\n    rtMdlInitializeSizesFcn rtmInitSizesFcn;\n    rtMdlInitializeSampleTimesFcn rtmInitSampTimesFcn;\n    rtMdlStartFcn rtmStartFcn;\n    rtMdlOutputsFcn rtmOutputsFcn;\n    rtMdlUpdateFcn rtmUpdateFcn;\n    rtMdlDerivativesFcn rtmDervisFcn;\n    rtMdlProjectionFcn rtmProjectionFcn;\n    rtMdlMassMatrixFcn rtmMassMatrixFcn;\n    rtMdlForcingFunctionFcn rtmForcingFunctionFcn;\n    rtMdlTerminateFcn rtmTerminateFcn;\n#ifdef RT_MALLOC\n    rtMdlDiscreteEventsFcn rtmDiscreteEventsFcn;\n#endif\n} RTWRTModelMethodsInfo;\n\n#define rtmiSetRTModelPtr(M, rtmp) ((M).rtModelPtr = (rtmp))\n#define rtmiGetRTModelPtr(M) (M).rtModelPtr\n\n#define rtmiSetInitSizesFcn(M, fp) ((M).rtmInitSizesFcn = ((rtMdlInitializeSizesFcn)(fp)))\n#define rtmiSetInitSampTimesFcn(M, fp) \\\n    ((M).rtmInitSampTimesFcn = ((rtMdlInitializeSampleTimesFcn)(fp)))\n#define rtmiSetStartFcn(M, fp) ((M).rtmStartFcn = ((rtMdlStartFcn)(fp)))\n#define rtmiSetOutputsFcn(M, fp) ((M).rtmOutputsFcn = ((rtMdlOutputsFcn)(fp)))\n#define rtmiSetUpdateFcn(M, fp) ((M).rtmUpdateFcn = ((rtMdlUpdateFcn)(fp)))\n#define rtmiSetDervisFcn(M, fp) ((M).rtmDervisFcn = ((rtMdlDerivativesFcn)(fp)))\n#define rtmiSetProjectionFcn(M, fp) ((M).rtmProjectionFcn = ((rtMdlProjectionFcn)(fp)))\n#define rtmiSetMassMatrixFcn(M, fp) ((M).rtmMassMatrixFcn = ((rtMdlMassMatrixFcn)(fp)))\n#define rtmiSetForcingFunctionFcn(M, fp) \\\n    ((M).rtmForcingFunctionFcn = ((rtMdlForcingFunctionFcn)(fp)))\n#define rtmiSetTerminateFcn(M, fp) ((M).rtmTerminateFcn = ((rtMdlTerminateFcn)(fp)))\n#ifdef RT_MALLOC\n#define rtmiSetDiscreteEventsFcn(M, fp) ((M).rtmDiscreteEventsFcn = ((rtMdlDiscreteEventsFcn)(fp)))\n#endif\n\n#define rtmiInitializeSizes(M) ((*(M).rtmInitSizesFcn)((M).rtModelPtr))\n#define rtmiInitializeSampleTimes(M) ((*(M).rtmInitSampTimesFcn)((M).rtModelPtr))\n#define rtmiStart(M) ((*(M).rtmStartFcn)((M).rtModelPtr))\n#define rtmiOutputs(M, tid) ((*(M).rtmOutputsFcn)((M).rtModelPtr, tid))\n#define rtmiUpdate(M, tid) ((*(M).rtmUpdateFcn)((M).rtModelPtr, tid))\n#define rtmiDerivatives(M) ((*(M).rtmDervisFcn)((M).rtModelPtr))\n#define rtmiProjection(M) ((*(M).rtmProjectionFcn)((M).rtModelPtr))\n#define rtmiMassMatrix(M) ((*(M).rtmMassMatrixFcn)((M).rtModelPtr))\n#define rtmiForcingFunction(M) ((*(M).rtmForcingFunctionFcn)((M).rtModelPtr))\n#define rtmiTerminate(M) ((*(M).rtmTerminateFcn)((M).rtModelPtr))\n#ifdef RT_MALLOC\n#define rtmiDiscreteEvents(M, x1, x2, x3, x4) \\\n    ((*(M).rtmDiscreteEventsFcn)((M).rtModelPtr, (x1), (x2), (x3), (x4)))\n#endif\n#endif /* __RTW_CONTINUOUS_H__ */\n"},{"name":"rtw_extmode.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/*\n * File: rtw_extmode.h\n *\n * Abstract:\n *   Type definitions for Simulink External Mode support.\n */\n\n#ifndef RTW_EXTMODE_H__\n#define RTW_EXTMODE_H__\n\n#ifndef _RTWEXTMODEINFO\n#define _RTWEXTMODEINFO\ntypedef struct _RTWExtModeInfo_tag RTWExtModeInfo;\n#endif\n\n/* =============================================================================\n * External mode object\n * =============================================================================\n */\nstruct _RTWExtModeInfo_tag {\n\n    void* subSysActiveVectorAddr;   /* Array of addresses pointing to\n                                     * the active vector slots for sub-systems.\n                                     * Sub-systems store information about their\n                                     * state in their extmode active vector.\n                                     */\n    uint32_T* checksumsPtr;         /* Pointer to the model's checksums array\n                                     */\n    const void** mdlMappingInfoPtr; /* Pointer to the model's mapping info\n                                     * pointer\n                                     */\n\n#if !defined(ENABLE_SLEXEC_SSBRIDGE)\n    void* tPtr; /* Copy of model's time pointer */\n#else\n    void* simStruct; /* simulink execution (raccel/rsim) needs simstruct */\n#endif\n\n    int32_T tFinalTicks; /* Used with integer only code, holds the\n                          * number of base rate ticks representing\n                          * the final time (final time in seconds\n                          * divided by base rate step size).\n                          */\n};\n\n/* gnat 3.12a2 doesn't like use \"/\" as line continuation here */\n#define rteiSetSubSystemActiveVectorAddresses(E, addr) ((E)->subSysActiveVectorAddr = ((void*)addr))\n#define rteiGetSubSystemActiveVectorAddresses(E) ((E)->subSysActiveVectorAddr)\n#define rteiGetAddrOfSubSystemActiveVector(E, idx) \\\n    ((int8_T*)((int8_T**)((E)->subSysActiveVectorAddr))[idx])\n\n#define rteiSetModelMappingInfoPtr(E, mip) ((E)->mdlMappingInfoPtr = (mip))\n#define rteiGetModelMappingInfo(E) (*((E)->mdlMappingInfoPtr))\n\n#define rteiSetChecksumsPtr(E, cp) ((E)->checksumsPtr = (cp))\n#define rteiGetChecksum0(E) (E)->checksumsPtr[0]\n#define rteiGetChecksum1(E) (E)->checksumsPtr[1]\n#define rteiGetChecksum2(E) (E)->checksumsPtr[2]\n#define rteiGetChecksum3(E) (E)->checksumsPtr[3]\n\n#define rteiGetTFinalTicks(E) ((int32_T)((E)->tFinalTicks))\n#define rteiGetPtrTFinalTicks(E) ((int32_T*)(&((E)->tFinalTicks)))\n\n#if defined(ENABLE_SLEXEC_SSBRIDGE)\n#include \"slexec_simbridge.h\"\n#else\n#define rteiSetTPtr(E, p) ((E)->tPtr = (p))\n#define rteiGetT(E) ((time_T*)(E)->tPtr)[0]\n#endif\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x) /* do nothing */\n#else\n/*\n * This is the semi-ANSI standard way of indicating that a\n * unused function parameter is required.\n */\n#define UNUSED_PARAMETER(x) (void)(x)\n#endif\n#endif\n\n#endif /* __RTW_EXTMODE_H__ */\n"},{"name":"rtw_linux.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"#ifndef RTW_LINUX_H\n#define RTW_LINUX_H\n\n/*\n * Copyright 2011-2018 The MathWorks, Inc.\n *\n * File: rtw_linux.h\n *\n * Abstract:\n *  Function prototypes and defines pthread mutex/semaphores\n */\n#include <pthread.h>\n#include <stdlib.h>\n#include <semaphore.h>\n\n#ifndef __USE_UNIX98\n#define __USE_UNIX98\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nextern void rtw_pthread_mutex_init( void** mutexDW );        \nextern void* rtw_register_task(void (*)(void));\nextern void rtw_trigger_task(void*);\nextern void rtw_waitfor_task(void*);\nextern void rtw_deregister_task(void*);\n\n#ifdef __cplusplus\n}\n#endif\n\n#define rtw_pthread_mutex_lock( mutexDW ) \\\n    pthread_mutex_lock((pthread_mutex_t *)(mutexDW));\n\n#define rtw_pthread_mutex_unlock( mutexDW ) \\\n    pthread_mutex_unlock((pthread_mutex_t *)(mutexDW));\n\n#define rtw_pthread_mutex_destroy( mutexDW )      \\\n    pthread_mutex_destroy((pthread_mutex_t *)(mutexDW)); \\\n    free(mutexDW);\n\n#define rtw_pthread_sem_create( semaphoreDW, initVal ) \\\n    *semaphoreDW = malloc(sizeof(sem_t));               \\\n    sem_init(*(semaphoreDW), 0, (initVal));\n\n#define rtw_pthread_sem_wait( semaphoreDW ) \\\n    sem_wait(semaphoreDW);\n\n#define rtw_pthread_sem_post( semaphoreDW ) \\\n    sem_post(semaphoreDW);\n\n#define rtw_pthread_sem_destroy( semaphoreDW ) \\\n    sem_destroy(semaphoreDW);                   \\\n    free(semaphoreDW);\n\n#endif /* RTW_LINUX_H */\n\n/* LocalWords:  pthread\n */\n"},{"name":"rtw_linux_mac.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"#ifndef RTW_LINUX_MAC_H\n#define RTW_LINUX_MAC_H\n\n/*\n * Copyright 2011 The MathWorks, Inc.\n *\n * File: rtw_linux_mac.h\n *\n * Abstract:\n *  Function prototypes and defines pthread mutex/semaphores\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <pthread.h>\n#include <stdlib.h>\n#include <semaphore.h>\n\n#ifndef __USE_UNIX98\n#define __USE_UNIX98\n#endif\n\nextern void rtw_pthread_mutex_init_mac( void** mutexDW );\nextern void* rtw_register_task(void (*)(void));\nextern void rtw_trigger_task(void*);\nextern void rtw_waitfor_task(void*);\nextern void rtw_deregister_task(void*);\n\n#define rtw_pthread_mutex_lock_mac( mutexDW )                   \\\n    pthread_mutex_lock((pthread_mutex_t *)(mutexDW));\n\n#define rtw_pthread_mutex_unlock_mac( mutexDW )                 \\\n    pthread_mutex_unlock((pthread_mutex_t *)(mutexDW));\n\n#define rtw_pthread_mutex_destroy_mac( mutexDW )                \\\n    pthread_mutex_destroy((pthread_mutex_t *)(mutexDW));        \\\n    free(mutexDW);\n\nextern void rtw_pthread_sem_create_mac( void** semaphoreDW1, \n                                 void** semaphoreDW2, \n                                 long initVal );\n\n\n#define rtw_pthread_sem_wait_mac( semaphoreDW ) \\\n    sem_wait(semaphoreDW);\n\n#define rtw_pthread_sem_post_mac( semaphoreDW ) \\\n    sem_post(semaphoreDW);\n\n#define rtw_pthread_sem_destroy_mac( semaphoreDW ) \\\n    sem_unlink((char*)(semaphoreDW));              \\\n    free(semaphoreDW);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* RTW_LINUX_MAC_H */\n\n/* LocalWords:  pthread\n */\n"},{"name":"rtw_matlogging.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/*\n * File: rtw_matlogging.h\n *\n * Abstract:\n *   Type definitions for MAT-file logging support.\n */\n\n#ifndef RTW_MATLOGGING_H__\n#define RTW_MATLOGGING_H__\n\n#include \"sl_types_def.h\" /* DTypeId */\n\n/*\n * The RTWLogSignalInfo and RTWLogInfo structures are for use by\n * the Real-Time Workshop and should not be used by S-functions.\n */\ntypedef const int8_T* const* LogSignalPtrsType;\n\n#ifndef NO_FLOATS /* ERT integer-only */\n\ntypedef struct RTWLogDataTypeConvert_tag {\n\n    int conversionNeeded;\n    BuiltInDTypeId dataTypeIdLoggingTo;\n    DTypeId dataTypeIdOriginal;\n    int bitsPerChunk;\n    int numOfChunk;\n    unsigned int isSigned;\n    real_T fracSlope;\n    int fixedExp;\n    real_T bias;\n\n} RTWLogDataTypeConvert;\n\ntypedef void (*RTWPreprocessingFcnPtr)(void*, const void*);\n\ntypedef struct RTWLogSignalInfo_tag {\n    int_T numSignals;\n    int_T* numCols;\n    int_T* numDims;\n    int_T* dims;\n    boolean_T* isVarDims;   /* Dimension Mode: true -- VarDims / false -- fixed dims */\n    void** currSigDims;     /* current signal dimensions */\n    int_T* currSigDimsSize; /* Size of currSigDims in bytes */\n    BuiltInDTypeId* dataTypes;\n    int_T* complexSignals;\n    int_T* frameData;\n    RTWPreprocessingFcnPtr* preprocessingPtrs;\n\n    union {\n        const char_T** cptr;\n        char_T** ptr;\n    } labels;\n\n    char_T* titles;\n    int_T* titleLengths;\n    int_T* plotStyles;\n\n    union {\n        const char_T** cptr;\n        char_T** ptr;\n    } blockNames;\n\n    union {\n        const char_T** cptr;\n        char_T** ptr;\n    } stateNames;\n\n    boolean_T* crossMdlRef;\n\n    RTWLogDataTypeConvert* dataTypeConvert;\n\n} RTWLogSignalInfo;\n\n/* =============================================================================\n * Logging object\n * =============================================================================\n */\ntypedef struct _RTWLogInfo_tag {\n    void* logInfo; /* Pointer to a book keeping structure    *\n                    * used in rtwlog.c                       */\n\n    union {\n        LogSignalPtrsType cptr; /* Pointers to the memory location    */\n        int8_T** ptr;           /* of the data to be logged into the  *\n                                 * states structure. Not used if      *\n                                 * logging data in matrix format.     */\n\n    } logXSignalPtrs;\n\n    union {\n        LogSignalPtrsType cptr; /* Pointers to the memory location    */\n        int8_T** ptr;           /* of the data to be logged into the  *\n                                 * outputs structure. Not used if     *\n                                 * logging data in matrix format.     */\n    } logYSignalPtrs;\n\n    int_T logFormat; /* matrix=0, struct=1, or strut_wo_time=2 */\n\n    int_T logMaxRows;    /* Max number of rows (0 for no limit)    */\n    int_T logDecimation; /* Data logging interval                  */\n\n    const char_T* logVarNameModifier; /* pre(post)fix string modifier for the   *\n                                       * log variable names                     */\n\n    const char_T* logT;      /* Name of variable to log time           */\n    const char_T* logX;      /* Name of variable to log states         */\n    const char_T* logXFinal; /* Name of variable to log final state    */\n    const char_T* logY;      /* Name of variable(s) to log outputs     */\n    const char_T* logSL;     /* Name of variable(s) to log signal logging */\n\n    union { /* Info about the states             */\n        const RTWLogSignalInfo* cptr;\n        RTWLogSignalInfo* ptr;\n    } logXSignalInfo;\n\n    union { /* Info about the outputs            */\n        const RTWLogSignalInfo* cptr;\n        RTWLogSignalInfo* ptr;\n    } logYSignalInfo;\n\n    void (*mdlLogData)(void* rtli, void* tPtr);\n    void (*mdlLogDataIfInInterval)(void* rtli, void* tPtr, boolean_T isInInterval);\n\n    const void* mmi; /* Add the ModelMapping Info to the LogInfo\n                      * so we can get at it for state logging */\n    void* loggingInterval;\n\n} RTWLogInfo;\n\n#endif\n\n/* Macros associated with RTWLogInfo */\n#define rtliGetLogInfo(rtli) ((LogInfo*)(rtli)->logInfo)\n#define rtliSetLogInfo(rtli, ptr) ((rtli)->logInfo = ((void*)ptr))\n\n#define rtliGetLogFormat(rtli) (rtli)->logFormat\n#define rtliSetLogFormat(rtli, f) ((rtli)->logFormat = (f))\n\n#define rtliGetLogVarNameModifier(rtli) (rtli)->logVarNameModifier\n#define rtliSetLogVarNameModifier(rtli, name) ((rtli)->logVarNameModifier = (name))\n\n#define rtliGetLogMaxRows(rtli) (rtli)->logMaxRows\n#define rtliSetLogMaxRows(rtli, num) ((rtli)->logMaxRows = (num))\n\n#define rtliGetLogDecimation(rtli) (rtli)->logDecimation\n#define rtliSetLogDecimation(rtli, l) ((rtli)->logDecimation = (l))\n\n#define rtliGetLogT(rtli) (rtli)->logT\n#define rtliSetLogT(rtli, lt) ((rtli)->logT = (lt))\n\n#define rtliGetLogX(rtli) (rtli)->logX\n#define rtliSetLogX(rtli, lx) ((rtli)->logX = (lx))\n\n#define rtliGetLogY(rtli) (rtli)->logY\n#define rtliSetLogY(rtli, ly) ((rtli)->logY = (ly))\n\n#define rtliGetLogXFinal(rtli) (rtli)->logXFinal\n#define rtliSetLogXFinal(rtli, lxf) ((rtli)->logXFinal = (lxf))\n\n#define rtliGetLogXSignalInfo(rtli) (rtli)->logXSignalInfo.cptr\n#define rtliSetLogXSignalInfo(rtli, lxi) ((rtli)->logXSignalInfo.cptr = (lxi))\n#define _rtliGetLogXSignalInfo(rtli) (rtli)->logXSignalInfo.ptr\n\n#define rtliGetLogYSignalInfo(rtli) (rtli)->logYSignalInfo.cptr\n#define rtliSetLogYSignalInfo(rtli, lyi) ((rtli)->logYSignalInfo.cptr = (lyi))\n#define _rtliGetLogYSignalInfo(rtli) (rtli)->logYSignalInfo.ptr\n\n#define rtliGetLogXSignalPtrs(rtli) (rtli)->logXSignalPtrs.cptr\n#define rtliSetLogXSignalPtrs(rtli, lxp) ((rtli)->logXSignalPtrs.cptr = (lxp))\n#define _rtliGetLogXSignalPtrs(rtli) (rtli)->logXSignalPtrs.ptr\n\n#define rtliGetLogYSignalPtrs(rtli) (rtli)->logYSignalPtrs.cptr\n#define rtliSetLogYSignalPtrs(rtli, lyp) ((rtli)->logYSignalPtrs.cptr = (lyp))\n#define _rtliGetLogYSignalPtrs(rtli) (rtli)->logYSignalPtrs.ptr\n\n#define rtliGetMMI(rtli) (rtli)->mmi\n#define rtliSetMMI(rtli, mmiIn) ((rtli)->mmi = ((void*)mmiIn))\n\n#define rtliGetLoggingInterval(rtli) (rtli)->loggingInterval\n\n/* ========================================================================== */\n\n#endif /* __RTW_MATLOGGING_H__ */\n"},{"name":"rtw_matlogging_simtarget.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/*\n * File: rtw_matlogging.h\n *\n * Abstract:\n *   Type definitions for MAT-file logging support.\n */\n\n#ifndef RTW_MATLOGGING_SIMTARGET_H__\n#define RTW_MATLOGGING_SIMTARGET_H__\n\n#include \"sl_types_def.h\" /* DTypeId */\n\n/*\n * The RTWLogSignalInfo and RTWLogInfo structures are for use by\n * the Real-Time Workshop and should not be used by S-functions.\n */\ntypedef const int8_T* const* LogSignalPtrsType;\n\n#ifndef NO_FLOATS /* ERT integer-only */\n\ntypedef struct RTWLogDataTypeConvert_tag {\n\n    int conversionNeeded;\n    BuiltInDTypeId dataTypeIdLoggingTo;\n    DTypeId dataTypeIdOriginal;\n    int bitsPerChunk;\n    int numOfChunk;\n    unsigned int isSigned;\n    real_T fracSlope;\n    int fixedExp;\n    real_T bias;\n\n} RTWLogDataTypeConvert;\n\ntypedef void (*RTWPreprocessingFcnPtr)(void*, const void*);\n\ntypedef struct RTWLogSignalInfo_tag {\n    int_T numSignals;\n    int_T* numCols;\n    int_T* numDims;\n    int_T* dims;\n    boolean_T* isVarDims;   /* Dimension Mode: true -- VarDims / false -- fixed dims */\n    void** currSigDims;     /* current signal dimensions */\n    int_T* currSigDimsSize; /* Size of currSigDims in bytes */\n    BuiltInDTypeId* dataTypes;\n    int_T* complexSignals;\n    int_T* frameData;\n    RTWPreprocessingFcnPtr* preprocessingPtrs;\n\n    union {\n        const char_T** cptr;\n        char_T** ptr;\n    } labels;\n\n    char_T* titles;\n    int_T* titleLengths;\n    int_T* plotStyles;\n\n    union {\n        const char_T** cptr;\n        char_T** ptr;\n    } blockNames;\n\n    union {\n        const char_T** cptr;\n        char_T** ptr;\n    } stateNames;\n\n    boolean_T* crossMdlRef;\n\n    RTWLogDataTypeConvert* dataTypeConvert;\n\n    int_T* stateIdxList;\n\n} RTWLogSignalInfo;\n\n/* =============================================================================\n * Logging object\n * =============================================================================\n */\ntypedef struct _RTWLogInfo_tag {\n    void* logInfo; /* Pointer to a book keeping structure    *\n                    * used in rtwlog.c                       */\n\n    union {\n        LogSignalPtrsType cptr; /* Pointers to the memory location    */\n        int8_T** ptr;           /* of the data to be logged into the  *\n                                 * states structure. Not used if      *\n                                 * logging data in matrix format.     */\n\n    } logXSignalPtrs;\n\n    union {\n        LogSignalPtrsType cptr; /* Pointers to the memory location    */\n        int8_T** ptr;           /* of the data to be logged into the  *\n                                 * outputs structure. Not used if     *\n                                 * logging data in matrix format.     */\n    } logYSignalPtrs;\n\n    int_T logFormat; /* matrix=0, struct=1, or strut_wo_time=2 */\n\n    int_T logMaxRows;    /* Max number of rows (0 for no limit)    */\n    int_T logDecimation; /* Data logging interval                  */\n\n    const char_T* logVarNameModifier; /* pre(post)fix string modifier for the   *\n                                       * log variable names                     */\n\n    const char_T* logT;      /* Name of variable to log time           */\n    const char_T* logX;      /* Name of variable to log states         */\n    const char_T* logXFinal; /* Name of variable to log final state    */\n    const char_T* logY;      /* Name of variable(s) to log outputs     */\n    const char_T* logSL;     /* Name of variable(s) to log signal logging */\n\n    union { /* Info about the states             */\n        const RTWLogSignalInfo* cptr;\n        RTWLogSignalInfo* ptr;\n    } logXSignalInfo;\n\n    union { /* Info about the outputs            */\n        const RTWLogSignalInfo* cptr;\n        RTWLogSignalInfo* ptr;\n    } logYSignalInfo;\n\n    void (*mdlLogData)(void* rtli, void* tPtr);\n    void (*mdlLogDataIfInInterval)(void* rtli, void* tPtr, boolean_T isInInterval);\n\n    const void* mmi; /* Add the ModelMapping Info to the LogInfo\n                      * so we can get at it for state logging */\n    void* loggingInterval;\n\n} RTWLogInfo;\n\n#endif\n\n/* Macros associated with RTWLogInfo */\n#define rtliGetLogInfo(rtli) ((LogInfo*)(rtli)->logInfo)\n#define rtliSetLogInfo(rtli, ptr) ((rtli)->logInfo = ((void*)ptr))\n\n#define rtliGetLogFormat(rtli) (rtli)->logFormat\n#define rtliSetLogFormat(rtli, f) ((rtli)->logFormat = (f))\n\n#define rtliGetLogVarNameModifier(rtli) (rtli)->logVarNameModifier\n#define rtliSetLogVarNameModifier(rtli, name) ((rtli)->logVarNameModifier = (name))\n\n#define rtliGetLogMaxRows(rtli) (rtli)->logMaxRows\n#define rtliSetLogMaxRows(rtli, num) ((rtli)->logMaxRows = (num))\n\n#define rtliGetLogDecimation(rtli) (rtli)->logDecimation\n#define rtliSetLogDecimation(rtli, l) ((rtli)->logDecimation = (l))\n\n#define rtliGetLogT(rtli) (rtli)->logT\n#define rtliSetLogT(rtli, lt) ((rtli)->logT = (lt))\n\n#define rtliGetLogX(rtli) (rtli)->logX\n#define rtliSetLogX(rtli, lx) ((rtli)->logX = (lx))\n\n#define rtliGetLogY(rtli) (rtli)->logY\n#define rtliSetLogY(rtli, ly) ((rtli)->logY = (ly))\n\n#define rtliGetLogXFinal(rtli) (rtli)->logXFinal\n#define rtliSetLogXFinal(rtli, lxf) ((rtli)->logXFinal = (lxf))\n\n#define rtliGetLogXSignalInfo(rtli) (rtli)->logXSignalInfo.cptr\n#define rtliSetLogXSignalInfo(rtli, lxi) ((rtli)->logXSignalInfo.cptr = (lxi))\n#define _rtliGetLogXSignalInfo(rtli) (rtli)->logXSignalInfo.ptr\n\n#define rtliGetLogYSignalInfo(rtli) (rtli)->logYSignalInfo.cptr\n#define rtliSetLogYSignalInfo(rtli, lyi) ((rtli)->logYSignalInfo.cptr = (lyi))\n#define _rtliGetLogYSignalInfo(rtli) (rtli)->logYSignalInfo.ptr\n\n#define rtliGetLogXSignalPtrs(rtli) (rtli)->logXSignalPtrs.cptr\n#define rtliSetLogXSignalPtrs(rtli, lxp) ((rtli)->logXSignalPtrs.cptr = (lxp))\n#define _rtliGetLogXSignalPtrs(rtli) (rtli)->logXSignalPtrs.ptr\n\n#define rtliGetLogYSignalPtrs(rtli) (rtli)->logYSignalPtrs.cptr\n#define rtliSetLogYSignalPtrs(rtli, lyp) ((rtli)->logYSignalPtrs.cptr = (lyp))\n#define _rtliGetLogYSignalPtrs(rtli) (rtli)->logYSignalPtrs.ptr\n\n#define rtliGetMMI(rtli) (rtli)->mmi\n#define rtliSetMMI(rtli, mmiIn) ((rtli)->mmi = ((void*)mmiIn))\n\n#define rtliGetLoggingInterval(rtli) (rtli)->loggingInterval\n\n/* ========================================================================== */\n\n#endif /* RTW_MATLOGGING_SIMTARGET_H__ */\n"},{"name":"rtw_modelmap.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2020 The MathWorks, Inc. */\n\n/*\n * File: rtw_modelmap.h\n *\n * Abstract:\n *   Model tuning information.  Use the provided structure access methods\n *   whenever possible.\n *\n *   For details about these structures see Simulink Coder User's guide.\n */\n\n#ifndef __RTW_MODELMAP__\n#define __RTW_MODELMAP__\n\n#ifdef SL_INTERNAL\n\n# include \"version.h\"\n# include \"util/memmgr/memalloc.hpp\"\n# include \"simstruct/simstruc_types.h\"\n# include \"simulinkcoder_capi_export.hpp\"\n\n#else\n\n# include <stdlib.h>\n\n#ifdef HOST_CAPI_BUILD\n# include \"simstruc_types.h\"\n#else\n# include \"rtwtypes.h\"\n#endif\n\n#ifndef __RTW_UTFREE__\n# define __RTW_UTFREE__\n# define  utFree(arg)    if (arg) free(arg)\n# define  utMalloc(arg)  malloc(arg)\n#endif\n\n# define SIMULINKCODER_CAPI_API extern\n#endif\n\n#include \"rtw_capi.h\"\n#include \"rtw_modelmap_logging.h\"\n\ntypedef struct rtwCAPI_ModelMappingInfo_tag rtwCAPI_ModelMappingInfo;\ntypedef struct rtwCAPI_ModelMappingStaticInfo_tag rtwCAPI_ModelMappingStaticInfo;\n\n/* ModelMappingStaticInfo */\nstruct rtwCAPI_ModelMappingStaticInfo_tag {\n    /* signals */\n    struct {\n        rtwCAPI_Signals const *signals;     /* Signals Array */\n        uint_T                numSignals;   /* Num Signals   */\n        rtwCAPI_Signals const *rootInputs;  /* Root Inputs array */\n        uint_T               numRootInputs; /* Num Root Inputs  */\n        rtwCAPI_Signals const *rootOutputs; /* Root Outputs array */\n        uint_T               numRootOutputs;/* Num Root Outputs  */\n    } Signals;\n\n    /* parameters */\n    struct {\n        rtwCAPI_BlockParameters const *blockParameters;   /* Block parameters Array   */\n        uint_T                       numBlockParameters; /* Num block parameters     */\n        rtwCAPI_ModelParameters const *modelParameters;   /* Model parameters Array*/\n        uint_T                       numModelParameters; /* Num Model parameters  */\n    } Params;\n\n    /* states */\n    struct {\n        rtwCAPI_States const *states;   /* States array */\n        uint_T               numStates; /* Num States   */\n    } States;\n\n    /* Static maps */\n    /* datatypes, dimensions, fixed point, structure elements, sample times  */\n    struct {\n        rtwCAPI_DataTypeMap   const   *dataTypeMap;       /* Data Type Map          */\n        rtwCAPI_DimensionMap  const   *dimensionMap;      /* Data Dimension Map     */\n        rtwCAPI_FixPtMap      const   *fixPtMap;          /* Fixed Point Map        */\n        rtwCAPI_ElementMap    const   *elementMap;        /* Structure Element map  */\n        rtwCAPI_SampleTimeMap const   *sampleTimeMap;     /* Sample Times Map       */\n        uint_T        const   *dimensionArray;    /* Dimension Array        */\n    } Maps;\n\n    /* TargetType - string specifying the intended target of the generated  *\n     * C-API.                                                               *\n     * targetType = \"float\"   - target supports floats and integer code     *\n     *            = \"integer\" - target supports integer only code           */\n    char_T const     *targetType;\n\n    /* for internal use */\n    uint32_T modelChecksum[4];\n    rtwCAPI_ModelMapLoggingStaticInfo const *staticLogInfo;\n    size_t\t rtpSize;\n    /* If this instance in a protected model*/\n    boolean_T isProtectedModel;\n};\n\n/* ModelMappingInfo */\nstruct rtwCAPI_ModelMappingInfo_tag {\n    /* ModelMappingInfo version */\n    uint8_T                 versionNum;\n\n    /* Reference to static model data, all model instances share this map   */\n    rtwCAPI_ModelMappingStaticInfo *staticMap;\n\n    /* Instance specific Maps, each model instance has a unique InstanceMap */\n    struct {\n        const char*                path;             /* Path to this instance */\n        char*                      fullPath;\n        void**                     dataAddrMap;      /* Data Address map      */\n        rtwCAPI_ModelMappingInfo** childMMIArray;    /* array of child MMI    */\n        uint_T                     childMMIArrayLen; /* Number of child MMIs  */\n        int_T                      contStateStartIndex; \n\n        /* for internal use */\n        rtwCAPI_ModelMapLoggingInstanceInfo *instanceLogInfo;\n        int32_T**                      vardimsAddrMap;   /* Vardims Address map   */\n        void*\t\t\t       rtpAddress;\n        RTWLoggingFcnPtr* RTWLoggingPtrs;   /* MatFile logging information */\n    } InstanceMap;\n};\n\n/* Macros for accessing ModelMappingStaticInfo fields */\n#define rtwCAPI_GetSignalsFromStaticMap(SM)             ((SM)->Signals.signals)\n#define rtwCAPI_GetNumSignalsFromStaticMap(SM)          ((SM)->Signals.numSignals) \n#define rtwCAPI_GetLogSignalsArrayFromStaticMap(SM)     ((SM)->Signals.logSignalsArray)\n#define rtwCAPI_GetNumLogSignalsFromStaticMap(SM)       ((SM)->Signals.numLogSignals) \n\n#define rtwCAPI_GetBlockParametersFromStaticMap(SM)     ((SM)->Params.blockParameters)\n#define rtwCAPI_GetNumBlockParametersFromStaticMap(SM)  ((SM)->Params.numBlockParameters) \n#define rtwCAPI_GetModelParametersFromStaticMap(SM)     ((SM)->Params.modelParameters)\n#define rtwCAPI_GetNumModelParametersFromStaticMap(SM)  ((SM)->Params.numModelParameters)\n\n#define rtwCAPI_GetStatesFromStaticMap(SM)              ((SM)->States.states)\n#define rtwCAPI_GetNumStatesFromStaticMap(SM)           ((SM)->States.numStates)\n\n#define rtwCAPI_GetRootInputsFromStaticMap(SM)          ((SM)->Signals.rootInputs) \n#define rtwCAPI_GetNumRootInputsFromStaticMap(SM)       ((SM)->Signals.numRootInputs)\n#define rtwCAPI_GetRootOutputsFromStaticMap(SM)         ((SM)->Signals.rootOutputs)\n#define rtwCAPI_GetNumRootOutputsFromStaticMap(SM)      ((SM)->Signals.numRootOutputs)\n\n#define rtwCAPI_GetDataTypeMapFromStaticMap(SM)         ((SM)->Maps.dataTypeMap)\n#define rtwCAPI_GetDimensionMapFromStaticMap(SM)        ((SM)->Maps.dimensionMap)\n#define rtwCAPI_GetFixPtMapFromStaticMap(SM)            ((SM)->Maps.fixPtMap)\n#define rtwCAPI_GetElementMapFromStaticMap(SM)          ((SM)->Maps.elementMap)\n#define rtwCAPI_GetSampleTimeMapFromStaticMap(SM)       ((SM)->Maps.sampleTimeMap)\n#define rtwCAPI_GetDimensionArrayFromStaticMap(SM)      ((SM)->Maps.dimensionArray)\n\n/* Macros for accessing ModelMappingInfo fields */\n#define rtwCAPI_GetSignals(MMI)         rtwCAPI_GetSignalsFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumSignals(MMI)      rtwCAPI_GetNumSignalsFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetLogSignalsArray(MMI) rtwCAPI_GetLogSignalsArrayFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumLogSignals(MMI)   rtwCAPI_GetNumLogSignalsFromStaticMap((MMI)->staticMap)\n\n#define rtwCAPI_GetBlockParameters(MMI)    rtwCAPI_GetBlockParametersFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumBlockParameters(MMI) rtwCAPI_GetNumBlockParametersFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetModelParameters(MMI)    rtwCAPI_GetModelParametersFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumModelParameters(MMI) rtwCAPI_GetNumModelParametersFromStaticMap((MMI)->staticMap)\n\n#define rtwCAPI_GetStates(MMI)     rtwCAPI_GetStatesFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumStates(MMI)  rtwCAPI_GetNumStatesFromStaticMap((MMI)->staticMap)\n\n#define rtwCAPI_GetRootInputs(MMI)     rtwCAPI_GetRootInputsFromStaticMap((MMI)->staticMap) \n#define rtwCAPI_GetNumRootInputs(MMI)  rtwCAPI_GetNumRootInputsFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetRootOutputs(MMI)    rtwCAPI_GetRootOutputsFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumRootOutputs(MMI) rtwCAPI_GetNumRootOutputsFromStaticMap((MMI)->staticMap)\n\n#define rtwCAPI_GetDataTypeMap(MMI)       rtwCAPI_GetDataTypeMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetDimensionMap(MMI)      rtwCAPI_GetDimensionMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetFixPtMap(MMI)          rtwCAPI_GetFixPtMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetElementMap(MMI)        rtwCAPI_GetElementMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetSampleTimeMap(MMI)     rtwCAPI_GetSampleTimeMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetDimensionArray(MMI)    rtwCAPI_GetDimensionArrayFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_IsProtectedModel(MMI)     ((MMI)->staticMap->isProtectedModel)\n\n#define rtwCAPI_GetStaticLoggingInfo(MMI) ((MMI)->staticMap->staticLogInfo)\n\n#define rtwCAPI_GetVersion(MMI)           ((MMI)->versionNum)\n#define rtwCAPI_GetDataAddressMap(MMI)    ((MMI)->InstanceMap.dataAddrMap)\n#define rtwCAPI_GetVarDimsAddressMap(MMI) ((MMI)->InstanceMap.vardimsAddrMap)\n#define rtwCAPI_GetRTWLoggingPtrsMap(MMI) ((MMI)->InstanceMap.RTWLoggingPtrs)\n#define rtwCAPI_GetPath(MMI)              ((MMI)->InstanceMap.path)\n#define rtwCAPI_GetFullPath(MMI)          ((MMI)->InstanceMap.fullPath)\n#define rtwCAPI_GetChildMMI(MMI,i)        ((MMI)->InstanceMap.childMMIArray[i])\n#define rtwCAPI_GetChildMMIArray(MMI)     ((MMI)->InstanceMap.childMMIArray)\n#define rtwCAPI_GetChildMMIArrayLen(MMI)  ((MMI)->InstanceMap.childMMIArrayLen)\n#define rtwCAPI_MMIGetContStateStartIndex(MMI) ((MMI)->InstanceMap.contStateStartIndex)\n#define rtwCAPI_GetInstanceLoggingInfo(MMI) ((MMI)->InstanceMap.instanceLogInfo)\n\n/* Macros for setting ModelMappingInfo fields */\n#define rtwCAPI_SetVersion(MMI, n)            ((MMI).versionNum = (n))\n#define rtwCAPI_SetStaticMap(MMI, statMap)    (MMI).staticMap = (statMap)\n#define rtwCAPI_SetLoggingStaticMap(MMI,lStatMap) (MMI).staticMap->staticLogInfo = (lStatMap)\n#define rtwCAPI_SetDataAddressMap(MMI, dAddr) (MMI).InstanceMap.dataAddrMap = (dAddr)\n#define rtwCAPI_SetVarDimsAddressMap(MMI, vAddr) (MMI).InstanceMap.vardimsAddrMap = (vAddr)\n#define rtwCAPI_SetLoggingPtrs(MMI, lAddr)    (MMI).InstanceMap.RTWLoggingPtrs = (lAddr)\n#define rtwCAPI_SetPath(MMI,p)                (MMI).InstanceMap.path = (p)\n#define rtwCAPI_SetFullPath(MMI,p)            (MMI).InstanceMap.fullPath = (p)\n#define rtwCAPI_SetChildMMI(MMI,i,cMMI)       (MMI).InstanceMap.childMMIArray[i] = (cMMI)\n#define rtwCAPI_SetChildMMIArray(MMI,cMMIs)   (MMI).InstanceMap.childMMIArray = (cMMIs)\n#define rtwCAPI_SetChildMMIArrayLen(MMI,n)    (MMI).InstanceMap.childMMIArrayLen = (n)\n#define rtwCAPI_MMISetContStateStartIndex(MMI,i) (MMI).InstanceMap.contStateStartIndex = (i)\n#define rtwCAPI_SetInstanceLoggingInfo(MMI,l) (MMI).InstanceMap.instanceLogInfo = (l)\n\n/* Functions in rtw_modelmap_utils.c */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nSIMULINKCODER_CAPI_API char*         rtwCAPI_EncodePath(const char* path);\nSIMULINKCODER_CAPI_API boolean_T     rtwCAPI_HasStates(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumStateRecords(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumStateRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumContStateRecords(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API void          rtwCAPI_FreeFullPaths(rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API const char_T* rtwCAPI_UpdateFullPaths(rtwCAPI_ModelMappingInfo* mmi,\n                                                                             const char_T*     path,\n                                                                             boolean_T isCalledFromTopModel);\nSIMULINKCODER_CAPI_API char*         rtwCAPI_GetFullStateBlockPath(const char* stateBlockPath,\n                                                                                   const char* mmiPath,\n                                                                                   size_t      mmiPathLen,\n                                                                                   boolean_T   crossingModel);\nSIMULINKCODER_CAPI_API uint_T        rtwCAPI_GetStateWidth(const rtwCAPI_DimensionMap* dimMap,\n                                                                           const uint_T*               dimArray,\n                                                                           const rtwCAPI_States*       states,\n                                                                           uint_T                      iState);\nSIMULINKCODER_CAPI_API const char_T* rtwCAPI_GetStateRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                                                                const char_T**                  sigBlockName,\n                                                                                const char_T**                  sigLabel,\n                                                                                const char_T**                  sigName,\n                                                                                int_T*                          sigWidth,\n                                                                                int_T*                          sigDataType,\n                                                                                int_T*                          logDataType,\n                                                                                int_T*                          sigComplexity,\n                                                                                void**                          sigDataAddr,\n                                                                                RTWLoggingFcnPtr*               RTWLoggingPtrs,\n                                                                                boolean_T*                      sigCrossMdlRef,\n                                                                                boolean_T*                      sigInProtectedMdl,\n                                                                                const char_T**                  sigPathAlias,\n                                                                                double*                         sigSampleTime,\n                                                                                int_T*                          sigHierInfoIdx,\n                                                                                uint_T*                         sigFlatElemIdx,\n                                                                                const rtwCAPI_ModelMappingInfo** sigMMI,\n                                                                                int_T*                          sigIdx,\n                                                                                boolean_T                       crossingModel,\n                                                                                boolean_T                       isInProtectedMdl,\n                                                                                real_T*                         stateDerivVector,\n                                                                                boolean_T                       rtwLogging);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumSigLogRecords(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumSigLogRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API const char_T* rtwCAPI_GetSigLogRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                                                                 const char_T**    sigBlockName,\n                                                                                 const char_T**    sigLabel,\n                                                                                 int_T*            sigWidth,\n                                                                                 int_T*            sigDataType,\n                                                                                 int_T*            logDataType,\n                                                                                 int_T*            sigComplexity,\n                                                                                 void**            sigDataAddr,\n                                                                                 boolean_T*        sigCrossMdlRef,\n                                                                                 int_T*            sigIdx,\n                                                                                 boolean_T         crossingModel,\n                                                                                 boolean_T         rtwLogging);\nSIMULINKCODER_CAPI_API void          rtwCAPI_CountSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n                                                                         int                            *count);\nSIMULINKCODER_CAPI_API void          rtwCAPI_FillSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n                                                                        sysRanDType                    **sysRan,\n                                                                        int                            *sysTid,\n                                                                        int                            *fillIdx);\n#ifdef __cplusplus\n}\n#endif\n\n#endif  /* __RTW_MODELMAP__ */\n\n/* EOF - rtw_modelmap.h */\n\n/* LocalWords:  MMI Vardims utils\n */\n"},{"name":"rtw_modelmap_logging.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2013 The MathWorks, Inc. */\n\n/*\n * File: rtw_modelmap_logging.h\n *\n * Abstract:\n *   Meta information used in conjunction with the ModelMappingInfo to\n *   facilitate logging.\n *\n */\n\n#ifndef __RTW_MODELMAP_LOGGING__\n#define __RTW_MODELMAP_LOGGING__\n\n#ifdef SL_INTERNAL\n# include \"simstruct/sysran_types.h\"\n#else\n# include \"sysran_types.h\"\n#endif\n\ntypedef struct rtwCAPI_ModelMapLoggingStaticInfo_tag rtwCAPI_ModelMapLoggingStaticInfo;\ntypedef struct rtwCAPI_ModelMapLoggingInstanceInfo_tag rtwCAPI_ModelMapLoggingInstanceInfo;\n\ntypedef struct rtwCAPI_LoggingMetaInfo_tag {\n    uint_T sigIdx;   /* same index as the rtwCAPI_Signals */\n    uint_T startIdx; /* starting index in the block I/O */\n    const char *blockPath;\n    uint_T portIdx;\n    int_T  parentSysNum;   /* system number of the parent signal that requested\n                              the logging */\n} rtwCAPI_LoggingMetaInfo;\n\ntypedef enum {\n    rtwCAPI_bus,\n    rtwCAPI_signal\n} rtwCAPI_LoggingBusElementType;\n\ntypedef struct rtwCAPI_LoggingBusElement_tag {\n    uint_T                        index;\n    rtwCAPI_LoggingBusElementType type;\n} rtwCAPI_LoggingBusElement;\n\ntypedef struct rtwCAPI_LoggingBusSignals_tag {\n    const char   *signalName;   /* logname should be in the sigProp */\n    const char   *blockPath;\n    uint_T  portIdx;\n    uint_T  numElements;\n\n    const rtwCAPI_LoggingBusElement *elements;\n} rtwCAPI_LoggingBusSignals;\n\ntypedef struct rtwCAPI_StateflowSignalLoggingInfo_tag {\n    const char   *signalName;\n    const char   *blockPath;\n    const char   *loggingName;\n    uint_T       maxPoints;\n    uint_T       decimation;\n    boolean_T    useCustomName;\n} rtwCAPI_StateflowSignalLoggingInfo;\n\n/* Structure used for representing bus hierarchy information for dataset logging */\ntypedef struct rtwCAPI_SignalHierLoggingInfo_tag {\n    const char_T* signalName;\n    uint_T        numChildren;\n    int_T         childStartIdx;\n} rtwCAPI_SignalHierLoggingInfo;\n\ntypedef struct rtwCAPI_SignalHierLoggingInfoTable_tag {\n    uint_T numSignals;\n    rtwCAPI_SignalHierLoggingInfo const* infoTable;\n    uint_T const* childIndexTable;\n} rtwCAPI_SignalHierLoggingInfoTable;\n\n/* ModelMapLoggingStaticInfo */\nstruct rtwCAPI_ModelMapLoggingStaticInfo_tag {\n    /* Total number of non-virtual systems */\n    uint_T numSystems;\n\n    /* Effective context systems array */\n    int_T const * contextSystems;\n\n    rtwCAPI_LoggingMetaInfo const *logInfo;\n\n    /* Bus signals info */\n    uint_T numBusSignals;\n    rtwCAPI_LoggingBusSignals const *busSignals;\n\n    /* Dataset format hierarchy info */\n    rtwCAPI_SignalHierLoggingInfoTable hierInfoTable;\n\n    /* Dataset format Stateflow logging info */\n    uint_T numChartSignals;\n    rtwCAPI_StateflowSignalLoggingInfo const *chartSignals;\n};\n\n/* Macros for accessing static fields */\n/* Note: These are all relative to the base MMI */\n#define rtwCAPI_GetHierInfoMap(MMI) \\\n    ((MMI)->staticMap->staticLogInfo->hierInfoTable)\n\n#define rtwCAPI_GetNumSystems(MMI) \\\n    ((MMI)->staticMap->staticLogInfo->numSystems)\n\n#define rtwCAPI_GetContextSystems(MMI) \\\n    ((MMI)->staticMap->staticLogInfo->contextSystems)\n\n#define rtwCAPI_GetLoggingInfoSigIdx(MMI, i) \\\n    ((MMI)->staticMap->staticLogInfo->logInfo[i].sigIdx)\n\n#define rtwCAPI_GetLoggingInfoStartIdx(MMI, i) \\\n    ((MMI)->staticMap->staticLogInfo->logInfo[i].startIdx)\n\n#define rtwCAPI_GetLoggingInfoBlockPath(MMI, i) \\\n    ((MMI)->staticMap->staticLogInfo->logInfo[i].blockPath)\n\n#define rtwCAPI_GetLoggingInfoPortNumber(MMI, i) \\\n    ((MMI)->staticMap->staticLogInfo->logInfo[i].portIdx)\n\n#define rtwCAPI_GetLoggingInfoParentSysNum(MMI, i) \\\n    ((MMI)->staticMap->staticLogInfo->logInfo[i].parentSysNum)\n\n#define rtwCAPI_GetLoggingInfoNumBusSignals(MMI) \\\n    ((MMI)->staticMap->staticLogInfo->numBusSignals)\n\n#define rtwCAPI_GetLoggingInfoBusSignalName(MMI, i) \\\n    ((MMI)->staticMap->staticLogInfo->busSignals[i].signalName)\n\n#define rtwCAPI_GetLoggingInfoBusBlockPath(MMI, i) \\\n    ((MMI)->staticMap->staticLogInfo->busSignals[i].blockPath)\n\n#define rtwCAPI_GetLoggingInfoBusPortIdx(MMI, i) \\\n    ((MMI)->staticMap->staticLogInfo->busSignals[i].portIdx)\n\n#define rtwCAPI_GetLoggingInfoBusNumElements(MMI, i) \\\n    ((MMI)->staticMap->staticLogInfo->busSignals[i].numElements)\n\n#define rtwCAPI_GetLoggingInfoBusElementIndex(MMI, i, j) \\\n    ((MMI)->staticMap->staticLogInfo->busSignals[i].elements[j].index)\n\n#define rtwCAPI_GetLoggingInfoBusElementType(MMI, i, j) \\\n    ((MMI)->staticMap->staticLogInfo->busSignals[i].elements[j].type)\n\n/* ModelMapLoggingInstanceInfo */\nstruct rtwCAPI_ModelMapLoggingInstanceInfo_tag {\n    /* Pointer to the sysRan dwork pointers */\n    sysRanDType **systemRan;\n\n    /* Effective non-triggered tid of each system */\n    int_T *systemTid;\n\n    /* Points to the global tid map */\n    int_T *globalTIDMap;\n};\n\n/* Note: These are all relative to the base MMI */\n\n/* Get methods */\n#define rtwCAPI_GetSystemRan(MMI) \\\n   ((MMI)->InstanceMap.instanceLogInfo->systemRan)\n\n#define rtwCAPI_GetSystemTid(MMI) \\\n   ((MMI)->InstanceMap.instanceLogInfo->systemTid)\n\n#define rtwCAPI_GetGlobalTIDMap(MMI) \\\n   ((MMI)->InstanceMap.instanceLogInfo->globalTIDMap)\n\n/* Set methods */\n#define rtwCAPI_SetSystemRan(MMI,s) \\\n   ((MMI).InstanceMap.instanceLogInfo->systemRan) = (s)\n\n#define rtwCAPI_SetSystemTid(MMI,s) \\\n   ((MMI).InstanceMap.instanceLogInfo->systemTid) = (s)\n\n#define rtwCAPI_SetGlobalTIDMap(MMI,s) \\\n   ((MMI).InstanceMap.instanceLogInfo->globalTIDMap) = (s)\n\n#endif  /* __RTW_MODELMAP_LOGGING__ */\n\n/* EOF - rtw_modelmap_logging.h */\n"},{"name":"rtw_modelmap_simtarget.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2020 The MathWorks, Inc. */\n\n/*\n * File: rtw_modelmap.h\n *\n * Abstract:\n *   Model tuning information.  Use the provided structure access methods\n *   whenever possible.\n *\n *   For details about these structures see Simulink Coder User's guide.\n */\n\n#ifndef __RTW_MODELMAP_SIMTARGET__\n#define __RTW_MODELMAP_SIMTARGET__\n\n#ifdef SL_INTERNAL\n\n# include \"version.h\"\n# include \"util.h\"\n# include \"simstruct/simstruc_types.h\"\n# include \"simulinkcoder_capi_export.hpp\"\n\n#else\n\n# include <stdlib.h>\n\n#ifdef HOST_CAPI_BUILD\n# include \"simstruc_types.h\"\n#else\n# include \"rtwtypes.h\"\n#endif\n\n#ifndef __RTW_UTFREE__\n# define __RTW_UTFREE__\n# define  utFree(arg)    if (arg) free(arg)\n# define  utMalloc(arg)  malloc(arg)\n#endif\n\n# define SIMULINKCODER_CAPI_API extern\n#endif\n\n#include \"rtw_capi.h\"\n#include \"rtw_modelmap_logging.h\"\n\ntypedef struct rtwCAPI_ModelMappingInfo_tag rtwCAPI_ModelMappingInfo;\ntypedef struct rtwCAPI_ModelMappingStaticInfo_tag rtwCAPI_ModelMappingStaticInfo;\n\n/* ModelMappingStaticInfo */\nstruct rtwCAPI_ModelMappingStaticInfo_tag {\n    /* signals */\n    struct {\n        rtwCAPI_Signals const *signals;     /* Signals Array */\n        uint_T                numSignals;   /* Num Signals   */\n        rtwCAPI_Signals const *rootInputs;  /* Root Inputs array */\n        uint_T               numRootInputs; /* Num Root Inputs  */\n        rtwCAPI_Signals const *rootOutputs; /* Root Outputs array */\n        uint_T               numRootOutputs;/* Num Root Outputs  */\n    } Signals;\n\n    /* parameters */\n    struct {\n        rtwCAPI_BlockParameters const *blockParameters;   /* Block parameters Array   */\n        uint_T                       numBlockParameters; /* Num block parameters     */\n        rtwCAPI_ModelParameters const *modelParameters;   /* Model parameters Array*/\n        uint_T                       numModelParameters; /* Num Model parameters  */\n    } Params;\n\n    /* states */\n    struct {\n        rtwCAPI_States const *states;   /* States array */\n        uint_T               numStates; /* Num States   */\n    } States;\n\n    /* Static maps */\n    /* datatypes, dimensions, fixed point, structure elements, sample times  */\n    struct {\n        rtwCAPI_DataTypeMap   const   *dataTypeMap;       /* Data Type Map          */\n        rtwCAPI_DimensionMap  const   *dimensionMap;      /* Data Dimension Map     */\n        rtwCAPI_FixPtMap      const   *fixPtMap;          /* Fixed Point Map        */\n        rtwCAPI_ElementMap    const   *elementMap;        /* Structure Element map  */\n        rtwCAPI_SampleTimeMap const   *sampleTimeMap;     /* Sample Times Map       */\n        uint_T        const   *dimensionArray;    /* Dimension Array        */\n    } Maps;\n\n    /* TargetType - string specifying the intended target of the generated  *\n     * C-API.                                                               *\n     * targetType = \"float\"   - target supports floats and integer code     *\n     *            = \"integer\" - target supports integer only code           */\n    char_T const     *targetType;\n\n    /* for internal use */\n    uint32_T modelChecksum[4];\n    rtwCAPI_ModelMapLoggingStaticInfo const *staticLogInfo;\n    size_t\t rtpSize;\n    /* If this instance in a protected model*/\n    boolean_T isProtectedModel;\n\n    /* Record index of blocks to map structured format logged states into dataset format */\n    int_T *stateIdxList;\n\n};\n\n/* ModelMappingInfo */\nstruct rtwCAPI_ModelMappingInfo_tag {\n    /* ModelMappingInfo version */\n    uint8_T                 versionNum;\n\n    /* Reference to static model data, all model instances share this map   */\n    rtwCAPI_ModelMappingStaticInfo *staticMap;\n\n    /* Instance specific Maps, each model instance has a unique InstanceMap */\n    struct {\n        const char*                path;             /* Path to this instance */\n        char*                      fullPath;\n        void**                     dataAddrMap;      /* Data Address map      */\n        rtwCAPI_ModelMappingInfo** childMMIArray;    /* array of child MMI    */\n        uint_T                     childMMIArrayLen; /* Number of child MMIs  */\n        int_T                      contStateStartIndex; \n\n        /* for internal use */\n        rtwCAPI_ModelMapLoggingInstanceInfo *instanceLogInfo;\n        int32_T**                      vardimsAddrMap;   /* Vardims Address map   */\n        void*\t\t\t       rtpAddress;\n        RTWLoggingFcnPtr* RTWLoggingPtrs;   /* MatFile logging information */\n    } InstanceMap;\n};\n\n/* Macros for accessing ModelMappingStaticInfo fields */\n#define rtwCAPI_GetSignalsFromStaticMap(SM)             ((SM)->Signals.signals)\n#define rtwCAPI_GetNumSignalsFromStaticMap(SM)          ((SM)->Signals.numSignals) \n#define rtwCAPI_GetLogSignalsArrayFromStaticMap(SM)     ((SM)->Signals.logSignalsArray)\n#define rtwCAPI_GetNumLogSignalsFromStaticMap(SM)       ((SM)->Signals.numLogSignals) \n\n#define rtwCAPI_GetBlockParametersFromStaticMap(SM)     ((SM)->Params.blockParameters)\n#define rtwCAPI_GetNumBlockParametersFromStaticMap(SM)  ((SM)->Params.numBlockParameters) \n#define rtwCAPI_GetModelParametersFromStaticMap(SM)     ((SM)->Params.modelParameters)\n#define rtwCAPI_GetNumModelParametersFromStaticMap(SM)  ((SM)->Params.numModelParameters)\n\n#define rtwCAPI_GetStatesFromStaticMap(SM)              ((SM)->States.states)\n#define rtwCAPI_GetNumStatesFromStaticMap(SM)           ((SM)->States.numStates)\n\n#define rtwCAPI_GetStateIdxListFromStaticMap(SM)        ((SM)->stateIdxList)\n\n#define rtwCAPI_GetRootInputsFromStaticMap(SM)          ((SM)->Signals.rootInputs) \n#define rtwCAPI_GetNumRootInputsFromStaticMap(SM)       ((SM)->Signals.numRootInputs)\n#define rtwCAPI_GetRootOutputsFromStaticMap(SM)         ((SM)->Signals.rootOutputs)\n#define rtwCAPI_GetNumRootOutputsFromStaticMap(SM)      ((SM)->Signals.numRootOutputs)\n\n#define rtwCAPI_GetDataTypeMapFromStaticMap(SM)         ((SM)->Maps.dataTypeMap)\n#define rtwCAPI_GetDimensionMapFromStaticMap(SM)        ((SM)->Maps.dimensionMap)\n#define rtwCAPI_GetFixPtMapFromStaticMap(SM)            ((SM)->Maps.fixPtMap)\n#define rtwCAPI_GetElementMapFromStaticMap(SM)          ((SM)->Maps.elementMap)\n#define rtwCAPI_GetSampleTimeMapFromStaticMap(SM)       ((SM)->Maps.sampleTimeMap)\n#define rtwCAPI_GetDimensionArrayFromStaticMap(SM)      ((SM)->Maps.dimensionArray)\n\n/* Macros for accessing ModelMappingInfo fields */\n#define rtwCAPI_GetSignals(MMI)         rtwCAPI_GetSignalsFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumSignals(MMI)      rtwCAPI_GetNumSignalsFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetLogSignalsArray(MMI) rtwCAPI_GetLogSignalsArrayFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumLogSignals(MMI)   rtwCAPI_GetNumLogSignalsFromStaticMap((MMI)->staticMap)\n\n#define rtwCAPI_GetBlockParameters(MMI)    rtwCAPI_GetBlockParametersFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumBlockParameters(MMI) rtwCAPI_GetNumBlockParametersFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetModelParameters(MMI)    rtwCAPI_GetModelParametersFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumModelParameters(MMI) rtwCAPI_GetNumModelParametersFromStaticMap((MMI)->staticMap)\n\n#define rtwCAPI_GetStates(MMI)     rtwCAPI_GetStatesFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumStates(MMI)  rtwCAPI_GetNumStatesFromStaticMap((MMI)->staticMap)\n\n#define rtwCAPI_GetStateIdxList(MMI)     rtwCAPI_GetStateIdxListFromStaticMap((MMI)->staticMap)\n\n#define rtwCAPI_GetRootInputs(MMI)     rtwCAPI_GetRootInputsFromStaticMap((MMI)->staticMap) \n#define rtwCAPI_GetNumRootInputs(MMI)  rtwCAPI_GetNumRootInputsFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetRootOutputs(MMI)    rtwCAPI_GetRootOutputsFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetNumRootOutputs(MMI) rtwCAPI_GetNumRootOutputsFromStaticMap((MMI)->staticMap)\n\n#define rtwCAPI_GetDataTypeMap(MMI)       rtwCAPI_GetDataTypeMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetDimensionMap(MMI)      rtwCAPI_GetDimensionMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetFixPtMap(MMI)          rtwCAPI_GetFixPtMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetElementMap(MMI)        rtwCAPI_GetElementMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetSampleTimeMap(MMI)     rtwCAPI_GetSampleTimeMapFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_GetDimensionArray(MMI)    rtwCAPI_GetDimensionArrayFromStaticMap((MMI)->staticMap)\n#define rtwCAPI_IsProtectedModel(MMI)     ((MMI)->staticMap->isProtectedModel)\n\n#define rtwCAPI_GetStaticLoggingInfo(MMI) ((MMI)->staticMap->staticLogInfo)\n\n#define rtwCAPI_GetVersion(MMI)           ((MMI)->versionNum)\n#define rtwCAPI_GetDataAddressMap(MMI)    ((MMI)->InstanceMap.dataAddrMap)\n#define rtwCAPI_GetVarDimsAddressMap(MMI) ((MMI)->InstanceMap.vardimsAddrMap)\n#define rtwCAPI_GetRTWLoggingPtrsMap(MMI) ((MMI)->InstanceMap.RTWLoggingPtrs)\n#define rtwCAPI_GetPath(MMI)              ((MMI)->InstanceMap.path)\n#define rtwCAPI_GetFullPath(MMI)          ((MMI)->InstanceMap.fullPath)\n#define rtwCAPI_GetChildMMI(MMI,i)        ((MMI)->InstanceMap.childMMIArray[i])\n#define rtwCAPI_GetChildMMIArray(MMI)     ((MMI)->InstanceMap.childMMIArray)\n#define rtwCAPI_GetChildMMIArrayLen(MMI)  ((MMI)->InstanceMap.childMMIArrayLen)\n#define rtwCAPI_MMIGetContStateStartIndex(MMI) ((MMI)->InstanceMap.contStateStartIndex)\n#define rtwCAPI_GetInstanceLoggingInfo(MMI) ((MMI)->InstanceMap.instanceLogInfo)\n\n/* Macros for setting ModelMappingInfo fields */\n#define rtwCAPI_SetVersion(MMI, n)            ((MMI).versionNum = (n))\n#define rtwCAPI_SetStaticMap(MMI, statMap)    (MMI).staticMap = (statMap)\n#define rtwCAPI_SetLoggingStaticMap(MMI,lStatMap) (MMI).staticMap->staticLogInfo = (lStatMap)\n#define rtwCAPI_SetDataAddressMap(MMI, dAddr) (MMI).InstanceMap.dataAddrMap = (dAddr)\n#define rtwCAPI_SetVarDimsAddressMap(MMI, vAddr) (MMI).InstanceMap.vardimsAddrMap = (vAddr)\n#define rtwCAPI_SetLoggingPtrs(MMI, lAddr)    (MMI).InstanceMap.RTWLoggingPtrs = (lAddr)\n#define rtwCAPI_SetPath(MMI,p)                (MMI).InstanceMap.path = (p)\n#define rtwCAPI_SetFullPath(MMI,p)            (MMI).InstanceMap.fullPath = (p)\n#define rtwCAPI_SetChildMMI(MMI,i,cMMI)       (MMI).InstanceMap.childMMIArray[i] = (cMMI)\n#define rtwCAPI_SetChildMMIArray(MMI,cMMIs)   (MMI).InstanceMap.childMMIArray = (cMMIs)\n#define rtwCAPI_SetChildMMIArrayLen(MMI,n)    (MMI).InstanceMap.childMMIArrayLen = (n)\n#define rtwCAPI_MMISetContStateStartIndex(MMI,i) (MMI).InstanceMap.contStateStartIndex = (i)\n#define rtwCAPI_SetInstanceLoggingInfo(MMI,l) (MMI).InstanceMap.instanceLogInfo = (l)\n\n/* Functions in rtw_modelmap_utils.c */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nSIMULINKCODER_CAPI_API char*         rtwCAPI_EncodePath(const char* path);\nSIMULINKCODER_CAPI_API boolean_T     rtwCAPI_HasStates(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumStateRecords(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumStateRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumContStateRecords(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API void          rtwCAPI_FreeFullPaths(rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API const char_T* rtwCAPI_UpdateFullPaths(rtwCAPI_ModelMappingInfo* mmi,\n                                                                             const char_T*     path,\n                                                                             boolean_T isCalledFromTopModel);\nSIMULINKCODER_CAPI_API char*         rtwCAPI_GetFullStateBlockPath(const char* stateBlockPath,\n                                                                                   const char* mmiPath,\n                                                                                   size_t      mmiPathLen,\n                                                                                   boolean_T   crossingModel);\nSIMULINKCODER_CAPI_API uint_T        rtwCAPI_GetStateWidth(const rtwCAPI_DimensionMap* dimMap,\n                                                                           const uint_T*               dimArray,\n                                                                           const rtwCAPI_States*       states,\n                                                                           uint_T                      iState);\nSIMULINKCODER_CAPI_API const char_T* rtwCAPI_GetStateRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                                                                const char_T**                  sigBlockName,\n                                                                                const char_T**                  sigLabel,\n                                                                                const char_T**                  sigName,\n                                                                                int_T*                          sigWidth,\n                                                                                int_T*                          sigDataType,\n                                                                                int_T*                          logDataType,\n                                                                                int_T*                          sigComplexity,\n                                                                                void**                          sigDataAddr,\n                                                                                RTWLoggingFcnPtr*               RTWLoggingPtrs,\n                                                                                boolean_T*                      sigCrossMdlRef,\n                                                                                boolean_T*                      sigInProtectedMdl,\n                                                                                const char_T**                  sigPathAlias,\n                                                                                double*                         sigSampleTime,\n                                                                                int_T*                          sigHierInfoIdx,\n                                                                                uint_T*                         sigFlatElemIdx,\n                                                                                const rtwCAPI_ModelMappingInfo** sigMMI,\n                                                                                int_T*                          sigIdx,\n                                                                                boolean_T                       crossingModel,\n                                                                                boolean_T                       isInProtectedMdl,\n                                                                                real_T*                         stateDerivVector,\n                                                                                boolean_T                       rtwLogging,\n                                                                                int_T*                          stateIdxList);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumSigLogRecords(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API int_T         rtwCAPI_GetNumSigLogRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi);\nSIMULINKCODER_CAPI_API const char_T* rtwCAPI_GetSigLogRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                                                                 const char_T**    sigBlockName,\n                                                                                 const char_T**    sigLabel,\n                                                                                 int_T*            sigWidth,\n                                                                                 int_T*            sigDataType,\n                                                                                 int_T*            logDataType,\n                                                                                 int_T*            sigComplexity,\n                                                                                 void**            sigDataAddr,\n                                                                                 boolean_T*        sigCrossMdlRef,\n                                                                                 int_T*            sigIdx,\n                                                                                 boolean_T         crossingModel,\n                                                                                 boolean_T         rtwLogging);\nSIMULINKCODER_CAPI_API void          rtwCAPI_CountSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n                                                                         int                            *count);\nSIMULINKCODER_CAPI_API void          rtwCAPI_FillSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n                                                                        sysRanDType                    **sysRan,\n                                                                        int                            *sysTid,\n                                                                        int                            *fillIdx);\n#ifdef __cplusplus\n}\n#endif\n\n#endif  /* __RTW_MODELMAP_SIMTARGET__ */\n\n/* EOF - rtw_modelmap.h */\n\n/* LocalWords:  MMI Vardims utils\n */\n"},{"name":"rtw_msvc_lshift.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"#ifndef RTW_VS_LSHIFT_H\n#define RTW_VS_LSHIFT_H\n\n#ifdef SUPPORTS_PRAGMA_ONCE\n #pragma once\n#endif\n\n/*\n * Copyright 2013 The MathWorks, Inc.\n *\n * File: rtw_vs_lshift.h\n *\n * Abstract:\n * Left shifting a 64-bit variable/constant by more than 30 bits inside a loop \n * generates wrong results in VS2005, VS2008 and VS2010 compilers, \n * when O2 optimization is turned on. This issue is fixed in VS2012.  \n * LCC64 does not have the bug. \n *  \n */\n\n#include <stdio.h>\n#if defined(__LCC__)\n  #define INLINE inline\n#elif defined(_WIN32)\n  #define INLINE _inline\n#else\n  #define INLINE __inline__\n#endif\n\n\nINLINE long long VS_LShift_Signed64(long long Mask, unsigned int ShiftVal)\n{\n    volatile unsigned int Val = ShiftVal;\n    return Mask << Val;\n}\n\nINLINE unsigned long long VS_LShift_Unsigned64(unsigned long long Mask, unsigned int ShiftVal)\n{\n    volatile unsigned int Val = ShiftVal;\n    return Mask << Val;\n}\n\nINLINE int VS_LShift_Signed32(int Mask, unsigned int ShiftVal)\n{\n    volatile unsigned int Val = ShiftVal;\n    return Mask << Val;\n}\n\nINLINE unsigned int VS_LShift_Unsigned32(unsigned int Mask, unsigned int ShiftVal)\n{\n    volatile unsigned int Val = ShiftVal;\n    return Mask << Val;\n}\n\n#endif /* RTW_VS_LSHIFT_H */\n"},{"name":"rtw_solver.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/*\n * File: rtw_solver.h\n *\n * Abstract:\n *   Type definitions for continuous-time solver support.\n *\n */\n\n/* Copyright 1990-2021 The MathWorks, Inc. */\n\n#ifndef RTW_SOLVER_H__\n#define RTW_SOLVER_H__\n\n#include \"rtw_continuous.h\"\n\n/* =============================================================================\n * Solver object\n * =============================================================================\n */\n#ifndef NO_FLOATS /* ERT integer-only */\n/*\n * Enum for solver tolerance\n */\ntypedef enum {\n    SL_SOLVER_TOLERANCE_AUTO = 0,       /* Set Automatically by Solver */\n    SL_SOLVER_TOLERANCE_LOCAL = 1,      /* Set Locally, e.g., by Blocks */\n    SL_SOLVER_TOLERANCE_GLOBAL = 2,     /* Set Globally, e.g., by Block Diagram */\n    SL_SOLVER_TOLERANCE_UNDEFINED = 255 /* Signal uninitialized */\n} SL_SolverToleranceControlFlag_T;\n\n\n/*\n * Enum for jacobian method control\n */\ntypedef enum {\n    SL_JM_BD_AUTO = 0,\n    SL_JM_BD_SPARSE_PERTURBATION,\n    SL_JM_BD_FULL_PERTURBATION,\n    SL_JM_BD_SPARSE_ANALYTICAL,\n    SL_JM_BD_FULL_ANALYTICAL\n} slJmBdControl;\n\n\ntypedef struct _ssSolverInfo_tag {\n    void* rtModelPtr;\n\n    SimTimeStep* simTimeStepPtr;\n    void* solverData;\n    const char_T* solverName;\n    boolean_T isVariableStepSolver;\n    boolean_T solverNeedsReset;\n    SolverMode solverMode;\n\n    time_T solverStopTime;\n    time_T* stepSizePtr;\n    time_T minStepSize;\n    time_T maxStepSize;\n    time_T fixedStepSize;\n\n    int_T solverShapePreserveControl;\n    int_T solverMaxConsecutiveMinStep;\n    int_T maxNumMinSteps;\n    int_T solverMaxOrder;\n    real_T solverConsecutiveZCsStepRelTol;\n    int_T solverMaxConsecutiveZCs;\n\n    int_T solverExtrapolationOrder;\n    int_T solverNumberNewtonIterations;\n\n    int_T solverRefineFactor;\n    real_T solverRelTol;\n    real_T unused_real_T_1;\n\n    real_T** dXPtr;\n    time_T** tPtr;\n\n    int_T* numContStatesPtr;\n    real_T** contStatesPtr;\n\n    int_T* numPeriodicContStatesPtr;\n    int_T** periodicContStateIndicesPtr;\n    real_T** periodicContStateRangesPtr;\n\n    real_T* zcSignalVector;\n    uint8_T* zcEventsVector;\n    uint8_T* zcSignalAttrib;\n    int_T zcSignalVectorLength;\n    uint8_T* reserved;\n\n    boolean_T foundContZcEvents;\n    boolean_T isAtLeftPostOfContZcEvent;\n    boolean_T isAtRightPostOfContZcEvent;\n    boolean_T adaptiveZcDetection;\n\n    int_T numZcSignals;\n\n    boolean_T stateProjection;\n    boolean_T robustResetMethod;     /* user's preference */\n    boolean_T updateJacobianAtReset; /* S-Fcn request (sticky) */\n    boolean_T consistencyChecking;\n\n    ssMatrixType massMatrixType;\n    int_T massMatrixNzMax;\n    int_T* massMatrixIr;\n    int_T* massMatrixJc;\n    real_T* massMatrixPr;\n\n    const char_T** errStatusPtr;\n\n    RTWRTModelMethodsInfo* modelMethodsPtr;\n    real_T zcThreshold;\n    int_T reserved_1;\n    int_T consecutiveZCsError;\n    boolean_T CTOutputIncnstWithState;\n    boolean_T isComputingJacobian;\n    slJmBdControl solverJacobianMethodControl;\n    int_T ignoredZcDiagnostic;\n    int_T maskedZcDiagnostic;\n    boolean_T isOutputMethodComputed;\n    int_T maxZcBracketingIterations;\n    boolean_T isMinorTimeStepWithModeChange;\n    int_T maxZcPerStep;\n    real_T** zcSignalPtr;\n} ssSolverInfo;\n\n/* Support old name RTWSolverInfo */\ntypedef ssSolverInfo RTWSolverInfo;\n\n#define rtsiSetRTModelPtr(S, rtmp) ((S)->rtModelPtr = (rtmp))\n#define rtsiGetRTModelPtr(S) (S)->rtModelPtr\n\n#define rtsiSetSimTimeStepPtr(S, stp) ((S)->simTimeStepPtr = (stp))\n#define rtsiGetSimTimeStepPtr(S) ((S)->simTimeStepPtr)\n#define rtsiGetSimTimeStep(S) *((S)->simTimeStepPtr)\n#define rtsiSetSimTimeStep(S, st) (*((S)->simTimeStepPtr) = (st))\n\n#define rtsiSetSolverData(S, sd) ((S)->solverData = (sd))\n#define rtsiGetSolverData(S) (S)->solverData\n\n#define rtsiSetSolverName(S, sn) ((S)->solverName = (sn))\n#define rtsiGetSolverName(S) (S)->solverName\n\n#define rtsiSetVariableStepSolver(S, vs) ((S)->isVariableStepSolver = (vs))\n#define rtsiIsVariableStepSolver(S) (S)->isVariableStepSolver\n\n#define rtsiSetSolverNeedsReset(S, sn) ((S)->solverNeedsReset = (sn))\n#define rtsiGetSolverNeedsReset(S) (S)->solverNeedsReset\n\n#define rtsiSetContTimeOutputInconsistentWithStateAtMajorStep(S, sn) \\\n    ((S)->CTOutputIncnstWithState = (sn))\n#define rtsiGetContTimeOutputInconsistentWithStateAtMajorStep(S) (S)->CTOutputIncnstWithState\n\n#define rtsiSetBlkStateChange(S, sn) ((S)->CTOutputIncnstWithState = (sn))\n#define rtsiGetBlkStateChange(S) (S)->CTOutputIncnstWithState\n\n#define rtsiSetBlockStateForSolverChangedAtMajorStep(S, sn) ((S)->solverNeedsReset = (sn))\n#define rtsiGetBlockStateForSolverChangedAtMajorStep(S) (S)->solverNeedsReset\n\n#define rtsiSetSolverMode(S, sm) ((S)->solverMode = (sm))\n#define rtsiGetSolverMode(S) (S)->solverMode\n\n#define rtsiSetSolverStopTime(S, st) ((S)->solverStopTime = (st))\n#define rtsiGetSolverStopTime(S) (S)->solverStopTime\n\n#define rtsiSetStepSizePtr(S, ssp) ((S)->stepSizePtr = (ssp))\n#define rtsiSetStepSize(S, ss) (*((S)->stepSizePtr) = (ss))\n#define rtsiGetStepSize(S) *((S)->stepSizePtr)\n\n#define rtsiSetMinStepSize(S, ss) (((S)->minStepSize = (ss)))\n#define rtsiGetMinStepSize(S) (S)->minStepSize\n\n#define rtsiSetMaxStepSize(S, ss) ((S)->maxStepSize = (ss))\n#define rtsiGetMaxStepSize(S) (S)->maxStepSize\n\n#define rtsiSetFixedStepSize(S, ss) ((S)->fixedStepSize = (ss))\n#define rtsiGetFixedStepSize(S) (S)->fixedStepSize\n\n#define rtsiSetMaxNumMinSteps(S, mns) ((S)->maxNumMinSteps = (mns))\n#define rtsiGetMaxNumMinSteps(S) (S)->maxNumMinSteps\n\n#define rtsiSetSolverMaxOrder(S, smo) ((S)->solverMaxOrder = (smo))\n#define rtsiGetSolverMaxOrder(S) (S)->solverMaxOrder\n\n#define rtsiSetSolverJacobianMethodControl(S, smcm) \\\n    (ssGetSolverInfo(S)->solverJacobianMethodControl = (smcm))\n#define rtsiGetSolverJacobianMethodControl(S) ssGetSolverInfo(S)->solverJacobianMethodControl\n\n#define rtsiSetSolverShapePreserveControl(S, smcm) \\\n    (ssGetSolverInfo(S)->solverShapePreserveControl = (smcm))\n#define rtsiGetSolverShapePreserveControl(S) ssGetSolverInfo(S)->solverShapePreserveControl\n\n#define rtsiSetSolverConsecutiveZCsStepRelTol(S, scr) \\\n    (ssGetSolverInfo(S)->solverConsecutiveZCsStepRelTol = (scr))\n#define rtsiGetSolverConsecutiveZCsStepRelTol(S) ssGetSolverInfo(S)->solverConsecutiveZCsStepRelTol\n\n#define rtsiSetSolverMaxConsecutiveZCs(S, smcz) \\\n    (ssGetSolverInfo(S)->solverMaxConsecutiveZCs = (smcz))\n#define rtsiGetSolverMaxConsecutiveZCs(S) ssGetSolverInfo(S)->solverMaxConsecutiveZCs\n\n#define rtsiSetSolverMaxConsecutiveMinStep(S, smcm) \\\n    (ssGetSolverInfo(S)->solverMaxConsecutiveMinStep = (smcm))\n#define rtsiGetSolverMaxConsecutiveMinStep(S) ssGetSolverInfo(S)->solverMaxConsecutiveMinStep\n\n#define rtsiSetSolverExtrapolationOrder(S, seo) ((S)->solverExtrapolationOrder = (seo))\n#define rtsiGetSolverExtrapolationOrder(S) (S)->solverExtrapolationOrder\n\n#define rtsiSetSolverNumberNewtonIterations(S, nni) ((S)->solverNumberNewtonIterations = (nni))\n#define rtsiGetSolverNumberNewtonIterations(S) (S)->solverNumberNewtonIterations\n\n#define rtsiSetSolverRefineFactor(S, smo) ((S)->solverRefineFactor = (smo))\n#define rtsiGetSolverRefineFactor(S) (S)->solverRefineFactor\n\n#define rtsiSetSolverRelTol(S, smo) ((S)->solverRelTol = (smo))\n#define rtsiGetSolverRelTol(S) (S)->solverRelTol\n\n#define rtsiSetSolverMassMatrixType(S, type) ((S)->massMatrixType = (type))\n#define rtsiGetSolverMassMatrixType(S) (S)->massMatrixType\n\n#define rtsiSetSolverMassMatrixNzMax(S, nzMax) ((S)->massMatrixNzMax = (nzMax))\n#define rtsiGetSolverMassMatrixNzMax(S) (S)->massMatrixNzMax\n\n#define rtsiSetSolverMassMatrixIr(S, ir) ((S)->massMatrixIr = (ir))\n#define rtsiGetSolverMassMatrixIr(S) (S)->massMatrixIr\n\n#define rtsiSetSolverMassMatrixJc(S, jc) ((S)->massMatrixJc = (jc))\n#define rtsiGetSolverMassMatrixJc(S) (S)->massMatrixJc\n\n#define rtsiSetSolverMassMatrixPr(S, pr) ((S)->massMatrixPr = (pr))\n#define rtsiGetSolverMassMatrixPr(S) (S)->massMatrixPr\n\n#define rtsiSetdXPtr(S, dxp) ((S)->dXPtr = (dxp))\n#define rtsiSetdX(S, dx) (*((S)->dXPtr) = (dx))\n#define rtsiGetdX(S) *((S)->dXPtr)\n\n#define rtsiSetTPtr(S, tp) ((S)->tPtr = (tp))\n#define rtsiSetT(S, t) ((*((S)->tPtr))[0] = (t))\n#define rtsiGetT(S) (*((S)->tPtr))[0]\n\n#define rtsiSetContStatesPtr(S, cp) ((S)->contStatesPtr = (cp))\n#define rtsiGetContStates(S) *((S)->contStatesPtr)\n\n#define rtsiSetNumContStatesPtr(S, cp) ((S)->numContStatesPtr = (cp))\n#define rtsiGetNumContStates(S) *((S)->numContStatesPtr)\n\n#define rtsiSetNumPeriodicContStatesPtr(S, cp) ((S)->numPeriodicContStatesPtr = (cp))\n#define rtsiGetNumPeriodicContStates(S) *((S)->numPeriodicContStatesPtr)\n\n#define rtsiSetPeriodicContStateIndicesPtr(S, cp) ((S)->periodicContStateIndicesPtr = (cp))\n#define rtsiGetPeriodicContStateIndices(S) *((S)->periodicContStateIndicesPtr)\n\n#define rtsiSetPeriodicContStateRangesPtr(S, cp) ((S)->periodicContStateRangesPtr = (cp))\n#define rtsiGetPeriodicContStateRanges(S) *((S)->periodicContStateRangesPtr)\n\n#define rtsiSetErrorStatusPtr(S, esp) ((S)->errStatusPtr = (esp))\n#define rtsiSetErrorStatus(S, es) (*((S)->errStatusPtr) = (es))\n#define rtsiGetErrorStatus(S) *((S)->errStatusPtr)\n\n#define rtsiSetModelMethodsPtr(S, mmp) ((S)->modelMethodsPtr = (mmp))\n#define rtsiGetModelMethodsPtr(S) (S)->modelMethodsPtr\n\n#define rtsiSetSolverComputingJacobian(S, val) ((S)->isComputingJacobian = (val))\n#define rtsiIsSolverComputingJacobian(S) (S)->isComputingJacobian\n\n#define rtsiSetSolverOutputComputed(S, val) ((S)->isOutputMethodComputed = (val))\n#define rtsiIsSolverOutputComputed(S) (S)->isOutputMethodComputed\n\n#define rtsiSetIsMinorTimeStepWithModeChange(S, sn) ((S)->isMinorTimeStepWithModeChange = (sn))\n#define rtsiGetIsMinorTimeStepWithModeChange(S) (S)->isMinorTimeStepWithModeChange\n\n#define rtsiIsModeUpdateTimeStep(S) \\\n    (rtsiGetSimTimeStep(S) == MAJOR_TIME_STEP || rtsiGetIsMinorTimeStepWithModeChange(S))\n\n#define rtsiSetSolverZcSignalPtr(S, zcp) ((S)->zcSignalPtr = (zcp))\n#define rtsiSetSolverZcSignalVector(S, zcp) (*((S)->zcSignalPtr) = (zcp))\n#define rtsiGetSolverZcSignalVector(S) *((S)->zcSignalPtr)\n\n\n#define rtsiSetSolverZcEventsVector(S, ptr) ((S)->zcEventsVector = (ptr))\n#define rtsiGetSolverZcEventsVector(S) ((S)->zcEventsVector)\n\n#define rtsiSetSolverZcSignalAttrib(S, ptr) ((S)->zcSignalAttrib = (ptr))\n#define rtsiGetSolverZcSignalAttrib(S) ((S)->zcSignalAttrib)\n\n#define rtsiSetSolverZcSignalVectorLength(S, n) ((S)->zcSignalVectorLength = (n))\n#define rtsiGetSolverZcSignalVectorLength(S) ((S)->zcSignalVectorLength)\n\n#define rtsiSetSolverFoundContZcEvents(S, val) ((S)->foundContZcEvents = (val))\n#define rtsiGetSolverFoundContZcEvents(S) ((S)->foundContZcEvents)\n\n#endif /* !NO_FLOATS */\n\n#endif /* RTW_SOLVER_H__ */\n"},{"name":"rtw_storage.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2019-2021 The MathWorks, Inc. */\n\n#ifndef SSRTWSTORAGE_TYPE_RTW_STORAGE_H\n#define SSRTWSTORAGE_TYPE_RTW_STORAGE_H\n/*\n * Enumeration of RTW storage class\n */\ntypedef enum {\n    SS_RTW_STORAGE_INVALID = -1,\n    SS_RTW_STORAGE_AUTO,\n    SS_RTW_STORAGE_EXPORTED_GLOBAL,\n    SS_RTW_STORAGE_IMPORTED_EXTERN,\n    SS_RTW_STORAGE_IMPORTED_EXTERN_POINTER,\n    SS_RTW_STORAGE_CUSTOM,\n    SS_RTW_STORAGE_SIMULINK_GLOBAL,\n    SS_RTW_STORAGE_MODEL_DEFAULT,\n    SS_RTW_STORAGE_NUM_CLASSES\n} ssRTWStorageType;\n\n#endif /*SSRTWSTORAGE_TYPE_RTW_STORAGE_H*/\n\n/* LocalWords:  SSRTWSTORAGE\n */\n"},{"name":"rtw_windows.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"#ifndef RTW_WINDOWS_H\n#define RTW_WINDOWS_H\n\n/*\n * Copyright 2011 The MathWorks, Inc.\n *\n * File: rtw_windows.h\n *\n * Abstract:\n *  Function prototypes and defines windows mutex/semaphores\n */\n#include <windows.h>\n\n#define rtw_win_mutex_create( mutexDW ) \\\n    *(mutexDW) = CreateMutex(NULL, 0U, NULL); \n\n#define rtw_win_mutex_wait( mutexDW ) \\\n    WaitForSingleObject(mutexDW, INFINITE);\n\n#define rtw_win_mutex_release( mutexDW ) \\\n    ReleaseMutex(mutexDW);\n\n#define rtw_win_mutex_close( mutexDW ) \\\n    CloseHandle(mutexDW);\n\n#define rtw_win_sem_create( semaphoreDW, initVal ) \\\n    if ((initVal) == 0) {*(semaphoreDW) =  CreateSemaphore(NULL, 0, 1, NULL);} \\\n    else {*(semaphoreDW) = CreateSemaphore(NULL, (initVal), (initVal), NULL);} \n\n#define rtw_win_sem_wait( semaphoreDW ) \\\n    WaitForSingleObject(semaphoreDW, INFINITE);\n\n#define rtw_win_sem_release( semaphoreDW ) \\\n    ReleaseSemaphore(semaphoreDW, 1, NULL);\n\n#define rtw_win_sem_close( semaphoreDW ) \\\n    CloseHandle(semaphoreDW);\n\n\n#endif /* RTW_WINDOWS_H */\n"},{"name":"sfcn_bridge.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: sfcn_bridge.h     \n *\n * Abstract:\n *   This file helps support a bridge between non-inlined S-functions\n *   and the rtModel. When we did not have the notion of an rtModel,\n *   non-inlined S-functions obtained model data by directly accessing\n *   the model's SimStruct. With the introduction of the rtModel, \n *   this direct access is no longer possible. Therefore, we need to \n *   redefine some of the macros inside simstruc.h to instead access\n *   fields of the rtModel. \n */\n\n#ifndef __SFCN_BRIDGE_H__\n#define __SFCN_BRIDGE_H__\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\ntypedef struct {\n    const char_T  **errorStatusPtr;\n    \n    int           *numRootSampTimesPtr;\n    \n    time_T        **tPtrPtr;\n    time_T        *tStartPtr;\n    time_T        *tFinalPtr;\n    time_T        *tOfLastOutputPtr;\n    time_T        *stepSizePtr;\n    boolean_T     *stopRequestedPtr;\n    boolean_T     *derivCacheNeedsResetPtr;\n    boolean_T     *zcCacheNeedsResetPtr;\n    boolean_T     *CTOutputIncnstWithStatePtr;\n\n    int_T         **sampleHitsPtr;\n    int_T         **perTaskSampleHitsPtr;\n\n    SS_SimMode    *simModePtr;\n    \n    RTWSolverInfo **siPtr;\n} RTWSfcnInfo;\n\n/* Get a type-cast sfcn info from the SimStruct */\n#define _RTSS(S) ((RTWSfcnInfo *) ssGetRTWSfcnInfo(S))\n\n/* Set/Get fields of the sfcn info */\n#define rtssSetErrorStatusPtr(sfi,p) (sfi)->errorStatusPtr = (p)\n\n#define rtssSetNumRootSampTimesPtr(sfi,p) (sfi)->numRootSampTimesPtr = (p)\n\n#define rtssSetTPtrPtr(sfi,p)        (sfi)->tPtrPtr = (p)\n#define rtssSetTStartPtr(sfi,p)      (sfi)->tStartPtr = (p)\n#define rtssSetTFinalPtr(sfi,p)      (sfi)->tFinalPtr = (p)\n#define rtssSetTimeOfLastOutputPtr(sfi,p) (sfi)->tOfLastOutputPtr = (p)\n#define rtssSetStepSizePtr(sfi,p)    (sfi)->stepSizePtr = (p)\n#define rtssSetStopRequestedPtr(sfi,p) (sfi)->stopRequestedPtr = (p)\n#define rtssSetDerivCacheNeedsResetPtr(sfi,p) \\\n     (sfi)->derivCacheNeedsResetPtr = (p)\n#define rtssSetZCCacheNeedsResetPtr(sfi,p) \\\n     (sfi)->zcCacheNeedsResetPtr = (p)\n#define rtssSetContTimeOutputInconsistentWithStateAtMajorStepPtr(sfi,p) \\\n     (sfi)->CTOutputIncnstWithStatePtr = (p)\n#define rtssSetSampleHitsPtr(sfi,p) (sfi)->sampleHitsPtr = (p)\n#define rtssSetPerTaskSampleHitsPtr(sfi,p) (sfi)->perTaskSampleHitsPtr = (p)\n\n#define rtssSetSimModePtr(sfi,p)      (sfi)->simModePtr = (p)\n\n#define rtssSetSolverInfoPtr(sfi,p)  (sfi)->siPtr = (p)\n\n/* Error status defines */\n#undef ssSetErrorStatus\n#define ssSetErrorStatus(S,e) *(_RTSS(S)->errorStatusPtr) = (e)\n\n#undef ssGetErrorStatus\n#define ssGetErrorStatus(S)   *(_RTSS(S)->errorStatusPtr)\n\n#undef ssGetNumRootSampleTimes\n#define ssGetNumRootSampleTimes(S) *(_RTSS(S)->numRootSampTimesPtr)\n\n/* Timing defines */\n#undef ssGetTPtr\n#define ssGetTPtr(S) (_RTSS(S)->tPtrPtr[0])\n\n#undef ssGetT\n#define ssGetT(S) *(_RTSS(S)->tPtrPtr[0])\n\n#undef ssGetTStart\n#define ssGetTStart(S) *(_RTSS(S)->tStartPtr)\n\n#undef ssGetTFinal\n#define ssGetTFinal(S) *(_RTSS(S)->tFinalPtr)\n\n#undef ssGetTimeOfLastOutput\n#define ssGetTimeOfLastOutput(S) *(_RTSS(S)->tOfLastOutputPtr)\n\n#undef ssGetStepSize\n#define ssGetStepSize(S) *(_RTSS(S)->stepSizePtr)\n\n#undef ssSetStopRequested\n#define ssSetStopRequested(S,v) *(_RTSS(S)->stopRequestedPtr) = (v)\n\n#undef ssGetStopRequested\n#define ssGetStopRequested(S) *(_RTSS(S)->stopRequestedPtr)\n\n#undef ssSetDerivCacheNeedsReset\n#define ssSetDerivCacheNeedsReset(S,v) \\\n     *(_RTSS(S)->derivCacheNeedsResetPtr) = (v)\n\n#undef ssGetDerivCacheNeedsReset\n#define ssGetDerivCacheNeedsReset(S) \\\n     *(_RTSS(S)->derivCacheNeedsResetPtr)\n\n#undef ssSetZCCacheNeedsReset\n#define ssSetZCCacheNeedsReset(S,v) \\\n     *(_RTSS(S)->zcCacheNeedsResetPtr) = (v)\n\n#undef ssGetZCCacheNeedsReset\n#define ssGetZCCacheNeedsReset(S) \\\n     *(_RTSS(S)->zcCacheNeedsResetPtr)\n\n#undef ssSetContTimeOutputInconsistentWithStateAtMajorStep\n#define ssSetContTimeOutputInconsistentWithStateAtMajorStep(S) *(_RTSS(S)->CTOutputIncnstWithStatePtr) = true\n\n#undef ssGetContTimeOutputInconsistentWithStateAtMajorStep\n#define ssGetContTimeOutputInconsistentWithStateAtMajorStep(S) *(_RTSS(S)->CTOutputIncnstWithStatePtr)\n\n#undef ssSetBlkStateChange\n#define ssSetBlkStateChange(S) *(_RTSS(S)->CTOutputIncnstWithStatePtr) = true\n\n#undef ssGetBlkStateChange\n#define ssGetBlkStateChange(S) *(_RTSS(S)->CTOutputIncnstWithStatePtr)\n\n#undef ssGetSampleHitPtr\n#define ssGetSampleHitPtr(S) *(_RTSS(S)->sampleHitsPtr)\n\n#undef ssGetPerTaskSampleHitsPtr\n#define ssGetPerTaskSampleHitsPtr(S) *(_RTSS(S)->perTaskSampleHitsPtr)\n           \n#undef ssGetSimMode\n#define ssGetSimMode(S) *(_RTSS(S)->simModePtr)\n\n/* Solver-related defines */\n#undef ssGetSolverName\n#define ssGetSolverName(S) \\\n   rtsiGetSolverName(*(_RTSS(S)->siPtr))\n\n#undef ssIsVariableStepSolver\n#define ssIsVariableStepSolver(S) \\\n   rtsiIsVariableStepSolver(*(_RTSS(S)->siPtr))\n\n#undef ssSetSolverNeedsReset\n#define ssSetSolverNeedsReset(S) \\\n   rtsiSetSolverNeedsReset(*(_RTSS(S)->siPtr), true)\n\n#undef ssGetSolverNeedsReset\n#define ssGetSolverNeedsReset(S) \\\n   rtsiGetSolverNeedsReset(*(_RTSS(S)->siPtr))\n\n#undef ssSetBlockStateForSolverChangedAtMajorStep\n#define ssSetBlockStateForSolverChangedAtMajorStep(S) \\\n   rtsiSetBlockStateForSolverChangedAtMajorStep(*(_RTSS(S)->siPtr), true)\n\n#undef ssGetBlockStateForSolverChangedAtMajorStep\n#define ssGetBlockStateForSolverChangedAtMajorStep(S) \\\n   rtsiGetBlockStateForSolverChangedAtMajorStep(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverMode\n#define ssGetSolverMode(S) \\\n   rtsiGetSolverMode(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverMode\n#define ssGetSolverMode(S) \\\n   rtsiGetSolverMode(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverStopTime\n#define ssGetSolverStopTime(S) \\\n   rtsiGetSolverStopTime(*(_RTSS(S)->siPtr))\n\n#undef ssGetMinStepSize\n#define ssGetMinStepSize(S) \\\n   rtsiGetMinStepSize(*(_RTSS(S)->siPtr))\n\n#undef ssGetMaxStepSize\n#define ssGetMaxStepSize(S) \\\n   rtsiGetMaxStepSize(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverMaxConsecutiveMinStep\n#define ssGetSolverMaxConsecutiveMinStep(S) \\\n   rtsiGetSolverMaxConsecutiveMinStep(*(_RTSS(S)->siPtr))\n\n#undef ssGetFixedStepSize\n#define ssGetFixedStepSize(S) \\\n   rtsiGetFixedStepSize(*(_RTSS(S)->siPtr))\n\n#undef ssGetMaxNumMinSteps\n#define ssGetMaxNumMinSteps(S) \\\n   rtsiGetMaxNumMinSteps(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverRefineFactor\n#define ssGetSolverRefineFactor(S) \\\n   rtsiGetSolverRefineFactor(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverRelTol\n#define ssGetSolverRelTol(S) \\\n   rtsiGetSolverRelTol(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverMaxOrder\n#define ssGetSolverMaxOrder(S) \\\n   rtsiGetSolverMaxOrder(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverConsecutiveZCsStepRelTol\n#define ssGetSolverConsecutiveZCsStepRelTol(S) \\\n   rtsiGetSolverConsecutiveZCsStepRelTol(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverZcThreshold\n#define ssGetSolverZcThreshold(S) \\\n   rtsiGetSolverZcThreshold(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverMaxConsecutiveZCs\n#define ssGetSolverMaxConsecutiveZCs(S) \\\n   rtsiGetSolverMaxConsecutiveZCs(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverExtrapolationOrder\n#define ssGetSolverExtrapolationOrder(S) \\\n   rtsiGetSolverExtrapolationOrder(*(_RTSS(S)->siPtr))\n\n#undef ssGetSolverNumberNewtonIterations\n#define ssGetSolverNumberNewtonIterations(S) \\\n    rtsiGetSolverNumberNewtonIterations(*(_RTSS(S)->siPtr))\n\n#undef ssIsModeUpdateTimeStep\n#define ssIsModeUpdateTimeStep(S)              \\\n    rtsiIsModeUpdateTimeStep(*(_RTSS(S)->siPtr))\n\n#undef ssGetSimTimeStep\n#define ssGetSimTimeStep(S) \\\n   rtsiGetSimTimeStep(*(_RTSS(S)->siPtr))\n\n#undef ssIsMinorTimeStep\n#if NCSTATES > 0\n#define ssIsMinorTimeStep(S) \\\n   (ssGetSimTimeStep(S) == MINOR_TIME_STEP)\n#else\n#define ssIsMinorTimeStep(S) (0)\n#endif\n\n#undef ssIsMajorTimeStep\n#if NCSTATES > 0\n#define ssIsMajorTimeStep(S) \\\n     (ssGetSimTimeStep(S) == MAJOR_TIME_STEP)\n#else\n#define ssIsMajorTimeStep(S) (1)\n#endif\n\n#undef ssGetTaskTime\n#define ssGetTaskTime(S,sti) \\\n    (*(_RTSS(S)->tPtrPtr[ssGetSampleTimeTaskID(S,sti)]))\n\n#undef ssIsSampleHit\n\n#if SS_MULTITASKING\n\n#if TID01EQ \n#define ssIsSampleHit(S,sti,tid) \\\n   ((ssGetSampleTimeTaskID(S,sti) == 1 ? \\\n     0:ssGetSampleTimeTaskID(S,sti)) == (tid))\n#else \n#define ssIsSampleHit(S,sti,tid) \\\n  (ssGetSampleTimeTaskID(S,sti) == (tid)) \n#endif \n\n#else\n\n#define ssIsSampleHit(S,sti,tid) \\\n     (ssIsMajorTimeStep(S) && (tid != CONSTANT_TID) &&\\\n            ((ssGetSampleHitPtr(S))[ssGetSampleTimeTaskID(S,sti)]))\n\n#endif \n\n#undef ssIsSampleHitInTask\n#undef ssIsSpecialSampleHit\n\n#if SS_MULTITASKING\n#define ssIsSampleHitInTask(S, my_sti, tid) \\\n    (ssGetPerTaskSampleHitsPtr(             \\\n        S))[ssGetSampleTimeTaskID(S, my_sti) + ((tid) * (ssGetNumRootSampleTimes(S)))]\n#define ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) \\\n    (ssIsMajorTimeStep(S) && ssIsSampleHitInTask(S, my_sti, ssGetSampleTimeTaskID(S, promoted_sti)))\n#else\n#define ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) ssIsSampleHit(S, my_sti, tid)\n#endif\n\n#undef  ssIsFirstInitCond\n#define ssIsFirstInitCond(S) (ssGetT(S)==ssGetTStart(S))\n\n#undef ssSetFirstInitCondCalled\n#define ssSetFirstInitCondCalled(S) \n\n#undef ssClearFirstInitCondCalled\n#define ssClearFirstInitCondCalled(S)\n\n#endif /* __SFCN_BRIDGE_H__ */\n\n/* [EOF] sfcn_bridge.h */\n\n\n\n"},{"name":"sfcn_loader_c_api.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* \\file sfcn_loader_c_api.h */\n/* The C API for dynamic mex s-function loading and mex file management */\n\n/* Copyright 2017-2021 The MathWorks, Inc. */\n\n#ifndef SFCN_LOADER_C_API_H\n#define SFCN_LOADER_C_API_H\n\n#ifndef DLL_EXPORT_SYM\n#ifdef SL_INTERNAL\n#include \"package.h\"\n#else\n#define DLL_EXPORT_SYM\n#endif\n#endif\n\n#ifdef __cplusplus\n#define SL_SFCN_LOADER_EXPORT_EXTERN_C extern \"C\" DLL_EXPORT_SYM\n#include <cstdarg>\n#else\n#define SL_SFCN_LOADER_EXPORT_EXTERN_C extern DLL_EXPORT_SYM\n#include <stdarg.h>\n#endif\n\n#ifdef BUILDING_LIBMWSL_SFCN_LOADER\n#include \"simstruct/simstruc.h\"\n#else\n#include \"simstruc.h\"\n#endif\n\n#include \"matrix.h\"\n\n\n\n/*******************************************************************************/\n/* for calling mexFunction */\ntypedef struct MexArgs_T {\n    int nlhs;\n    mxArray** plhs;\n    int nrhs;\n    const mxArray** prhs;\n} MexArgs;\n\n\n/*******************************************************************************/\n/* s-function parameter information */\ntypedef struct ParameterInfo_T {\n    bool isString;\n} ParameterInfo;\n\n\n/*******************************************************************************/\n/* ports */\ntypedef int_T (*SetRegNumPortsFcn)(void*, int_T);\n\ntypedef struct PortInfoFcns_T {\n    SetRegNumPortsFcn setRegNumInputPorts;\n    SetRegNumPortsFcn setRegNumOutputPorts;\n} PortInfoFcns;\n\n\n/*******************************************************************************/\n/* data type access */\n\ntypedef DTypeId (*DTARegisterDataTypeFcn)(void* v, const char_T* c1, const char_T* c2);\n\ntypedef int_T (*DTAGetNumDataTypesFcn)(void* v);\n\ntypedef DTypeId (*DTAGetDataTypeIdFcn)(void* v, const char_T* c);\n\ntypedef int_T (*DTAGetGenericDTAIntPropFcn)(void* v,\n                                            const char_T* c,\n                                            DTypeId d,\n                                            GenDTAIntPropType g);\n\ntypedef int_T (\n    *DTASetGenericDTAIntPropFcn)(void*, const char_T*, DTypeId, int_T, GenDTAIntPropType);\n\ntypedef const void* (*DTAGetGenericDTAVoidPropFcn)(void* v,\n                                                   const char_T* c1,\n                                                   DTypeId d,\n                                                   GenDTAVoidPropType g);\n\ntypedef int_T (*DTASetGenericDTAVoidPropFcn)(void* v1,\n                                             const char_T* c1,\n                                             DTypeId d,\n                                             const void* v2,\n                                             GenDTAVoidPropType g);\n\ntypedef GenericDTAUnaryFcn (*DTAGetGenericDTAUnaryFcnGWFcn)(void* v,\n                                                            const char_T* c1,\n                                                            DTypeId d,\n                                                            GenDTAUnaryFcnType g);\n\ntypedef int_T (*DTASetGenericDTAUnaryFcnGWFcn)(void* v,\n                                               const char_T* c1,\n                                               DTypeId d,\n                                               GenericDTAUnaryFcn f,\n                                               GenDTAUnaryFcnType g);\n\ntypedef GenericDTABinaryFcn (*DTAGetGenericDTABinaryFcnGWFcn)(void* v,\n                                                              const char_T* c1,\n                                                              DTypeId d,\n                                                              GenDTABinaryFcnType g);\n\ntypedef int_T (*DTASetGenericDTABinaryFcnGWFcn)(void* v,\n                                                const char_T* c1,\n                                                DTypeId d,\n                                                GenericDTABinaryFcn f,\n                                                GenDTABinaryFcnType g);\n\ntypedef ConvertBetweenFcn (*DTAGetConvertBetweenFcnFcn)(void* v, const char_T* c1, DTypeId d);\n\ntypedef int_T (*DTASetConvertBetweenFcnFcn)(void* v,\n                                            const char_T* c1,\n                                            DTypeId d,\n                                            ConvertBetweenFcn f);\n\ntypedef int_T (*DTAGetGenericDTADiagnosticFcn)(void* v,\n                                               const char_T* c1,\n                                               GenDTADiagnosticType g,\n                                               BDErrorValue* b);\n\ntypedef void* (*DTARegisterDataTypeWithCheckFcn)(void* v,\n                                                 const char_T* c1,\n                                                 const char_T* c2,\n                                                 DTypeId* d);\n\ntypedef int_T (*DTAGetGenericDTAIntElemPropFcn)(void* v,\n                                                const char_T* c1,\n                                                DTypeId d,\n                                                int_T i,\n                                                GenDTAIntElemPropType g);\n\ntypedef int_T (*DTASetGenericDTAIntElemPropFcn)(void* v,\n                                                const char_T* c1,\n                                                DTypeId d,\n                                                int_T i,\n                                                int_T j,\n                                                GenDTAIntElemPropType g);\n\ntypedef const void* (*DTAGetGenericDTAVoidElemPropFcn)(void* v,\n                                                       const char_T* c1,\n                                                       DTypeId d,\n                                                       int_T i,\n                                                       GenDTAVoidElemPropType g);\n\ntypedef int_T (*DTASetGenericDTAVoidElemPropFcn)(void* v1,\n                                                 const char_T* c1,\n                                                 DTypeId d,\n                                                 int_T i,\n                                                 const void* v2,\n                                                 GenDTAVoidElemPropType g);\n\ntypedef real_T (*DTAGetGenericDTARealElemPropFcn)(void* v,\n                                                  const char_T* c1,\n                                                  DTypeId d,\n                                                  int_T i,\n                                                  GenDTARealElemPropType g);\n\ntypedef int_T (*DTASetGenericDTARealElemPropFcn)(void* v,\n                                                 const char_T* c1,\n                                                 DTypeId d,\n                                                 int_T i,\n                                                 int_T j,\n                                                 GenDTARealElemPropType g);\n\ntypedef struct DataTypeAccessFcns_T {\n    DTARegisterDataTypeFcn registerDataType;\n    DTAGetNumDataTypesFcn getNumDataTypes;\n    DTAGetDataTypeIdFcn getDataTypeId;\n    DTAGetGenericDTAIntPropFcn getGenericDTAIntProp;\n    DTASetGenericDTAIntPropFcn setGenericDTAIntProp;\n    DTAGetGenericDTAVoidPropFcn getGenericDTAVoidProp;\n    DTASetGenericDTAVoidPropFcn setGenericDTAVoidProp;\n    DTAGetGenericDTAUnaryFcnGWFcn getGenericDTAUnaryFcnGW;\n    DTASetGenericDTAUnaryFcnGWFcn setGenericDTAUnaryFcnGW;\n    DTAGetGenericDTABinaryFcnGWFcn getGenericDTABinaryFcnGW;\n    DTASetGenericDTABinaryFcnGWFcn setGenericDTABinaryFcnGW;\n    DTAGetConvertBetweenFcnFcn getConvertBetweenFcn;\n    DTASetConvertBetweenFcnFcn setConvertBetweenFcn;\n    DTAGetGenericDTADiagnosticFcn getGenericDTADiagnostic;\n    DTARegisterDataTypeWithCheckFcn registerDataTypeWithCheck;\n    DTAGetGenericDTAIntElemPropFcn getGenericDTAIntElemProp;\n    DTASetGenericDTAIntElemPropFcn setGenericDTAIntElemProp;\n    DTAGetGenericDTAVoidElemPropFcn getGenericDTAVoidElemProp;\n    DTASetGenericDTAVoidElemPropFcn setGenericDTAVoidElemProp;\n    DTAGetGenericDTARealElemPropFcn getGenericDTARealElemProp;\n    DTASetGenericDTARealElemPropFcn setGenericDTARealElemProp;\n} DataTypeAccessFcns;\n\n\n/*******************************************************************************/\n/* generic function */\ntypedef int_T (*GenericFcn)(SimStruct*, GenFcnType, int_T, void*);\n\n\n/*******************************************************************************/\n/* register data type */\n\ntypedef DTypeId (*RDTRegisterFcnFcn)(void* v, const char* c);\n\ntypedef int_T (*RDTSetDataTypeSizeFcn)(void* v, DTypeId d, int_T i);\n\ntypedef int_T (*RDTGetDataTypeSizeFcn)(void* v, DTypeId d);\n\ntypedef int_T (*RDTSetDataTypeZeroFcn)(void* v1, DTypeId d, void* v2);\n\ntypedef const void* (*RDTGetDataTypeZeroFcn)(void* v, DTypeId d);\n\ntypedef const char_T* (*RDTGetDataTypeNameFcn)(void* v, DTypeId d);\n\ntypedef DTypeId (*RDTGetDataTypeIdFcn)(void* v, const char_T* c);\n\ntypedef int_T (*RDTSetNumDWorkFcnFcn)(SimStruct* s, int_T i);\n\ntypedef struct RegisterDataTypeFcns_T {\n    RDTRegisterFcnFcn registerFcn;\n    RDTSetDataTypeSizeFcn setDataTypeSize;\n    RDTGetDataTypeSizeFcn getDataTypeSize;\n    RDTSetDataTypeZeroFcn setDataTypeZero;\n    RDTGetDataTypeZeroFcn getDataTypeZero;\n    RDTGetDataTypeNameFcn getDataTypeName;\n    RDTGetDataTypeIdFcn getDataTypeId;\n    RDTSetNumDWorkFcnFcn setNumDWorkFcn;\n} RegisterDataTypeFcns;\n\n\n/*******************************************************************************/\n/* mex API */\ntypedef bool (*MexIsLockedFcn)(void);\n\ntypedef int (*MexPutVarFcn)(const char*, const char*, const mxArray*);\n\ntypedef const mxArray* (*MexGetVarPtrFcn)(const char*, const char*);\n\ntypedef mxArray* (*MexGetVarFcn)(const char*, const char*);\n\ntypedef void (*MexLockFcn)(void);\n\ntypedef void (*MexUnlockFcn)(void);\n\ntypedef const char* (*MexFunctionNameFcn)(void);\n\ntypedef int (*MexEvalStringFcn)(const char*);\n\ntypedef mxArray* (*MexEvalStringWithTrapFcn)(const char*);\n\ntypedef int (*MexSetFcn)(double, const char*, mxArray*);\n\ntypedef const mxArray* (*MexGetFcn)(double, const char*);\n\ntypedef int (*MexCallMatlabFcn)(int, mxArray* plhs[], int, mxArray* prhs[], const char*, bool);\n\ntypedef mxArray* (\n    *MexCallMatlabWithTrapFcn)(int, mxArray* plhs[], int, mxArray* prhs[], const char*);\n\ntypedef mxArray* (*MexCreateSimpleFunctionHandleFcn)(mxFunctionPtr f);\n\ntypedef int (*MexAtExitFcn)(void (*exitFcn)(void));\n\ntypedef void (*MexErrMsgIdAndTxtFcn)(const char*, const char*, va_list);\n\ntypedef void (*MexErrMsgTxtFcn)(const char*);\n\ntypedef void (*MexWarnMsgTxtFcn)(const char*);\n\ntypedef void (*MexWarnMsgIdAndTxtFcn)(const char*, const char*, va_list);\n\ntypedef bool (*MexSetMexTrapFlagFcn)(void);\n\ntypedef struct MexCallbacks_T {\n    MexIsLockedFcn isLocked_;\n    MexPutVarFcn putVar_;\n    MexGetVarPtrFcn getVarPtr_;\n    MexGetVarFcn getVar_;\n    MexLockFcn lock_;\n    MexUnlockFcn unlock_;\n    MexFunctionNameFcn functionName_;\n    MexEvalStringFcn evalString_;\n    MexEvalStringWithTrapFcn evalStringWithTrap_;\n    MexSetFcn set_;\n    MexGetFcn get_;\n    MexCallMatlabFcn mexCallMatlab_;\n    MexCallMatlabWithTrapFcn mexCallMatlabWithTrap_;\n    MexCreateSimpleFunctionHandleFcn createSimpleFunctionHandle_;\n    MexAtExitFcn atExit_;\n    MexErrMsgIdAndTxtFcn errMsgIdAndTxt_;\n    MexErrMsgTxtFcn errMsgTxt_;\n    MexWarnMsgTxtFcn warnMsgTxt_;\n    MexWarnMsgIdAndTxtFcn warnMsgIdAndTxt_;\n    MexSetMexTrapFlagFcn setMexTrapFlag_;\n} MexCallbacks;\n\n\n/*******************************************************************************/\n/* C API */\nSL_SFCN_LOADER_EXPORT_EXTERN_C void sfcnLoader_initialize_for_rapid_accelerator(\n    const char** gblErrorStatusPtr,\n    const char* const sFcnInfoFileName,\n    const MexCallbacks* const mexCallbacks,\n    const PortInfoFcns* const portInfoFcns,\n    const DataTypeAccessFcns* const dataTypeAccessFcns,\n    const GenericFcn* const genericFcn,\n    const RegisterDataTypeFcns* const registerDataTypeFcns);\n\nSL_SFCN_LOADER_EXPORT_EXTERN_C void sfcnLoader_callSFcn(const char* const sFcnName,\n                                                        const char* const blockSID,\n                                                        SimStruct* simstruct);\n\nSL_SFCN_LOADER_EXPORT_EXTERN_C size_t sfcnLoader_numSFcnBlocks();\n\nSL_SFCN_LOADER_EXPORT_EXTERN_C void sfcnLoader_interleavedComplexHandler_noTID(\n    SimStruct* simstruct,\n    void (*sfcnMethodPtr)(SimStruct*));\n\nSL_SFCN_LOADER_EXPORT_EXTERN_C void sfcnLoader_interleavedComplexHandler_withTID(\n    SimStruct* simstruct,\n    void (*sfcnMethodPtr)(SimStruct*, int),\n    int tid);\n\nSL_SFCN_LOADER_EXPORT_EXTERN_C void sfcnLoader_setCurrentSFcnBlockSID(const char* const blockSID);\n\nSL_SFCN_LOADER_EXPORT_EXTERN_C const char* sfcnLoader_getCurrentSFcnName();\n\nSL_SFCN_LOADER_EXPORT_EXTERN_C void sfcnLoader_separateComplexHandler(\n    SimStruct* simstruct,\n    void (*const sfcnMethod)(SimStruct*));\n\nSL_SFCN_LOADER_EXPORT_EXTERN_C void sfcnLoader_separateComplexHandler_withTID(\n    SimStruct* simstruct,\n    void (*const sfcnMethod)(SimStruct*, int),\n    int tid);\n#endif\n"},{"name":"sigmapdef_sfcn.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1990-2018 The MathWorks, Inc.\n *\n * MathWorks grants you the right to copy this file to other \n * computer systems and embed this file within your products. You \n * can make modifications for your application.\n *\n *  Data structures and access methods for sigmaps, siglists and sigregions.\n *\n *  Allows access to Simulink signals.  See matlab/simulink/src/barplot.c\n *  for example code and sfcndemo_barplot for an example model.  Note that direct\n *  access to these structures is not recommended as the structures may change\n *  in future releases.\n */\n\n#ifndef sigmapdef_sfcn_h\n#define sigmapdef_sfcn_h\n\n#include \"sigregdef.h\"\n\ntypedef struct SL_SigInfo_tag {\n    const void *portObj;\n    const void *sigMap;  /* actual region map for this port */\n} SL_SigInfo;\n\ntypedef struct SL_SigList_tag {  /* an array of sigInfos */\n    int        nSigs;\n    SL_SigInfo *sigInfos;\n} SL_SigList;\n\n/*\n * Signal selection option.\n */\n#define SIGSET_GRAPH            (0) /* specified graph only */\n#define SIGSET_GRAPH_N_CHILDREN (1) /* specified graph and all child graphs */\n\n/*******************************************************************************\n *                  SIGLIST: PUBLIC DESCRIPTION                                *\n ******************************************************************************/\n\n/*\n * A high-level overview of the signal list is provided here.  For more details,\n * feel free to examine the data structures defined above.  More information\n * is also provided for the individual access macros defined below.\n *\n * WARNING:\n *  DO NOT DIRECTLY ACCESS ANY OF THESE DATA STRUCTURES.  THEY MAY CHANGE\n *  IN FUTURE RELEASES.  USE THE ACCESS MACROS PROVIDED BELOW.  SEE\n *  <matlabroot>/simulink/src/barplot.c FOR A WORKING EXAMPLE OF DATA ACCESS\n *  VIA SIGNAL MAPS.\n *\n *\n * A signal list is an array of sigInfo structures:\n *  -----------------------------------\n *  | graphical port | graphical port |\n *  | signal map     | signal map     |\n *  -----------------------------------\n *\n *      graphical port:\n *          A pointer to the output port associated with a signal.  It is\n *          graphical in the sense that it may or may not map back to the\n *          actual outport from which the data originates.   Consider:\n *\n *          -----        --------\n *          | A |>------>|      |\n *          -----        |      |\n *          -----        |  C   |>---------->\n *          | B |>------>|      |\n *          -----        |------|\n *                         mux\n *\n *          For the mux block, the 'graphical' port is C.  The two 'actual'\n *          ports are A and B.\n *\n *      signal map:\n *          A linked list of contiguous regions of memory corresponding to\n *          the graphical signal.  Assuming that A and B above are \n *          non-virtual blocks (e.g., gains, constants, etc, but not mux\n *          demux, etc), then the signal C has two contiguous regions.\n *\n *          The signal map looks like:\n *              \n *              ----------------   --> ----------------   --> NULL\n *              | region info A|   |   | region info B|   |\n *              | next region--|----   | next region--|----\n *              ----------------       ---------------- \n *\n *          Note that if we create a signal list for A, the graphical port\n *          and the actual port are an identity mapping.  The resulting\n *          signal map consists would consist of only 1 region (assuming that\n *          the output of A is contiguous).\n *              \n *          The regions are essentially pointers into the Simulink memory areas\n *          that are used for block input and output.  Here is some of the info \n *          contained in the regions.  Other info is also available.  See macro\n *          definitions at the bottom of this file.\n *\n *              data: a void pointer to the data in this region\n *              nEls: number of elements in region\n *              \n *              status: a flag that indicates whether or not the region is\n *                      available for access.  When regions are not available,\n *                      the 'data' field is NULL.  Status can take on the\n *                      following values:\n *                  \n *                          SLREG_AVAIL:\n *                              Data is available for access.\n *\n *                          ====================================================\n *                          The following types of regions are excluded by\n *                          default from the signal list.\n *                          ====================================================\n *\n *                          SLREG_REUSED:\n *                              The output memory area for this signal is being\n *                              shared with the output from another port.  This\n *                              signal can not be accessed (click 'Disable\n *                              optimized block I/O storage' on the Diagnostics\n *                              page of the Simulation Parameter Dialog box\n *                              to disable the sharing of block I/O memory).\n *\n *                          SLREG_FCNCALL:\n *                              The data corresponds to a fcn-call connection.\n *                              There is no data to view.\n *\n *                          SLREG_MERGE:\n *                              This signal is being merged.  This is a special\n *                               case of a buffer being re-used.  The\n *                               signal cannot be accessed.\n *\n *                          SLREG_ACTION:\n *                              The data corresponds to an action signal, this\n *                              data can not be viewed. \n *                             \n *                          ====================================================\n *                          The following types of regions are optionally\n *                          excluded from the signal list.  See the excludeFlags\n *                          arg of ssCallSigListCreateFcn().\n *\n *                          If you are not excluding a given region type, the \n *                          region status will be SLREG_AVAIL.  Otherwise, if\n *                          the excluded region type, SLREG_xxx, is encountered,\n *                          the region status will be SLREG_xxx.\n *                          ====================================================\n *\n *                          SLREG_FRAME:\n *                              The data region corresponds to a frame (a time\n *                              series of data points).  If your application\n *                              does not support frames, include SLREG_FRAME\n *                              as part of the excludeFlags to ensure that\n *                              all frame data is excluded from the sigList.\n *\n *                          SLREG_WIDE_FRAME:\n *                              The data region corresponds to a wide frame, \n *                              size greated than 1. If your application\n *                              does not support wide frames, include \n *                              SLREG_WIDE_FRAME as part of the excludeFlags to \n *                              ensure that all wide frame data is excluded from the \n *                              sigList.\n *\n *                          SLREG_MATRIX:\n *                              The data region corresponds to a matrix.  If\n *                              your application does not support matrices,\n *                              include SLREG_MATRIX as part of the \n *                              excludeFlags to ensure that all matrices are\n *                              excluded from the sigList.\n *\n *                          SLREG_COMPLEX:\n *                              The data region corresponds to complex data.  If\n *                              your application does not support complex data,\n *                              include SLREG_COMPLEX as part of the \n *                              excludeFlags to ensure that all complex data is\n *                              excluded from the sigList.\n *\n *                          ====================================================\n *                          The following overrides the default exclusions\n *                          of the specified type of regions.\n *                          ====================================================\n *\n *                          SLREG_ALLOW_REUSED\n *                              \"un-exludes\" reused regions (which are excluded\n *                              by default.  As described above in the\n *                              SLREG_REUSED section, this can lead to\n *                              unexpected results, unless the block that is\n *                              requesting the signal access is hardwired into\n *                              the diagram.\n *\n *                              In general, if a block has input ports, this\n *                              flag should be specified (assuming that the \n *                              sigmaps being created correspond to its input\n *                              ports).\n *\n *              dType:      The Simulink data type id for the data.\n *              dTypeSize:  Number of bytes in 1 non-complex element.\n *              complexity: true if the data values are complex\n *              m:          if a matrix, the number of rows (-1 if not matrix)\n *              n:          if a matrix, the number of cols (-1 if not matrix)\n *\n *\n *  In general, the following snippet of code can be used to walk the elements\n *  of a signal:\n *      SL_SigRegion *sigReg = gsl_FirstReg(sigList,i);\n *       \n *      do {\n *         int nEls = gsr_nEls(sigReg);\n *\n *          if (nEls > 0) {\n *              int        el;\n *              int        dType   = gsr_DataType(sigReg);\n *              int        elSize  = gsr_DataTypeSize(sigReg);\n *              const char *data   = gsr_data(sigReg);\n *\n *              for (el=0; el<nEls; el++) {\n *                  data += elSize;\n *              }\n *          }\n *      } while((sigReg = gsr_NextReg(sigReg)) != NULL);\n */\n\n\n/*******************************************************************************\n *                  SIGLIST: PUBLIC ACCESSORS                                  *\n ******************************************************************************/\n\n/*\n * Number of signals in the signal list.\n */\n#define gsl_nSigs(sigList) ((sigList)->nSigs)\n\n/*\n * Number of regions comprising the 'listIdx-th' signal in the list.\n */\n#define gsl_nSigRegions(S, sigList, lstIdx) \\\n    ssCallSigListGetNumRegionsFcn(S, sigList, lstIdx)\n\n/*\n * A pointer to the first region of the 'listIdx-th' signal in the list.\n */\n#define gsl_FirstReg(S, sigList, lstIdx) \\\n    (SL_SigRegion *)(ssCallSigListGetFirstRegFcn(S,(void *)sigList,lstIdx))\n\n/*\n * The total number of elements comprising the 'listIdx-th' signal in the list.\n */\n#define gsl_NumElements(S, sigList,lstIdx) \\\n    ssCallSigListGetNumElementsFcn(S, sigList, lstIdx)\n\n/*\n * Returns true if the signal is a tie wrap.  This means that the signal map\n * consists of either:\n *  o one entire signal (i.e., the output of 1 non-virtual block)\n *  o a simple bundling together of multiple entire signals\n *\n *  Generally the only way to get a non-tie-wrapped signal is to mix the\n *  elements of existing signals or re-shuffle them via the use of the selector,\n *  mux and demux blocks.\n *\n *\n *      -----      -----                               --------\n *      | 1 | ---->|   |           -----               |      |\n *      -----      |   |           |   |        ------>|      |\n *     constant    |   | tie wrap  |   |------  |      |      |  not a tie wrap  \n *      -----      |   |---------->|   |     |  |      |      |--------------->\n *      | 1 | ---->|   |           |   |  ---|--|      |      | elements got \n *      -----      |   |           |   |--|  |-------->|      |   shuffled\n *     constant    -----           |   |               |      |\n *                   mux           -----               --------\n *                                 demux                 mux\n *\n *\n */\n#define gsl_TieWrap(S, sigList, lstIdx) \\\n    ssCallSigListGetIfTieWrapFcn(S, sigList, lstIdx)\n\n/*\n * Get the pointer to the port associated with the 'listIdx-th' signal in the\n * list.\n */\n#define gsl_PortObj(sigList,lstIdx) \\\n    (sigList->sigInfos[(lstIdx)].portObj)\n\n#endif /* sigmapdef_sfcn_h */\n"},{"name":"sigregdef.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/*\n * MathWorks grants you the right to copy this file to other\n * computer systems and embed this file within your products. You\n * can make modifications for your application.\n *\n *  Data structures and access methods for sigregions.\n *\n *  Allows access to Simulink signals.  See matlab/simulink/src/barplot.c\n *  for example code and sfcndemo_barplot for an example model.  Note that direct\n *  access to these structures is not recommended as the structures may change\n *  in future releases.\n */\n\n#ifndef sigregdef_h\n#define sigregdef_h\n\n#define SLREG_NO_FLAGS (0)\n\n#define SLREG_AVAIL (1U << 0)\n#define SLREG_REUSED (1U << 1)\n#define SLREG_FCNCALL (1U << 2)\n#define SLREG_MERGE (1U << 3)\n#define SLREG_GROUND (1U << 4)\n#define SLREG_FRAME (1U << 5)        /* opt exclude flag-see below          */\n#define SLREG_WIDE_FRAME (1U << 6)   /* opt exclude flag-see below          */\n#define SLREG_MATRIX (1U << 7)       /* opt exclude flag-see below          */\n#define SLREG_COMPLEX (1U << 8)      /* opt exclude flag-see below          */\n#define SLREG_ALLOW_REUSED (1U << 9) /* opt un-exclude flag - see below     */\n#define SLREG_ACTION (1U << 10)\n#define SLREG_CONDEXEC (1U << 11)        /* signal is only conditional executed */\n#define SLREG_EXTMODE_UNAVAIL (1U << 12) /* signal is not available in extmode  */\n#define SLREG_ELIMINATED (1U << 13)      /* dead branch elimination             */\n#define SLREG_INCLUDE_GRND (1U << 14)    /* opt include ground regions          */\n#define SLREG_VIRTSIGCNV                              \\\n    (1U << 15) /* signal connected to signal type     \\\n                * conversion such as frame conversion \\\n                */\n#define SLREG_VARDIMS (1U << 16)\n#define SLREG_MESSAGES (1U << 17)\n#define SLREG_DES_STAT (1U << 18)\n#define SLREG_STRING (1U << 19)\n\n#define IS_BIT_SET(uword32, bit) ((uword32 & bit) != 0)\n\n/* region node */\ntypedef struct SL_SigRegion_tag {\n#if !defined(S_FUNCTION_NAME) && !defined(BUILDING_SL_LOGGING)\n    slPort* portObj; /* output port associated with reg */\n#else\n    void* portObj;\n#endif\n    void* data;          /* pointer to the data              */\n    int startIdx;        /* starting element of the region (i.e., 'data'\n                          * points to the 'startIdx' element of the port)\n                          */\n    int nEls;            /* number of elements in region     */\n    bool entireSig;      /* is this region the whole sig?    */\n    unsigned int status; /* bit field: see SLREG_* status\n                          * vals above */\n\n    int index; /* The i'th region in the original map.  So, if a mux\n                * has three sigs coming in, a,b,c, a is index 0, b 1,\n                * and c 3.  If the regions were an array instead of\n                * a linked list this would be the array index.\n                * BE CAREFUL: If regions are removed due to being\n                * duplicate or unavailable, the index field is not\n                * touched up, so the index field always remains what\n                * the original signal map for the composite signal\n                * represented.  I'm not sure if this is good behavior\n                * or not, but this is how it currently works:\n                * 1/16/04 HJT\n                */\n\n    int workInt; /* A work integer.  Temp mem location for use when\n                  * shuffling regions.\n                  */\n\n    /*\n     * The following can be derived from the port, but since s-functions\n     * do not currently have direct access to the internal slPort *,\n     * we must put a copy of the required info directly into this struct.\n     */\n    int dType;\n    int dTypeSize;\n    int complexity;\n    int frameSize;\n\n    /*\n     *\n     */\n    bool discrete; /*true if discrete in time or value (draw as stair)*/\n\n    /*\n     * Dimensions\n     *\n     * o Notes:\n     *    If not a frame (frameSize == 0)\n     *       dims[0...numDims], numDims = 1 for a scalar signal\n     *    If frame\n     *       dims[0] = frameSize\n     *       dims[1] = number of columns\n     *    basically, the frame is treated as a matrix.\n     *\n     */\n    int numDims;\n    int* dims;\n\n    /* Cache var dims info in the sig region */\n    int* currDims;\n\n    struct SL_SigRegion_tag* next;\n    struct SL_SigRegion_tag* prev;\n\n    const char* name;\n\n    int unitId;\n\n} SL_SigRegion;\n\n\n/*******************************************************************************\n *                  SIGREGION: PUBLIC ACCESSORS                                *\n ******************************************************************************/\n\n/*\n * The number of elements in the region.\n */\n#define gsr_nEls(reg) ((reg)->nEls)\n\n/*\n * A pointer to the next region in the linked list. NULL if at the end of\n * the list.\n */\n#define gsr_NextReg(reg) ((reg)->next)\n\n/*\n * A const char * pointer into the data.\n */\n#define gsr_data(reg) ((char*)((reg)->data))\n\n/*\n * Starting element of the region (i.e., 'data' points to the 'startIdx'\n * element of the port)\n */\n#define gsr_startIdx(reg) ((reg)->startIdx)\n\n/*\n * Output port associated with region.\n */\n#define gsr_portObj(reg) ((reg)->portObj)\n\n/*\n * The Simulink data type identifier for the region.\n */\n#define gsr_DataType(reg) ((reg)->dType)\n\n/*\n * The number of bytes in one, non-complex data value.\n */\n#define gsr_DataTypeSize(reg) ((reg)->dTypeSize)\n\n/*\n * The Simulink unit identifier for the region.\n */\n#define gsr_Unit(reg) ((reg)->unitId)\n\n/*\n * True if the data region contains complex elements.\n */\n#define gsr_Complex(reg) ((reg)->complexity)\n\n/*\n * The number of rows.  If not matrix, -1.\n * NOTE:\n *  This access macro is deprecated and will only work correctly if\n *  gsr_NumDims <= 2 (i.e.: this macro does not support N-D signals N >2)\n */\n#define gsr_M(reg) (((reg)->numDims <= 1) ? -1 : (reg)->dims[0])\n\n/*\n * The number of cols.  If not matrix, the sig width of the corresponding\n * region.\n * NOTE:\n *  This access macro is deprecated and will only work correctly if\n *  gsr_NumDims <= 2 (i.e.: this macro does not support N-D signals N >2)\n */\n#define gsr_N(reg) (((reg)->numDims <= 1) ? (reg)->nEls : (reg)->dims[1])\n\n/*\n * The number of dimensions. Can be greater than 2 for N-dimensional signals.\n */\n#define gsr_NumDims(reg) ((reg)->numDims)\n\n/*\n * An integer pointer to the dimensions vector. Use gsr_NumDims to determine\n * the length of the dimensions array.\n */\n#define gsr_Dims(reg) ((reg)->dims)\n\n/*\n * The availability status of the region (SLREG_AVAIL if avail, else one\n * of the status described above in the \"Public Description\" section.\n */\n#define gsr_status(reg) ((reg)->status)\n\n/*\n * Variable-dimensions info - int pointer to current dims\n */\n#define gsr_currDims(reg) ((reg)->currDims)\n\n\n#endif /* sigregdef_h */\n"},{"name":"sigstream_rtw.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifdef SUPPORTS_PRAGMA_ONCE\n# pragma once\n#endif\n#ifndef sl_sigstream_rtw_h\n#define sl_sigstream_rtw_h\n/*\n *\n * Copyright 2008-2019 The MathWorks, Inc.\n *\n * This header is the interface to the sigstream module. It is used by the\n * RTW-RSim and Rapid Accelerator targets.\n *\n * \n *\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern void rtwOSigstreamManagerSaveDatasetsToMatFile(\n    void *pOpaqueOSigstreamManager,\n    const char *fileName\n    );\n\nextern void rtwISigstreamManagerSetDestinationBase(\n    void *pOpaqueISigstreamManager,\n    const size_t destinationId,\n    void *pDestinationBase\n    );\n\nextern void* rtwISigstreamManagerCreateInstance(void);\n\nextern void rtwISigstreamManagerDestroyInstance(void *pOpaqueISigstreamManager);\n\nextern void rtwISigstreamManagerGetDatasetInputFromMatFile(\n    void *pOpaqueISigstreamManager,\n    const char *fileName,\n    char errmsg[],\n    const int maxErrorBufferSize,\n    int errorXmlMode\n    );\n\nextern void rtwISigstreamManagerAddAperiodicPartitionHitTimes(\n    void* pOpaqueISigstreamManager,\n    void* unconstrainedPartitionHitTimes,\n    char const* const* unconstrainedPartitionNames,\n    unsigned int numAperiodicPartitions,\n    char errmsg[]);\n\nextern void rtwISigstreamManagerGetInputIsInDatasetFormat(\n    void *pOpaqueISigstreamManager,\n    bool *outInputIsInDatasetFormat\n    );\n\nextern void rtwISigstreamManagerHasAperiodicPartitionHitTimes(\n    void *pOpaqueISigstreamManager,\n    bool *outHasAperiodicPartitionHitTimes\n    );\n    \nextern bool rtwISigstreamManagerIsPeriodicFcnCall(\n    void *pOpaqueISigstreamManager,\n    const size_t destinationId\n    );\n\n/* return false if there is an error, otherwise return true */\nextern int rtwISigstreamManagerAperiodicPartitionDestinationIdx(\n    void* pOpaqueISigstreamManager,\n    const char* partitionName);\n\n\n/* return false if there is an error, otherwise return true */\nextern bool rtwISigstreamManagerInjectDataAperiodicPartitions(\n    void* pOpaqueISigstreamManager,\n    const int destinationId,\n    const double time,\n    int errorXMLMode,\n    const char* partitionName,\n    char errMsg[],\n    const int maxErrorBufferSize);\n\n/* return false if there is an error, otherwise return true */\nextern bool rtwISigstreamManagerInjectDataMultiRate(\n    void *pOpaqueISigstreamManager,\n    const size_t destinationId,\n    const double time,\n    int errorXMLMode,\n    const char *block,\n    const char *var,\n    int *sampleHitPtr,\n    char errmsg[],\n    const int maxErrorBufferSize\n    );\n\n/* return false if there is an error, otherwise return true */\nextern bool rtwISigstreamManagerInjectDataSingleRate(\n    void *pOpaqueISigstreamManager,\n    const double time,\n    int errorXMLMode,\n    const char *block,\n    const char *var,\n    char errmsg[],\n    const int maxErrorBufferSize\n    );\n\n/* get the data time that is after time (time) for destination with id (destinationId) */\nextern double rtwISigstreamManagerNextTimeForDestination(void* pOpaqueISigstreamManager,\n                                                         const int destinationId,\n                                                         const double time);\n\n/* get the data time that is after time (time) accross all destinations */\nextern double rtwISigstreamManagerNextTime(void* pOpaqueISigstreamManager, const double time);\n\n/* get the next data time for external inputs that is after time (time) */\nextern double rtwISigstreamManagerNextTimeForExternalInputs(void* pOpaqueISigstreamManager,\n                                                            const double time);\n\n/* get the next hit time for aperiodic partitions that is after time (time) */\nextern double rtwISigstreamManagerNextTimeForAperiodicPartitions(void* pOpaqueISigstreamManager,\n                                                                 const double time);\n\n/* return false if there is an error, otherwise return true */\nextern bool rtwOSigstreamManagerCreateInstance(\n    const char *settingsFileName,\n    void * r2,\n    void **outpOSigstreamManager,\n    char errmsg[],\n    const int maxErrorBufferSize\n    );\n\nextern void rtwOSigstreamManagerDestroyInstance(void *pOpaqueOSigstreamManager);\n\nextern void rtwLoggingIntervalCreateInstance(void **outpLoggingInterval);\nextern void rtwLoggingIntervalDestroyInstance(void *pOpaqueLoggingInterval);\nextern bool rtwLoggingIntervalConstructIntervalTree(\n    void *pOpaqueLoggingInterval, \n    void *pOpaqueIntervals);\n\nextern bool rtwTimeInLoggingInterval(void *pOpaqueLoggingInterval, \n                                     const time_T time);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* sl_sigstream_rtw_h */\n\n/* LocalWords:  RSim\n */\n"},{"name":"simlogCIntrf.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2016-2017 The MathWorks, Inc. */\n#ifndef simlogCIntrf_h\n#define simlogCIntrf_h\n\n#ifdef __cplusplus\n#define SIMLOG_API_EXTERN_C extern \"C\"\n#else\n#define SIMLOG_API_EXTERN_C\n#endif\n\n#ifdef SL_INTERNAL\n\n#include \"version.h\"\n\n#if defined(BUILDING_LIBMWCODER_SIMLOG)\n#define SIMLOG_API DLL_EXPORT_SYM\n#define SIMLOG_API_C SIMLOG_API_EXTERN_C DLL_EXPORT_SYM\n#else\n#define SIMLOG_API DLL_IMPORT_SYM\n#define SIMLOG_API_C SIMLOG_API_EXTERN_C DLL_IMPORT_SYM\n#endif\n\n#else\n\n#define SIMLOG_API\n#define SIMLOG_API_C SIMLOG_API_EXTERN_C\n\n#endif\n\n#if defined(_MSC_VER) && (_MSC_VER < 1910)\ntypedef unsigned int uint32_t;\n#elif defined(__LCC__)\ntypedef unsigned int uint32_t;\n#else\n#include <stdint.h>\n#endif\n\nSIMLOG_API_C void observerLogInitialize(int aSimLogIOChannelKey);\n\nSIMLOG_API_C void observerLogInit(void);\n\nSIMLOG_API_C void observerLogReadPIC(int* PICVal);\n\nSIMLOG_API_C void observerLogWritePIC(int PICVal);\n\nSIMLOG_API_C void observerLogCleanup(void);\n\nSIMLOG_API_C void observerLog(int key, void* value, int size);\n\nSIMLOG_API_C void modifierInit(int numMods, void* modSpec);\n\nSIMLOG_API_C void getQuantizationParams(int key,\n                                        int* wl,\n                                        int* sign,\n                                        int* fl,\n                                        int* rounding,\n                                        int* wrapsat,\n                                        int* active);\n\nSIMLOG_API_C void modifierCleanup(void);\n\n#endif /* simlogCIntrf_h */\n"},{"name":"simstruc.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/**\n * @file: simstruc.h\n *\n * @brief S-function Authoring APIs\n *\n * Abstract:\n *      Data structures and access methods for S-functions.\n *\n *      A Simulink model is an S-function.  The SimStruct contains all entry\n *      points within the S-function (e.g. mdlOutputs) as well any data\n *      associated with the S-function.\n *\n *      This file contains details of SimStruct (Simulink data structure)\n *      which is used to store attributes of the model such as pointers to\n *      storage vectors.\n *\n *      Multiple SimStructs are, in general, used by a model. These SimStruct's\n *      are arranged as a \"tree\". The \"root\" SimStruct is used by\n *      the Simulink model. There is one child SimStruct for each S-function\n *      block with in the model.\n *\n *      The SimStruct can be used in three environments:\n *        o With MATLAB/Simulink (MATLAB_MEX_FILE)\n *        o With Real-Time Workshop in non-real-time (NRT)\n *        o With Real-Time Workshop in real-time (RT)\n *\n * Defines:\n *      One of the following must be defined.\n *        MATLAB_MEX_FILE    - Must be defined when compiling as a MEX file,\n *                             otherwise must not be defined.\n *        NRT                - Define if creating non-real-time executable\n *        RT                 - Define if creating real-time executable.\n *\n *        See ENVIRONMENT MACROS section below for more info.\n *\n *      Defines which must be declared by the Real-Time Workshop\n *      generated model source.\n *        Simulink_NAME=\"name\"\n *        NSAMPLE_TIMES=n\n *\n *      Defines for use with the Real-Time Workshop (these are configured\n *\tby the template makefile, do not add directly to make command):\n *        MULTITASKING       - Optional (use MT for a synonym).\n *        NUMST=n            - Number of sample times in the root SimStruct.\n *        TID01EQ=1 or 0     - Optional. Only define to 1 if sample time task\n *                             id's 0 and 1 have equal rates.\n * =============================================================================\n */\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#if defined(__has_warning)\n#if __has_warning(\"-Wreserved-id-macro\")\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"\n#endif\n#endif\n#endif\n\n#ifndef __SIMSTRUC__\n#define __SIMSTRUC__\n\n#include \"simstruc_compcond.h\"\n#include \"simstruc_types.h\"\n#include \"simstruc_def.h\"\n#include \"simstruc_debug.h\"\n\n/** @defgroup IOPorts Input and Output Ports\n *  @{\n */\n/*======================================*\n * Input and Output Ports *\n *======================================*/\n\n/** @ingroup IOPorts\n */\n\n/** @defgroup SignalSpec Signal Specification\n **\n *  @{\n */\n\n/** Signal Specification **/\n\n#if !SS_SFCN_LEVEL_1\n\n/**\n * @brief ssGetNumInputPorts(S)\n *\n * Get the number of input ports that an S-function block has\n * @param  S           SimStruct pointer\n * @return an int_T value indicating the number of input ports\n */\n#if !SS_SL_INTERNAL\n#define ssGetNumInputPorts(S) (S)->sizes.in.numInputPorts /*(int_T)*/\n#endif\n\n/**\n * @brief ssSetNumInputPorts(S, nInputPorts)\n *\n * Specify the number of input ports an S-function block has\n * @param  S           SimStruct pointer\n * @param  nInputPorts number of S-function input port\n * @return the Boolean value true if successful. Otherwise, returns false\n */\n#if SS_SFCN_FOR_SIM\n#define ssSetNumInputPorts(S, nInputPorts) \\\n    (*(S)->portInfo.regNumInputPortsFcn)((S)->portInfo.regNumInputPortsFcnArg, nInputPorts)\n\n#elif SS_SFCN_FOR_RTW\n/* RTW S-function block */\n#define ssSetNumInputPorts(S, nInputPorts) ((_ssSetNumInputPorts(S, nInputPorts)) >= 0)\n#elif SS_SL_INTERNAL || SS_RTW_INTERNAL\n/* Simulink or RTW model/run-time interface code */\n#define ssSetNumInputPorts(S, nInputPorts) ((_ssSetNumInputPorts(S, nInputPorts)) >= 0)\n#endif\n\n/**\n * @brief ssGetNumOutputPorts(S)\n *\n * Get the number of output ports that an S-function block has\n * @param  S           SimStruct pointer\n * @return an int_T value indicating the number of output ports\n */\n#if !SS_SL_INTERNAL\n#define ssGetNumOutputPorts(S) (S)->sizes.out.numOutputPorts /*(int_T)*/\n#endif\n\n/**\n * @brief ssSetNumOutputPorts(S, nOutputPorts)\n *\n * Specify the number of output ports an S-function block has\n * @param  S           SimStruct pointer\n * @param  nOutputPorts number of S-function input port\n * @return the Boolean value true if successful. Otherwise, returns false\n */\n#if SS_SFCN_FOR_SIM\n#define ssSetNumOutputPorts(S, nOutputPorts) \\\n    (*(S)->portInfo.regNumOutputPortsFcn)((S)->portInfo.regNumOutputPortsFcnArg, nOutputPorts)\n#elif SS_SFCN_FOR_RTW\n/* RTW S-function block */\n#define ssSetNumOutputPorts(S, nOutputPorts) ((_ssSetNumOutputPorts(S, nOutputPorts)) >= 0)\n#elif SS_SL_INTERNAL || SS_RTW_INTERNAL\n/* Simulink or RTW model/run-time interface code */\n#define ssSetNumOutputPorts(S, nOutputPorts) ((_ssSetNumOutputPorts(S, nOutputPorts)) >= 0)\n#endif\n\n/**\n * @brief ssGetInputPortDataType\n *\n * Get the data type ID of an input port\n * @param  S     SimStruct pointer\n * @param  port  input port index\n * @return the data type ID for the input port\n */\n#define ssGetInputPortDataType(S, port) \\\n    (S)->portInfo.inputs[(port)].dataTypeId /*     (DTypeId)   */\n\n/**\n * @brief ssSetInputPortDataType\n *\n * Set the data type ID of an input port\n * @param  S     SimStruct pointer\n * @param  port  input port index\n * @param  id    ID of the data type accepted by the input port\n * @return the data type ID specified by id. Returns -1 if id is DYNAMICALLY_TYPED\n */\n#define ssSetInputPortDataType(S, port, dTypeId) \\\n    ((S)->portInfo.inputs[(port)].dataTypeId = (dTypeId))\n\n\n/**\n * @brief ssGetInputPortComplexSignal\n *\n * Determine whether an input port accepts complex signals\n * @param S    SimStruct pointer\n * @param port input port index\n * @return COMPLEX_YES (1) if port accepts complex signals, COMPLEX_NO (0) if port does\n * not accept complex signals, and COMPLEX_INHERITED (-1) if port inherits its numeric\n * type from the port to which it is connected\n */\n#define ssGetInputPortComplexSignal(S, port) \\\n    (S)->portInfo.inputs[(port)].complexSignal /*   (CSignal_T)    */\n\n/**\n * @brief ssSetInputPortComplexSignal\n *\n * Determine whether an input port accepts complex signals\n * @param S    SimStruct pointer\n * @param port input port index\n * @param csig  Numeric type of the signals accepted by port. Valid values are COMPLEX_NO\n * (real signal), COMPLEX_YES (complex signal), and COMPLEX_INHERITED (numeric type\n * inherited from driving block).\n * @return 1 (COMPLEX_YES), 0 (COMPLEX_NO), or -1 (COMPLEX_INHERITED) depending on\n * the value specified by csig.\n */\n#define ssSetInputPortComplexSignal(S, port, csig) \\\n    (S)->portInfo.inputs[(port)].complexSignal = (csig)\n\n/**\n * @brief ssGetOutputPortComplexSignal\n *\n * Get the numeric type (complex or real) of an output port\n * @param S    SimStruct pointer\n * @param port Index of an output port.\n * @return COMPLEX_YES (1) if port accepts complex signals, COMPLEX_NO (0) if port does\n * not accept complex signals, and COMPLEX_INHERITED (-1) if port inherits its numeric\n * type from the port to which it is connected\n */\n#define ssGetOutputPortComplexSignal(S, port) \\\n    (S)->portInfo.outputs[(port)].complexSignal /* (CSignal_T)  */\n\n/**\n * @brief ssSetInputPortComplexSignal\n *\n * Set the numeric type (real or complex) of an output port\n * @param S    SimStruct pointer\n * @param port Output port index\n * @param csig  Numeric type of the signals accepted by port. Valid values are COMPLEX_NO\n * (real signal), COMPLEX_YES (complex signal), and COMPLEX_INHERITED (numeric type\n * inherited from driving block).\n * @return 1 (COMPLEX_YES), 0 (COMPLEX_NO), or -1 (COMPLEX_INHERITED) depending on\n * the value specified by csig.\n */\n#define ssSetOutputPortComplexSignal(S, port, val) \\\n    (S)->portInfo.outputs[(port)].complexSignal = (val)\n\n\n/**\n * @brief ssGetInputPortUnit\n *\n * Get unit of input port\n * @param  S     SimStruct pointer\n * @param  port  input port index\n * @return The unit ID of the input port specified by port. This ID is returned\n * from thes sRegisterUnitFromExpr method. Returns DYNAMICALLY_TYPED if the input\n * port inherits its unit.\n */\n#define ssGetInputPortUnit(S, port) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputUnits[(port)].unitId /*   (UnitId)    */\n\n/**\n * @brief ssSetInputPortUnit\n *\n * Specify unit for input port\n * @param  S     SimStruct pointer\n * @param  port  input port index\n * @param  id    ID of the unit accepted by port. This ID is returned from the\n * ssRegisterUnitFromExpr method\n * @return The unit ID specified by id. Returns -1 if id is DYNAMICALLY_TYPED\n */\n#define ssSetInputPortUnit(S, port, val) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputUnits[(port)].unitId = (val)\n\n#endif /* !SS_SFCN_LEVEL_1 */\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetInputPortDirectFeedThrough\n *\n * Specify the direct feedthrough status of a block's ports\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the input port whose direct feedthrough property is being set.\n * @param    dirFeed       Direct feedthrough status of the block specified by port.\n */\n#if !SS_DEBUG_FOR_SIM\n#define ssSetInputPortDirectFeedThrough(S, port, dirFeed) \\\n    (S)->portInfo.inputs[(port)].directFeedThrough = (dirFeed)\n#endif\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortDirectFeedThrough\n *\n * Determine whether a port has direct feedthrough\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the input port whose direct feedthrough property is being set.\n * @return   The int_T value 1 if the input port specified by the index port has direct feedthrough.\n * Otherwise, returns 0.\n */\n#define ssGetInputPortDirectFeedThrough(S, port) \\\n    (S)->portInfo.inputs[(port)].directFeedThrough /*   (int_T)       */\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortOffsetTime\n *\n * Get the offset time of an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the input port whose direct feedthrough property is required.\n * @return   A real_T value indicating the offset time of the input port specified by the index\n * inputPortIdx.\n */\n#define ssGetInputPortOffsetTime(S, port) \\\n    ((S)->portInfo.inputs[(port)].offsetTime) /* (real_T)      */\n\n/**\n * @brief ssSetInputPortOffsetTime\n *\n * Specify the offset time of an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the input port whose direct feedthrough property is being set.\n * @param    val           Offset time.\n * @return   The real_T value of the offset time passed into the macro.\n */\n#define ssSetInputPortOffsetTime(S, port, val) \\\n    (S)->portInfo.inputs[(port)].offsetTime = (val) /* (real_T)      */\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortRequiredContiguous\n *\n * Determine whether the signal elements entering a port must be contiguous\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the input port.\n * @return   An int_T (1 or 0) or boolean_T (true or false) value indicating\n * if the signal elements entering a port must be contiguous.\n */\n#define ssGetInputPortRequiredContiguous(S, port) \\\n    ((S)->portInfo.inputs[(port)].attributes.contiguity != 0)\n\n\n/**\n * @brief ssSetInputPortRequiredContiguous\n *\n * Specify that the signal elements entering a port must be contiguous\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the input port.\n * @param    val           True(1) if signal elements must be contiguous.\n */\n#define ssSetInputPortRequiredContiguous(S, port, val) \\\n    (S)->portInfo.inputs[(port)].attributes.contiguity = ((val) != 0)\n\n#endif\n\n/**\n * @brief ssRegisterUnitFromExpr\n *\n * Register unit from unit expression\n * @param    S             SimStruct representing an S-Function block.\n * @param    expr          Function pointer corresponding to the unit expression for the unit being\n * registered.\n * @param    id            An integer whose value is the numeric unit type identifier after the\n * call to ssRegisterUnitFromExpr.\n */\n#if !SS_SFCN_LEVEL_1\n#if SS_SIM\ntypedef struct _ssRegisterUnitFromExprType_tag {\n    const char* unitExpr;\n    int* unitId;\n} ssRegisterUnitFromExprType;\n#define ssRegisterUnitFromExpr(S, expr, id)                                    \\\n    {                                                                          \\\n        ssRegisterUnitFromExprType _slRegisterUnitFromExprInfo;                \\\n        _slRegisterUnitFromExprInfo.unitExpr = (expr);                         \\\n        _slRegisterUnitFromExprInfo.unitId = (id);                             \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REGISTER_UNIT_FROM_EXPR, 0, \\\n                                        (void*)&_slRegisterUnitFromExprInfo)   \\\n            _ssSafelyCallGenericFcnEnd;                                        \\\n    }\n#else\n#define ssRegisterUnitFromExpr(S, name, id)\n#endif\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetOutputPortSampleTime\n *\n * Specify the sample time of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port whose sample time is being set.\n * @param    val           Sample time of the output port.\n * @return   The real_T value of the sample time passed into the macro.\n */\n#define ssSetOutputPortSampleTime(S, port, val) \\\n    (S)->portInfo.outputs[(port)].sampleTime = (val) /* (real_T)      */\n\n/**\n * @brief ssGetOutputPortOffsetTime\n *\n * Get the offset time of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port whose offset time is being set.\n * @return   A real_T value indicating the offset time of the output port specified by the index\n * outputPortIdx.\n */\n#define ssGetOutputPortOffsetTime(S, port) \\\n    ((S)->portInfo.outputs[(port)].offsetTime) /* (real_T)      */\n\n/**\n * @brief ssSetOutputPortOffsetTime\n *\n * Specify the offset time of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port whose offset time is being set.\n * @param    val           Offset time of the output port.\n * @return   The real_T value of the offset time passed into the macro.\n */\n#define ssSetOutputPortOffsetTime(S, port, val) \\\n    (S)->portInfo.outputs[(port)].offsetTime = (val) /* (real_T)      */\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortFrameData\n *\n * Determine whether a port accepts signal frames\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port.\n * @return   A value of type Frame_T, indicating if the input port specified by the index\n * port accepts signal frames.\n */\n#define ssGetInputPortFrameData(S, port) \\\n    CONV_BITS2INT((S)->portInfo.inputs[(port)].attributes.frameData)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetOutputPortFrameData\n *\n * Determine whether a port outputs signal frames\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port.\n * @return   A value of type Frame_T, indicating if the output port specified by the index port\n * produces signal frames.\n */\n#define ssGetOutputPortFrameData(S, port) \\\n    CONV_BITS2INT((S)->portInfo.outputs[(port)].attributes.frameData)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetOutputPortUnit\n *\n * Get unit of output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port.\n * @return   The unit ID of the output port specified by port.\n * Returns DYNAMICALLY_TYPED if the output port inherits its unit.\n */\n#define ssGetOutputPortUnit(S, port) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputUnits[(port)].unitId /*   (UnitId)    */\n\n/**\n * @brief ssSetOutputPortUnit\n *\n * Specify unit of output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port.\n * @param   val           ID of the unit accepted by port. This ID is returned from\n * the ssRegisterUnitFromExpr method.\n * @return   The unit ID specified by id. Returns -1 if id is DYNAMICALLY_TYPED.\n */\n#define ssSetOutputPortUnit(S, port, val) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputUnits[(port)].unitId = (val)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssAllowSignalsWithMoreThan2D\n *\n * Enable S-function to work with multidimensional signals\n * @param    S             SimStruct representing an S-Function block.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssAllowSignalsWithMoreThan2D(S)                                              \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ALLOW_MORE_THAN_2D_SIGS, 1, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssAllowSignalsWithMoreThan2D(S)\n#endif\n#endif\n\n/**\n * @brief ssSetOneBasedIndexInputPort\n *\n * Specify that an input port expects one-based indices\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Input port of the S-function\n */\n#if SS_SFCN && SS_SIM\n#define ssSetOneBasedIndexInputPort(S, pIdx)                                      \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ONE_BASED_IN_PORT, pIdx, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\n/**\n * @brief ssSetOneBasedIndexOutputPort\n *\n * Specify that an output port expects one-based indices\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Output port of the S-function\n */\n#if SS_SFCN && SS_SIM\n#define ssSetOneBasedIndexOutputPort(S, pIdx)                                      \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ONE_BASED_OUT_PORT, pIdx, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\n/**\n * @brief ssSetZeroBasedIndexInputPort\n *\n * Specify that an input port expects zero-based indices\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Input port of the S-function\n */\n#if SS_SFCN && SS_SIM\n#define ssSetZeroBasedIndexInputPort(S, pIdx)                                      \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ZERO_BASED_IN_PORT, pIdx, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\n/**\n * @brief ssSetZeroBasedIndexOutputPort\n *\n * Specify that an output port expects zero-based indices\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Output port of the S-function\n */\n#if SS_SFCN && SS_SIM\n#define ssSetZeroBasedIndexOutputPort(S, pIdx)                                      \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ZERO_BASED_OUT_PORT, pIdx, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetInputPortIsContinuousQuantity\n *\n * Specify that an input port expects co-simulation signals that represents continuous quantities\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Input port of the S-function.\n * @param    val           Int or boolean value (0 or 1) that indicates if this port expects\n * a co-simulation signal, which is a discrete-time signal that represents a continuous quantity.\n */\n#define ssSetInputPortIsContinuousQuantity(S, port, val) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputCoSimAttribute[(port)].isContinuousQuantity = (val)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortIsContinuousQuantity\n *\n * Determine whether an input port expects co-simulation signals that represents continuous\n * quantities\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Input port of the S-function.\n * @return   Int or boolean value (0 or 1) that indicates if this port expects\n * a co-simulation signal, which is a discrete-time signal that represents a continuous quantity.\n */\n#define ssGetInputPortIsContinuousQuantity(S, port) \\\n    ((S)->blkInfo.blkInfo2->portInfo2->inputCoSimAttribute[(port)].isContinuousQuantity == 1U)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetOutputPortIsContinuousQuantity\n *\n * Specify that an output port generates co-simulation signals that represents continuous quantities\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Output port of the S-function.\n * @param    val           Int or boolean value (0 or 1) that indicates if this port generates\n * a co-simulation signal, which is a discrete-time signal that represents a continuous quantity.\n */\n#define ssSetOutputPortIsContinuousQuantity(S, port, val) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputCoSimAttribute[(port)].isContinuousQuantity = (val)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetOutputPortIsContinuousQuantity\n *\n * Determine whether an output port generates co-simulation signals that represents continuous\n * quantities\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Output port of the S-function.\n * @return   Int or boolean value (0 or 1) that indicates if this port generates\n * a co-simulation signal, which is a discrete-time signal that represents a continuous quantity.\n */\n#define ssGetOutputPortIsContinuousQuantity(S, port) \\\n    ((S)->blkInfo.blkInfo2->portInfo2->outputCoSimAttribute[(port)].isContinuousQuantity == 1U)\n#endif\n\n/** @} */ /* end of SignalSpec */\n\n/** @ingroup IOPorts\n */\n\n/** @defgroup SignalDims Signal Dimensions\n **\n *  @{\n */\n\n/** Signal Dimensions **/\n\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetInputPortDimensionInfo\n *\n * Specify information about the dimensionality of an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port.\n * @param    val           Structure of type DimsInfo_T that specifies the dimensionality of\n * the signals accepted by port.\n * @return   1 if successful; otherwise, 0.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetInputPortDimensionInfo(S, port, val)               \\\n    (((ssGetRegInputPortDimensionInfoFcn(S)) != NULL)           \\\n         ? (ssGetRegInputPortDimensionInfoFcn(S))(S, port, val) \\\n         : (1))\n#else /* RTW S-function block */\n#define ssSetInputPortDimensionInfo(S, port, val) (1)\n#endif\n#endif\n\n/**\n * @brief ssSetInputPortDimensionsMode\n *\n * Set the dimensions mode of the input port indexed by pIdx\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Index of an input port.\n * @param    value         Enum value corresponding to the ports dimensions mode.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetInputPortDimensionsMode(S, pIdx, value)                                  \\\n    {                                                                                 \\\n        DimensionsMode_T val = value;                                                 \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_INPUT_DIMS_MODE, pIdx, &val) \\\n            _ssSafelyCallGenericFcnEnd;                                               \\\n    }\n#else\n#define ssSetInputPortDimensionsMode(S, pIdx, value)\n#endif\n\n/**\n * @brief ssSetInputPortDimsSameAsOutputPortDims\n *\n * Set the dimensions of output port outIdx to be equal to the dimensions of input port inpIdx.\n * This method is called from mdlSetWorkWidths\n * @param    S             SimStruct representing an S-Function block.\n * @param    inpIdx        Index of an input port.\n * @param    outIdx        Output port index.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetInputPortDimsSameAsOutputPortDims(S, inpIdx, outIdx)                            \\\n    {                                                                                        \\\n        int val = outIdx;                                                                    \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_INPUT_DIMS_SAMEAS_OUTPUT, (inpIdx), \\\n                                        (&val)) _ssSafelyCallGenericFcnEnd;                  \\\n    }\n#else\n#define ssSetInputPortDimsSameAsOutputPortDims(S, inpIdx, outIdx)\n#endif\n\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetInputPortMatrixDimensions\n *\n * Specify dimension information for an input port that accepts matrix signalsl.\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port\n * @param    val1          Row dimension of matrix signals accepted by port or DYNAMICALLY_SIZED.\n * @param    val2          Column dimension of matrix signals accepted by port or DYNAMICALLY_SIZED.\n */\n#if SS_SFCN_FOR_SIM\n#if defined(USE_64BIT_FIELDS)\n#define ssSetInputPortMatrixDimensions(S, port, val1, val2) \\\n    (_ssSetInputPortMatrixDimensionsSLSize(S, port, val1, val2))\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetInputPortMatrixDimensions(S, port, val1, val2) \\\n    (_ssSetInputPortMatrixDimensions(S, port, val1, val2))\n#endif\n#else /* RTW S-function block */\n#define ssSetInputPortMatrixDimensions(S, port, val1, val2) (1)\n#endif\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetInputPortVectorDimension\n *\n * Specify dimension information for an input port that accepts vector signals\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port\n * @param    val           Width of the vector or DYNAMICALLY_SIZED.\n */\n#if SS_SFCN_FOR_SIM\n#if defined(USE_64BIT_FIELDS)\n#define ssSetInputPortVectorDimension(S, port, val) \\\n    (_ssSetInputPortVectorDimensionSLSize(S, port, val))\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetInputPortVectorDimension(S, port, val) (_ssSetInputPortVectorDimension(S, port, val))\n#endif\n#else /* RTW S-function block */\n#define ssSetInputPortVectorDimension(S, port, val) (1)\n#endif\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortWidth\n *\n * Get the width of an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the port whose width is required\n * @return   An int_T value indicating the number of elements in the input signal.\n * If the number of elements is unknown, returns DYNAMICALLY_SIZED.\n */\n\n\n#if defined(USE_64BIT_FIELDS)\n#define ssGetInputPortWidth(S, port) (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].width\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetInputPortWidth(S, port) (S)->portInfo.inputs[(port)].width\n#endif\n\n/**\n * @brief ssSetInputPortWidth\n *\n * Specify the width of an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the port whose width is being set.\n * @param    width         Width of the input port.\n */\n\n#if defined(USE_64BIT_FIELDS)\n#define ssSetInputPortWidth(S, port, val) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].width = (val)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetInputPortWidth(S, port, val) (S)->portInfo.inputs[(port)].width = (val)\n#endif\n\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssPruneNDMatrixSingletonDims\n *\n * Prune trailing singleton dimensions\n * @param    S             SimStruct representing an S-Function block.\n * @param    dimsInfo      Structure of type DimsInfo_T that specifies the dimensionality of the\n * signals accepted by port.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssPruneNDMatrixSingletonDims(S, dimInfo)                                      \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_PRUN_TRAILING_DIMS, 0, (void*)dimInfo) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssPruneNDMatrixSingletonDims(S, dimInfo)\n#endif\n#endif\n\n/**\n * @brief ssSetCurrentOutputPortDimensions\n *\n * Set the current size corresponding to dimension dIdx of the output signal at port pIdx\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Output port index being set.\n * @param    dIdx          Index of dimension being set.\n * @param    val           Current size value to set for dimension dIdx.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetCurrentOutputPortDimensions(S, pIdx, _dIdx, _val)                             \\\n    {                                                                                      \\\n        struct _ssVarDimsIdxVal_tag dIdxVal;                                               \\\n        dIdxVal.dIdx = _dIdx;                                                              \\\n        dIdxVal.dVal = _val;                                                               \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_CURR_OUTPUT_DIMS, pIdx, &dIdxVal) \\\n            _ssSafelyCallGenericFcnEnd;                                                    \\\n    }\n#else\n#define ssSetCurrentOutputPortDimensions(S, pIdx, dIdx, val) \\\n    _ssSetCurrentOutputPortDimensions(S, pIdx, dIdx, val)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetOutputPortDimensionInfo\n *\n * Specify information about the dimensionality of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port\n * @param    val           Structure of type DimsInfo_T that specifies the dimensionality of the\n * signals emitted by port.\n * @return   1 if successful; otherwise, 0.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetOutputPortDimensionInfo(S, port, val)               \\\n    (((ssGetRegOutputPortDimensionInfoFcn(S)) != NULL)           \\\n         ? (ssGetRegOutputPortDimensionInfoFcn(S))(S, port, val) \\\n         : (1))\n#else /* RTW S-function block */\n#define ssSetOutputPortDimensionInfo(S, port, val) (1)\n#endif\n#endif\n\n/**\n * @brief ssSetOutputPortDimensionsMode\n *\n * Set the dimensions mode of the output port indexed by pIdx\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Output port index being polled.\n * @param    value         Enum value corresponding to the ports dimensions mode.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetOutputPortDimensionsMode(S, pIdx, value)                                  \\\n    {                                                                                  \\\n        DimensionsMode_T val = value;                                                  \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_OUTPUT_DIMS_MODE, pIdx, &val) \\\n            _ssSafelyCallGenericFcnEnd;                                                \\\n    }\n#else\n#define ssSetOutputPortDimensionsMode(S, pIdx, value)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetOutputPortMatrixDimensions\n *\n * Specify dimension information for an output port that emits matrix signals\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port.\n * @param    val1          Row dimension of matrix signals emitted by port or DYNAMICALLY_SIZED.\n * @param    val2          Column dimension of matrix signals emitted by port or DYNAMICALLY_SIZED.\n * @return   1 if successful; otherwise, 0.\n */\n#if SS_SFCN_FOR_SIM\n#if defined(USE_64BIT_FIELDS)\n#define ssSetOutputPortMatrixDimensions(S, port, val1, val2) \\\n    (_ssSetOutputPortMatrixDimensionsSLSize(S, port, val1, val2))\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetOutputPortMatrixDimensions(S, port, val1, val2) \\\n    (_ssSetOutputPortMatrixDimensions(S, port, val1, val2))\n#endif\n#else /* RTW S-function block */\n#define ssSetOutputPortMatrixDimensions(S, port, val1, val2) (1)\n#endif\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetOutputPortVectorDimension\n *\n * Specify dimension information for an output port that emits vector signals\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port.\n * @param    val           Width of the vector or DYNAMICALLY_SIZED.\n * @return   1 if successful; otherwise, 0.\n */\n#if SS_SFCN_FOR_SIM\n#if defined(USE_64BIT_FIELDS)\n#define ssSetOutputPortVectorDimension(S, port, val) \\\n    (_ssSetOutputPortVectorDimensionSLSize(S, port, val))\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetOutputPortVectorDimension(S, port, val) (_ssSetOutputPortVectorDimension(S, port, val))\n#endif\n#else /* RTW S-function block */\n#define ssSetOutputPortVectorDimension(S, port, val) (1)\n#endif\n#endif\n\n/**\n * @brief ssGetOutputPortWidth\n *\n * Get the width of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port.\n * @return   An int_T value indicating the width of the output port specified by the index port.\n */\n\n#if defined(USE_64BIT_FIELDS)\n#define ssGetOutputPortWidth(S, port) (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].width\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetOutputPortWidth(S, port) (S)->portInfo.outputs[(port)].width /*   (int_T)       */\n#endif\n/**\n * @brief ssSetOutputPortWidth\n *\n * Specify the width of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port whose width is being set.\n * @param    val           Width of an output port\n */\n\n#if defined(USE_64BIT_FIELDS)\n#define ssSetOutputPortWidth(S, port, val) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].width = (val)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetOutputPortWidth(S, port, val) (S)->portInfo.outputs[(port)].width = (val)\n#endif\n\n/**\n * @brief ssAddOutputDimsDependencyRule\n *\n * Register a method to handle current dimensions update.\n * @param    S             SimStruct representing an S-Function block.\n * @param    outIdx        Output port index\n * @param    ruleInfo      Structure containing the dimensions propagation method information.\n */\n#if SS_SFCN_FOR_SIM\n#define ssAddOutputDimsDependencyRule(S, outIdx, ruleInfo)                                       \\\n    {                                                                                            \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ADD_DIMS_DEPEND_RULE, (outIdx), (ruleInfo)) \\\n            _ssSafelyCallGenericFcnEnd;                                                          \\\n    }\n#else\n#define ssAddOutputDimsDependencyRule(S, outIdx, ruleInfo)\n#endif\n\n/**\n * @brief ssAddVariableSizeSignalsRuntimeChecker\n *\n * Register a method to check the current input dimensions\n * @param    S             SimStruct representing an S-Function block.\n * @param    checker_type  Enum value corresponding to the checker type.\n */\n#if SS_SFCN && SS_SIM\n#define ssAddVariableSizeSignalsRuntimeChecker(S, checker_type)                                   \\\n    {                                                                                             \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ADD_VARDIMS_RUNTIME_CHECKER, (checker_type), \\\n                                        NULL) _ssSafelyCallGenericFcnEnd;                         \\\n    }\n#endif\n\n/**\n * @brief ssRegMdlSetInputPortDimensionsModeFcn\n *\n * Register the method to handle dimensions mode propagation for each input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    fcn           Function pointer corresponding to the function being registered.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssRegMdlSetInputPortDimensionsModeFcn(S, fcn)                                       \\\n    {                                                                                       \\\n        mdlSetInputPortDimensionsModeFcn _mdlDimsModeFcn = fcn;                             \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REG_SET_INPUT_DIMS_MODE_MTH, 0,        \\\n                                        (void*)_mdlDimsModeFcn) _ssSafelyCallGenericFcnEnd; \\\n    }\n#else\n#define ssRegMdlSetInputPortDimensionsModeFcn(S, fcn)\n#endif\n\n/**\n * @brief ssSetDWorkRequireResetForSignalSize\n *\n * Set the block flag for resetting the index Dwork size upon subsystem reset.\n * @param    S             SimStruct representing an S-Function block.\n * @param    index         Dwork index.\n * @param    n             Enum value corresponding to the signal size compute type.\n */\n#define ssSetDWorkRequireResetForSignalSize(S, index, n) \\\n    (S)->work.dWorkAux[index].flags.ensureResetForSizeVary = (unsigned int)(n)\n\n\n/**\n * @brief ssSetSignalSizesComputeType\n *\n * Set the type of ouput dependency on the input signal\n * @param    S             SimStruct representing an S-Function block.\n * @param    type          Enum value corresponding to the signal size compute type.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetSignalSizesComputeType(S, type)                                                   \\\n    {                                                                                          \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_COMP_VARSIZE_COMPUTE_TYPE, (type), 0) \\\n            _ssSafelyCallGenericFcnEnd;                                                        \\\n    }\n#else\n#define ssSetSignalSizesComputeType(S, type)\n#endif\n\n\n/**\n * @brief ssSetVectorMode\n *\n * Specify the vector mode that an S-function supports\n * @param    S             SimStruct representing an S-Function block.\n * @param    n             Vector mode\n */\n#define ssSetVectorMode(S, n) (S)->sizes.flags.vectMode = (n)\n\n\n/**\n * @brief ssGetCurrentInputPortDimensions\n *\n * Get the current size of dimension dIdx of input port pIdx\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Input port index being polled.\n * @param    dIdx          Index of dimension being polled.\n * @return   An int_T value indicating the size of dimension dIdx.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetCurrentInputPortDimensions(S, pIdx, dIdx) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(pIdx)].portVarDims[(dIdx)]\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetCurrentInputPortDimensions(S, pIdx, dIdx) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputs[(pIdx)].portVarDims[(dIdx)]\n#endif\n\n\n/**\n * @brief ssGetCurrentInputPortWidth\n *\n * Get the total width (total number of elements) of the signal at input port pIdx\n * @param    S             SimStruct representing an S-Function block.\n * @param    portIdx          Input port index being polled.\n * @return   An int_T value indicating the current width of the signal at input port portIdx.\n */\n#define ssGetCurrentInputPortWidth(S, portIdx) _ssGetCurrentInputPortWidth(S, portIdx)\n\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortDimensions\n *\n * Get the dimensions of the signal accepted by an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port\n * @return   A pointer (int_T *) to an array of integers. The array contains elements with the\n * value DYNAMICALLY_SIZED (-1) when the size of a dimension is unknown.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetInputPortDimensions(S, port) (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetInputPortDimensions(S, port) ((S)->portInfo.inputs[(port)].dims)\n#endif\n\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortDimensionSize\n *\n * Get the size of one dimension of the signal entering an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port.\n * @param    dIdx          Index of the dimension.\n * @return   An int_T value indicating the size of dimension, dIdx, at the input port specified by\n * port. Returns 1 if the dIdx is greater than or equal to the number of input port dimensions.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetInputPortDimensionSize(S, port, dIdx)                           \\\n    ((dIdx) < ssGetInputPortNumDimensions((S), (port))                       \\\n         ? (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims[(dIdx)] \\\n         : 1)\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetInputPortDimensionSize(S, port, dIdx)                                                 \\\n    ((dIdx) < ssGetInputPortNumDimensions((S), (port)) ? (S)->portInfo.inputs[(port)].dims[(dIdx)] \\\n                                                       : 1)\n#endif\n\n#endif\n\n/**\n * @brief ssGetInputPortDimensionsMode\n *\n * Get the dimensions mode of the input port indexed by pIdx\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Input port index being polled.\n * @return   A DimensionsMode_T value indicating the current dimensions mode.\n * Possible values are INHERIT_DIMS_MODE FIXED_DIMS_MODE and VARIABLE_DIMS_MODE.\n */\n#if SS_SIM\n#define ssGetInputPortDimensionsMode(S, pIdx) \\\n    CONV_BITS2DIMSMODE((S)->portInfo.inputs[(pIdx)].attributes.dimensionsMode)\n#else\n#define ssGetInputPortDimensionsMode(S, pIdx) ssGetInputPortDimensionsMode_cannot_be_used_in_RTW\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortNumDimensions\n *\n * Get the dimensions mode of the signals accepted by an input port.\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port.\n * @return   A positive integer indicating the number of dimensions of the input port specified by\n * the index port, or DYNAMICALLY_SIZED, if the number of dimensions is unknown.\n */\n#define ssGetInputPortNumDimensions(S, port)            \\\n    ((S)->portInfo.inputs[(port)].numDims) /*   (int_T) \\\n                                            */\n#endif\n\n\n/**\n * @brief ssGetCurrentOutputPortDimensions\n *\n * Get the current size of dimension dIdx of the signal at output port pIdx.\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Output port index being polled.\n * @param    dIdx          Index of dimension being polled.\n * @return   An int_T value indicating the size of dimension dIdx\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetCurrentOutputPortDimensions(S, pIdx, dIdx) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(pIdx)].portVarDims[(dIdx)]\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetCurrentOutputPortDimensions(S, pIdx, dIdx) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputs[(pIdx)].portVarDims[(dIdx)]\n#endif\n\n/**\n * @brief ssGetCurrentOutputPortDimensionsAndRecordIndex\n *\n * Get the current size of dimension dIdx of the signal at output port pIdx and record this port\n * index.\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Output port index being polled.\n * @param    dIdx          Index of dimension being polled.\n * @return   An int_T value indicating the size of dimension dIdx\n */\n#define ssGetCurrentOutputPortDimensionsAndRecordIndex(S, pIdx, dIdx)                            \\\n    *((_ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ADD_OUTPUT_VARDIMS_PORT_INDEX, (pIdx), NULL) \\\n           _ssSafelyCallGenericFcnEnd)                                                           \\\n          ? &(ssGetCurrentOutputPortDimensions(S, pIdx, dIdx))                                   \\\n          : &(ssGetCurrentOutputPortDimensions(S, pIdx, dIdx)))\n\n/**\n * @brief ssGetCurrentOutputPortWidth\n *\n * Get the total (total number of elements) of the signal at output port pIdx\n * @param    S             SimStruct representing an S-Function block.\n * @param    portIdx          Output port index being polled.\n * @return   An int_T value indicating the current width of the signal at output port portIdx.\n */\n#define ssGetCurrentOutputPortWidth(S, portIdx) _ssGetCurrentOutputPortWidth(S, portIdx)\n\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetOutputPortDimensions\n *\n * Get the dimensions of the signal leaving an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port\n * @return   A pointer (int_T *) to an array of integers. The array contains elements with the value\n * DYNAMICALLY_SIZED (-1) when the size of a dimension is unknown.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetOutputPortDimensions(S, port) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetOutputPortDimensions(S, port) ((S)->portInfo.outputs[(port)].dims)\n#endif\n\n/**\n * @brief ssGetOutputPortDimensionSize\n *\n * Get the size of one dimension of the signal leaving an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port.\n * @param    dIdx          Index of the dimension.\n * @return   An int_T value indicating the size of dimension, dIdx, at the output port specified by\n * port. Returns 1 if the dIdx is greater than or equal to the number of output port dimensions.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetOutputPortDimensionSize(S, port, dIdx)                           \\\n    ((dIdx) < ssGetOutputPortNumDimensions((S), (port))                       \\\n         ? (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims[(dIdx)] \\\n         : 1)\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetOutputPortDimensionSize(S, port, dIdx)     \\\n    ((dIdx) < ssGetOutputPortNumDimensions((S), (port)) \\\n         ? (S)->portInfo.outputs[(port)].dims[(dIdx)]   \\\n         : 1)\n#endif\n\n#endif\n/**\n * @brief ssGetOutputPortDimensionsMode\n *\n * Get the dimensions mode of the output port indexed by pIdx\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Output Port index being polled.\n * @return   A DimensionsMode_T value indicating the current dimensions mode. Possible values are\n * INHERIT_DIMS_MODE FIXED_DIMS_MODE and VARIABLE_DIMS_MODE.\n */\n#if SS_SIM\n#define ssGetOutputPortDimensionsMode(S, pIdx) \\\n    CONV_BITS2DIMSMODE((S)->portInfo.outputs[(pIdx)].attributes.dimensionsMode)\n#else\n#define ssGetOutputPortDimensionsMode(S, pIdx) ssGetOutputPortDimensionsMode_cannot_be_used_in_RTW\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetOutputPortNumDimensions\n *\n * Get the number of dimensions of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port\n * @return   A positive integer indicating the number of dimensions of the output port specified\n * by the index port, or DYNAMICALLY_SIZED, if the number of dimensions is unknown.\n */\n#define ssGetOutputPortNumDimensions(S, port) \\\n    ((S)->portInfo.outputs[(port)].numDims) /*   (int_T) */\n#endif\n\n/** @} */ /* end of SignalDims */\n\n/** @defgroup SignalAccess Signal Access\n **\n *  @{\n */\n\n/** Signal Access **/\n\n\n#if !SS_SFCN_LEVEL_1\n#if !SS_DEBUG_FOR_SIM\n/**\n * @brief ssGetInputPortBufferDstPort\n *\n * Determine the output port that is sharing this input port's buffer\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port on S\n * @return   The int_T index of the output port that reuses the memory buffer of the input port\n * indicated by the index inputPortIdx. If none of the S-function's output ports reuse this input\n * port buffer, returns INVALID_PORT_IDX (-1).\n */\n#define ssGetInputPortBufferDstPort(S, port) \\\n    ((S)->portInfo.inputs[(port)].bufferDstPort) /* (int_T) */\n#endif                                           /* !SS_DEBUG_FOR_SIM */\n#endif                                           /* !SS_SFCN_LEVEL_1 */\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortConnected\n *\n * Determine whether a port is connected to a nonvirtual block\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Port whose connected status is needed.\n * @return   Either an int_T (1 or 0) or boolean_T (true or false) value indicating if the\n * input port specified by the index port is connected to a nonvirtual block.\n */\n#define ssGetInputPortConnected(S, port) (S)->portInfo.inputs[(port)].connected /* (int_T) */\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortOptimOpts\n *\n * Get the reusability setting of the memory allocated to the input port of an S-function\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port of S.\n * @return   One of the followings: SS_NOT_REUSABLE_AND_GLOBAL,SS_REUSABLE_AND_LOCAL,\n * SS_REUSABLE_AND_GLOBAL, SS_NOT_REUSABLE_AND_LOCAL\n */\n#define ssGetInputPortOptimOpts(S, port) ((S)->portInfo.inputs[(port)].attributes.optimOpts)\n\n/**\n * @brief ssSetInputPortOptimOpts\n *\n * Specify reusability of the memory allocated to the input port of an S-function\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port of S.\n * @param    val           One of the followings: SS_NOT_REUSABLE_AND_GLOBAL,SS_REUSABLE_AND_LOCAL,\n * SS_REUSABLE_AND_GLOBAL, SS_NOT_REUSABLE_AND_LOCAL\n */\n#define ssSetInputPortOptimOpts(S, port, val) \\\n    ((S)->portInfo.inputs[(port)].attributes.optimOpts = (val))\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetInputPortOverWritable\n *\n * Determine whether an input port can be overwritten\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port whose overwritability is required.\n * @return   An int_T (1 or 0) or boolean_T (true or false) value indicating if the input port\n * specified by the index port can be overwritten.\n */\n#define ssGetInputPortOverWritable(S, port) \\\n    ((S)->portInfo.inputs[(port)].attributes.overWritable == 1U)\n\n/**\n * @brief ssSetInputPortOverWritable\n *\n * Specify whether one of an S-function's input ports can be overwritten by one of its output ports\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an input port whose overwritability is being set.\n * @param    val           Value specifying whether port is overwritable.\n */\n#define ssSetInputPortOverWritable(S, port, val) \\\n    ((S)->portInfo.inputs[(port)].attributes.overWritable = (val) ? 1U : 0U)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n#if !SS_DEBUG_FOR_SIM\n/**\n * @brief ssGetInputPortSignal\n *\n * Get the address of a contiguous signal entering an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    ip            Index of the port whose address is required.\n * @return   A pointer (void *) to the input port specified by the index ip.\n */\n#define ssGetInputPortSignal(S, ip) ((S)->portInfo.inputs[(ip)].signal.vect) /* (const void *) */\n\n/**\n * @brief ssGetInputPortRealSignal\n *\n * Get the address of a real, contiguous signal entering an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    ip            Index of the port whose address is required.\n * @return   A pointer (real_T *) to a real signal on the input port specified by the index ip.\n */\n#define ssGetInputPortRealSignal(S, ip) ((const real_T*)ssGetInputPortSignal(S, ip))\n\n/**\n * @brief ssGetInputPortSignalPtrs\n *\n * Get pointers to an input port's signal elements\n * @param    S             SimStruct representing an S-Function block.\n * @param    ip            Index of the input port\n * @return   Pointer to an array of signal element pointers for the specified input port ip.\n */\n#define ssGetInputPortSignalPtrs(S, ip) \\\n    ((S)->portInfo.inputs[(ip)].signal.ptrs) /* (InputPtrsType) */\n\n/**\n * @brief ssGetInputPortRealSignalPtrs\n *\n * Get pointers to signals of type double connected to an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    ip            Index of the input port\n * @return   Pointers to the elements of a signal of type double connected to the input port\n * specified by the index ip.\n */\n#define ssGetInputPortRealSignalPtrs(S, ip) ((InputRealPtrsType)ssGetInputPortSignalPtrs(S, ip))\n#endif /* __SS_DEBUG_FOR_SIM__ */\n#endif /*__!SS_SFCN_LEVEL_1_*/\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetOutputPortConnected\n *\n * Determine whether an output port is connected to a nonvirtual block\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Port whose connection status is needed.\n * @return   An int_T (1 or 0) or boolean_T (true or false) value indicating if this output port\n * signal is connected to a nonvirtual block.\n */\n#define ssGetOutputPortConnected(S, port) (S)->portInfo.outputs[(port)].connected /* (int_T) */\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetOutputPortBeingMerged\n *\n * Determine whether an output port of this block is connected to a Merge block\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port\n * @return   An int_T (1 or 0) or boolean_T (true or false) value indicating if this output port\n * signal is being merged with other signals.\n */\n#define ssGetOutputPortBeingMerged(S, port) \\\n    ((S)->portInfo.outputs[(port)].attributes.cToMergeBlk == 1U)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetOutputPortOptimOpts\n *\n * Get the reusability setting of the memory allocated to the output port of an S-function\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port\n * @return   One of the following values: SS_NOT_REUSABLE_AND_GLOBAL,SS_REUSABLE_AND_LOCAL,\n * SS_REUSABLE_AND_GLOBAL, SS_NOT_REUSABLE_AND_LOCAL\n */\n#define ssGetOutputPortOptimOpts(S, port) ((S)->portInfo.outputs[(port)].attributes.optimOpts)\n\n/**\n * @brief ssSetOutputPortOptimOpts\n *\n * Specify reusability of the memory allocated to the output port of an S-function\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port\n * @param    val           Permissible values: SS_NOT_REUSABLE_AND_GLOBAL,SS_REUSABLE_AND_LOCAL,\n * SS_REUSABLE_AND_GLOBAL, SS_NOT_REUSABLE_AND_LOCAL\n */\n#define ssSetOutputPortOptimOpts(S, port, val) \\\n    ((S)->portInfo.outputs[(port)].attributes.optimOpts = (val))\n\n#endif\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetOutputPortRealSignal\n *\n * Get a pointer to an output signal of type double (real_T)\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port\n * @return   A contiguous real_T vector of length equal to the width of the output port.\n */\n#define ssGetOutputPortRealSignal(S, port) \\\n    ((real_T*)(S)->portInfo.outputs[(port)].signalVect) /* (real_T*)       */\n#endif\n\n/**\n * @brief ssSetOutputPortOverwritesInputPort\n *\n * Specify whether an output port can share its memory buffer with an input port.\n * @param    S             SimStruct representing an S-Function block.\n * @param    pIdx          Index of the output port.\n * @return   val           Index of the input port.\n */\n#if SS_SFCN && SS_SIM\n#define ssSetOutputPortOverwritesInputPort(S, pIdx, val)                                     \\\n    {                                                                                        \\\n        int inpIdx = val;                                                                    \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_OUTPUT_OVERWRITE_INPUT_IDX, (pIdx), \\\n                                        (&inpIdx)) _ssSafelyCallGenericFcnEnd;               \\\n    }\n#endif\n\n/** @} */ /* end of SignalAccess */\n\n/** @} */ /* end of InputOutputPorts */\n\n\n/** @defgroup SampleTime Sample Time\n *  @{\n */\n/*======================================*\n * Sample Time *\n *======================================*/\n\n/**\n * @brief ssGetSampleTime\n *\n * Get one of an S-function's sample times\n * @param    S             SimStruct representing an S-Function block.\n * @param    sti           Index of the sample time to be returned.\n * @return   A time_T value indicating the sample time associated with the index sti.\n */\n#define ssGetSampleTime(S, sti) (S)->stInfo.sampleTimes[sti] /*   (time_T)      */\n\n/**\n * @brief ssSetSampleTime\n *\n * Set the period of a sample time\n * @param    S             SimStruct representing an S-Function block.\n * @param    sti           Index of the sample time to be set.\n * @param    t             Period of the sample time specified by sti.\n * @return   The time_T sample time value specified by period.\n */\n#define ssSetSampleTime(S, sti, t) (S)->stInfo.sampleTimes[sti] = (t)\n\n\n/**\n * @brief ssGetInputPortSampleTime\n *\n * Get the sample time of an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the input port whose sample time is required.\n * @return   The real_T value of the sample time of the input port specified by the index port.\n */\n#define ssGetInputPortSampleTime(S, port) \\\n    ((S)->portInfo.inputs[(port)].sampleTime) /* (real_T)      */\n\n/**\n * @brief ssSetInputPortSampleTime\n *\n * Specify the sample time of an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the input port whose sample time is being set.\n * @param    val           Sample period\n * @return   The real_T value of the sample time passed into the macro.\n */\n#define ssSetInputPortSampleTime(S, port, val) \\\n    (S)->portInfo.inputs[(port)].sampleTime = (val) /* (real_T)      */\n\n\n\n/**\n * @brief ssGetNumSampleTimes\n *\n * Get the number of sample times that a block has\n * @param    S             SimStruct representing an S-Function block.\n * @return   An int_T value indicating the total number of port-based and block-based sample times.\n * Returns -1 if the block has unspecified port-based sample times.\n */\n#define ssGetNumSampleTimes(S) (S)->sizes.numSampleTimes /*   (int_T)       */\n\n/**\n * @brief ssSetNumSampleTimes\n *\n * Specify the number of sample times that a block has\n * @param    S             SimStruct representing an S-Function block.\n * @param    nSampleTimes  Number of sample times that S has.\n * @return   The number of sample times specified by nSampleTimes, or -1 if PORT_BASED_SAMPLE_TIMES.\n */\n#define ssSetNumSampleTimes(S, nSampleTimes) (S)->sizes.numSampleTimes = (nSampleTimes)\n\n\n/**\n * @brief ssGetOffsetTime\n *\n * Get one of an S-function's sample time offsets.\n * @param    S             SimStruct representing an S-Function block.\n * @param    sti           Index of the sample time whose offset is to be set.\n * @return   A time_T value indicating the sample time offset.\n */\n#define ssGetOffsetTime(S, sti) (S)->stInfo.offsetTimes[sti] /*   (time_T)      */\n\n/**\n * @brief ssSetOffsetTime\n *\n * Set the offset time of a block\n * @param    S             SimStruct representing an S-Function block.\n * @param    sti           Index of the sample time whose offset is to be set.\n * @param    offset        Offset of the sample time specified by sti.\n * @return   The time_T offset value specified by offset.\n */\n#define ssSetOffsetTime(S, sti, t) (S)->stInfo.offsetTimes[sti] = (t)\n\n/**\n * @brief ssGetTNext\n *\n * Get the time of the next sample hit\n * @param    S             SimStruct representing an S-Function block.\n * @return   A value of type time_T.\n */\n#define ssGetTNext(S) (S)->stInfo.tNext /*   (time_T)      */\n\n/**\n * @brief ssSetTNext\n *\n * Set the time of the next sample hit\n * @param    S             SimStruct representing an S-Function block.\n * @param    tnext         Time of the next sample hit.\n */\n#define ssSetTNext(S, tnext) (S)->stInfo.tNext = (tnext)\n\n/**\n * @brief ssGetInputPortSampleTimeIndex\n *\n * Get the sample time index of an input port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the input port whose sample time index is to be returned.\n */\n#define ssGetInputPortSampleTimeIndex(S, port) \\\n    (S)->portInfo.inputs[(port)].sampleTimeIndex /* (int_T)       */\n\n/**\n * @brief ssGetOutputPortSampleTime\n *\n * Get the sample time of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port\n * @return   A real_T value indicating the sample time of the output port specified by the index\n * port.\n */\n#define ssGetOutputPortSampleTime(S, port) \\\n    ((S)->portInfo.outputs[(port)].sampleTime) /* (real_T)      */\n\n/**\n * @brief ssGetOutputPortSampleTimeIndex\n *\n * Get the sample time index of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of the output port\n * @return   An int_T value indicating the sample time index for the output port specified by the\n * index outputPortIdx. Returns CONSTANT_TID (-2) for constant (inf) sample times.\n */\n#define ssGetOutputPortSampleTimeIndex(S, port) \\\n    (S)->portInfo.outputs[(port)].sampleTimeIndex /* (int_T)       */\n\n\n\n/**\n * @brief ssGetPortBasedSampleTimeBlockIsTriggered\n *\n * Determine whether a block that uses port-based sample times resides in a triggered subsystem\n * @param    S             SimStruct representing an S-Function block.\n * @return   The Boolean value true if S uses port-based sample times and resides in a triggered\n * subsystem. Otherwise, returns false.\n */\n#define ssGetPortBasedSampleTimeBlockIsTriggered(S) \\\n    ((S)->stInfo.sampleTimes[0] == INHERITED_SAMPLE_TIME)\n\n/**\n * @brief ssSetDeepCopyCompliant\n *\n * Set compliant to data types with deep copy\n * @param    S             SimStruct representing an S-Function block.\n * @param    dtype         Logical value indicating whether to allow a datatype with deepcopy\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n\n#define ssSetDeepCopyCompliant(S, flag)                                            \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_DEEPCOPY_COMPLIANT, flag, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n\n#define ssSetDeepCopyCompliant(S, flag)\n\n#endif\n\n\n/**\n * @brief ssSetParameterTuningCompliance\n *\n * Specify sample time behavior and tunability for S-function blocks with port-based sample times\n * @param    S             SimStruct representing an S-Function block.\n * @param    flag          Logical value indicating whether to allow a sample time of Inf for\n * ports in the S-function.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n\n#define ssSetParameterTuningCompliance(S, flag)                                       \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_PRM_TUNING_COMPLIANCE, flag, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n\n#define ssSetParameterTuningCompliance(S, flag)\n\n#endif\n\n\n/**\n * @brief ssGetParameterTuningCompliance\n *\n * Get the sample time behavior and tunability for S-function blocks with port-based sample times\n * @param    S             SimStruct representing an S-Function block.\n */\n#if SS_SFCN_FOR_SIM\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern boolean_T ssGetParameterTuningCompliance(SimStruct* S);\n#ifdef __cplusplus\n}\n#endif\n#endif\n\n\n/**\n * @brief ssIsContinuousTask\n *\n * Determine whether a task is continuous\n * @param    S             SimStruct representing an S-Function block.\n * @param    tid           Task ID\n * @return   The Boolean value true when the simulation is executing the continuous task. Otherwise,\n * returns false.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#if defined(RSIM_WITH_SOLVER_MULTITASKING) && RSIM_WITH_SOLVER_MULTITASKING\n#if SS_TID01EQ_EQUAL_ONE\n#define ssIsContinuousTask(S, tid) ((tid) <= 1)\n#else\n#define ssIsContinuousTask(S, tid) ((tid) == 0)\n#endif\n#else\n/*\n * During simulation, tid passed to S-functions is always 0 even in\n * multitasking mode\n */\n#define ssIsContinuousTask(S, tid) (((tid) == 0) && (S)->mdlInfo->sampleHits[0])\n#endif\n#elif SS_TID01EQ_EQUAL_ONE\n#define ssIsContinuousTask(S, tid) ((tid) <= 1)\n#else\n#define ssIsContinuousTask(S, tid) ((tid) == 0)\n#endif\n\n/**\n * @brief ssIsSampleHit\n *\n * Determine whether the sample time is hit\n * @param    S             SimStruct representing an S-Function block.\n * @param    sti           Index of the sample time\n * @param    tid           Task ID\n * @return   The Boolean value true when the simulation is executing in the task represented\n * by task ID tid. Otherwise, returns false.\n */\n#if SS_MULTITASKING || (defined(RSIM_WITH_SOLVER_MULTITASKING) && RSIM_WITH_SOLVER_MULTITASKING)\n\n#define ssIsSampleHit(S, sti, tid) \\\n    (!ssIsTIDInStInfo(S, sti) || (ssGetSampleTimeTaskID(S, sti) == (tid)))\n\n#else\n\n#define ssIsSampleHit(S, sti, tid) \\\n    (((tid) != CONSTANT_TID) &&    \\\n     (!ssIsTIDInStInfo(S, sti) ||  \\\n      (ssIsMajorTimeStep(S) && (ssGetSampleHitPtr(S))[ssGetSampleTimeTaskID(S, sti)])))\n\n#endif\n\n\n/**\n * @brief ssIsSpecialSampleHit\n *\n * Determine whether the sample time is hit\n * @param    S             SimStruct representing an S-Function block.\n * @param    my_sti        Index of the sample time\n * @param    promoted_sti  Index of the sample time\n * @param    tid           Task ID\n * @return   The Boolean value true if a sample hit has occurred at sti1 and a sample hit has\n * also occurred at sti2 in the same time step. Otherwise, returns false.\n */\n#if SS_MULTITASKING || SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n/*\n * The ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) macro will be\n * \"true\" if the block is executing in a major time step in context of a\n * promoted sample time (promoted_sti) and we have a sample hit in the\n * original task (my_sti) which translates to:\n *    1) tid == tid_for(promoted_sti). It is required that this macro be\n *       invoked with in a ssIsSampleHit(S,promoted_sti,tid) to guarantee this\n *       case.\n *    2) Must be major time step.\n *    3) my_sti (the block's sti) has a sample hit at the current point in\n *       time.\n * Valid usage in an S-function would be:\n *\tif (ssIsSampleHit(S, promoted_sti)) {\n *        if (ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid)) {\n *        }\n *      }\n * providing promoted_sti is not the continuous task. If promoted_sti is\n * the continuous task, then the following must be used:\n *\tif (ssIsContinuousTask(S, promoted_sti)) {\n *        if (ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid)) {\n *        }\n *      }\n *\n * Note, failure to wrap ssIsSpecialSampleHit() within ssIsSampleHit() or\n * ssIsContinuousTask will result in unexpected behavior.\n */\n#define ssIsSampleHitInTask(S, my_sti, tid) \\\n    (ssGetPerTaskSampleHitsPtr(             \\\n        S))[ssGetSampleTimeTaskID(S, my_sti) + ((tid) * (ssGetNumRootSampleTimes(S)))]\n\n#define ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) \\\n    (ssIsMajorTimeStep(S) && ssIsSampleHitInTask(S, my_sti, ssGetSampleTimeTaskID(S, promoted_sti)))\n#else\n#define ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) ssIsSampleHit(S, my_sti, tid)\n#endif\n\n/**\n * @brief ssSampleAndOffsetAreTriggered\n *\n * Determine whether a sample time and offset value pair indicate a triggered sample time\n * @param    st            The sample time.\n * @param    ot            The offset time.\n * @return   The Boolean value true if both st and ot are equal to INHERITED_SAMPLE_TIME. Otherwise,\n * returns false.\n */\n#define ssSampleAndOffsetAreTriggered(st, ot) \\\n    ((st == INHERITED_SAMPLE_TIME) && (ot == INHERITED_SAMPLE_TIME))\n\n/**\n * @brief ssSampleAndOffsetAreTriggeredOrAsync\n *\n * Determine whether a sample time and offset value pair indicate a triggered or asynchronous sample\n * time\n * @param    st            The sample time.\n * @param    ot            The offset time.\n * @return   The Boolean value true if st is equal to INHERITED_SAMPLE_TIME (-1) and ot is either\n * INHERITED_SAMPLE_TIME (-1) or any other negative integer.\n */\n#define ssSampleAndOffsetAreTriggeredOrAsync(st, ot) \\\n    ((st == INHERITED_SAMPLE_TIME) && (ot <= INHERITED_SAMPLE_TIME))\n\n/**\n * @brief ssSetControllableSampleTime\n *\n * Register controllable sample time in a block\n * @param    S          SimStruct representing an S-Function block\n * @param    sti        Index of the contollable sample time in the block.\n * @param    base       Sample time resolution of the block. This is the smallest time step that the\n * block can take Events of the block can be set to occur at integral multiples of resolution.\n *\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetControllableSampleTime(S, sti, base)                                                \\\n    {                                                                                            \\\n        real_T tmp = base;                                                                       \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_CONTROLLABLE_SAMPLE_TIME, (int)sti, &tmp) \\\n            _ssSafelyCallGenericFcnEnd;                                                          \\\n    }\n#else\n#define ssSetControllableSampleTime(S, sti, base)\n#endif\n\n\n/** @} */ /* end of SampleTime */\n\n/** @defgroup DataType Data Type\n *  @{\n */\n\n/*======================================*\n * Data Type *\n *======================================*/\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssRegisterDataType\n *\n * Register a custom data type\n * @param    S             SimStruct representing an S-Function block.\n * @param    name          Name of the custom data type.\n * @return   The DTypeId associated with the registered data type.\n *  Otherwise, reports an error and returns INVALID_DTYPE_ID.\n */\n#if SS_SIM\n#define ssRegisterDataType(S, name)                                       \\\n    (((S)->regDataType.registerFcn != NULL)                               \\\n         ? (*(S)->regDataType.registerFcn)((S)->regDataType.arg1, (name)) \\\n         : (INVALID_DTYPE_ID))\n#else\n#define ssRegisterDataType(S, name) ssRegisterDataType_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssSetDataTypeSize\n *\n * Set the size of a custom data type\n * @param    S             SimStruct representing an S-Function block.\n * @param    id            ID of the data type.\n * @param    size          Size of the custom data type in bytes\n * @return   1 (true) if successful. Otherwise, returns 0 (false).\n */\n#if SS_SIM\n#define ssSetDataTypeSize(S, id, size)                                         \\\n    (((S)->regDataType.setSizeFcn != NULL)                                     \\\n         ? (*(S)->regDataType.setSizeFcn)((S)->regDataType.arg1, (id), (size)) \\\n         : (0))\n#else\n#define ssSetDataTypeSize(S, id, size) ssSetDataTypeSize_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssGetDataTypeSize\n *\n * Get the size of a custom data type\n * @param    S             SimStruct representing an S-Function block.\n * @param    id            ID of the data type.\n * @return   An int_T value indicating the size of the data type specified by id, if id is valid and\n * the data type's size has been set. Otherwise, returns INVALID_DTYPE_SIZE and reports an error.\n */\n#if SS_SIM\n#define ssGetDataTypeSize(S, id)                                       \\\n    (((S)->regDataType.getSizeFcn != NULL)                             \\\n         ? (*(S)->regDataType.getSizeFcn)((S)->regDataType.arg1, (id)) \\\n         : (INVALID_DTYPE_SIZE))\n#else\n#define ssGetDataTypeSize(S, id) ssGetDataTypeSize_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssGetNumDataTypes\n *\n * Get number of data types registered for this simulation, including build-in types\n * @param    S             SimStruct representing an S-Function block.\n * @return   An int_T value indicating the number of registered data types.\n */\n#if SS_SIM\n#define ssGetNumDataTypes(S) (dtaGetNumDataTypes(ssGetDataTypeAccess(S)))\n#else\n#define ssGetNumDataTypes(S) ssGetNumDataTypes_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssSetDataTypeZero\n *\n * Set the zero representation of a data type\n * @param    S             SimStruct representing an S-Function block.\n * @param    id            ID of the data type.\n * @param    zero          Zero representation of the data type specified by id.\n * @return   1 (true) if successful. Otherwise, returns 0 (false) and reports an error.\n */\n#if SS_SIM\n#define ssSetDataTypeZero(S, id, zero)                                         \\\n    (((S)->regDataType.setZeroFcn != NULL)                                     \\\n         ? (*(S)->regDataType.setZeroFcn)((S)->regDataType.arg1, (id), (zero)) \\\n         : (0))\n#else\n#define ssSetDataTypeZero(S, id, zero) ssSetDataTypeZero_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssGetDataTypeZero\n *\n * Get the zero representation of a data type\n * @param    S             SimStruct representing an S-Function block.\n * @param    id            ID of the data type.\n * @return   A pointer (void *) to the zero representation of the data type specified by id,\n * if id is valid and the data type's size has been set. Otherwise, returns NULL and reports an\n * error.\n */\n#if SS_SIM\n#define ssGetDataTypeZero(S, id)                                       \\\n    (((S)->regDataType.getZeroFcn != NULL)                             \\\n         ? (*(S)->regDataType.getZeroFcn)((S)->regDataType.arg1, (id)) \\\n         : (NULL))\n#else\n#define ssGetDataTypeZero(S, id) ssGetDataTypeZero_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssGetDataTypeId\n *\n * Get the ID of a data type\n * @param    S             SimStruct representing an S-Function block.\n * @param    name          Name of a data type\n * @return   The ID of the custom data type specified by name if name is a registered type name.\n * Otherwise, returns INVALID_DTYPE_ID and reports an error.\n */\n#if SS_SIM\n#define ssGetDataTypeId(S, name)                                       \\\n    (((S)->regDataType.getIdFcn != NULL)                               \\\n         ? (*(S)->regDataType.getIdFcn)((S)->regDataType.arg1, (name)) \\\n         : (INVALID_DTYPE_ID))\n#else\n#define ssGetDataTypeId(S, name) ssGetDataTypeId_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssGetDataTypeName\n *\n * Get the name of a data type\n * @param    S             SimStruct representing an S-Function block.\n * @param    id            ID of a data type.\n * @return   The name of the data type specified by id, if id is valid.\n * Otherwise, returns NULL and reports an error.\n */\n#if SS_SIM\n#define ssGetDataTypeName(S, id)                                       \\\n    (((S)->regDataType.getNameFcn != NULL)                             \\\n         ? (*(S)->regDataType.getNameFcn)((S)->regDataType.arg1, (id)) \\\n         : (NULL))\n#else\n#define ssGetDataTypeName(S, id) ssGetDataTypeName_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssGetDataTypeIdAliasedThruTo\n *\n * Get the base data type associated with a data type alias\n * @param    S             SimStruct representing an S-Function block.\n * @param    id            ID of the data type alias\n * @return   The base data type ID associated with the data type alias specified by id.\n * Otherwise, returns NULL and reports an error.\n */\n#if SS_SIM\n#define ssGetDataTypeIdAliasedThruTo(S, id) \\\n    (dtaGetDataTypeIdAliasedThruTo(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetDataTypeIdAliasedThruTo(S, id) ssGetDataTypeIdAliasedThruTo_cannot_be_used_in_RTW\n#endif\n\n#endif /* !SS_SFCN_LEVEL_1 */\n\n\n/**\n * @brief ssGetOutputPortDataType\n *\n * Get the data type of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port\n * @return   The data type ID of the output port specified by the index port.\n * Returns DYNAMICALLY_TYPED if the output port inherits its data type.\n */\n#define ssGetOutputPortDataType(S, port) \\\n    (S)->portInfo.outputs[(port)].dataTypeId /* (DTypeId)     */\n\n/**\n * @brief ssSetOutputPortDataType\n *\n * Set the data type of an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port\n * @param    dTypeId       ID of the data type accepted by port.\n * @return   The data type ID specified by id. Returns -1 if id is DYNAMICALLY_TYPED.\n */\n#define ssSetOutputPortDataType(S, port, dTypeId) \\\n    ((S)->portInfo.outputs[(port)].dataTypeId = (dTypeId))\n\n/**\n * @brief ssGetOutputPortSignal\n *\n * Get the vector of signal elements emitted by an output port\n * @param    S             SimStruct representing an S-Function block.\n * @param    port          Index of an output port\n * @return   A pointer (void *) to the vector of signal elements output at the port specified by the\n * index port.\n */\n#define ssGetOutputPortSignal(S, port) \\\n    (S)->portInfo.outputs[(port)].signalVect /* (void *)        */\n\n/**\n * @brief ssGetSFcnParamDataType\n *\n * Get the data type of a parameter for an S-Function block\n * @param    S             SimStruct representing an S-Function block.\n * @param    index         Index of the target parameter.\n * @param    result        ID of the parameter data type.\n */\n#define ssGetSFcnParamDataType(S, index, result)                                          \\\n    {                                                                                     \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_PARAM_DATATYPE, (index), (result)) \\\n            _ssSafelyCallGenericFcnEnd;                                                   \\\n    }\n\n/** @} */ /* end of DataType */\n\n/** @defgroup SimulinkString Simulink String\n *  @{\n */\n\n/*======================================*\n * Simulink String *\n *======================================*/\n\n#if !SS_SFCN_LEVEL_1\n\n/**\n * @brief ssRegisterStringDataType\n *\n * Register string data type\n * @param    S               SimStruct representing an S-Function block.\n * @param    maxStringLength Maximum length of string.\n * @return   The DTypeId associated with the registered data type.\n *  Otherwise, reports an error and returns INVALID_DTYPE_ID.\n */\n#if SS_SIM\n#define ssRegisterStringDataType(S, maxStringLength)                                            \\\n    (_ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REGISTER_STRING_TYPE, (int_T)(maxStringLength), \\\n                                     NULL) _ssSafelyCallGenericFcnEnd)\n#else\n#define ssRegisterStringDataType(S, maxStringLength) ssRegisterStringDataType_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssIsStringDataType\n *\n * Determine if data type is string\n * @param    S         SimStruct representing an S-Function block.\n * @param    ID        ID of data type.\n * @return   The Boolean value true if the data type is a string. Otherwise, returns false.\n */\n#if SS_SIM\n#define ssIsStringDataType(S, ID)                                               \\\n    ((bool)_ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_IS_STRING_TYPE, ID, NULL) \\\n         _ssSafelyCallGenericFcnEnd)\n#else\n#define ssIsStringDataType(S, ID) ssIsStringDataType_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssGetStringDataTypeMaxLength\n *\n * Get maximum length of string data type\n * @param    S         SimStruct representing an S-Function block.\n * @param    ID        ID of data type.\n * @return   A value of type size_T, indicating the maximum length of the string.\n *  Or 0, if the string has no maximum length.\n */\n#if SS_SIM\n#define ssGetStringDataTypeMaxLength(S, ID)                                                   \\\n    ((size_t)_ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_STRING_TYPE_MAX_LENGTH, ID, NULL) \\\n         _ssSafelyCallGenericFcnEnd)\n#else\n#define ssGetStringDataTypeMaxLength(S, ID) ssGetStringDataTypeMaxLength_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief _ssReadInputStringFcn\n *\n * Read C string from input port (implementation of ssReadInputString)\n * @param    S         SimStruct representing an S-Function block.\n * @param    portIdx   Input port from which to read string.\n * @return   Null-terminated C string read from input port.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern const char_T* _ssReadInputStringFcn(SimStruct* S, int portIdx);\n#ifdef __cplusplus\n}\n#endif\n\n/**\n * @brief ssReadInputString\n *\n * Read C string from input port\n * @param    S         SimStruct representing an S-Function block.\n * @param    portIdx   Input port from which to read string.\n * @return   Null-terminated C string read from input port.\n */\n#if SS_SIM\n#define ssReadInputString(S, portIdx) _ssReadInputStringFcn(S, portIdx)\n#else\n#define ssReadInputString(S, ID) ssReadInputString_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssGetInputStringLength\n *\n * Get length of string from input port\n * @param    S         SimStruct representing an S-Function block.\n * @param    portIdx   Input port from which to read string.\n * @return   A value of type size_T indicating the length of the input string.\n */\n#if SS_SIM\n#define ssGetInputStringLength(S, portIdx)                                                      \\\n    ((size_t)_ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_INPUT_STRING_LENGTH, portIdx, NULL) \\\n         _ssSafelyCallGenericFcnEnd)\n#else\n#define ssGetInputStringLength(S, ID) ssGetInputStringLength_cannot_be_used_in_RTW\n#endif\n\n/**\n * @brief ssWriteOutputString\n *\n * Write C string to output port\n * @param    S         SimStruct representing an S-Function block.\n * @param    portIdx   Port to which to write string.\n * @param    str       String to write to output port.\n */\n#if SS_SIM\n#define ssWriteOutputString(S, portIdx, str)                                                \\\n    {                                                                                       \\\n        const char_T* s = str;                                                              \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_WRITE_STRING_OUTPUT, portIdx, (void*)&s) \\\n            _ssSafelyCallGenericFcnEnd;                                                     \\\n    }\n#else\n#define ssWriteOutputString(S, ID) ssWriteOutputString_cannot_be_used_in_RTW\n#endif\n\n#endif /* !SS_SFCN_LEVEL_1 */\n\n/** @} */ /* end of SimulinkString */\n\n/** @defgroup BlockDialogParam  Block Dialog Parameters\n *  @{\n */\n\n/*======================================*\n * Block Dialog Parameters *\n *======================================*/\n\n/**\n * @brief ssGetDTypeIdFromMxArray\n *\n * Get the data type of an S-function parameter\n * @param    m         MATLAB array representing the parameter\n * @return   The data type ID of an S-function parameter represented by a MATLAB array.\n * Returns INVALID_DTYPE_ID if the MATLAB data type does not map to any built-in Simulink data type\n * ID.\n */\n#if SS_SFCN_FOR_SIM\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern DTypeId ssGetDTypeIdFromMxArray(const mxArray* m);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n\n\n/**\n * @brief ssGetNumSFcnParams\n *\n * Get the number of parameters that an S-Function block expects\n * @param    S        SimStruct representing an S-Function block.\n * @return   An int_T value indicating the number of expected S-function parameters\n */\n#define ssGetNumSFcnParams(S) (S)->sizes.numSFcnParams /*   (int_T)       */\n\n/**\n * @brief ssSetNumSFcnParams\n *\n * Specify the number of parameters that an S-Function block has\n * @param    S             SimStruct representing an S-Function block.\n * @param    nSFcnParams   Number of parameters that S has.\n * @return   The number of parameters specified in nSFcnParams.\n */\n#define ssSetNumSFcnParams(S, nSFcnParams) (S)->sizes.numSFcnParams = (nSFcnParams)\n\n/**\n * @brief ssGetSFcnParam\n *\n * Get a parameter of an S-Function block\n * @param    S             SimStruct representing an S-Function block.\n * @param    index         Index of the parameter to be returned\n * @return   A pointer (const mxArray *) to the value of the S-function parameter specified by\n * index.\n */\n#define ssGetSFcnParam(S, index)                                     \\\n    ((const mxArray*)_ssGetSFcnParam(S, index)) /* (const mxArray *) \\\n                                                 */\n\n\n/**\n * @brief ssGetSFcnParamsCount\n *\n * Get the number of block dialog parameters that an S-Function block has\n * @param    S             SimStruct representing an S-Function block.\n * @return   An int_T value\n */\n#define ssGetSFcnParamsCount(S) (S)->sfcnParams.dlgNum /*   (int_T)       */\n\n\n\n/**\n * @brief ssSetSFcnParamTunable\n *\n * Make a block parameter tunable\n * @param    S             SimStruct representing an S-Function block.\n * @param    index         Index of the parameter\n * @param    val           Valid values are SS_PRM_TUNABLE (true / tunable),\n * SS_PRM_NOT_TUNABLE (false / not tunable), or SS_PRM_SIM_ONLY_TUNABLE (tunable only during\n * simulation).\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetSFcnParamTunable(S, index, val)                                                      \\\n    (S)->sfcnParams.dlgAttribs[index] =                                                           \\\n        (((ssParamTunability)val) == SS_PRM_TUNABLE)                                              \\\n            ? (((S)->sfcnParams.dlgAttribs[index] & SFCNPARAM_CLEAR_TUNABLE) | SFCNPARAM_TUNABLE) \\\n            : ((((ssParamTunability)val) == SS_PRM_SIM_ONLY_TUNABLE)                              \\\n                   ? (((S)->sfcnParams.dlgAttribs[index] & SFCNPARAM_CLEAR_TUNABLE) |             \\\n                      SFCNPARAM_SIMONLY_TUNABLE)                                                  \\\n                   : (((S)->sfcnParams.dlgAttribs[index] & SFCNPARAM_CLEAR_TUNABLE) |             \\\n                      SFCNPARAM_NOT_TUNABLE))\n#else                                            /* RT or NRT */\n#define ssSetSFcnParamTunable(S, index, boolval) /* do nothing */\n#endif\n\n/** @} */ /* end of BlockDialogParam */\n\n/** @defgroup FcnCallSubsystem  Function-Call Subsystems\n *  @{\n */\n\n/*======================================*\n * Function-Call Subsystems *\n *======================================*/\n\n#if SS_RT\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern int_T rt_CallSys(SimStruct* S, int_T element, int_T tid);\n#ifdef __cplusplus\n}\n#endif\n#define ssCallSystemWithTid(S, element, tid) \\\n    (((S)->callSys.fcns[(element)] != NULL) ? rt_CallSys((S), (element), (tid)) : 1)\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern int_T rt_EnableSys(SimStruct* S, int_T element, int_T tid);\n#ifdef __cplusplus\n}\n#endif\n#define ssEnableSystemWithTid(S, element, tid)                                 \\\n    (((S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)] != NULL ||   \\\n      (S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)] != NULL) \\\n         ? rt_EnableSys((S), (element), (tid))                                 \\\n         : 1)\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern int_T rt_DisableSys(SimStruct* S, int_T element, int_T tid);\n#ifdef __cplusplus\n}\n#endif\n\n#define ssDisableSystemWithTid(S, element, tid)                                \\\n    (((S)->callSys.fcns[3 * ssGetOutputPortWidth((S), 0) + (element)] != NULL) \\\n         ? rt_DisableSys((S), (element), (tid))                                \\\n         : 1)\n#else /* #if SS_RT */\n/**\n * @brief ssCallSystemWithTid\n *\n * Call the update and outputs methods of a function-call subsystem\n * @param    S         SimStruct representing an S-Function block.\n * @param    element   Index of the output port element corresponding to the function-call\n * subsystem.\n * @param    tid       Task ID.\n */\n#define ssCallSystemWithTid(S, element, tid)                                            \\\n    (((S)->callSys.fcns[(element)] != NULL)                                             \\\n         ? ((*(S)->callSys.fcns[(element)])((S)->callSys.args1[(element)],              \\\n                                            (S)->callSys.args2[(element)], (tid))       \\\n                ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\n                : (0))                                                                  \\\n         : (1))\n\n#if defined(RSIM_WITH_SL_SOLVER)\n#define ssEnableSystemWithTid(S, element, tid)                                           \\\n    ((((S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)] != NULL)              \\\n          ? ((*(S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)])(             \\\n                 (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\n                 ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\n                 : (0))                                                                  \\\n          : (1)) &                                                                       \\\n     (((S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)] != NULL)          \\\n          ? ((*(S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)])(         \\\n                 (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\n                 ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\n                 : (0))                                                                  \\\n          : (1)))\n\n#define ssDisableSystemWithTid(S, element, tid)                                         \\\n    (((S)->callSys.fcns[3 * ssGetOutputPortWidth((S), 0) + (element)] != NULL)          \\\n         ? ((*(S)->callSys.fcns[3 * ssGetOutputPortWidth((S), 0) + (element)])(         \\\n                (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\n                ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\n                : (0))                                                                  \\\n         : (1))\n#else /* #if defined(RSIM_WITH_SL_SOLVER) */\n\n/**\n * @brief ssEnableSystemWithTid\n *\n * Enable a function-call subsystem connected to this S-function\n * @param    S         SimStruct representing an S-Function block.\n * @param    element   Index of the output port element corresponding to the function-call\n * subsystem.\n * @param    tid       Task ID.\n */\n#define ssEnableSystemWithTid(S, element, tid)                                          \\\n    (((S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)] != NULL)              \\\n         ? ((*(S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)])(             \\\n                (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\n                ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\n                : (0))                                                                  \\\n         : (1))\n\n/**\n * @brief ssDisableSystemWithTid\n *\n * Disable a function-call subsystem connected to this S-function block\n * @param    S         SimStruct representing an S-Function block.\n * @param    element   Index of the output port element corresponding to the function-call\n * subsystem.\n * @param    tid       Task ID.\n */\n#define ssDisableSystemWithTid(S, element, tid)                                         \\\n    (((S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)] != NULL)          \\\n         ? ((*(S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)])(         \\\n                (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\n                ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\n                : (0))                                                                  \\\n         : (1))\n#endif /* #if defined(RSIM_WITH_SL_SOLVER) */\n#endif /* #if SS_RT */\n\n\n/**\n * @brief ssGetCallSystemNumFcnCallDestinations\n *\n * Get the number of function-call destinations.\n * @param    S         SimStruct representing an S-Function block.\n * @param    elemIdx   The zero-based element index that is output on the first output port\n * @return   int_T\n */\n#define ssGetCallSystemNumFcnCallDestinations(S, elemIdx) \\\n    _ssGetCallSystemNumFcnCallDestinations(S, elemIdx)\n\n\n/**\n * @brief ssGetExplicitFCSSCtrl\n *\n * Determine whether this S-function explicitly enables and disables the function-call subsystems\n * that it invokes\n * @param    S         SimStruct representing an S-Function block.\n * @return   The uint_T 1 if S explicitly enables or disables the function-control subsystem that it\n * invokes. Otherwise, returns 0.\n */\n#define ssGetExplicitFCSSCtrl(S) (S)->sizes.flags.explicitFCSSCtrl /*   (unsigned int_T: 1) */\n\n/**\n * @brief ssSetExplicitFCSSCtrl\n *\n * Specify whether this S-function explicitly enables and disables the function-call subsystem that\n * it calls\n * @param    S         SimStruct representing an S-Function block.\n * @param    n         1 if this S-function explicitly enables and disables the function-call\n * subsystems it enables\n */\n#define ssSetExplicitFCSSCtrl(S, n) (S)->sizes.flags.explicitFCSSCtrl = (n)\n\n/** @} */ /* end of FcnCallSubsystem */\n\n/** @defgroup ModelReference  Model Reference\n *  @{\n */\n\n/*======================================*\n * Model Reference *\n *======================================*/\n/**\n * @brief ssRTWGenIsModelReferenceRTWTarget\n *\n * Determine if the model reference Simulink Coder target is generating\n * @param    S           SimStruct representing an S-Function block.\n * @return   The Boolean value true if the model reference Simulink Coder target is building.\n * Returns false if the model reference simulation target is building.\n */\n#if SS_SIM\n#define ssRTWGenIsModelReferenceRTWTarget(S) \\\n    (ssGetSimMode(S) == SS_SIMMODE_RTWGEN && \\\n     ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_MODELREFERENCE_RTW_TARGET))\n#else\n#define ssRTWGenIsModelReferenceRTWTarget(S) (false)\n#endif\n\n/**\n * @brief ssRTWGenIsModelReferenceSimTarget\n *\n * Determine if the model reference simulation target is generating\n * @param    S           SimStruct representing an S-Function block.\n * @return   The Boolean value true if the model reference Simulation target is building. Returns\n * false if the model reference Simulink Coder target is building.\n */\n#if SS_SIM\n#define ssRTWGenIsModelReferenceSimTarget(S) \\\n    (ssGetSimMode(S) == SS_SIMMODE_RTWGEN && \\\n     ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_MODELREFERENCE_SIM_TARGET))\n#else\n#define ssRTWGenIsModelReferenceSimTarget(S) (false)\n#endif\n\n\n\n/**\n * @brief ssSetModelReferenceNormalModeSupport\n *\n * Specify if S-function can be used in referenced model simulating in normal mode\n * @param    S    SimStruct representing an S-Function block.\n * @param    n    Flag for normal mode simulation support when the S-Function block is used in a\n * referenced model.\n */\n#define ssSetModelReferenceNormalModeSupport(S, n) (S)->sizes.flags.modelRefNormalModeSupport = (n)\n\n/**\n * @brief ssSetModelReferenceSampleTimeDefaultInheritance\n *\n * Specify that a referenced model containing this S-function can inherit its sample time from its\n * parent model\n * @param    S    SimStruct representing an S-Function block.\n */\n#define ssSetModelReferenceSampleTimeDefaultInheritance(S) \\\n    (S)->sizes.flags.modelRefTsInhSupLevel = USE_DEFAULT_FOR_DISCRETE_INHERITANCE\n\n/**\n * @brief ssSetModelReferenceSampleTimeDisallowInheritance\n *\n * Specify that the use of this S-function in a referenced model prevents the referenced model from\n * inheriting its sample time from its parent model\n * @param    S    SimStruct representing an S-Function block.\n */\n#define ssSetModelReferenceSampleTimeDisallowInheritance(S) \\\n    (S)->sizes.flags.modelRefTsInhSupLevel = DISALLOW_SAMPLE_TIME_INHERITANCE\n\n/**\n * @brief ssSetModelReferenceSampleTimeInheritanceRule\n *\n * Specify whether use of this S-function in a referenced model prevents the referenced model\n * from inheriting its sample time from its parent model\n * @param    S    SimStruct representing an S-Function block.\n * @param    n    Rule for allowing referenced models containing this S-function to inherit\n * their sample times from the parent model.\n */\n#define ssSetModelReferenceSampleTimeInheritanceRule(S, n) \\\n    (S)->sizes.flags.modelRefTsInhSupLevel = (n)\n\n\n/** @} */ /* end of ModelReference */\n\n/** @defgroup Buses  Buses\n *  @{\n */\n\n/*======================================*\n * Buses *\n *======================================*/\n\n#if SS_SIM\n#define ssGetDataTypeAccess(S) ((S)->mdlInfo->dataTypeAccess)\n#else\n#define ssGetDataTypeAccess(S) ssGetDataTypeAccess_cannot_be_used_in_RTW\n#endif\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n/**\n * @brief ssGetBusElementComplexSignal\n *\n * Get the signal complexity for a bus element\n * @param    S           SimStruct representing an S-Function block.\n * @param    busTypeID   The bus data type identifier that represents the bus signal\n * @param    elemIdx     The zero-based bus element index\n * @return   CSignal_T\n */\n#define ssGetBusElementComplexSignal(S, busTypeID, elemIdx) \\\n    (dtaGetDataTypeElementSignalType(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\n\n/**\n * @brief ssGetBusElementDataType\n *\n * Get the data type identifier for a bus element\n * @param    S           SimStruct representing an S-Function block.\n * @param    busTypeID   The bus data type identifier that represents the bus signal\n * @param    elemIdx     The zero-based bus element index\n * @return   int_T\n */\n#define ssGetBusElementDataType(S, busTypeID, elemIdx) \\\n    (dtaGetDataTypeElementDataType(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\n\n/**\n * @brief ssGetBusElementDimensions\n *\n * Get the dimensions of a bus element\n * @param    S           SimStruct representing an S-Function block.\n * @param    busTypeID   The bus data type identifier that represents the bus signal\n * @param    elemIdx     The zero-based bus element index\n * @return   const int_T*\n */\n#define ssGetBusElementDimensions(S, busTypeID, elemIdx) \\\n    (dtaGetDataTypeElementDimensions(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\n\n\n/**\n * @brief ssGetBusElementName\n *\n * Get the name of a bus element\n * @param    S           SimStruct representing an S-Function block.\n * @param    busTypeID   The bus data type identifier that represents the bus signal\n * @param    elemIdx     The zero-based bus element index\n * @return   const char*\n */\n#define ssGetBusElementName(S, busTypeID, elemIdx) \\\n    (dtaGetDataTypeElementName(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\n\n/**\n * @brief ssGetBusElementNumDimensions\n *\n * Get the number of dimensions for a bus element\n * @param    S           SimStruct representing an S-Function block.\n * @param    busTypeID   The bus data type identifier that represents the bus signal\n * @param    elemIdx     The zero-based bus element index\n * @return   int_T\n */\n#define ssGetBusElementNumDimensions(S, busTypeID, elemIdx)                                \\\n    (dtaGetDataTypeElementNumDimensions(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), \\\n                                        (elemIdx)))\n\n/**\n * @brief ssGetBusElementOffset\n *\n * Get the offset from the start of the bus data type to a bus element\n * @param    S           SimStruct representing an S-Function block.\n * @param    busTypeID   The bus data type identifier that represents the bus signal\n * @param    elemIdx     The zero-based bus element index\n * @return   int_T\n */\n#define ssGetBusElementOffset(S, busTypeID, elemIdx) \\\n    (dtaGetDataTypeElementOffset(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\n\n\n/**\n * @brief ssGetNumBusElements\n *\n * Get the number of elements in a bus signal\n * @param    S           SimStruct representing an S-Function block.\n * @param    busTypeID   The bus data type identifier that represents the bus signal\n * @return   int_T\n */\n#define ssGetNumBusElements(S, busTypeID) \\\n    (dtaGetDataTypeNumElements(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID)))\n\n\n/**\n * @brief ssGetSFcnParamName\n *\n * Get the value of a block parameter for an S-function block\n * @param    S           SimStruct representing an S-Function block.\n * @param    pIdx        The zero-based index into the S-function parameters\n * @param    result      Value of the parameter specified in the block dialog box\n */\n#define ssGetSFcnParamName(S, pIdx, result)                                      \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_PARAM_NAME, pIdx, (result)) \\\n        _ssSafelyCallGenericFcnEnd\n\n\n/**\n * @brief ssIsDataTypeABus\n *\n * Determine whether a data type identifier represents a bus signal\n * @param    S           SimStruct representing an S-Function block.\n * @param    typeID      The data type identifier that represents a signal\n * @return   int_T       1 for bus, 0 for non-bus, and -1 when error occurs\n */\n#define ssIsDataTypeABus(S, typeID) \\\n    (dtaGetDataTypeIsBus(ssGetDataTypeAccess(S), ssGetPath(S), typeID))\n\n/**\n * @brief ssSetBusInputAsStruct\n *\n * Specify whether to convert the input bus signal for an S-function from virtual to nonvirtual\n * @param    S           SimStruct representing an S-Function block.\n * @param    pIdx        The zero-based index of the input port of the S-function block\n * @param    value       True, if the input signal is a virtual bus and should be converted to a\n * nonvirtual bus; false otherwise\n */\n#define ssSetBusInputAsStruct(S, pIdx, value)                                             \\\n    {                                                                                     \\\n        boolean_T tmp = value;                                                            \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BUS_INPUT_AS_STRUCT, pIdx, &tmp) \\\n            _ssSafelyCallGenericFcnEnd;                                                   \\\n    }\n/**\n * @brief ssSetBusOutputAsStruct\n *\n * Specify whether the output bus signal from an S-function must be virtual or nonvirtual\n * @param    S           SimStruct representing an S-Function block.\n * @param    pIdx        The zero-based index of the output port of the S-function block\n * @param    value       True, if the output signal is a nonvirtual bus and should be converted to a\n * virtual bus; false otherwise\n */\n#define ssSetBusOutputAsStruct(S, pIdx, value)                                             \\\n    {                                                                                      \\\n        boolean_T tmp = value;                                                             \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BUS_OUTPUT_AS_STRUCT, pIdx, &tmp) \\\n            _ssSafelyCallGenericFcnEnd;                                                    \\\n    }\n/**\n * @brief ssSetBusOutputObjectName\n *\n * Specify the name of the bus object that defines the structure and type of the output bus signal\n * @param    S           SimStruct representing an S-Function block\n * @param    pIdx        The zero-based index of the output port of the S-function block\n * @param    name        The name of the bus object\n */\n#define ssSetBusOutputObjectName(S, pIdx, name)                                          \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BUS_OUTPUT_OBJECT_NAME, pIdx, name) \\\n        _ssSafelyCallGenericFcnEnd\n\n#else\n\n#define ssGetBusElementComplexSignal(S, busTypeID, elemIdx) \\\n    ssGetBusElementComplexSignal_cannot_be_used_in_RTW\n\n#define ssGetBusElementDataType(S, busTypeID, elemIdx) ssGetBusElementDataType_cannot_be_used_in_RTW\n\n#define ssGetBusElementDimensions(S, busTypeID, elemIdx) \\\n    ssGetBusElementDimensions_cannot_be_used_in_RTW\n\n#define ssGetBusElementName(S, busTypeID, elemIdx) ssGetBusElementName_cannot_be_used_in_RTW\n\n#define ssGetBusElementNumDimensions(S, busTypeID, elemIdx) \\\n    ssGetBusElementNumDimensions_cannot_be_used_in_RTW\n\n#define ssGetBusElementOffset(S, busTypeID, elemIdx) ssGetBusElementOffset_cannot_be_used_in_RTW\n\n#define ssGetNumBusElements(S, busTypeID) ssGetNumBusElements_cannot_be_used_in_RTW\n\n#define ssGetSFcnParamName(S, pIdx, result)\n\n#define ssIsDataTypeABus(S, typeID) ssIsDataTypeABus_cannot_be_used_in_RTW\n\n#define ssSetBusInputAsStruct(S, pIdx, value)\n\n#define ssSetBusOutputAsStruct(S, pIdx, value)\n\n#define ssSetBusOutputObjectName(S, pIdx, name)\n\n#endif\n\n\n/**\n * @brief ssSetCallSystemOutput\n *\n * Specify that an output port is issuing a function call.\n * @param    S           SimStruct representing an S-Function block.\n * @param    element     Index of the element of the first output port that is issuing a function\n * call.\n */\n#define ssSetCallSystemOutput(S, element) (S)->callSys.outputs[element] = ((int_T)1)\n\n\n\n#if !SS_SFCN_LEVEL_1\n#if SS_SIM\n/**\n * @brief ssRegisterTypeFromParameter\n *\n * Register a data type that a parameter in the Simulink data type table specifies\n * @param    S           SimStruct representing an S-Function block.\n * @param    idx         The zero-based index of the S-function parameter that specifies the bus\n * object name\n * @return   id          A pointer to an int_T that contains the Simulink ID of the newly registered\n * data type\n */\n#define ssRegisterTypeFromParameter(S, idx, id)                                               \\\n    {                                                                                         \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REGISTER_TYPE_FROM_PARAMETER, (idx), (id)) \\\n            _ssSafelyCallGenericFcnEnd;                                                       \\\n    }\n/**\n * @brief ssRegisterTypeFromParameter\n *\n * Register a custom data type from a Simulink.AliasType, Simulink.NumericType, or Simulink.Bus\n * object.\n * @param    S           SimStruct representing an S-Function block.\n * @param    n           Name of the Simulink object to assign to the custom data type.\n * @return   id          An integer whose value is the numeric data type identifier after the call\n * to ssRegisterTypeFromNamedObject\n */\n#define ssRegisterTypeFromNamedObject(S, n, id)                                        \\\n    {                                                                                  \\\n        ssRegisterTypeFromNameType _slRegisterTypeFromNameInfo;                        \\\n        _slRegisterTypeFromNameInfo.name = (n);                                        \\\n        _slRegisterTypeFromNameInfo.dataTypeId = (id);                                 \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REGISTER_TYPE_FROM_NAMED_OBJECT, 0, \\\n                                        (void*)&_slRegisterTypeFromNameInfo)           \\\n            _ssSafelyCallGenericFcnEnd;                                                \\\n    }\n\n#else\n#define ssRegisterTypeFromParameter(S, idx, id)\n#define ssRegisterTypeFromNamedObject(S, name, id)\n#endif\n#endif\n\n/** @} */ /* end of Buses */\n\n/** @defgroup SimulationInformation  Simulation Information\n *  @{\n */\n\n/*======================================*\n * Simulation Information *\n *======================================*/\n\n/**\n * @brief ssSetStateAbsTol\n *\n * Set the absolute tolerance used by a variable-step solver for a specific S-function continuous\n * state.\n * @param    S           SimStruct representing an S-Function block.\n * @param    idx         An index representing an S-function continuous state.\n * @param    val         The value of the absolute tolerance.\n */\n#define ssSetStateAbsTol(S, idx, val) _ssSetStateAbsTol(S, idx, val)\n\n/**\n * @brief ssGetStateAbsTol\n *\n * Get the absolute tolerance used by the variable-step solver for a specified state\n * @param    S           SimStruct representing an S-Function block.\n * @param    idx         An index representing an S-function continuous state.\n */\n#define ssGetStateAbsTol(S, idx) (const real_T)(((S)->states.statesInfo2)->absTol[idx])\n\n/**\n * @brief ssGetBlockReduction\n *\n * Determine whether a block has requrested block reduction before the simulation has begun\n * and whether it has actually been reduced after the simulation loop has begun\n * @param    S           SimStruct representing an S-Function block.\n */\n#define ssGetBlockReduction(S) (S)->sizes.flags.blockReduction /*   (unsigned int_T: 1) */\n\n/**\n * @brief ssSetBlockReduction\n *\n * Request that the Simulink engine attempt to reduce a block\n * @param    S           SimStruct representing an S-Function block.\n * @param    n           If not zero, the Simulink engine should attempt to reduce this block.\n */\n#define ssSetBlockReduction(S, n) (S)->sizes.flags.blockReduction = (n)\n\n/**\n * @brief ssSetOperatingPointCompliance\n *\n * Specify the behavior of a Simulink S-function when saving and restoring the operating point of a\n * model containing the given S-function\n * @param    S           SimStruct representing an S-function block.\n * @param    set         Define how to treat an S-function simulation state when saving and\n * restoring the model operating point.\n */\n#define ssSetOperatingPointCompliance(S, set) (S)->sizes.flags.simStateCompliance = (set)\n\n/**\n * @brief ssSetOperatingPointVisibility\n *\n * Specify whether to make the S-function's simulation state visible in the operating point of the\n * model.\n * @param    S           SimStruct representing an S-Function block.\n * @param    vis         Option to specify the visibility of the S-function simulation state.\n * The default is false; the simulation state is hidden.\n */\n#define ssSetOperatingPointVisibility(S, vis) (S)->sizes.flags.simStateVisibility = (vis)\n\n/**\n * @brief ssGetGetOperatingPointFcn\n *\n * Get the mdlGetOperatingPoint function pointer from simstruct\n * model.\n * @param    S           SimStruct representing an S-Function block.\n */\n#define ssGetGetOperatingPointFcn(S) (S)->states.modelMethods2->modelMethods4->mdlGetOperatingPoint\n\n/**\n * @brief ssGetSetOperatingPointFcn\n *\n * Get the mdlSetOperatingPoint function pointer from simstruct\n * model.\n * @param    S           SimStruct representing an S-Function block.\n */\n#define ssGetSetOperatingPointFcn(S) (S)->states.modelMethods2->modelMethods4->mdlSetOperatingPoint\n\n/**\n * @brief ssSetSkipContStatesConsistencyCheck\n *\n * Ask Simulink engine to reset solver\n * @param    S           SimStruct representing an S-Function block.\n * @param    val         Boolean value (boolean_T) telling Simulink to skip the continuous state\n * consistency check.\n */\n#define ssSetSkipContStatesConsistencyCheck(S, val) \\\n    ((S)->states.flags.skipContStatesConsistencyCheck = ((val) ? 1U : 0U))\n\n/**\n * @brief ssGetSimStatus\n *\n * Get the current simulation status of an S-function block\n * @param    S           SimStruct representing an S-Function block.\n * @param    result      SS_SimStatus object that returns the current simulation status.\n */\n#define ssGetSimStatus(S, result)                                               \\\n    {                                                                           \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_SIM_STATUS, 0, result) \\\n            _ssSafelyCallGenericFcnEnd;                                         \\\n    }\n\n/**\n * @brief ssIsExternalSim\n *\n * Determine if the model is running in the external mode\n * @param    S           SimStruct representing an S-Function block.\n * @return   The Boolean value true if the model is running in external mode.\n * Returns false otherwise. Note: if ssGetSimMode returns \"external\", the result is identical to\n * that of ssIsExternalSim.\n */\n#if SS_SIM\n#define ssIsExternalSim(S) \\\n    (ssGetSimMode(S) == SS_SIMMODE_EXTERNAL && ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_RTW_CODE))\n#else\n#define ssIsExternalSim(S) (false)\n#endif\n\n\n/**\n * @brief ssRTWGenIsAccelerator\n *\n * Determine if the model is running in Accelerator mode.\n * @param    S           SimStruct representing an S-Function block.\n * @return   The Boolean value true if the model has compiled or is compiling for Accelerator mode\n * simulation. Returns false otherwise.\n */\n#if SS_SIM\n#define ssRTWGenIsAccelerator(S) \\\n    (ssGetSimMode(S) == SS_SIMMODE_RTWGEN && ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_ACCELERATOR))\n#else\n#define ssRTWGenIsAccelerator(S) (false)\n#endif\n\n\n/**\n * @brief ssIsRapidAcceleratorActive\n *\n * Determine whether the model is running in Rapid Accelerator mode.\n * @param    S           SimStruct representing an S-Function block.\n * @return   The Boolean value true if the model is being built or simulated in the Rapid\n * Accelerator mode. Returns false otherwise.\n */\n#define ssIsRapidAcceleratorActive(S)                                        \\\n    ((!ssGetParentSS(S)) ? ((S)->sizes.flags.isRapidAcceleratorActive == 1U) \\\n                         : ((ssGetParentSS(S))->sizes.flags.isRapidAcceleratorActive == 1U))\n\n/**\n * @brief ssGetT\n *\n * Get the current simulation time\n * @param  S       SimStruct representing an S-Function block.\n * @return A value of type time_T indicating the current simulation time.\n */\n#define ssGetT(S) (S)->mdlInfo->t[0] /*   (time_T)      */\n\n/**\n * @brief ssGetTStart\n *\n * Get the simulation start time\n * @param  S       SimStruct representing an S-Function block.\n * @return A value of type time_T.\n */\n#define ssGetTStart(S) (S)->mdlInfo->tStart /*   (time_T)      */\n\n/**\n * @brief ssGetTFinal\n *\n * Get the simulation stop time\n * @param  S       SimStruct representing an S-Function block.\n * @return A value of type time_T.\n */\n#define ssGetTFinal(S) (S)->mdlInfo->tFinal /*   (time_T)      */\n\n\n/**\n * @brief ssGetStopRequested\n *\n * Get the value of the simulation stop requested flag\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\n * @return   The int_T value of the simulation stop requested flag.\n */\n#define ssGetStopRequested(S) (S)->mdlInfo->stopRequested /*   (int_T)   */\n/**\n * @brief ssSetStopRequested\n *\n * Set the simulation stop requested flag\n * @param    S           SimStruct representing an S-Function block or a Simulink model\n * @param    val         Boolean value (int_T) specifying whether stopping the simulation has been\n * requested (1) or not (0).\n */\n#if SS_SFCN && SS_SFCN_FOR_SIM\n#define ssSetStopRequested(S, val)                                                        \\\n    {                                                                                     \\\n        boolean_T val2 = (val);                                                           \\\n        _ssSafelyCallConstGenericFcnStart(S)((((const SimStruct*)(S))),                   \\\n                                             GEN_FCN_SET_STOP_REQUESTED_SFUN, 0, &(val2)) \\\n            _ssSafelyCallGenericFcnEnd;                                                   \\\n        (S)->mdlInfo->stopRequested = (val);                                              \\\n    }\n#else\n#define ssSetStopRequested(S, val) (S)->mdlInfo->stopRequested = (val)\n#endif\n\n/**\n * @brief ssGetSimMode\n *\n * Get the simulation mode of an S-Function block\n * @param    S           SimStruct representing an S-Function block or a Simulink model\n * @return   An enumerated value of type SS_SimMode\n */\n#define ssGetSimMode(S) (S)->mdlInfo->simMode /* (SS_SimMode)    */\n\n/**\n * @brief ssGetSolverName\n *\n * Get the name of the solver being used to solve the S-function\n * @param    S           SimStruct representing an S-Function block or a Simulink model\n * @return   A pointer (char_T *) to the name of the solver being used.\n */\n#define ssGetSolverName(S) (S)->mdlInfo->solverName /*   (char_T *)    */\n\n\n/**\n * @brief ssIsVariableStepSolver\n *\n * Determine if a variable-step solver is being used to solve the S-function\n * @param    S           SimStruct representing an S-Function block or a Simulink model\n * @return   The Boolean value true if the solver being used to solve S is a variable-step solver.\n * Otherwise, returns false.\n */\n#define ssIsVariableStepSolver(S) (S)->mdlInfo->variableStepSolver /*   (int_T *)  */\n\n\n/**\n * @brief ssSetSolverNeedsReset\n *\n * Ask Simulink engine to reset solver\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\n */\n#define ssSetSolverNeedsReset(S) (S)->mdlInfo->solverNeedsReset = ((int_T)1)\n\n\n/**\n * @brief ssSetContTimeOutputInconsistentWithStateAtMajorStep\n *\n * Notify Simulink that the block's continuous outputs have become inconsistent since the last call\n * to mdlOutputs (even though time and inputs many have not changed). This call will force Simulink\n * to re-evaluate this block's continuous outputs at the beginning of the next integration step.\n *\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\n */\n#define ssSetContTimeOutputInconsistentWithStateAtMajorStep(S) \\\n    (S)->mdlInfo->mdlFlags.cTimeOutputInconsistentWithStateAtMajorStep = 1U\n\n\n/**\n * @brief ssSetContTimeOutputInconsistentWithStateAtMajorStep\n *\n * Notify Simulink that the block's continuous states have changed at the current major time\n * step. This call will force Simulink to reset solver data based on cached values of the continuous\n * states at the beginning of the next integration step.\n *\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\n */\n#define ssSetBlockStateForSolverChangedAtMajorStep(S) \\\n    (S)->mdlInfo->mdlFlags.blockStateForSolverChangedAtMajorStep = 1U\n\n\n/**\n * @brief ssGetSolverMode\n *\n * Get solver mode\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\n */\n#define ssGetSolverMode(S) (S)->mdlInfo->solverMode /*   (SolverMode)   */\n\n\n/**\n * @brief ssGetFixedStepSize\n *\n * Get the fixed step size of the model containing the S-function.\n * @param    S           SimStruct representing an S-Function block.\n */\n#define ssGetFixedStepSize(S) (S)->mdlInfo->fixedStepSize /*   (time_T)      */\n\n/**\n * @brief ssIsFirstInitCond\n *\n * Determine whether the simulation time is equal to the start time.\n * @param    S             SimStruct representing an S-Function block.\n * @return   The Boolean value true if the current simulation time is equal to the simulation start\n * time. Otherwise, returns false.\n */\n#define ssIsFirstInitCond(S) (!((ssGetRootSS(S)->mdlInfo->mdlFlags).firstInitCondCalled))\n\n#if !defined(ENABLE_SLEXEC_SSBRIDGE)\n\n#define ssGetGlobalInitialStatesAvailable(S) 0\n\n#endif\n\n/**\n * @brief ssIsMinorTimeStep\n *\n * Determine whether the simulation is in a minor step\n * @param    S           SimStruct representing an S-Function block.\n * @return   The Boolean value true if the simulation is in a minor time step. Otherwise, returns\n * false.\n */\n#define ssIsMinorTimeStep(S) ((S)->mdlInfo->simTimeStep == MINOR_TIME_STEP) /*  (int_T)    */\n\n\n/**\n * @brief ssIsMajorTimeStep\n *\n * Determine whether the simulation is in a major step\n * @param    S           SimStruct representing an S-Function block.\n * @return   The Boolean value true if the simulation is in a major time step. Otherwise, returns\n * false.\n */\n#define ssIsMajorTimeStep(S) ((S)->mdlInfo->simTimeStep == MAJOR_TIME_STEP) /*  (int_T)    */\n\n\n/**\n * @brief ssSetNeedAbsoluteTime\n *\n * Register whether the block requires  absolute time\n * @param    S          SimStruct representing an S-Function block\n * @param    n          Boolean flag indicating whether the block must use absolute time\n *\n */\n#define ssSetNeedAbsoluteTime(S, n) (S)->sizes.flags.needAbsoluteTime = (n)\n\n\n/**\n * @brief ssSetTimeSource\n *\n * Register time source for an asynchronous task\n * @param    S             SimStruct representing an S-Function block.\n * @param    timeSource    Source of time used by the asynchronous task created by the block\n * for the asynchronous task the S-function registers\n *    SS_TIMESOURCE_BASERATE\n *    SS_TIMESOURCE_SELF\n *    SS_TIMESOURCE_CALLER\n *    SS_TIMESOURCE_SELF_INTERNAL\n */\n#if SS_SFCN\n\n#define ssSetTimeSource(S, timeSource)                                            \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_TIME_SOURCE, timeSource, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n\n#endif\n\n\n/**\n * @brief ssGetTaskTime\n *\n * Get the current time for the current task.\n * @param    S           SimStruct representing an S-Function block.\n * @param    sti         Index of the sample time corresponding to the task for which the current\n * time is to be returned.\n * @return   A value of type time_T.\n */\n#define ssGetTaskTime(S, sti) \\\n    (S)->mdlInfo->t[ssIsTIDInStInfo(S, sti) ? ssGetSampleTimeTaskID(S, sti) : 0] /*  (time_T)   */\n\n\n/** @} */ /* end of SimulationInformation */\n\n/** @defgroup RunTimeParams  Run-Time Parameters\n *  @{\n */\n\n/*======================================*\n * Run-Time Parameters *\n *======================================*/\n\n/**\n * @brief ssGetNumRunTimeParams\n *\n * Get the number of run-time parameters created by this S-function\n * @param  S           SimStruct representing an S-Function block.\n * @return An int_T value indicating the number of run-time parameters.\n */\n#define ssGetNumRunTimeParams(S) (S)->sfcnParams.numRtp.numRtp\n\n/**\n * @brief ssGetRunTimeParamInfo\n *\n * Get the attributes of a run-time parameter\n * @param  S           SimStruct representing an S-Function block.\n * @param  idx         Index of a run-time parameter.\n * @return A pointer to the ssParamRec describing the attributes of the run-time parameter specified\n * by the index param.\n */\n#define ssGetRunTimeParamInfo(S, idx) (S)->sfcnParams.rtp[idx]\n\n\n/**\n * @brief ssRegAllTunableParamsAsRunTimeParams\n *\n * Register all tunable parameters as run-time parameters\n * @param  S           SimStruct representing an S-Function block.\n * @param  ms          Array of names for the run-time parameters.\n */\n#define ssRegAllTunableParamsAsRunTimeParams(S, nms)                                   \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REG_ALL_TUNE_PRM_AS_RTP, 0, (void*)nms) \\\n        _ssSafelyCallGenericFcnEnd\n\n\n\n/**\n * @brief ssRegDlgParamAsRunTimeParam\n *\n * Register a dialog parameter as a run-time parameter\n * @param    S           SimStruct representing an S-Function block.\n * @param    dlgIdxArg   Index of the dialog parameter.\n * @param    rtIdxArg    Index of the run-time parameter.\n * @param    nameArg     Name of the run-time parameter.\n * @dtIdArg  dtIdArg     Value of type DTypeId that specifies the data type of the run-time\n * parameter.\n */\n#if SS_SFCN && SS_SIM\n#define ssRegDlgParamAsRunTimeParam(S, dlgIdxArg, rtIdxArg, nameArg, dtIdArg)     \\\n    {                                                                             \\\n        ssRTPRegInfoWithType _slConvTypeAndRegParamInfo;                          \\\n        _slConvTypeAndRegParamInfo.dlgIdx = (dlgIdxArg);                          \\\n        _slConvTypeAndRegParamInfo.rtIdx = (rtIdxArg);                            \\\n        _slConvTypeAndRegParamInfo.name = (nameArg);                              \\\n        _slConvTypeAndRegParamInfo.dtId = (dtIdArg);                              \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REG_AND_CNV_RUN_TIME_PARAM, 0, \\\n                                        (void*)&_slConvTypeAndRegParamInfo)       \\\n            _ssSafelyCallGenericFcnEnd;                                           \\\n    }\n#endif\n\n\n\n/**\n * @brief ssSetNumRunTimeParams\n *\n * Specify the number of run-time parameters created by this S-function\n * @param    S           SimStruct representing an S-Function block.\n * @param    num         Number of run-time parameters.\n */\n#if SS_SFCN\n#if SS_RTW\n#define ssSetNumRunTimeParams(S, num) _ssSetNumRunTimeParams(S, num)\n#else\n#define ssSetNumRunTimeParams(S, num)                                              \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_NUM_RUN_TIME_PARAMS, num, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n#endif\n\n\n/**\n * @brief ssSetRunTimeParamInfo\n *\n * Specify the attributes of a run-time parameter\n * @param    S           SimStruct representing an S-Function block.\n * @param    idx         Index of a run-time parameter\n * @param    p           ssParamRec structure containing the attributes of the run-time parameter.\n */\n#if SS_SFCN\n#if SS_RTW\n#define ssSetRunTimeParamInfo(S, idx, p) _ssSetRunTimeParamInfo(S, idx, p)\n#else\n#define ssSetRunTimeParamInfo(S, idx, p)                                          \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REG_RUN_TIME_PARAM, idx, (void*)p) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n#endif\n\n\n#if SS_SFCN && SS_SIM\n/**\n * @brief ssUpdateAllTunableParamsAsRunTimeParams\n *\n * Update the values of run-time parameters to be the same as those of the corresponding tunable\n * dialog parameters.\n * @param    S           SimStruct representing an S-Function block.\n */\n#define ssUpdateAllTunableParamsAsRunTimeParams(S)                                  \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_UPDATE_ALL_TUNE_PRM_AS_RTP, 0, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n\n\n\n/**\n * @brief ssUpdateDlgParamAsRunTimeParam\n *\n * Update a run-time parameter that corresponds to a dialog parameter.\n * @param    S           SimStruct representing an S-Function block.\n * @param    rtIdxArg    Index of the run-time parameter.\n */\n#define ssUpdateDlgParamAsRunTimeParam(S, rtIdxArg)                                           \\\n    {                                                                                         \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_UPDATE_AND_CNV_RUN_TIME_PARAM, (rtIdxArg), \\\n                                        NULL) _ssSafelyCallGenericFcnEnd;                     \\\n    }\n\n\n/**\n * @brief ssUpdateRunTimeParamData\n *\n * Update the value of a run-time parameter\n * @param    S           SimStruct representing an S-Function block.\n * @param    idx         Index of the run-time parameter.\n * @param    d           New value of the parameter.\n */\n#define ssUpdateRunTimeParamData(S, idx, d) ((S)->sfcnParams.rtp[idx])->data = (d)\n\n/**\n * @brief ssUpdateRunTimeParamInfo\n *\n * Update the attributes of a run-time parameter\n * @param    S           SimStruct representing an S-Function block.\n * @param    idx         Index of the run-time parameter.\n * @param    p           Attributes of the run-time parameter.\n */\n#define ssUpdateRunTimeParamInfo(S, idx, p)                                          \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_UPDATE_RUN_TIME_PARAM, idx, (void*)p) \\\n        _ssSafelyCallGenericFcnEnd\n\n#endif /* __SS_SFCN && SS_SIM__ */\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssSetRuntimeThreadSafetyCompliance\n *\n * Specify that the S-function is run-time thread-safe.\n * @param    S             SimStruct representing an S-Function block.\n * @param    val           One of the following enumerated values that indicates if the\n * S-function is run-time thread-safe or not or unknown:\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_FALSE\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_UNKNOWN\n */\n#define ssSetRuntimeThreadSafetyCompliance(S, val) \\\n    (S)->blkInfo.sfcnFlags.runtimeThreadSafetyCompliance = (val)\n#endif\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetRuntimeThreadSafetyCompliance\n *\n * Determine whether the S-function is run-time thread-safe.\n * @return   One of the following enumerated values that indicates if the\n * S-function is run-time thread-safe or not or unknown:\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_FALSE\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_UNKNOWN\n */\n#define ssGetRuntimeThreadSafetyCompliance(S) \\\n    ((RuntimeThreadSafetyCompliance)((S)->blkInfo.sfcnFlags.runtimeThreadSafetyCompliance))\n#endif\n\n/** @} */ /* end of RunTimeParams */\n\n/** @defgroup StateWorkVector  State and Work Vector\n *  @{\n */\n\n/*======================================*\n * State and Work Vector *\n *======================================*/\n/**\n * @brief ssSetNumDWork\n *\n * Specify the number of data type work vectors used by a block\n * @param  S         SimStruct representing an S-Function block.\n * @param  num       Number of data type work vectors.\n * @return The Boolean value true if nDWork is zero or a positive integer; otherwise, false.\n */\n#if !SS_SFCN_LEVEL_1\n#if SS_SFCN_FOR_SIM\n#if defined(USE_64BIT_FIELDS)\n#define ssSetNumDWork(S, num)                                                            \\\n    (((S)->blkInfo.blkInfo2->blkInfoSLSize->regDataType.setNumDWorkFcn != NULL)          \\\n         ? (*(S)->blkInfo.blkInfo2->blkInfoSLSize->regDataType.setNumDWorkFcn)((S), num) \\\n         : (0))\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumDWork(S, num) \\\n    (((S)->regDataType.setNumDWorkFcn != NULL) ? (*(S)->regDataType.setNumDWorkFcn)((S), num) : (0))\n#endif\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumDWork(S, num) ((_ssSetNumDWork(S, num)) >= -1)\n#endif\n#endif /* NOT level 1 S-function */\n\n/**\n * @brief ssGetNumDWork\n *\n * Get the number of data type work vectors used by a block\n * @param  S         SimStruct representing an S-Function block.\n * @return An int_T value indicating the number of DWork vectors in this S-function.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetNumDWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDWork\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetNumDWork(S) (S)->sizes.numDWork\n#endif\n\n/**\n * @brief ssGetDWorkComplexSignal\n *\n * Determine whether the elements of a data type work vector are real or complex numbers\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return COMPLEX_YES (1) if the specified vector contains complex numbers; otherwise, COMPLEX_NO\n * (0).\n */\n#define ssGetDWorkComplexSignal(S, index) \\\n    ((S)->work.dWork.sfcn[(index)].complexSignal) /* (CSignal_T) */\n\n/**\n * @brief ssSetDWorkComplexSignal\n *\n * Specify whether the elements of a data type work vector are real or complex\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  val       Numeric type, either COMPLEX_YES or COMPLEX_NO.\n * @return 1 (COMPLEX_YES), 0 (COMPLEX_NO), or -1 (COMPLEX_INHERITED) depending on the value\n * specified by csig.\n */\n#define ssSetDWorkComplexSignal(S, index, val) (S)->work.dWork.sfcn[index].complexSignal = (val)\n\n/**\n * @brief ssGetDWorkDataType\n *\n * Get the data type of a data type work vector\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return The data type ID of the DWork vector specified by the index vector if the data type is\n * valid. Otherwise, returns INVALID_DTYPE_ID.\n */\n#define ssGetDWorkDataType(S, index) ((S)->work.dWork.sfcn[(index)].dataTypeId) /* (DTypeId) */\n\n/**\n * @brief ssSetDWorkDataType\n *\n * Specify the data type of a data type work vector\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  val       ID of a data type.\n * @return The data type ID specified by dtID. Returns -1 if dtID is DYNAMICALLY_TYPED.\n */\n#define ssSetDWorkDataType(S, index, val) (S)->work.dWork.sfcn[index].dataTypeId = (val)\n\n/**\n * @brief ssGetDWorkName\n *\n * Get the name of a data type work vector\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return A pointer (char_T *) to the character vector representing the name of the DWork vector\n * specified by the index vector.\n */\n#define ssGetDWorkName(S, index) ((S)->work.dWork.sfcn[(index)].name) /* (char_T *) */\n\n/**\n * @brief ssSetDWorkName\n *\n * Specify the name of a data type work vector\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  val       Name of a work vector.\n * @return The name of the DWork vector entered in name.\n */\n#define ssSetDWorkName(S, index, val) (S)->work.dWork.sfcn[index].name = val\n\n\n/**\n * @brief ssGetDWorkUsageType\n *\n * Determine how DWork vector is used in S-function\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return One of the enumerated types defined for ssDWorkUsageType in simstruc_types.h.\n */\n#define ssGetDWorkUsageType(S, index) (S)->work.dWork.sfcn[(index)].usedAs\n\n/**\n * @brief ssSetDWorkUsageType\n *\n * Specify how DWork vector is used in S-function\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  type      Usage type of the DWork vector.\n * @return The usage type entered in type\n */\n#define ssSetDWorkUsageType(S, index, val) (S)->work.dWork.sfcn[(index)].usedAs = val\n\n\n/**\n * @brief ssGetDWorkUsedAsDState\n *\n * Determine whether a data type work vector is used as a discrete state vector\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return The int_T value 1 (SS_DWORK_USED_AS_DSTATE) if this vector is used to store a block's\n * discrete states. Otherwise, returns 0 (SS_DWORK_USED_AS_DWORK)..\n */\n#define ssGetDWorkUsedAsDState(S, index) \\\n    ((S)->work.dWork.sfcn[(index)].usedAs == SS_DWORK_USED_AS_DSTATE)\n\n/**\n * @brief ssSetDWorkUsedAsDState\n *\n * Specify that a data type work vector is used as a discrete state vector\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  val       How this vector is used. A value of 1 indicates that the work vector is to be\n * used to store the block's discrete states (SS_DWORK_USED_AS_DSTATE), a value of 0 indicates that\n * the work vector is to be used as a work vector (SS_DWORK_USED_AS_DWORK).\n * @return 0 if usage is SS_DWORK_USED_AS_DWORK (0), otherwise returns 1.\n */\n#define ssSetDWorkUsedAsDState(S, index, val) \\\n    (S)->work.dWork.sfcn[(index)].usedAs =    \\\n        ((val) ? SS_DWORK_USED_AS_DSTATE : ((S)->work.dWork.sfcn[(index)].usedAs))\n\n\n\n/**\n * @brief ssGetDWorkWidth\n *\n * Get the size of a data type work vector\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return The int_T number of elements in the DWork vector specified by the index vector.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetDWorkWidth(S, index) ((S)->work.dWorkAux[(index)].widthSLSize)\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetDWorkWidth(S, index) ((S)->work.dWork.sfcn[(index)].width)\n#endif\n\n/**\n * @brief ssSetDWorkWidth\n *\n * Specify the width of a data type work vector\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  val       Number of elements in the work vector.\n * @return The number of elements passed in through width.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssSetDWorkWidth(S, index, val) (S)->work.dWorkAux[(index)].widthSLSize = (val)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetDWorkWidth(S, index, val) (S)->work.dWork.sfcn[index].width = (val)\n#endif\n\n/**\n * @brief ssGetDWork\n *\n * Get a DWork vector\n * @param  S         SimStruct representing an S-Function block.\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return A pointer (void *) to the DWork vector specified by the index vector.\n */\n#define ssGetDWork(S, index) ((S)->work.dWork.sfcn[(index)].array) /*   (void *)  */\n\n/**\n * @brief ssGetdX\n *\n * Get the derivatives of a blocks's continuous states\n * @param  S         SimStruct representing an S-Function block or Simulink model.\n * @return A pointer (real_T *) to an array containing the derivatives of the continuous states of\n * S, which can be a block or the model. Returns NULL if there are no continuous states.\n */\n#define ssGetdX(S) (S)->states.dX /*   (real_T *)    */\n\n\n#if !SS_SFCN_LEVEL_1\n/**\n * @brief ssGetContStates\n *\n * Get a block's continuous states\n * @param  S               SimStruct representing an S-Function block.\n * @return A pointer (real_T *) to the continuous state vector as an array of length\n * ssGetNumContStates(S). Returns NULL if the S-function does not have any continuous states.\n */\n#define ssGetContStates(S) (S)->states.contStates /*   (real_T *)    */\n/**\n * @brief ssGetDiscStates\n *\n * Get a block's discrete states\n * @param  S               SimStruct representing an S-Function block.\n * @return A pointer (real_T *) to the discrete state vector as an array of length\n * ssGetNumDiscStates(S). Returns NULL if the S-function does not have any discrete states.\n */\n#define ssGetDiscStates(S) ((S)->states.discStates) /*   (real_T *)    */\n\n/**\n * @brief ssGetRealDiscStates\n *\n * Get a block's discrete state vector\n * @param  S               SimStruct representing an S-Function block.\n * @return The discrete state vector as an array of real_T elements of length ssGetNumDiscStates(S).\n */\n#define ssGetRealDiscStates(S) ssGetDiscStates(S) /*   (real_T *)    */\n\n#endif\n\n/**\n * @brief ssGetNumContStates\n *\n * Get the number of continuous states that a block has\n * @param  S         SimStruct representing an S-Function block or Simulink model.\n * @return An int_T value indicating the number of continuous states.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetNumContStates(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numContStates\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetNumContStates(S) (S)->sizes.numContStates\n#endif\n\n/**\n * @brief ssSetNumContStates\n *\n * Specify the number of continuous states that a block has\n * @param  S            SimStruct representing an S-Function block.\n * @param  nContStates  Number of continuous states to be set for the block represented by S.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssSetNumContStates(S, nContStates) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numContStates = (nContStates)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumContStates(S, nContStates) (S)->sizes.numContStates = (nContStates)\n#endif\n\n/**\n * @brief ssGetNumDiscStates\n *\n * Get the number of discrete states that a block has\n * @param  S            SimStruct representing an S-Function block or a Simulink model.\n * @return  An int_T value indicating the number of discrete states.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetNumDiscStates(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDiscStates\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetNumDiscStates(S) (S)->sizes.numDiscStates\n#endif\n\n/**\n * @brief ssSetNumDiscStates\n *\n * Specify the number of discrete states that a block has\n * @param  S            SimStruct representing an S-Function block.\n * @param  nContStates  Number of continuous states to be set for the block represented by S.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssSetNumDiscStates(S, nDiscStates) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDiscStates = (nDiscStates)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumDiscStates(S, nDiscStates) (S)->sizes.numDiscStates = (nDiscStates)\n#endif\n\n/**\n * @brief ssGetNumNonsampledZCs\n *\n * Get the size of the zero-crossing vector\n * @param  S            SimStruct representing an S-Function block.\n * @return  An int_T value indicating the size of the zero-crossing vector.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetNumNonsampledZCs(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numNonsampledZCs\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetNumNonsampledZCs(S) (S)->sizes.numNonsampledZCs\n#endif\n\n/**\n * @brief ssSetNumNonsampledZCs\n *\n * Specify the number of states for which a block detects zero crossings that occur between sample\n * points\n * @param  S               SimStruct representing an S-Function block.\n * @param  nNonsampledZCs  Number of nonsampled zero crossings that a block detects.\n * @return The number of modes specified by nNonsampledZCs, or -1 if DYNAMICALLY_SIZED.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssSetNumNonsampledZCs(S, nNonsampledZCs) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numNonsampledZCs = (nNonsampledZCs)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumNonsampledZCs(S, nNonsampledZCs) (S)->sizes.numNonsampledZCs = (nNonsampledZCs)\n#endif\n\n/**\n * @brief ssGetNonsampledZCs\n *\n * Get the zero-crossing signal values\n * @param  S               SimStruct representing an S-Function block.\n * @return A pointer (real_T *) to the zero-crossing signal values.\n */\n#define ssGetNonsampledZCs(S) (S)->states.nonsampledZCs /*   (real_T *)    */\n\n\n/**\n * @brief ssGetNumRWork\n *\n * Get the size of a block's floating-point work vector\n * @param  S               SimStruct representing an S-Function block.\n * @return An int_T value indicating the size of the RWork vector.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetNumRWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numRWork\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetNumRWork(S) (S)->sizes.numRWork\n#endif\n\n/**\n * @brief ssSetNumRWork\n *\n * Specify the size of a block's floating-point work vector\n * @param  S               SimStruct representing an S-Function block.\n * @param  nRwork          Number of elements in the floating-point work vector.\n * @return The number of elements specified by nRWork, or -1 if DYNAMICALLY_SIZED.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssSetNumRWork(S, nRWork) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numRWork = (nRWork)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumRWork(S, nRWork) (S)->sizes.numRWork = (nRWork)\n#endif\n\n/**\n * @brief ssGetRWork\n *\n * Get a block's floating-point work vector\n * @param  S               SimStruct representing an S-Function block.\n * @return A pointer (real_T *) to the RWork vector.\n */\n#define ssGetRWork(S) (S)->work.rWork /*   (real_T *)    */\n\n\n\n#if !SS_DEBUG_FOR_SIM\n/**\n * @brief ssGetRWorkValue\n *\n * Get an element of a block's floating-point work vector\n * @param  S               SimStruct representing an S-Function block.\n * @param  rworkIdx        Index of the element returned by this function.\n * @return The real_T value stored in the RWork vector element specified by the index idx.\n */\n#define ssGetRWorkValue(S, rworkIdx) (S)->work.rWork[rworkIdx] /*   (real_T)      */\n\n\n/**\n * @brief ssSetRWorkValue\n *\n * Set an element of a block's floating-point work vector\n * @param  S               SimStruct representing an S-Function block.\n * @param  rworkIdx        Index of the element to be set.\n * @param  value           New value of element.\n * @return The real_T value passed into the macro.\n */\n#define ssSetRWorkValue(S, rworkIdx, rworkValue) (S)->work.rWork[rworkIdx] = (rworkValue)\n\n#endif\n\n\n/**\n * @brief ssGetNumIWork\n *\n * Get the size of a block's integer work vector.\n * @param  S               SimStruct representing an S-Function block.\n * @return An int_T value indicating the size of the IWork vector.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetNumIWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numIWork\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetNumIWork(S) (S)->sizes.numIWork\n#endif\n\n/**\n * @brief ssSetNumIWork\n *\n * Specify the size of a block's integer work vector\n * @param  S               SimStruct representing an S-Function block.\n * @param  nIWork          Number of elements in the integer work vector.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssSetNumIWork(S, nIWork) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numIWork = (nIWork)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumIWork(S, nIWork) (S)->sizes.numIWork = (nIWork)\n#endif\n\n/**\n * @brief ssGetIWork\n *\n * Get a block's integer work vector.\n * @param  S               SimStruct representing an S-Function block.\n * @return A pointer (int_T *) to the integer work vector for this S-function.\n */\n#define ssGetIWork(S) (S)->work.iWork /*   (int_T *)     */\n\n\n\n#if !SS_DEBUG_FOR_SIM\n/**\n * @brief ssGetIWorkValue\n *\n * Get an element of a block's integer work vector.\n * @param  S         SimStruct representing an S-Function block.\n * @param  iworkIdx  Index of the element returned by this function.\n * @return The int_T value stored in the idx element of the integer work vector for this S-function.\n * Returns NULL if no value was assigned into the idx element of the IWork vector.\n */\n#define ssGetIWorkValue(S, iworkIdx) (S)->work.iWork[iworkIdx] /*   (int_T)       */\n\n/**\n * @brief ssSetIWorkValue\n *\n * Set an element of a block's integer work vector.\n * @param  S           SimStruct representing an S-Function block.\n * @param  iworkIdx    Index of the element to be set.\n * @param  iworkValue  New value of element.\n * @return The int_T value passed into the macro.\n */\n#define ssSetIWorkValue(S, iworkIdx, iworkValue) (S)->work.iWork[iworkIdx] = (iworkValue)\n\n#endif\n\n\n/**\n * @brief ssGetNumPWork\n *\n * Get the size of a block's pointer work vector.\n * @param  S               SimStruct representing an S-Function block.\n * @return A int_T value indicating the size of the PWork vector.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetNumPWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numPWork\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetNumPWork(S) (S)->sizes.numPWork\n#endif\n\n/**\n * @brief ssSetNumPWork\n *\n * Specify the size of a block's pointer work vector.\n * @param  S           SimStruct representing an S-Function block.\n * @param  nPWork      Number of elements to be allocated to the pointer work vector of the block\n * represented by S.\n * @return The number of elements specified by nPWork, or -1 if DYNAMICALLY_SIZED.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssSetNumPWork(S, nPWork) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numPWork = (nPWork)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumPWork(S, nPWork) (S)->sizes.numPWork = (nPWork)\n#endif\n\n/**\n * @brief ssGetPWork\n *\n * Get a block's pointer work vector.\n * @param  S           SimStruct representing an S-Function block.\n * @return A pointer to the PWork vector.\n */\n#define ssGetPWork(S) (S)->work.pWork /*   (void **)     */\n\n\n#if !SS_DEBUG_FOR_SIM\n\n/**\n * @brief ssGetPWorkValue\n *\n * Get a pointer from a block's pointer work vector\n * @param  S           SimStruct representing an S-Function block.\n * @param  pworkIdx    Index of the pointer returned by this function.\n * @return The (void *) element of the PWork vector at the index pworkIdx.\n */\n#define ssGetPWorkValue(S, pworkIdx) (S)->work.pWork[pworkIdx] /*   (void *)      */\n\n/**\n * @brief ssSetPWorkValue\n *\n * Set an element of a block's pointer work vector\n * @param  S           SimStruct representing an S-Function block.\n * @param  pworkIdx    Index of the element to be set.\n * @param  pworkValue  New pointer element.\n * @return The pointer passed into the macro.\n */\n#define ssSetPWorkValue(S, pworkIdx, pworkValue) (S)->work.pWork[pworkIdx] = (pworkValue)\n\n\n#endif\n\n/**\n * @brief ssGetNumModes\n *\n * Get the size of the mode vector\n * @param  S           SimStruct representing an S-Function block.\n * @return An int_T value indicating the size of the mode work vector.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssGetNumModes(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numModes\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetNumModes(S) (S)->sizes.numModes /*   (int_T)       */\n#endif\n\n/**\n * @brief ssSetNumModes\n *\n * Specify the size of the block's mode vector\n * @param  S       SimStruct representing an S-Function block.\n * @param  n       Size of the mode vector for the block represented by S. Valid values are 0, a\n * positive integer, or DYNAMICALLY_SIZED.\n * @return The number of modes specified by n, or -1 if DYNAMICALLY_SIZED.\n */\n#if defined(USE_64BIT_FIELDS)\n#define ssSetNumModes(S, n) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numModes = (n)\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumModes(S, n) (S)->sizes.numModes = (n)\n#endif\n\n/**\n * @brief ssGetModeVector\n *\n * Get the mode vector\n * @param  S           SimStruct representing an S-Function block.\n * @return A pointer (int_T *) to the mode vector.\n */\n#define ssGetModeVector(S) (S)->work.modeVector /*   (int_T *)     */\n\n/**\n * @brief ssGetModeVectorValue\n *\n * Get an element of a block's mode vector\n * @param  S           SimStruct representing an S-Function block.\n * @param  idx         Index of a mode vector element.\n * @return An int_T value for the element of the mode vector specified by the index idx.\n * Returns NULL if no value was assigned into the idx element of the mode vector.\n */\n#define ssGetModeVectorValue(S, idx) (S)->work.modeVector[idx] /*   (int_T)       */\n\n\n/**\n * @brief ssSetModeVectorValue\n *\n * Set an element of a block's mode vector\n * @param  S           SimStruct representing an S-Function block.\n * @param  idx         Index of a mode vector element.\n * @param  val         Mode vector value.\n */\n#define ssSetModeVectorValue(S, idx, val) (S)->work.modeVector[idx] = (val)\n\n/** @} */ /* end of StateWorkVector */\n\n/** @defgroup CodeGeneration Code Generation\n *  @{\n */\n\n/*======================================*\n * Code Generation *\n *======================================*/\n/**\n * @brief ssGetDWorkRTWIdentifier\n *\n * Get the identifier used to declare a DWork vector in code generated from the associated\n * S-function\n * @param  S       SimStruct representing an S-Function block\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return A pointer (char_T *) to the character vector used as the Simulink Coder identifier for\n * the DWork vector specified by the index vector. Returns NULL if no Simulink Coder identifier is\n * specified.\n */\n#define ssGetDWorkRTWIdentifier(S, index) \\\n    ((S)->work.dWorkAux[(index)].rtwIdentifier) /* (char_T *) */\n\n/**\n * @brief ssSetDWorkRTWIdentifier\n *\n * Specify the identifier used to declare a DWork vector in code generated from the associated\n * S-function\n * @param  S       SimStruct representing an S-Function block\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  val      DWork vector identifier\n * @return A pointer (char_T *) to the Simulink Coder identifier entered in id.\n */\n#define ssSetDWorkRTWIdentifier(S, index, val) (S)->work.dWorkAux[index].rtwIdentifier = val\n\n/**\n * @brief ssGetDWorkRTWIdentifierMustResolveToSignalObject\n *\n * Get a flag indicating if a DWork vector resolves to a Simulink.Signal object\n * @param  S       SimStruct representing an S-Function block\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return A uint_T flag with the value of 0, 1, or 2.\n */\n#define ssGetDWorkRTWIdentifierMustResolveToSignalObject(S, index) \\\n    ((S)->work.dWorkAux[(index)].flags.rtwIdMustResolveToSignalObject)\n\n/**\n * @brief ssSetDWorkRTWIdentifierMustResolveToSignalObject\n *\n * Specify if a DWork vector resolves to a Simulink.Signal object\n * @param  S       SimStruct representing an S-Function block\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  n       Flag to control if the DWork vector resolves to a Simulink.Signal object, either\n * 0, 1, or 2.\n * @return The value for flag if flag is 0, 1, or 2. Otherwise, returns 0.\n */\n#define ssSetDWorkRTWIdentifierMustResolveToSignalObject(S, index, n) \\\n    (S)->work.dWorkAux[index].flags.rtwIdMustResolveToSignalObject = (n)\n\n/**\n * @brief ssGetDWorkRTWStorageClass\n *\n * Get the storage class of a DWork vector in code generated from the associated S-function\n * @param  S       SimStruct representing an S-Function block\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return One of the enumerated types defined for ssRTWStorageType.\n */\n#define ssGetDWorkRTWStorageClass(S, index) ((S)->work.dWorkAux[(index)].rtwStorageClass)\n\n/**\n * @brief ssSetDWorkRTWStorageClass\n *\n * Specify the storage class of a DWork vector in code generated from the associated S-function\n * @param  S       SimStruct representing an S-Function block\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  val     Storage class of the work vector. Must be one of the values enumerated by\n * ssRTWStorageType.\n * @return The ssRTWStorageType value entered as sc. Invokes an error if sc is not a valid storage\n * class.\n */\n#define ssSetDWorkRTWStorageClass(S, index, val) (S)->work.dWorkAux[index].rtwStorageClass = val\n\n/**\n * @brief ssGetDWorkRTWTypeQualifier\n *\n * Get the C type qualifier used to declare a DWork vector in code generated from the associated\n * S-function\n * @param  S       SimStruct representing an S-Function block\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @return A pointer (char_T *) to a character vector indicating the C type qualifier used to\n * declare the DWork vector specified by the index vector. Returns NULL if no type qualifier is\n * specified.\n */\n#define ssGetDWorkRTWTypeQualifier(S, index) ((S)->work.dWorkAux[(index)].rtwTypeQualifier)\n\n/**\n * @brief ssSetDWorkRTWTypeQualifier\n *\n * Specify the C type qualifier used to declare a DWork vector in code generated from the associated\n * S-function\n * @param  S       SimStruct representing an S-Function block\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\n * ssGetNumDWork(S)-1.\n * @param  val     Type qualifier\n * @return The C type qualifier entered in tq.\n */\n#define ssSetDWorkRTWTypeQualifier(S, index, val) (S)->work.dWorkAux[index].rtwTypeQualifier = val\n\n\n/**\n * @brief ssGetPlacementGroup\n *\n * Get the name of the placement group of a block\n * @param  S       SimStruct representing an S-Function block. The block must be either a source\n * block (i.e., a block without input ports) or a sink block (i.e., a block without output ports).\n * @return A pointer (char_T *) to the character vector indicating the name of the S-function\n * placement group.\n */\n#define ssGetPlacementGroup(S) (S)->blkInfo.placementGroup\n\n/**\n * @brief ssRTWGenIsCodeGen\n *\n * Identify any code generation that is not used by the Accelerator\n * @param  S       SimStruct representing an S-Function block.\n * @return The Boolean value true if the model is generating code for any purpose other than\n * Accelerator mode simulation. Returns false if the model is not generating code or is generating\n * code for Accelerator mode simulation.\n */\n#if SS_SIM\n#define ssRTWGenIsCodeGen(S)                                               \\\n    (ssGetSimMode(S) == SS_SIMMODE_RTWGEN &&                               \\\n     (((S)->mdlInfo->rtwgenMode == SS_RTWGEN_RTW_CODE) ||                  \\\n      ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_MODELREFERENCE_SIM_TARGET) || \\\n      ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_MODELREFERENCE_RTW_TARGET)))\n#else\n#define ssRTWGenIsCodeGen(S) (false)\n#endif\n\n/**\n * @brief ssWriteRTW2dMatParam\n *\n * Write a matrix parameter to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  n       Parameter name.\n * @param  v       Parameter values.\n * @param  dt      DataType of parameter elements.\n * @param  nr      Number of rows in the matrix.\n * @param  nc      Number of columns in the matrix.\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\n#define ssWriteRTW2dMatParam(S, n, v, dt, nr, nc) \\\n    ssWriteRTWNameValuePair(S, SSWRITE_VALUE_DTYPE_2DMAT, n, v, dt, nr, nc)\n\n#if SS_SFCN_FOR_SIM\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/**\n * @brief ssWriteRTWMx2dMatParam\n *\n * Write a matrix parameter in MATLAB format to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  name    Parameter name.\n * @param  rVal    Real elements of the parameter array.\n * @param  iVal    Imaginary elements of the parameter array.\n * @param  dtInfo  Data type of the parameter elements.\n * @param  nRows   Number of rows in the matrix.\n * @param  nCols   Number of columns in the matrix.\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\nextern int_T ssWriteRTWMx2dMatParam(SimStruct* S,\n                                    const char_T* name,\n                                    const void* rVal,\n                                    const void* iVal,\n                                    int_T dtInfo,\n                                    int_T nRows,\n                                    int_T nCols);\n\n\n/**\n * @brief ssWriteRTWMxVectParam\n *\n * Write a vector parameter in MATLAB format to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  name    Parameter name.\n * @param  rVal    Real elements of the parameter array.\n * @param  iVal    Imaginary elements of the parameter array.\n * @param  dtInfo  Data type of the parameter elements.\n * @param  numEL   Number of elements in the vector.\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\nextern int_T ssWriteRTWMxVectParam(SimStruct* S,\n                                   const char_T* name,\n                                   const void* rVal,\n                                   const void* iVal,\n                                   int_T dtInfo,\n                                   int_T numEl);\n\n/**\n * @brief ssWriteRTWParameters\n *\n * Write tunable parameter information to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  nParams Number of tunable parameters\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\nextern int_T ssWriteRTWParameters(SimStruct* S, int_T nParams, ...);\n\n/**\n * @brief ssWriteRTWParamSettings\n *\n * Write values of nontunable parameters to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  nParams Number of parameter settings.\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\nextern int_T ssWriteRTWParamSettings(SimStruct* S, int_T nParams, ...);\n\n\n/**\n * @brief ssWriteRTWScalarParam\n *\n * Write a scalar parameter to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  n       Parameter name.\n * @param  v       Parameter value.\n * @param  dt      Integer ID of the type of the parameter value.\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\n#define ssWriteRTWScalarParam(S, n, v, dt) \\\n    ssWriteRTWNameValuePair(S, SSWRITE_VALUE_DTYPE_NUM, n, v, dt)\n\n\n\n/**\n * @brief ssWriteRTWStr\n *\n * Write a character vector to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  str     Character vector.\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\nextern int_T ssWriteRTWStr(SimStruct* S, const char_T* str);\n\n/**\n * @brief ssWriteRTWStrParam\n *\n * Write a character vector parameter to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  n       Parameter name.\n * @param  v       Parameter value.\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\n#define ssWriteRTWStrParam(S, n, v) ssWriteRTWNameValuePair(S, SSWRITE_VALUE_QSTR, n, v)\n\n\n/**\n * @brief ssWriteRTWStrVectParam\n *\n * Write a vector of character vector parameters to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  n       Parameter name.\n * @param  v       Parameter value.\n * @param  len     Number of elements in the vector.\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\n#define ssWriteRTWStrVectParam(S, n, v, len) \\\n    ssWriteRTWNameValuePair(S, SSWRITE_VALUE_VECT_STR, n, v, len)\n\n/**\n * @brief ssWriteRTWVectParam\n *\n * Write a vector parameter to the model.rtw file\n * @param  S       SimStruct representing an S-Function block.\n * @param  n       Parameter name.\n * @param  v       Parameter value.\n * @param  dt      Data type of the parameter elements.\n * @param  len     Number of elements in the vector.\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\n#define ssWriteRTWVectParam(S, n, v, dt, len) \\\n    ssWriteRTWNameValuePair(S, SSWRITE_VALUE_DTYPE_VECT, n, v, dt, len)\n\n/**\n * @brief ssWriteRTWWorkVect\n *\n * Write work vectors to the model.rtw file\n * @param  S         SimStruct representing an S-Function block.\n * @param  vectName  Name of the work vector.\n * @param  nNames    Number of names\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\n * function.\n */\nextern int_T ssWriteRTWWorkVect(SimStruct* S, const char_T* vectName, int_T nNames, ...);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n/** @} */ /* end of StateWorkVector */\n\n/** @defgroup ErrorHandling Error Handling\n *  @{\n */\n\n/*======================================*\n * Error Handling *\n *======================================*/\n\n/**\n * @brief ssPrintf\n *\n * Print a variable-content message\n * @param msg Must be a ANSI C printf-style character vector with optional variable replacement\n * parameters.\n * @return A positive value indicating the number of bytes transmitted. Returns a negative number\n * indicating an error.\n *\n * @brief ssWarning\n *\n * Display a warning message\n * @param S Simstruct representing an S-Function block or a Simulink model.\n * @param msg Warning message\n */\n#if !SS_SL_INTERNAL\n#if SS_SFCN_FOR_SIM\n\n#define SS_STDIO_AVAILABLE\n#define ssPrintf mexPrintf\nextern\n#ifdef __cplusplus\n    \"C\"\n#endif\n    void\n    ssWarning(SimStruct*, const char* msg);\n#elif SS_HAVESTDIO /* for Real-Time Workshop with stdio facilities */\n#include <stdio.h>\n#define SS_STDIO_AVAILABLE\n#define ssPrintf printf\n#define ssWarning(S, msg) printf(\"Warning: block '%s': %s\\n\", ssGetPath(S), msg)\n#else /* for Real-Time Workshop without stdio facilities */\nextern int rtPrintfNoOp(const char* fmt, ...);\n#undef SS_STDIO_AVAILABLE\n#define ssPrintf rtPrintfNoOp\n#define ssWarning(S, msg) /* do nothing */\n#endif\n#endif\n\n/**\n * @brief ssGetErrorStatus\n *\n * Get a character vector that identifies the last error\n * @param  S      SimStruct representing an S-Function block.\n * @return A pointer (char_T *) to a character vector that identifies the last error message.\n */\n#define ssGetErrorStatus(S) ssGetRootSS(S)->errorStatus.str /* (const char_T*) */\n\n/**\n * @brief ssSetErrorStatus\n *\n * report an error\n * @param  S       SimStruct representing an S-Function block or a Simulink model\n * @param  string  Error message\n */\n#define ssSetErrorStatus(S, string)                              \\\n    {                                                            \\\n        ssGetRootSS(S)->mdlInfo->mdlFlags.errorStatusIsMsg = 0U; \\\n        ssGetRootSS(S)->errorStatus.str = (string);              \\\n    }\n\n/**\n * @brief ssGetLocalErrorStatus\n *\n * Get a character vector that identifies the last error\n * @param  S      SimStruct representing an S-Function block.\n * @return A pointer (char_T *) to a character vector that identifies the last error message.\n */\n#define ssGetLocalErrorStatus(S) S->blkInfo.blkInfo2->localErrorStatus.str /* (const char_T*) */\n\n/**\n * @brief ssSetLocalErrorStatus\n *\n * report an error\n * @param  S       SimStruct representing an S-Function block or a Simulink model\n * @param  string  Error message\n */\n#define ssSetLocalErrorStatus(S, string)                          \\\n    {                                                             \\\n        (S)->blkInfo.sfcnFlags.localErrorStatusIsMsg = 0U;        \\\n        if (S->blkInfo.blkInfo2->localErrorStatus.str == NULL ||  \\\n            (const char_T*)(string) == NULL) {                    \\\n            S->blkInfo.blkInfo2->localErrorStatus.str = (string); \\\n        }                                                         \\\n    }\n\n/** @} */ /* end of ErrorHandling */\n\n/** @defgroup InfoOptions Information and Options\n *  @{\n */\n\n/*======================================*\n * Information and Options *\n *======================================*/\n\n/**\n * @brief ssGetModelName\n *\n * Get the model name\n * @param  S     SimStruct pointer\n * @return The name of the S-function MEX-file associated with the block if S is a SimStruct for an\n * S-Function block. If S is the root SimStruct, this macro returns the name of the Simulink block\n * diagram.\n */\n#define ssGetModelName(S) (S)->modelName /* (const char_T*) */\n\n/**\n * @brief ssSetOptions\n *\n * Specify S-function options\n * @param  S     SimStruct pointer\n * @param  opts  S-Function Options\n */\n#define ssSetOptions(S, opts) (S)->sizes.options = (opts)\n\n\n/**\n * @brief ssGetParentSS\n *\n * Get the parent of a SimStruct\n * @param  S     SimStruct pointer\n * @return The parent SimStruct of S, or NULL if S is the root SimStruct.\n */\n#define ssGetParentSS(S) (S)->parent /*   (SimStruct *) */\n\n/**\n * @brief ssGetPath\n *\n * Get the path of a block\n * @param  S     SimStruct representing an S-function block or a Simulink model.\n * @return A pointer (char_T *) to a character vector containing the path to a block.\n */\n#define ssGetPath(S) (S)->path /* (const char_T*) */\n\n/**\n * @brief ssGetRootSS\n *\n * Get the root of a SimStruct hierarchy\n * @param  S     SimStruct representing an S-function block or a Simulink model.\n * @return The SimStruct at the root of the SimStruct hierarchy.\n */\n#define ssGetRootSS(S) (S)->root /*   (SimStruct *) */\n\n/**\n * @brief ssGetUserData\n *\n * Access the user data\n * @param  S     SimStruct representing an S-function block.\n * @return A pointer (void *) to the S-function's user data\n */\n#define ssGetUserData(S) (S)->work.userData /*   (void *)      */\n\n\n/**\n * @brief ssSetPlacementGroup\n *\n * Specify the name of the placement group of a block\n * @param  S     SimStruct representing an S-Function block. The block must be either a source block\n * (i.e., a block without input ports) or a sink block (i.e., a block without output ports).\n * @param  name    Name of the placement group of the block represented by S.\n */\n#define ssSetPlacementGroup(S, name) (S)->blkInfo.placementGroup = (name)\n\n/**\n * @brief ssSetUserData\n *\n * Specify user data\n * @param  S     SimStruct representing an S-Function block.\n * @param  userDataPtr  User data\n */\n#define ssSetUserData(S, userDataPtr) (S)->work.userData = (userDataPtr)\n\n/**\n * @brief ssGetOwnerBlock\n *\n * Get the owner block of an S-function block\n * @param  S     SimStruct representing an S-Function block.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#if !SS_SFCN_LEVEL_1\n#define ssGetOwnerBlock(S) ((S)->blkInfo.block)\n#endif\n#if !SS_SFCN\n#define ssSetOwnerBlock(S, block) (S)->blkInfo.block = (block)\n#else\n#define ssSetOwnerBlock(S, block) ssSetOwnerBlock_cannot_be_used_in_SFunctions\n#endif\n#endif\n\n/**\n * @brief ssSupportsMultipleExecInstances\n *\n * Specify that a For Each Subsystem block supports an S-function operating inside the subsystem.\n * @param  S      SimStruct representing an S-Function block.\n * @param  value  A character vector have a value of either true or false. If true, then the For\n * Each Subsystem will support having an S-function operate inside of it.\n */\n#if (SS_SL_INTERNAL || SS_SFCN_FOR_SIM) && defined(ssGetOwnerBlock)\n#define ssSupportsMultipleExecInstances(S, value)                                           \\\n    {                                                                                       \\\n        if (ssGetOwnerBlock(S) != NULL) {                                                   \\\n            boolean_T val = value;                                                          \\\n            _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SUP_MULTI_EXEC_INSTANCES, 0, &val) \\\n                _ssSafelyCallGenericFcnEnd;                                                 \\\n        }                                                                                   \\\n    }\n#else\n#define ssSupportsMultipleExecInstances(S, value)\n#endif\n\n/** @} */ /* end of InfoOptiopns */\n\n/** @defgroup SimulinkFunctionAPI S-Function API for Simulink Functions\n *  @{\n */\n\n/*======================================*\n * Simulink Function API for registering,\n * accessing Simulink Functions *\n *======================================*/\n\ntypedef enum { SS_SIMULINK_FUNCTION_QUERY_IS_DECLARED } SSSimulinkFunctionQueryType;\n\ntypedef enum { SS_SCOPED_VISIBILITY, SS_GLOBAL_VISIBILITY } SSSimulinkFunctionVisibility;\n\ntypedef struct ssFunctionQueryInfo_tag {\n    const char* scopedFcnName;\n    SSSimulinkFunctionQueryType queryType;\n    boolean_T queryResult;\n    void* reservedForFuture[4];\n} _ssFunctionQueryInfo;\n\ntypedef struct ssFunctionExecArguments_tag {\n    const char* scopedFcnName;\n    int numInArgs;\n    _ssFcnCallExecArgInfo* inArgs;\n    int numOutArgs;\n    _ssFcnCallExecArgInfo* outArgs;\n} _ssFunctionExecArguments;\n\ntypedef void (*SSSimulinkFunctionPtr)(SimStruct*, int, _ssFcnCallExecArgs*);\n\ntypedef struct ssFunctionAttributeInfo_tag {\n    const char* fcnPrototype;\n    SSSimulinkFunctionVisibility fcnVisibility;\n    SSSimulinkFunctionPtr fcnPtr;\n    void* reservedForFuture[4];\n} _ssFunctionAttributeInfo;\n\ntypedef enum {\n    SS_SIMULINK_FUNCTION_ARG_DIMS,\n    SS_SIMULINK_FUNCTION_ARG_DTYPE,\n    SS_SIMULINK_FUNCTION_ARG_CPLX\n} SSFunctionArgAttributeType;\n\ntypedef struct ssFunctionArgAttributeInfo_tag {\n    const char* scopedFcnName;\n    const char* argName;\n    int argDT;\n    int argNumDims;\n    size_t* argDims;\n    int argCplx;\n    SSFunctionArgAttributeType argAttrToSet;\n    void* reservedForFuture[4];\n} _ssFunctionArgAttributeInfo;\n\n#if SS_SFCN && SS_SIM\n/*\n * Note that in ssQuerySimulinkFunction, there is an extra () around the macro\n * definition, and this is to allow returning a boolean result for the query.\n */\n\n/**\n * @brief ssQuerySimulinkFunction\n *\n * @param  S         SimStruct representing an S-Function block\n * @param scopedName Name of function being queried.\n * @param query      Enumeration of type SSSimulinkFunctionQueryType\n * @return           Boolean result of query\n */\n#define ssQuerySimulinkFunction(S, scopedName, query)                                           \\\n    ({                                                                                          \\\n        _ssFunctionQueryInfo locQueryInfo;                                                      \\\n        locQueryInfo.scopedFcnName = scopedName;                                                \\\n        locQueryInfo.queryType = query;                                                         \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_QUERY_SIMULINK_FUNCTION, 0, &locQueryInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                         \\\n        locQueryInfo.queryResult;                                                               \\\n    })\n\n/**\n * @brief ssDeclareSimulinkFunction\n *\n * Declares either a global or scoped function\n * @param  S     SimStruct representing an S-Function block\n * @param proto  Prototype of function being declared.\n * @param ptr    Pointer to C function\n * @param vis    Visibility of function\n */\n#define ssDeclareSimulinkFunction(S, proto, ptr, vis)                                            \\\n    {                                                                                            \\\n        _ssFunctionAttributeInfo locAttrInfo;                                                    \\\n        locAttrInfo.fcnPrototype = proto;                                                        \\\n        locAttrInfo.fcnVisibility = vis;                                                         \\\n        locAttrInfo.fcnPtr = ptr;                                                                \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_DECLARE_SIMULINK_FUNCTION, 0, &locAttrInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                          \\\n    }\n\n/**\n * @brief ssDeclareFunctionCaller\n *\n * @param  S     SimStruct representing an S-Function block\n * @param  proto Prototype of function that will be called\n */\n#define ssDeclareFunctionCaller(S, proto)                                                        \\\n    {                                                                                            \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_DECLARE_SIMULINK_FUNCTION_CALLER, 0, proto) \\\n            _ssSafelyCallGenericFcnEnd;                                                          \\\n    }\n\n/**\n * @brief ssCallSimulinkFunction\n *\n * @param  S            SimStruct representing an S-Function block\n * @param  scopedName   Scoped name of called function\n * @param  nArgin       Number of input arguments\n * @param  argins       Array of void * pointer to input arguments\n * @param  nArgout      Number of output arguments\n * @param  argouts      Array of void * pointer to output arguments\n */\n#define ssCallSimulinkFunction(S, scopedName, nArgin, argins, nArgout, argouts)               \\\n    {                                                                                         \\\n        _ssFunctionExecArguments locExecArgs;                                                 \\\n        locExecArgs.scopedFcnName = scopedName;                                               \\\n        locExecArgs.numInArgs = nArgin;                                                       \\\n        locExecArgs.inArgs = argins;                                                          \\\n        locExecArgs.numOutArgs = nArgout;                                                     \\\n        locExecArgs.outArgs = argouts;                                                        \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_CALL_SIMULINK_FUNCTION, 0, &locExecArgs) \\\n            _ssSafelyCallGenericFcnEnd;                                                       \\\n    }\n\n/**\n * @brief ssGetSimulinkFunctionInput\n *\n * @param args  Pointer to arguments passed to called C function\n * @param idx   Index of input argument\n */\n#define ssGetSimulinkFunctionInput(args, idx) ((args)->inArgs[(idx)].dataPtr)\n\n/**\n * @brief ssGetSimulinkFunctionOutput\n *\n * @param args  Pointer to arguments passed to called C function\n * @param idx   Index of output argument\n */\n#define ssGetSimulinkFunctionOutput(args, idx) ((args)->outArgs[(idx)].dataPtr)\n\n/**\n * @brief ssSetSimulinkFunctionArgComplexity\n *\n * @param  S          SimStruct representing an S-Function block\n * @param scopedName  Name of function (or scoped name when the function is being called)\n * @param arg         Name of argument\n * @param val         Complexity of argument\n */\n#define ssSetSimulinkFunctionArgComplexity(S, scopedName, arg, val)                               \\\n    {                                                                                             \\\n        _ssFunctionArgAttributeInfo locAttrInfo;                                                  \\\n        locAttrInfo.scopedFcnName = scopedName;                                                   \\\n        locAttrInfo.argName = arg;                                                                \\\n        locAttrInfo.argCplx = (int)val;                                                           \\\n        locAttrInfo.argAttrToSet = SS_SIMULINK_FUNCTION_ARG_CPLX;                                 \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SIMULINK_FUNCTION_ARGUMENT, 0, &locAttrInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                           \\\n    }\n\n/**\n * @brief ssSetSimulinkFunctionArgDataType\n *\n * @param  S     SimStruct representing an S-Function block\n * @param scopedName  Name of function (or scoped name when the function is being called)\n * @param arg         Name of argument\n * @param val         Data type of argument\n */\n#define ssSetSimulinkFunctionArgDataType(S, scopedName, arg, val)                                 \\\n    {                                                                                             \\\n        _ssFunctionArgAttributeInfo locAttrInfo;                                                  \\\n        locAttrInfo.scopedFcnName = scopedName;                                                   \\\n        locAttrInfo.argName = arg;                                                                \\\n        locAttrInfo.argDT = (int)val;                                                             \\\n        locAttrInfo.argAttrToSet = SS_SIMULINK_FUNCTION_ARG_DTYPE;                                \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SIMULINK_FUNCTION_ARGUMENT, 0, &locAttrInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                           \\\n    }\n\n/**\n * @brief ssSetSimulinkFunctionArgDimensions\n *\n * @param  S          SimStruct representing an S-Function block\n * @param scopedName  Name of function (or scoped name when the function is being called)\n * @param arg         Name of argument\n * @param nDims       Number of dimensions of argument\n * @param val         Integer array of dimensions.\n */\n#define ssSetSimulinkFunctionArgDimensions(S, scopedName, arg, nDims, val)                        \\\n    {                                                                                             \\\n        _ssFunctionArgAttributeInfo locAttrInfo;                                                  \\\n        locAttrInfo.scopedFcnName = scopedName;                                                   \\\n        locAttrInfo.argName = arg;                                                                \\\n        locAttrInfo.argNumDims = nDims;                                                           \\\n        locAttrInfo.argDims = (size_t*)val;                                                       \\\n        locAttrInfo.argAttrToSet = SS_SIMULINK_FUNCTION_ARG_DIMS;                                 \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SIMULINK_FUNCTION_ARGUMENT, 0, &locAttrInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                           \\\n    }\n#endif\n\n/**\n * @brief ssSetArrayLayoutForCodeGen\n *\n * @param S         SimStruct representing an S-Function block\n * @param majority  Type of the array layout configuration of the S-Function TLC\n */\n#define ssSetArrayLayoutForCodeGen(S, majority) \\\n    (S)->blkInfo.sfcnFlags.sCodeGenArrayLayout = (majority)\n\n/** @} */ /* end of SFunctionAPI */\n\n/** @defgroup SigRegion Signal Region APIs\n *  @{\n */\n\n/*======================================*\n * Signal Region                        *\n *======================================*/\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n\n/**\n * @brief ssCallSelectedSignalsFcn\n *\n * Get a list of selected output ports in the current graph.  These ports may be used\n * in ssCallSigListCreateFcn to access the data for these ports.\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidBlock        S-Function block (see ssGetOwnerBlock)\n * @param sigSetOpt        SIGSET_GRAPH or SIGSET_GRAPH_N_CHILDREN\n * @param voidOutPortObjs  Array of port objects;  free using ssCallGenericDestroyFcn\n * @param outnPortObjs     Number of ports returned\n */\n#define ssCallSelectedSignalsFcn(S, voidBlock, sigSetOpt, voidOutPortObjs, outnPortObjs)     \\\n    (S)->mdlInfo->signalAccess->SelectedSignals((voidBlock), (sigSetOpt), (voidOutPortObjs), \\\n                                                (outnPortObjs))\n\n/**\n * @brief ssCallGenericDestroyFcn\n *\n * Free a Free a port list obtained from ssCallSelectedSignalsFcn\n *\n * @param S                SimStruct representing an S-Function block\n * @param ptr              Port list to destroy\n */\n#define ssCallGenericDestroyFcn(S, ptr) (S)->mdlInfo->signalAccess->utFree((ptr))\n\n/**\n * @brief ssCallSigListCreateFcn\n *\n * Get the \"signal list\" for a given set of ports.  This is used to access data for\n * the given signals\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidBlock        S-Function (see ssGetOwnerBlock)\n * @param nPorts           Number of ports in voidPortObjs\n * @param voidPortObjs     Array of port objects from ssCallSelectedSignalsFcn\n * @param excludeFlags     Options of what to exclude\n * @param voidOutSigList   SL_SigList returned; free using ssCallSigListDestroyFcn\n */\n#define ssCallSigListCreateFcn(S, voidBlock, nPorts, voidPortObjs, excludeFlags, voidOutSigList) \\\n    (S)->mdlInfo->signalAccess->SigListCreate((voidBlock), (nPorts), (voidPortObjs),             \\\n                                              (excludeFlags), (voidOutSigList))\n\n/**\n * @brief ssCallSigListDestroyFcn\n *\n * Free a SL_SigList created from ssCallSigListCreateFcn\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidSigList      SL_SigList to destroy\n */\n#define ssCallSigListDestroyFcn(S, voidSigList) \\\n    (S)->mdlInfo->signalAccess->SigListDestroy((voidSigList))\n\n/**\n * @brief ssCallSigListUnavailSigAlertFcn\n *\n * Report an error if any signals in the signal list are not available\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidSigList      SL_SigList\n */\n#define ssCallSigListUnavailSigAlertFcn(S, voidSigList) \\\n    (S)->mdlInfo->signalAccess->SigListUnavailSigAlert((voidSigList))\n\n/**\n * @brief ssCallUnselectSigFcn\n *\n * Un-select a given port from the signal list\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidPortObj      Port pointer from ssCallSelectedSignalsFcn\n */\n#define ssCallUnselectSigFcn(S, voidPortObj) (S)->mdlInfo->signalAccess->UnselectSig((voidPortObj))\n\n/**\n * @brief ssCallGetPortNameFcn\n *\n * Get the name for a given port. Returns a const char *\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidPortObj      Port pointer from ssCallSelectedSignalsFcn\n */\n#define ssCallGetPortNameFcn(S, voidPortObj) (S)->mdlInfo->signalAccess->GetPortName((voidPortObj))\n\n/**\n * @brief ssCallSigListGetNumRegionsFcn\n *\n * Get the number of regions in the idx-th element of the signal list.\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidSigList      SL_SigList\n * @param idx              Index within the signal list\n */\n#define ssCallSigListGetNumRegionsFcn(S, voidSigList, idx) \\\n    (S)->mdlInfo->signalAccess->SigListGetNumRegions((voidSigList), (idx))\n\n/**\n * @brief ssCallSigListGetFirstRegFcn\n *\n * Get the first signal region of the idx-th element of the signal list.\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidSigList      SL_SigList\n * @param idx              Index within the signal list\n */\n#define ssCallSigListGetFirstRegFcn(S, voidSigList, idx) \\\n    (S)->mdlInfo->signalAccess->SigListGetFirstReg((voidSigList), (idx))\n\n/**\n * @brief ssCallSigListGetNumElementsFcn\n *\n * Get the total number of elements in the idx-th element of the signal list.\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidSigList      SL_SigList\n * @param idx              Index within the signal list\n */\n#define ssCallSigListGetNumElementsFcn(S, voidSigList, idx) \\\n    (S)->mdlInfo->signalAccess->SigListGetNumElements((voidSigList), (idx))\n\n/**\n * @brief ssCallSigListGetIfTieWrapFcn\n *\n * Return true if the idx-th element of the signal list is a \"tie wrap\"\n *\n * @param S                SimStruct representing an S-Function block\n * @param voidSigList      SL_SigList\n * @param idx              Index within the signal list\n */\n#define ssCallSigListGetIfTieWrapFcn(S, voidSigList, idx) \\\n    (S)->mdlInfo->signalAccess->SigListGetIfTieWrap((voidSigList), (idx))\n\n#endif\n/** @} */ /* end of SigRegion */\n\n#define ssSetSimStruct(S, srcS) (S)->work.localMdlInfo->simStruct = ((void*)(srcS))\n\n#define ssGetSimStruct(S) (S)->work.localMdlInfo->simStruct\n\n#ifndef USE_PUBLISHED_ONLY\n#include \"simstruc_internal.h\"\n#else\n#include \"simstruc_implement.h\"\n#endif\n\n#endif /* __SIMSTRUC__ */\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n/* EOF: simstruc.h */\n"},{"name":"simstruc_64_internal.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2020-2021 The MathWorks, Inc. */\n\n#ifndef __SIMSTRUC_64_INTERNAL__\n#define __SIMSTRUC_64_INTERNAL__\n\n#if !defined(IS_RSIM) && !defined(IS_RAPID_ACCEL)\n#include \"sl_utility/simstruct_bridge_utils.hpp\"\n#endif\n\n/* defined in simstruc.h */\n/*_ssPortInfo*/\n#define ssGetInputPortWidth(S, port)                                 \\\n    (isSimStruct64FeatureOn ? ssGetInputPortWidthSLSize_fwd(S, port) \\\n                            : ssGetInputPortWidth_fwd(S, port))\n#define ssSetInputPortWidth(S, port, val)                                 \\\n    (isSimStruct64FeatureOn ? ssSetInputPortWidthSLSize_fwd(S, port, val) \\\n                            : ssSetInputPortWidth_fwd(S, port, val))\n#define ssGetOutputPortWidth(S, port)                                 \\\n    (isSimStruct64FeatureOn ? ssGetOutputPortWidthSLSize_fwd(S, port) \\\n                            : ssGetOutputPortWidth_fwd(S, port))\n#define ssSetOutputPortWidth(S, port, val)                                 \\\n    (isSimStruct64FeatureOn ? ssSetOutputPortWidthSLSize_fwd(S, port, val) \\\n                            : ssSetOutputPortWidth_fwd(S, port, val))\n#define ssGetInputPortDimensions(S, port)                                 \\\n    (isSimStruct64FeatureOn ? ssGetInputPortDimensionsSLSize_fwd(S, port) \\\n                            : ssGetInputPortDimensions_fwd(S, port))\n#define ssGetInputPortDimensionSize(S, port, dIdx)                                  \\\n    (isSimStruct64FeatureOn ? ssGetInputPortDimensionsSizeSLSize_fwd(S, port, dIdx) \\\n                            : ssGetInputPortDimensionSize_fwd(S, port, dIdx))\n#define ssGetOutputPortDimensions(S, port)                                 \\\n    (isSimStruct64FeatureOn ? ssGetOutputPortDimensionsSLSize_fwd(S, port) \\\n                            : ssGetOutputPortDimensions_fwd(S, port))\n#define ssGetOutputPortDimensionSize(S, port, dIdx)                                  \\\n    (isSimStruct64FeatureOn ? ssGetOutputPortDimensionsSizeSLSize_fwd(S, port, dIdx) \\\n                            : ssGetOutputPortDimensionSize_fwd(S, port, dIdx))\n\n/*_ssSizes*/\n#define ssGetNumY(S) (isSimStruct64FeatureOn ? ssGetNumYSLSize_fwd(S) : ssGetNumY_fwd(S))\n#define ssSetNumY(S, nY) \\\n    (isSimStruct64FeatureOn ? ssSetNumYSLSize_fwd(S, nY) : ssSetNumY_fwd(S, nY))\n#define ssGetSizeofY(S) (isSimStruct64FeatureOn ? ssGetSizeofYSLSize_fwd(S) : ssGetSizeofY_fwd(S))\n#define ssSetSizeofY(S, nY) \\\n    (isSimStruct64FeatureOn ? ssSetSizeofYSLSize_fwd(S, nY) : ssSetSizeofY_fwd(S, nY))\n#define ssGetNumU(S) (isSimStruct64FeatureOn ? ssGetNumUSLSize_fwd(S) : ssGetNumU_fwd(S))\n#define ssSetNumU(S, nY) \\\n    (isSimStruct64FeatureOn ? ssSetNumUSLSize_fwd(S, nY) : ssSetNumU_fwd(S, nY))\n#define ssGetSizeofU(S) (isSimStruct64FeatureOn ? ssGetSizeofUSLSize_fwd(S) : ssGetSizeofU_fwd(S))\n#define ssSetSizeofU(S, nY) \\\n    (isSimStruct64FeatureOn ? ssSetSizeofUSLSize_fwd(S, nY) : ssSetSizeofU_fwd(S, nY))\n\n/*_ssWork*/\n#define ssGetDWorkWidth(S, index) \\\n    (isSimStruct64FeatureOn ? ssGetDWorkWidthSLSize_fwd(S, index) : ssGetDWorkWidth_fwd(S, index))\n#define ssSetDWorkWidth(S, index, val)                                 \\\n    (isSimStruct64FeatureOn ? ssSetDWorkWidthSLSize_fwd(S, index, val) \\\n                            : ssSetDWorkWidth_fwd(S, index, val))\n#endif\n"},{"name":"simstruc_compcond.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2017 The MathWorks, Inc. */\n\n/**\n * @file: simstruc_compcond.h\n *\n * @brief Defines controlling conditional compilation\n *\n */\n\n#ifndef __SIMSTRUC_COMPCOND__\n#define __SIMSTRUC_COMPCOND__\n\n/*===========================================================================*\n * BEGIN SECTION\n * LIST OF KEY DEFINES CONTROLLING CONDITIONAL COMPILATION\n *\n * Simstruc properties such as definitions, access methods, etc.\n * are conditionally compiled depending on \"who\" is using the simstruc\n * and in what mode.\n *\n * This section list all the key #define macros controlling the inclusion/\n * exclusion of features, definitions, etc.\n *\n * Typically, this section only assigns a default value (such as false).\n * The final value is adjusted in a subsequent section.\n *===========================================================================*/\n\n/*=======================================================*\n * MODE: SINGLE-TASKING OR MULTI-TASKING\n */\n#define SS_MULTITASKING (0)\n\n/*=======================================================*\n * MODE: SIMULATION OR GENERATED CODE\n *\n * The following #defines determine whether the simstruc is used in \"normal\"\n * Simulink simulation or in Real Time Workshop generated code.\n *\n * This is designed to be a mutually exclusive set.\n * One and only one should be defined to be true.\n */\n#define SS_SIM (0)\n#define SS_RTW (0)\n\n/*=======================================================*\n * MODE: WHO IS USING THE SIMSTRUC\n *\n * The following #defines determine \"who\" is using the simstruc.\n *\n * This is designed to be a mutually exclusive set.\n * One and only one should be defined to be true.\n */\n#define SS_SFCN_LEVEL_1 (0)\n#define SS_SFCN_NORMAL (0)\n#define SS_GENERATED_S_FUNCTION (0)\n#define SS_SL_INTERNAL (0)\n#define SS_RTW_INTERNAL (0)\n#define SS_SHARED_MODULE (0)\n\n/*=======================================================*\n * MODE: GENERATED CODE IS REAL-TIME OR NON-REAL-TIME\n *\n * Both can be false, but both can't be true\n */\n#define SS_RT (0)\n#define SS_NRT (0)\n\n/*=======================================================*\n * MODE: ENFORCE NDEBUG\n */\n#define SS_NDEBUG (0)\n\n/*=======================================================*\n * MODE: ENVIRONMENT HAS STANDARD IO AVAILABLE\n */\n#define SS_HAVESTDIO (0)\n\n/*=======================================================*\n * MODE: TID_EQUALS_SAMPLE_TIME_INDEX -\n *     The model will function correctly if this define is false, however if\n *     this define is true the model's performance may be increased depending\n *     upon whether or not the model has fast to slow rate transitions.\n */\n#define TID_EQUALS_SAMPLE_TIME_INDEX (0)\n\n/*=======================================================*\n * MODE: TID01EQ == 1\n */\n#define SS_TID01EQ_EQUAL_ONE (0)\n\n/*===========================================================================*\n * END SECTION\n * LIST OF KEY DEFINES CONTROLLING CONDITIONAL COMPILATION\n *===========================================================================*/\n\n#ifndef _SIMSTRUCT\n#define _SIMSTRUCT\n/*\n * Use incomplete type for function prototypes within SimStruct itself\n */\ntypedef struct SimStruct_tag SimStruct;\n#endif\n\n/*=================*\n * Nested includes *\n *=================*/\n#include <limits.h>\n#include <string.h>\n#include \"simstruc_types.h\"\n#include \"solver_zc.h\"\n\n#include \"stdio.h\"\n\n/*===========================================================================*\n * BEGIN SECTION\n * DETERMINE FINAL VALUES OF KEY DEFINES CONTROLLING CONDITIONAL COMPILATION\n *===========================================================================*/\n\n/*====================================*\n * Model reference sim target is an RTW generated\n * S-Function (from the point view of Simstruct).\n */\n#if defined(MDL_REF_SIM_TGT)\n\n#undef MATLAB_MEX_FILE\n#define MATLAB_MEX_FILE (1)\n\n#undef RTW_GENERATED_S_FUNCTION\n#define RTW_GENERATED_S_FUNCTION (1)\n\n#endif\n\n/*====================================*\n * Determine => MODE: SINGLE-TASKING OR MULTI-TASKING\n *\n * This must come after the inclusion of simstruc_types.h\n */\n#if defined(MULTITASKING)\n#undef SS_MULTITASKING\n#define SS_MULTITASKING (1)\n#endif\n\n/*====================================*\n * Determine => MODE: SIMULATION OR GENERATED CODE\n */\n#if defined(MATLAB_MEX_FILE) || defined(SL_INTERNAL) || defined(FIPXT_SHARED_MODULE)\n#undef SS_SIM\n#define SS_SIM (1)\n#else\n#undef SS_RTW\n#define SS_RTW (1)\n#endif\n\n/*====================================*\n * Determine => MODE: WHO IS USING THE SIMSTRUC\n */\n#if !defined(S_FUNCTION_LEVEL)\n#if defined(S_FUNCTION_NAME)\n#define S_FUNCTION_LEVEL 1 /* Backwards compatibility old S-functions */\n#else\n#define S_FUNCTION_LEVEL 2\n#endif\n#endif\n\n#if S_FUNCTION_LEVEL != 1 && S_FUNCTION_LEVEL != 2\n#error Invalid S_FUNCTION_LEVEL\n#endif\n\n#if defined(RTW_GENERATED_S_FUNCTION)\n/*\n * Used by RTW Generated S Function, ex  s-fcn target.\n * This flag is independent of how the\n * s-function is built (i.e., it is a #define in the code, not a build\n * flag).  It is true when building the s-function for use with simulink and\n * when building the s-function for use with RTW.\n */\n#undef SS_GENERATED_S_FUNCTION\n#define SS_GENERATED_S_FUNCTION (1)\n\n#elif S_FUNCTION_LEVEL == 1\n/*\n * Used with any LEVEL 1 s-function (user written) including:\n *  o build for use with a normal simulation (via mex command)\n *  o build for use with rtw (grt)\n */\n#undef SS_SFCN_LEVEL_1\n#define SS_SFCN_LEVEL_1 (1)\n\n#elif defined(S_FUNCTION_NAME)\n/*\n * Used with any s-function (user written) including:\n *  o build for use with a normal simulation (via mex command)\n *  o build for use with rtw (grt)\n */\n#undef SS_SFCN_NORMAL\n#define SS_SFCN_NORMAL (1)\n\n#elif defined(SL_INTERNAL) || defined(RSIM_WITH_SL_SOLVER)\n/*\n * Used internally by Simulink (simulink.dll).\n */\n#undef SS_SL_INTERNAL\n#define SS_SL_INTERNAL (1)\n\n#elif defined(RT) || defined(NRT)\n/*\n * Used in \"root\" model of generated code, but not in\n * non-inlined, s-functions being compiled for use with the\n * generated code (i.e., rt_main and model.c have access, but\n * sfunc.c does not).\n */\n#undef SS_RTW_INTERNAL\n#define SS_RTW_INTERNAL (1)\n\n#elif defined(FIPXT_SHARED_MODULE)\n/*\n * Used in shared module (such as a dll) that needs to be able to\n * use some feature of the simstruc.\n */\n/*\n * Currently, shared module will be treated as if they are\n * normal sfunctions.\n *\n# undef  SS_SHARED_MODULE\n# define SS_SHARED_MODULE  (1)\n*/\n#undef SS_SFCN_NORMAL\n#define SS_SFCN_NORMAL (1)\n\n#elif defined(MATLAB_MEX_FILE)\n/*  Used in mex function that is NOT an S-Function mex\n */\n/*\n * Currently, plain mex functions will be treated as if they are\n * normal sfunctions.\n *\n# undef  SS_MEX\n# define SS_MEX  (1)\n*/\n#undef SS_SFCN_NORMAL\n#define SS_SFCN_NORMAL (1)\n\n#else\n#error Unrecognized use.\n#endif\n\n/*=======================================================*\n * Determine => MODE: GENERATED CODE IS REAL-TIME OR NON-REAL-TIME\n */\n#if defined(RT)\n#undef SS_RT\n#define SS_RT (1)\n#endif\n#if defined(NRT)\n#undef SS_NRT\n#define SS_NRT (1)\n#endif\n\n/*=======================================================*\n * Determine => MODE: ENFORCE NDEBUG\n */\n#if defined(NDEBUG) /* sbcheck: ok(NDEBUG) */\n#undef SS_NDEBUG\n#define SS_NDEBUG (1)\n#endif\n\n/*=======================================================*\n * Determine => MODE: ENVIRONMENT HAS STANDARD IO AVAILABLE\n */\n#if defined(HAVESTDIO)\n#undef SS_HAVESTDIO\n#define SS_HAVESTDIO (1)\n#endif\n\n/*=======================================================*\n * Determine => MODE: TID_EQUALS_SAMPLE_TIME_INDEX -\n */\n#if SS_SL_INTERNAL\n#undef TID_EQUALS_SAMPLE_TIME_INDEX\n#define TID_EQUALS_SAMPLE_TIME_INDEX (1)\n#else\n#if defined(NUMST) && defined(NSAMPLE_TIMES)\n#if NUMST < NSAMPLE_TIMES\n#error NUMST specified incorrectly\n#elif NUMST == NSAMPLE_TIMES\n#undef TID_EQUALS_SAMPLE_TIME_INDEX\n#define TID_EQUALS_SAMPLE_TIME_INDEX (1)\n#endif\n#endif\n#endif\n\n/*=======================================================*\n * Determine => MODE: TID01EQ == 1\n */\n#if defined(TID01EQ)\n#if TID01EQ == 1\n#undef SS_TID01EQ_EQUAL_ONE\n#define SS_TID01EQ_EQUAL_ONE (1)\n#endif\n#endif\n\n/*=======================================================*\n * Determine => MODE: ACCESS 32-BIT OR 64-BIT OR BOTH SIMSTRUCT FIELDS\n */\n#if defined(SFCN64)\n#define USE_64BIT_FIELDS\n#elif (defined(SL_INTERNAL) || defined(IS_RSIM) || defined(IS_RAPID_ACCEL)) && \\\n    !(defined(RTW_GENERATED_S_FUNCTION) || defined(MATLAB_MEX_FILE) || defined(S_FUNCTION_NAME))\n#define USE_32BIT_AND_64BIT_FIELDS\n#else\n#define USE_32BIT_FIELDS\n#endif\n\n/*===========================================================================*\n * END SECTION\n * DETERMINE FINAL VALUES OF KEY DEFINES CONTROLLING CONDITIONAL COMPILATION\n *===========================================================================*/\n\n\n/*===========================================================================*\n * BEGIN SECTION\n * CHECK PROPER USAGE\n *\n * Issue errors if incompatible modes have been selected\n *===========================================================================*/\n\n#if (defined(RT) + defined(NRT) + defined(MATLAB_MEX_FILE) + defined(SL_INTERNAL) + \\\n         defined(FIPXT_SHARED_MODULE) !=                                            \\\n     1)\n#error Must define one of RT, NRT, MATLAB_MEX_FILE, SL_INTERNAL, or FIPXT_SHARED_MODULE\n#if defined(RT)\n#error defined(RT)\n#endif\n#if defined(NRT)\n#error defined(NRT)\n#endif\n#if defined(MATLAB_MEX_FILE)\n#error defined(MATLAB_MEX_FILE)\n#endif\n#if defined(SL_INTERNAL)\n#error defined(SL_INTERNAL)\n#endif\n#if defined(FIPXT_SHARED_MODULE)\n#error defined(FIPXT_SHARED_MODULE)\n#endif\n#endif\n\n#if (defined(NRT) && SS_MULTITASKING)\n#error NRT does not support MULTITASKING\n#endif\n\n#if (SS_SIM && SS_MULTITASKING)\n#error MATLAB/Simulink does not support MULTITASKING\n#endif\n\n#if (defined(USE_32BIT_FIELDS) + defined(USE_64BIT_FIELDS) + \\\n         defined(USE_32BIT_AND_64BIT_FIELDS) !=              \\\n     1)\n#error Must define one of USE_32BIT_FIELDS, USE_64BIT_FIELDS, or USE_32BIT_AND_64BIT_FIELDS\n#if defined(USE_32BIT_FIELDS)\n#error defined(USE_32BIT_FIELDS)\n#endif\n#if defined(USE_64BIT_FIELDS)\n#error defined(USE_64BIT_FIELDS)\n#endif\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n#error defined(USE_32BIT_AND_64BIT_FIELDS)\n#endif\n#endif\n\n/*===========================================================================*\n * END SECTION\n * CHECK PROPER USAGE\n *\n * Issue errors if incompatible modes have been selected\n *===========================================================================*/\n\n\n/*===========================================================================*\n * BEGIN SECTION\n * DETERMINE GROUP DEFINES\n *\n * Group defines are derived from the \"KEY DEFINES\" listed and determined\n * in previous sections.\n *===========================================================================*/\n\n#if (SS_SFCN_LEVEL_1 || SS_SFCN_NORMAL || SS_GENERATED_S_FUNCTION)\n#define SS_SFCN (1)\n#else\n#define SS_SFCN (0)\n#endif\n\n\n#define SS_SFCN_FOR_SIM (0)\n#define SS_SFCN_FOR_RTW (0)\n#if SS_SFCN\n#if SS_SIM\n/*\n * Used for s-functions (user written or s-fcn target) that are being\n * compiled for use with simulink.dll (i.e., for a regular sim).  Includes:\n *      o build for use with normal simulation (via mex command)\n *\n *  but does not include:\n *\n *      o build for use with rtw (grt)\n */\n#undef SS_SFCN_FOR_SIM\n#define SS_SFCN_FOR_SIM (1)\n#else\n#undef SS_SFCN_FOR_RTW\n#define SS_SFCN_FOR_RTW (1)\n#endif\n#endif\n\n#define SS_DEBUG_FOR_SIM (SS_SFCN_FOR_SIM && !SS_NDEBUG)\n\n/*===========================================================================*\n * END SECTION\n * DETERMINE GROUP DEFINES\n *\n * Group defines are derived from the \"KEY DEFINES\" listed and determined\n * in previous sections.\n *===========================================================================*/\n\n/*\n * Include headers for MATLAB API function prototypes (e.g. mxGetPr)\n */\n#if SS_SL_INTERNAL\n#if defined(RSIM_WITH_SL_SOLVER)\n/*\n * Run-time interface for Real-Time Workshop RSIM Full target.\n */\n#ifdef IS_RAPID_ACCEL\n#include \"matrix.h\"\n#else\n#include \"rt_matrx.h\"\n#endif\n#else\n/*\n * Using within Simulink itself\n */\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"matrix.h\"\n#include \"sl_sfcn_st_api.h\"\n#endif\n\n#elif SS_SFCN_FOR_SIM\n/*\n * Used in simulation by sfunction\n */\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"mex.h\"\n#include \"sl_sfcn_st_api.h\"\n#if !defined(S_FUNCTION_NAME)\n#define _S_FUNCTION_NAME_NOT_DEFINED_BEFORE_SIMSTRUCT\n#endif\n#elif SS_SFCN_FOR_RTW\n/*\n * Used in RTW by sfunction\n */\n#include \"rt_matrx.h\" /* S-function is being used with Real-Time Workshop */\n#elif SS_RTW_INTERNAL\n/*\n * Run-time interface for Real-Time Workshop\n */\n#if !defined(TYPEDEF_MX_ARRAY)\n#define TYPEDEF_MX_ARRAY\ntypedef real_T mxArray;\n#endif\n#else\n/*\n * Error\n */\n#error Unhandled case\n#endif\n\n#if defined(ENABLE_SLEXEC_SSBRIDGE)\n/*\n * Prototypes of functions exported from slexec_simbridge component\n */\n#include \"slexec_simstruct_bridge.h\"\n#endif\n\n#include \"slexec_block_runtime_service.h\"\n\n/*===========================================================================*\n *===========================================================================*\n *===========================================================================*\n * WARNING: For maintainability:\n *\n * Conditional Compilation below this point should only depend on\n *    KEY DEFINES\n * or\n *    GROUP DEFINES\n * that where determined in the sections above.\n *\n * In particular, #if and #elif should only depend on the KEY DEFINES and/or\n * GROUP DEFINES.\n *\n * All the KEY DEFINES and GROUP DEFINES always have definitions.  Therefore,\n * the preprocessor directives defined(), #ifdef, and #ifndef are not needed\n * below, and their use indicates a likely maintainability problem.  The\n * only exception is the use of #ifndef in the standard technique for guarding\n * against multiple inclusion and multiple definition.\n *===========================================================================*\n *===========================================================================*\n *===========================================================================*/\n#endif\n"},{"name":"simstruc_debug.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/**\n * @file: simstruc_debug.h\n *\n * @brief SimStruct debug version of access methods, which are active for MEX files built with -g\n * option.\n *\n */\n\n#ifndef __SIMSTRUC__DEBUG\n#define __SIMSTRUC__DEBUG\n\n#if SS_DEBUG_FOR_SIM\n\n#ifdef __cplusplus\nextern \"C\" {\n#else\nextern\n#endif\nvoid _ssSetInputPortDirectFeedThroughFcn(const SimStruct* S, int port, int dirFeed);\n#ifdef __cplusplus\n}\n#endif\n\n#define ssSetInputPortDirectFeedThrough(S, port, dirFeed) \\\n    _ssSetInputPortDirectFeedThroughFcn(S, port, dirFeed)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern void _ssSetRWorkValueFcn(const char* file,\n                                int line,\n                                SimStruct* S,\n                                int rworkIdx,\n                                real_T rworkValue);\n#ifdef __cplusplus\n}\n#endif\n#define ssSetRWorkValue(S, rworkIdx, rworkValue) \\\n    _ssSetRWorkValueFcn(__FILE__, __LINE__, S, rworkIdx, rworkValue)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern real_T _ssGetRWorkValueFcn(const char* file, int line, const SimStruct* S, int rworkIdx);\n#ifdef __cplusplus\n}\n#endif\n#define ssGetRWorkValue(S, rworkIdx) _ssGetRWorkValueFcn(__FILE__, __LINE__, S, rworkIdx)\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern void _ssSetIWorkValueFcn(const char* file,\n                                int line,\n                                SimStruct* S,\n                                int iworkIdx,\n                                int_T iworkValue);\n#ifdef __cplusplus\n}\n#endif\n#define ssSetIWorkValue(S, iworkIdx, iworkValue) \\\n    _ssSetIWorkValueFcn(__FILE__, __LINE__, S, iworkIdx, iworkValue)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern int_T _ssGetIWorkValueFcn(const char* file, int line, const SimStruct* S, int iworkIdx);\n#ifdef __cplusplus\n}\n#endif\n#define ssGetIWorkValue(S, iworkIdx) _ssGetIWorkValueFcn(__FILE__, __LINE__, S, iworkIdx)\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern void _ssSetPWorkValueFcn(const char* file,\n                                int line,\n                                SimStruct* S,\n                                int pworkIdx,\n                                void* pworkValue);\n#ifdef __cplusplus\n}\n#endif\n#define ssSetPWorkValue(S, pworkIdx, pworkValue) \\\n    _ssSetPWorkValueFcn(__FILE__, __LINE__, S, pworkIdx, pworkValue)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern void* _ssGetPWorkValueFcn(const char* file, int line, const SimStruct* S, int pworkIdx);\n#ifdef __cplusplus\n}\n#endif\n#define ssGetPWorkValue(S, pworkIdx) _ssGetPWorkValueFcn(__FILE__, __LINE__, S, pworkIdx)\n\n#if !SS_SFCN_LEVEL_1\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern const void* _ssGetInputPortSignalFcn(const SimStruct* S, int ip);\n#ifdef __cplusplus\n}\n#endif\n#define ssGetInputPortSignal(S, ip) _ssGetInputPortSignalFcn(S, ip)\n#define ssGetInputPortRealSignal(S, ip) ((const real_T*)_ssGetInputPortSignalFcn(S, ip))\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern int_T _ssGetInputPortBufferDstPortFcn(const char* file,\n                                             int line,\n                                             const SimStruct* S,\n                                             int port);\n#ifdef __cplusplus\n}\n#endif\n#define ssGetInputPortBufferDstPort(S, port) \\\n    _ssGetInputPortBufferDstPortFcn(__FILE__, __LINE__, S, port)\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern InputPtrsType _ssGetInputPortSignalPtrsFcn(const SimStruct* S, int ip);\n#ifdef __cplusplus\n}\n#endif\n#define ssGetInputPortSignalPtrs(S, ip) _ssGetInputPortSignalPtrsFcn(S, ip)\n#define ssGetInputPortRealSignalPtrs(S, ip) ((InputRealPtrsType)_ssGetInputPortSignalPtrsFcn(S, ip))\n#endif /*__!SS_SFCN_LEVEL_1_*/\n\n#endif\n\n\n#endif /* __SIMSTRUC__DEBUG */\n"},{"name":"simstruc_def.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/**\n * @file: simstruc_def.h\n *\n * @brief SimStruct structure definitions\n *\n */\n\n#ifndef __SIMSTRUC__DEF\n#define __SIMSTRUC__DEF\n\n#include \"simstruc_types.h\"\n#include \"simstruc_internal_types.h\"\n\n/*===============================*\n * Defines for S-function blocks *\n *===============================*/\n\n/*\n * DYNAMICALLY_SIZED - Specify for sizes entries that inherit their values\n * from the block that drives them.\n * SIMSTRUCT_VERSION - An integer which is the sizeof the SimStruct times\n * 10000 plus the version times 100. When updating version numbers within the\n * Matlab image, increment both level 1 and level 2 S-functions. Level 1\n * version cannot be in range 220 to 229.  This was the level 2 version in\n * Simulink 2.20 (R10)\n *\n * DYNAMIC_DIMENSION - Specify for input/output port dimension entries that\n * the port inherits its dimension from the block that drives it.\n */\n\n#define ALWAYS_NEEDED (0)\n#define CONDITIONALLY_NEEDED (1)\n#define NEVER_NEEDED (2)\n\n#define ALWAYS_REFRESHED (0)\n#define CONDITIONALLY_REFRESHED (1)\n#define NEVER_REFRESHED (2)\n\n#define SIMSTRUCT_VERSION_LEVEL1 (sizeof(SimStruct) * 10000 + 214)\n#define SIMSTRUCT_VERSION_LEVEL2 (sizeof(SimStruct) * 10000 + 229)\n\n#include \"sl_common_types_def.h\"\n\n#if SS_SL_INTERNAL\n#if defined(RSIM_WITH_SL_SOLVER)\n#define DISABLED_VARIABLE_NEXT_TIME rtMinusInf\n#else\n#define DISABLED_VARIABLE_NEXT_TIME (utGetMinusInf())\n#endif\n#endif\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n\n#define ssSetSimulinkVersionGeneratedIn(S, ver)                                            \\\n    {                                                                                      \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_SIMULINK_VERSION_GENERATED_IN, 0, \\\n                                        (void*)(ver)) _ssSafelyCallGenericFcnEnd;          \\\n    }\n\n#else\n#define ssSetSimulinkVersionGeneratedIn(S, ver)\n#endif\n\n/*\n * Task ID's ordering\n *      Continuous task\n *      Continuous but fixed in minor step task\n *      Discrete task 1\n *         ...\n *      Discrete task N\n *      Variable sample time task(s), offset is instance number.\n *\n * If continuous task is present then it's task ID is 0, otherwise the\n * first discrete task ID will be 0 if it is present, etc.\n * All blocks with varying sample times have same sample task period of -2,\n * and the offset is the instance number.\n *\n * The triggered blocks are not in the sample time table and have a task ID\n * of -1.\n */\n\n#define CONSTANT_TID (-2)\n#define GENERIC_ASYNC_TID (-3)\n#define COMPOSITE_TID (-4)\n#define PARAMETER_TUNING_TID (-5)\n\n/*==========================================================================*\n * PropagationPassType - used to distinguish for pass initialization\n * If you add or update PropagationPassType, update simulink/sl_types_compile.hpp too\n *==========================================================================*/\n#ifndef _PROPAGATIONPASSTYPE\n#define _PROPAGATIONPASSTYPE\ntypedef enum {\n    DIMENSION_PROPAGATION,\n    TYPE_PROPAGATION,\n    COMPLEX_PROPAGATION,\n    UNIT_PROPAGATION\n} PropagationPassType;\n#endif\n\n/*===============================================*\n * General defines used only by the macros below *\n *===============================================*/\n\n\n/*\n * Conversion routines for frame data storage\n */\n#define NEG1_2BITS '\\x03'\n#define CONV_BITS2INT(val) \\\n    ((((val)&2U) != 0U) ? FRAME_INHERITED : (((val)&1U) != 0U) ? FRAME_YES : FRAME_NO)\n#define CONV_INT2BITS(val) (((val) == FRAME_INHERITED) ? (NEG1_2BITS) : ((val)&1U))\n\n/*\n * Conversion routines for dimensions mode storage\n */\n#define CONV_BITS2DIMSMODE(val)                \\\n    ((((val)&2U) != 0)    ? INHERIT_DIMS_MODE  \\\n     : (((val)&1U) != 0U) ? VARIABLE_DIMS_MODE \\\n                          : FIXED_DIMS_MODE)\n#define CONV_DIMSMODE2BITS(val) (((val) == INHERIT_DIMS_MODE) ? (NEG1_2BITS) : ((val)&1U))\n\n/*\n * Conversion routines for bus mode storage\n */\n#define CONV_BITS2BUSMODE(val) \\\n    ((((val)&2U) != 0) ? SL_INHERIT_BUS_MODE : (((val)&1U) != 0U) ? SL_BUS_MODE : SL_NON_BUS_MODE)\n#define CONV_BUSMODE2BITS(val) (((val) == SL_INHERIT_BUS_MODE) ? (NEG1_2BITS) : ((val)&1U))\n\n/*=================================================================*\n * Defines used by Simulink.c when calling the S-function routines *\n *=================================================================*/\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define SS_CALL_MDL_INITIALIZE_SAMPLE_TIMES 101\n#define SS_CALL_MDL_INITIALIZE_CONDITIONS 102\n#define SS_CALL_MDL_GET_TIME_OF_NEXT_VAR_HIT 103\n#define SS_CALL_MDL_OUTPUTS 104\n#define SS_CALL_MDL_UPDATE 105\n#define SS_CALL_MDL_DERIVATIVES 106\n#define SS_CALL_MDL_TERMINATE 107\n#define SS_CALL_MDL_ZERO_CROSSINGS 108\n#define SS_CALL_MDL_GET_INPUT_PORT_WIDTH 109\n#define SS_CALL_MDL_GET_OUTPUT_PORT_WIDTH 110\n#define SS_CALL_MDL_SET_WORK_WIDTHS 111\n#define SS_CALL_MDL_CHECK_PARAMETERS 112\n#define SS_CALL_MDL_SET_INPUT_PORT_DATA_TYPE 113\n#define SS_CALL_MDL_SET_OUTPUT_PORT_DATA_TYPE 114\n#define SS_CALL_MDL_SET_INPUT_PORT_WIDTH 115\n#define SS_CALL_MDL_SET_OUTPUT_PORT_WIDTH 116\n#define SS_CALL_MDL_START 117\n#define SS_CALL_MDL_PROCESS_PARAMETERS 118\n#define SS_CALL_MDL_RTW 119\n#define SS_CALL_MDL_SET_INPUT_PORT_COMPLEX_SIGNAL 120\n#define SS_CALL_MDL_SET_OUTPUT_PORT_COMPLEX_SIGNAL 121\n#define SS_CALL_MDL_SET_INPUT_PORT_SAMPLE_TIME 122\n#define SS_CALL_MDL_SET_OUTPUT_PORT_SAMPLE_TIME 123\n#define SS_CALL_RTW_GENERATED_ENABLE 124\n#define SS_CALL_RTW_GENERATED_DISABLE 125\n#define SS_CALL_MDL_SET_INPUT_PORT_DIMENSION_INFO 126\n#define SS_CALL_MDL_SET_OUTPUT_PORT_DIMENSION_INFO 127\n#define SS_CALL_MDL_SET_INPUT_PORT_FRAME_DATA 128\n#define SS_CALL_MDL_PROJECTION 129\n#define SS_CALL_MDL_JACOBIAN 130\n#define SS_CALL_MDL_SET_DEFAULT_PORT_DIMENSION_INFO 131\n#define SS_CALL_MDL_SET_DEFAULT_PORT_DATA_TYPES 132\n#define SS_CALL_MDL_SET_DEFAULT_PORT_COMPLEX_SIGNALS 133\n#define SS_CALL_MDL_EXT_MODE_EXEC 134\n#define SS_CALL_MDL_RTWCG 135\n#define SS_CALL_MDL_MASSMATRIX 136\n#define SS_CALL_MDL_FORCINGFUNCTION 137\n/*       UNUSED                                      138 */\n#define SS_CALL_MDL_ENABLE 139\n#define SS_CALL_MDL_DISABLE 140\n#define SS_CALL_MDL_SIM_STATUS_CHANGE 141\n#define SS_CALL_MDL_INITIALIZE_PROPAGATION_PASS 142\n#define SS_CALL_MDL_CONSTRAINTS 143\n#define SS_CALL_MDL_GET_SIM_STATE 144\n#define SS_CALL_MDL_SET_SIM_STATE 145\n#define SS_CALL_MDL_INIT_SYSTEM_MATRICES 146\n#define SS_CALL_MDL_FINALIZE_ALL_DIMS 147\n#define SS_CALL_MDL_JACOBIANIRJC 148\n#define SS_CALL_MDL_SET_INPUT_PORT_SYMBOLIC_DIMENSIONS 149\n#define SS_CALL_MDL_SET_OUTPUT_PORT_SYMBOLIC_DIMENSIONS 150\n#define SS_CALL_MDL_SETUP_RUNTIME_RESOURCES 151\n#define SS_CALL_MDL_CLEANUP_RUNTIME_RESOURCES 152\n#define SS_CALL_MDL_PRE_INITIALIZE 153\n#define SS_CALL_MDL_COPY_RTP_DATA 154\n#endif\n\n\n/*==================================*\n * Structures with in the SimStruct *\n *==================================*/\n\ntypedef struct ssSparseMatrixInfo_tag {\n    int_T mRows; /* number of rows   */\n    int_T nCols; /* number of cols   */\n    int_T nzMax; /* size of *pr, *ir */\n    int_T* Ir;   /* row indices      */\n    int_T* Jc;   /* column offsets   */\n    real_T* Pr;  /* nonzero entries  */\n} ssSparseMatrixInfo;\n\n\n/* For Backward compatibility with R12Lcs */\n#define SS_UNORIENTED_OR_COL_VECT SS_1_D_OR_COL_VECT\n#define SS_UNORIENTED_OR_ROW_VECT SS_1_D_OR_ROW_VECT\n#define SS_UNORIENTED_ROW_OR_COL_VECT SS_1_D_ROW_OR_COL_VECT\n#define SS_UNORIENTED_VECT SS_1_D_VECT\n\n/*\n * _ssSizes - valid in all SimStruct's. There is one sizes for a level-1\n * S-function and another sizes for a level 2 S-function.\n */\n\nstruct _ssSizes {\n    int_T numContStates; /* number of continuous states                    */\n    int_T numDiscStates; /* number of discrete states                      */\n    union {\n        int_T numOutputPorts; /* number of output ports for S-functions         */\n        int_T numY;           /* Length of the external output vector for models\n                                 i.e. the sum of the widths of the outports.\n                                 For level 1 S-functions, this is the output\n                                 port width.                                    */\n    } out;\n    union {\n        int_T numInputPorts; /* number of input ports for S-functions          */\n        int_T numU;          /* Length of the external input vector for models\n                                i.e. the sum of the widths of the inports.\n                                For level 1 S-functions, this is the input\n                                port width.                                    */\n    } in;\n    int_T mexApiInt1; /* reserved for use by Simulink mex api         */\n\n    int_T sysDirFeedThrough; /* Not used by s-functions - only for root models */\n\n\n    int_T numSampleTimes; /* # of different sample times and/or time offsets*/\n    int_T numSFcnParams;  /* number of external matrices passed in          */\n\n    /* -------- Work vectors ------------------------ */\n    int_T numIWork; /* size of integer work vector                    */\n    int_T numRWork; /* size of real_T precision work vector           */\n    int_T numPWork; /* size of pointer work vector                    */\n\n    /* -------- Block counts ------------------------ */\n    int_T numBlocks;     /* number of Blocks in the model                  */\n    int_T numSFunctions; /* number of S-Functions                          */\n\n    /* -------- Model bookkeeping ------------------- */\n    int_T numBlockIO;      /* number of block outputs                        */\n    int_T numBlockParams;  /* number of block parameters                     */\n    uint32_T checksums[4]; /* Checksums  of model                            */\n\n    /* -------- Version ----------------------------- */\n    int32_T simStructVer; /* SimStruct version                              */\n\n    /* -------- Zero Crossings ---------------------- */\n    int_T numNonsampledZCs; /* number of non-sampled zero crossings            */\n    int_T numZCEvents;      /* number of zero crossing events                 */\n\n    /* -------- Modes ------------------------------- */\n    int_T numModes; /* number of modes                                */\n\n    /* -------- Configuration options --------------- */\n    uint32_T options; /* General options                                */\n\n\n    /* -------- Vector Sizes In Bytes  -------------- */\n\n    int_T sizeofY;       /* Sizeof of external input, Y, in bytes          */\n    int_T sizeofU;       /* Sizeof of external input, U, in bytes          */\n    int_T sizeofBlockIO; /* size of block outputs (number of bytes)        */\n\n    int_T sizeofGlobalBlockIO; /* size of the global block outputs in bytes*/\n\n    int_T numDWork;         /* size of data type work vectors                 */\n    int_T sizeofDWork;      /* Size of data type work vector. Depends on\n                               dwork data types, complex signals, and\n                               num dworks.                                    */\n    int_T RTWGeneratedSFcn; /* Flag which is set for rtw generated s-function */\n                            /* Remove once all dstates are changed to dworks  */\n                            /* ------------- Reserved ------------------------*/\n    struct {\n        unsigned int hasMdlDimensionsFcn : 1; /* uses width or dimension method*/\n        unsigned int usesNumPorts : 1;        /* used for distinguishing between\n                                                 union fields in. and out. */\n        unsigned int vectMode : 4;            /* used in set dimension methods */\n        unsigned int blockReduction : 1;      /* used to request blk reduction */\n        unsigned int treatAsAtomic : 1;       /* used to treat block as atomic\n                                                 subsystem */\n        unsigned int rtwcg : 1;               /* supports CGIR */\n        unsigned int needAbsoluteTime : 1;\n        unsigned int explicitFCSSCtrl : 1; /* used for explicit fcncall orig */\n\n        unsigned int modelRefTsInhSupLevel : 2; /* used for determining if a model\n                                                 * can inherit a sample time when it\n                                                 * is used as a block*/\n        unsigned int needElapseTime : 1;\n        unsigned int hasSubFunctions : 1;\n        unsigned int callsOutputInInit : 1;\n        /* mdlProjection may be present, but we may not want to call it */\n        unsigned int disableMdlProjection : 1;\n\n        unsigned int modelRefNormalModeSupport : 2;\n        unsigned int simStateCompliance : 4;\n        unsigned int simStateVisibility : 1;\n        /* Use JacobianFcn in places of SlvrJacobianFcn */\n        unsigned int disableMdlSlvrJacobian : 1;\n\n        /* Used to check if rapid accelerator is active */\n        unsigned int isRapidAcceleratorActive : 1;\n        unsigned int isConcurrentTasks : 1;\n\n        unsigned int usesCustomCodeFcns : 1;\n        unsigned int crlReplacementEnabled : 1;\n\n        unsigned int vmSimulationsCompliance : 3;\n\n        /* each bit field has to be no more than 16 bits!  (some targets, for ex,\n           TI 2000, do not support more than 16 bits per single field */\n    } flags;\n\n    int_T numJacobianNzMax; /* number of nonzero elements in sparse Jacobian  */\n\n    void* rtModel;            /* rtModel pointer */\n    const void* constBlockIO; /* Pointer to invariant signals */\n\n    /*\n     * The funky statements below were necessitated because we originally\n     * had 5 reserved integer fields. In order to get a (void *) field\n     * we need one int on certain platforms and two on others. To\n     * overcome this, we have the definition below.\n     *\n     * Note that there is only ONE remaining reserved int (for alpha\n     * anyway, there are 3 on other platforms i.e. the ones where\n     * sizeof(int) = sizeof(void*) )\n     *\n     * In order to use it, there will need to be added some appropriate\n     * pre-processor definitions to keep from attempting to instantiate\n     * an array of length 0.\n     *\n     * The problem is that on alpha sizeof(void *) = 64 and\n     * sizeof(int) = 32 so we have:\n     *   4 - 2*sizeof(void *)/sizeof(int) = 4 - 2*64/32 = 0\n     */\n    int reservedForFuture[5 - 2 * sizeof(void*) / sizeof(int)];\n};\n\n#define SIZES_LENGTH (sizeof(struct _ssSizes) / sizeof(int_T))\n\n/*\n * _ssPortInfo (S->portInfo), this is only used by level 2 S-functions.\n *\n */\n\ntypedef const void* const* InputPtrsType;\n\ntypedef const real_T* const* InputRealPtrsType;\ntypedef const real32_T* const* InputReal32PtrsType;\ntypedef const int8_T* const* InputInt8PtrsType;\ntypedef const uint8_T* const* InputUInt8PtrsType;\ntypedef const int16_T* const* InputInt16PtrsType;\ntypedef const uint16_T* const* InputUInt16PtrsType;\ntypedef const int32_T* const* InputInt32PtrsType;\ntypedef const uint32_T* const* InputUInt32PtrsType;\ntypedef const boolean_T* const* InputBooleanPtrsType;\n\ntypedef void* OutputVectType;\n\n#define GET_DATA_TYPE(dt) ((dt)&0xFFFF)\n#define GET_COMPLEX_SIGNAL(dt) (((dt)&0x10000) != 0)\n\n\n/*\n * Auxiliary DWork structure for S-Functions, one for each dwork.\n */\nstruct _ssDWorkAuxRecord {\n    char_T* rtwIdentifier;\n    int_T rtwStorageClass;\n    char_T* rtwTypeQualifier;\n    struct {\n        unsigned int DisableBoundsChecking : 1; /* disable bounds check    */\n        unsigned int ExtModeUpload : 1;         /* upload dwork in extmode */\n        unsigned int rtwIdMustResolveToSignalObject : 2;\n        /* identifier must resolve to signal object\n         * 0U: Try resolve (implicit signal resolution)\n         * 1U: Must resolve\n         * 2U: Must not resolve */\n        unsigned int rtwIdDoneResolve : 1;       /* done resolving identifier */\n        unsigned int ensureResetForSizeVary : 1; /* ensure reset for size change */\n        unsigned int minMaxCheckpoint : 2;       /* remainder are reserved    */\n        unsigned int optimizeInIR : 1;           /* convert to local if correct */\n        unsigned int reserved7 : 7;              /* remainder are reserved    */\n        unsigned int reserved16 : 16;            /* remainder are reserved  */\n    } flags;\n    int_T icPrmIdxPlus1; /* block IC parameter (if\n                          * there is) mapped to this\n                          * dwork; 0 for none\n                          */\n    int_T bitFieldWidth;\n    int_T widthSLSize;\n    int_T unusedInts[1];\n\n    void* resolvedSignalObject;\n    void* unusedPtrs[3];\n};\n\n/* Registration returns 1 for success and 0 for failure */\ntypedef int_T (*_ssRegNumInputPortsFcn)(void* arg1, int_T nInputPorts);\ntypedef int_T (*_ssRegNumOutputPortsFcn)(void* arg1, int_T nOutputPorts);\n\ntypedef int_T (*_ssSetInputPortDimensionInfoFcn)(SimStruct* arg1,\n                                                 int_T port,\n                                                 const DimsInfo_AsInt* dimsInfo);\ntypedef int_T (*_ssSetOutputPortDimensionInfoFcn)(SimStruct* arg1,\n                                                  int_T port,\n                                                  const DimsInfo_AsInt* dimsInfo);\ntypedef int_T (*_ssSetInputPortDimensionInfoFcnSLSize)(SimStruct* arg1,\n                                                       int_T port,\n                                                       const DimsInfo_AsSLSize* dimsInfo);\ntypedef int_T (*_ssSetOutputPortDimensionInfoFcnSLSize)(SimStruct* arg1,\n                                                        int_T port,\n                                                        const DimsInfo_AsSLSize* dimsInfo);\n\n\nstruct _ssPortInputs {\n    int_T width;             /* Number of elements in input\n                                port                          */\n    int_T directFeedThrough; /* Direct feedthrough for input\n                                port                          */\n    DTypeId dataTypeId;      /* Data type of input port.      */\n    CSignal_T complexSignal; /* Complex signal (-1=either,\n                                0=no, or 1=yes)?              */\n    union {\n        const void* vect;\n        InputPtrsType ptrs;\n    } signal; /* Inputs for level 2 S-functions */\n\n    int_T connected; /* Are there signals entering\n                        the input port of the Sfcn?   */\n    struct {\n        unsigned int overWritable : 1;\n        unsigned int optimOpts : 2;\n        unsigned int frameData : 2;\n        unsigned int contiguity : 1;\n        unsigned int acceptExprInRTW : 1;\n        unsigned int cinId : 2;\n        unsigned int nonDerivPort : 1;\n        unsigned int dimensionsMode : 2;\n        unsigned int busMode : 2;\n        unsigned int optimizeInIR : 1;\n        unsigned int reserved1 : 1;\n        unsigned int reserved16 : 16;\n    } attributes;\n\n    real_T sampleTime; /* Sample and offset time when   */\n    real_T offsetTime; /* block specifies port based ts */\n    int_T* dims;       /* port dimensions               */\n    int_T bufferDstPort;\n\n    int_T sampleTimeIndex; /* Sample time index when using\n                              port based sample times       */\n    int_T numDims;         /* port number of dimensions     */\n};\n\nstruct _ssPortOutputs {\n    int_T width;             /* Number of elements in output\n                                port                          */\n    DTypeId dataTypeId;      /* Data type of outputs          */\n    CSignal_T complexSignal; /* Complex signal (-1=either,\n                                0=no, or 1=yes)?              */\n    void* signalVect;        /* Output signal                 */\n    int_T connected;         /* Are the signals leaving the\n                                Sfcn driving other blocks?    */\n    struct {\n        unsigned int optimOpts : 2;\n        unsigned int frameData : 2;\n        unsigned int cToMergeBlk : 1;\n        unsigned int constOutputExprInRTW : 1;\n        unsigned int outputExprInRTW : 1;\n        unsigned int trivialOutputExprInRTW : 1;\n        unsigned int okToMerge : 2;\n        unsigned int cecId : 2;\n        unsigned int nonContPort : 1;\n        unsigned int dimensionsMode : 2;\n        unsigned int fedByBlockWithModesNoZCs : 1;\n        unsigned int busMode : 2;\n        unsigned int optimizeInIR : 1;\n        unsigned int reserved13 : 13;\n    } attributes;\n\n    real_T sampleTime;     /* Sample and offset time when   */\n    real_T offsetTime;     /* block specifies port based ts */\n    int_T* dims;           /* port dimensions               */\n    int_T sampleTimeIndex; /* Sample time index when using\n                              port based sample times       */\n    int_T icPrmIdxPlus1;   /* block IC parameter (if\n                            * there is) mapped to this\n                            * port; 0 for none\n                            */\n    int_T numDims;         /* port number of dimensions     */\n};\n\nstruct _ssPortInfo {\n\n    _ssRegNumInputPortsFcn regNumInputPortsFcn;\n    void* regNumInputPortsFcnArg;\n    _ssRegNumOutputPortsFcn regNumOutputPortsFcn;\n    void* regNumOutputPortsFcnArg;\n\n    struct _ssPortInputs* inputs;   /* Info for each input port of blk  */\n    struct _ssPortOutputs* outputs; /* Info for each output port of blk */\n};\n\n\n\ntypedef struct ssContextMemoryInfo_tag {\n    void* base;\n    size_t size;\n} ssContextMemoryInfo;\n\n/* Masks for determining the parameter attributes (see ssSfcnParams struct). */\n#define SFCNPARAM_NOT_TUNABLE (1 << 0x0)\n#define SFCNPARAM_TUNABLE (1 << 0x1)\n#define SFCNPARAM_SIMONLY_TUNABLE (1 << 0x2)\n#define SFCNPARAM_CLEAR_TUNABLE \\\n    (~(SFCNPARAM_NOT_TUNABLE | SFCNPARAM_TUNABLE | SFCNPARAM_SIMONLY_TUNABLE))\n\nstruct _ssSFcnParams {\n    int_T dlgNum;        /* Number of S-function parameters passed in   */\n    mxArray** dlgParams; /* The S-function parameters                   */\n    uint_T* dlgAttribs;  /* Disable parameter changes during simulation?*/\n\n    /* union preserves the memory map of the Simstruc; the size of an integer\n     * is always less than or equal to that of a pointer\n     */\n    union {\n        int_T numRtp;\n        void* placeholder;\n    } numRtp;\n    ssParamRec** rtp;\n};\n\n\nstruct _ssWork {\n    int_T* iWork;      /* integer work vector             */\n    real_T* rWork;     /* real work vector                */\n    void** pWork;      /* pointer work vector             */\n    int_T* modeVector; /* mode work vector                */\n    void* userData;    /* User/application specific data  */\n\n    union {\n        struct _ssDWorkRecord* sfcn;\n        void* root;\n    } dWork; /* data type work vector            */\n\n    struct _ssDWorkAuxRecord* dWorkAux;\n    struct _ssLocalMdlInfo* localMdlInfo;\n};\n\n\n/*\n * Input port variable dimensions information.\n */\nstruct _ssInPortVarDims {\n    const int* portVarDims;\n    void* reserved[8];\n};\n\n/*\n * Output port variable dimensions information.\n */\nstruct _ssOutPortVarDims {\n    int* portVarDims;\n    void* reserved[8];\n};\n\n/*\n * Input port unit ID\n */\nstruct _ssInPortUnit {\n    UnitId unitId;\n};\n\n/*\n * Output port unit ID\n */\nstruct _ssOutPortUnit {\n    UnitId unitId;\n};\n\ntypedef enum {\n    SS_DIMS_CONSTRAINT_UNSPECIFIED = 0, /* Default - no block implementation */\n    SS_DIMS_CONSTRAINT_NONE,            /* No constraint */\n    SS_DIMS_CONSTRAINT_MULTIPLE,        /* Dims size must be a multiple of a specified value */\n    SS_DIMS_CONSTRAINT_EXPLICIT,        /* Dims size must be an explicitly specified value */\n    SS_DIMS_CONSTRAINT_IMMUTABLE, /* Port dims[0] cannot be cascaded - block is not vectorizable */\n    SS_DIMS_CONSTRAINT_MULTIPORTEQUALSIZE /* Dims[0] size is equal on all inports and outport */\n} SS_DimsConstraintType;\n\n/*\n * Input port dataflow dims constraint info\n */\nstruct _ssInPortDimsConstraint {\n    SS_DimsConstraintType type;\n    uint_T size;\n};\n\n/*\n * Output port dataflow dims constraint info\n */\nstruct _ssOutPortDimsConstraint {\n    SS_DimsConstraintType type;\n    uint_T size;\n};\n\n/*\n * Input port cosim signal attributes\n */\nstruct _ssInPortCoSimAttribute {\n    boolean_T isContinuousQuantity;\n};\n\n/*\n * Output port cosim signal attributes\n */\nstruct _ssOutPortCoSimAttribute {\n    boolean_T isContinuousQuantity;\n};\n\n/*\n * The _ssPortInfo2 structure is used by S-function blocks to store port\n * variable dimensions information\n */\nstruct _ssPortInfo2 {\n    struct _ssInPortVarDims* inputs;\n    struct _ssOutPortVarDims* outputs;\n    struct _ssInPortUnit* inputUnits;\n    struct _ssOutPortUnit* outputUnits;\n    struct _ssInPortDimsConstraint* inputDimsConstraint;\n    struct _ssOutPortDimsConstraint* outputDimsConstraint;\n    struct _ssInPortCoSimAttribute* inputCoSimAttribute;\n    struct _ssOutPortCoSimAttribute* outputCoSimAttribute;\n    void* reserved[2];\n};\n\nstruct _ssSTInfo2 {\n    size_t* ctrlRateInstanceIndex;\n    boolean_T* isControlledByThisBlock;\n    size_t nRateIndices;\n    void* reserved[10];\n};\n\n/* Enum for Majority of S-Functions */\ntypedef enum {\n    SS_UNSET = 0,\n    SS_COLUMN_MAJOR = 1,\n    SS_ROW_MAJOR = 2,\n    SS_ALL = 3,\n    SS_COLUMN_AUTO = 4,\n    SS_ROW_AUTO = 5\n} SSArrayLayout;\n\nstruct _ssPortInputsSLSize {\n    int_T width;\n    int_T* dims;\n    const int_T* portVarDims;\n};\nstruct _ssPortOutputsSLSize {\n    int_T width;\n    int_T* dims;\n    int_T* portVarDims;\n};\nstruct _ssSizesSLSize {\n    SLSize numContStates;\n    SLSize numDiscStates;\n    SLSize numNonsampledZCs;\n    SLSize numModes;\n    SLSize numIWork;\n    SLSize numRWork;\n    SLSize numPWork;\n    SLSize numDWork;\n    int_T numY;\n    int_T numU;\n    int_T sizeofY;\n    int_T sizeofU;\n};\n\ntypedef int_T (*SetNumDWorkSLSize)(SimStruct*, SLSize);\nstruct _ssRegDataTypeSLSize {\n    SetNumDWorkSLSize setNumDWorkFcn;\n};\n\nstruct _ssJacobianInfoSLSize {\n    int_T numSlvrJacobianNzmax;\n    int_T numJacobianNzmax;\n};\n\nstruct _ssMdlInfoSLSize {\n    _ssSetInputPortDimensionInfoFcnSLSize regInputPortDimsInfo;\n    _ssSetOutputPortDimensionInfoFcnSLSize regOutputPortDimsInfo;\n};\n\nstruct _ssBlkInfoSLSize {\n    struct _ssPortInputsSLSize* inputs;\n    struct _ssPortOutputsSLSize* outputs;\n    struct _ssSizesSLSize sizes;\n    struct _ssRegDataTypeSLSize regDataType;\n    struct _ssJacobianInfoSLSize jacobianInfo;\n};\n\n/*\n * Enum for dictating how an s-function should\n * be used in accelerated simulations\n */\ntypedef enum {\n    SS_SFCNREP_AUTO = 0,\n    SS_SFCNREP_BINARY,\n    SS_SFCNREP_TLC,\n    SS_SFCNREP_CCODE\n} SSRepresentation;\n\n/*\n * The _ssBlkInfo structure can be used by S-function blocks to determine\n * status about the model in which they reside.\n */\nstruct _ssBlkInfo2 {\n    void* rtwSfcnInfo; /* Used only in RTW by the S-function     */\n    void* unused;\n    struct _ssPortInfo2* portInfo2;\n    struct _ssSTInfo2* stInfo2;\n    char_T* localErrorStatusBuffer; /* local error status string buffer */\n    union {\n        const char_T* str;\n        void* msg;\n    } localErrorStatus;\n\n    struct _ssBlkInfoSLSize* blkInfoSLSize;\n    struct _ssMdlInfoSLSize* mdlInfoSLSize;\n    void* reservedPtrs[9];\n\n    int_T impulseResponseLength;\n    int_T reserved[15];\n};\n\nstruct _ssBlkInfo {\n    int_T inputConnected;         /* Is input connected to a non-virtual block? */\n    int_T outputConnected;        /* Is output connected to a non-virtual block?*/\n    const char_T* placementGroup; /* Name of group to place block in. Only\n                                     applies to sources and sinks. Blocks with\n                                     same group name will appear adjacent in\n                                     the sorted list.                          */\n\n    void* block; /* The owner SLBlock * of the s-function     */\n\n    struct _ssBlkInfo2* blkInfo2; /* More block info                           */\n\n    int_T absTolOffset_Obsolete; /* Offset from the root SimStruct absTol     */\n\n    struct {\n        /* bit field for flags which are only relevant to s-functions */\n\n        /* each bit field has to be no more than 16 bits!  (some targets, for ex,\n           TI 2000, do not support more than 16 bits per single field */\n\n        uint_T okToCallStartTerminateOnSimRestart : 1;\n        uint_T sCodeGenArrayLayout : 3;\n        uint_T sRowMajorOptIn : 1;\n        uint_T runtimeThreadSafetyCompliance : 4;\n        uint_T localErrorStatusIsMsg : 1; /* 1 SimStruct_tag errorStatus is void*,\n                                           * otherwise is const char*  */\n        uint_T sReuseAcrossModels : 1;\n        uint_T ssSupportsMultipleExecInstancesForModelRefNormalMode : 1;\n        uint_T ssUserDataInvariantPostCompile : 1;\n        uint_T ssCombineCompExecUserData : 1;\n        uint_T reserved1 : 2;\n        uint_T reserved2 : 16;\n    } sfcnFlags;\n};\n\n/*==================================================================*\n * Mode of simulation - single vs multi-tasking. Note, variable       *\n * step solvers ignore this property and are always single-tasking   *\n *==================================================================*/\ntypedef enum {\n    GEN_FCN_SET_NUM_RUN_TIME_PARAMS,\n    GEN_FCN_REG_RUN_TIME_PARAM,\n    GEN_FCN_UPDATE_RUN_TIME_PARAM,\n    GEN_FCN_REG_ALL_TUNE_PRM_AS_RTP,\n    GEN_FCN_UPDATE_ALL_TUNE_PRM_AS_RTP,\n    GENFCNFIXPT_DIMS_SUM_IN,\n    GENFCNFIXPT_DIMS_SUM_OUT,\n    GENFCNFIXPT_DIMS_SUM_DEFAULT,\n    GENFCNFIXPT_DIMS_PROD_IN,\n    GENFCNFIXPT_DIMS_PROD_OUT,\n    GENFCNFIXPT_DIMS_PROD_DEFAULT,\n    GENFCNFIXPT_DIMS_MPSWITCH_IN,\n    GENFCNFIXPT_DIMS_MPSWITCH_OUT,\n    GENFCNFIXPT_DIMS_LOGIC_IN,\n    GENFCNFIXPT_DIMS_LOGIC_OUT,\n    GENFCNFIXPT_DIMS_LOGIC_DEFAULT,\n    GENFCNFIXPT_DIMS_GAIN_IN,\n    GENFCNFIXPT_DIMS_GAIN_OUT,\n    GENFCNFIXPT_DIMS_GAIN_DEFAULT,\n    GENFCNFIXPT_LICENSE,\n    GEN_FCN_IS_RTPARAM_TUNABLE,\n    GEN_FCN_GET_BLOCK_HANDLE,\n    GEN_FCN_REGISTER_DATA_STORE_FROM_NAME,\n    GEN_FCN_READ_FROM_DATA_STORE,\n    GEN_FCN_WRITE_TO_DATA_STORE,\n    GEN_FCN_REGISTER_NUM_DATA_STORE,\n    GEN_FCN_COMPUTE_INPUT,\n    GEN_FCN_GET_DATATYPEOVERRIDE,\n    GEN_FCN_GET_MINMAXLOG,\n    GEN_FCN_GET_MINMAXARCHIVE,\n    GEN_FCN_REG_CONST_RUN_TIME_PARAM,\n    GEN_FCN_SF_INLINABLE,\n    GEN_FCN_REG_AND_CNV_RUN_TIME_PARAM,\n    GEN_FCN_UPDATE_AND_CNV_RUN_TIME_PARAM,\n    GEN_FCN_SET_ZERO_BASED_IN_PORT,\n    GEN_FCN_SET_ZERO_BASED_OUT_PORT,\n    GEN_FCN_SET_ONE_BASED_IN_PORT,\n    GEN_FCN_SET_ONE_BASED_OUT_PORT,\n    GEN_FCN_SET_SFCN_REPRESENTATION,\n    GEN_FCN_GET_SFCN_REPRESENTATION,\n    GEN_FCN_REGISTER_TYPE_FROM_NAMED_OBJECT,\n    GEN_FCN_REGISTER_TYPE_FROM_PARAMETER,\n    GEN_FCN_CREATE_SLCG_STRING_BUFFER,\n    GEN_FCN_ADD_TO_SLCG_STRING_BUFFER,\n    GEN_FCN_UNUSED_22,\n    GEN_FCN_UNUSED_23,\n    GEN_FCN_CREATE_RUN_TIME_PARAM_FROM_DATA,\n    GEN_FCN_UPDATE_RUN_TIME_PARAM_FROM_DATA,\n    GEN_FCN_FULL_REG_AND_CNV_RUN_TIME_PARAM,\n    GEN_FCN_UNUSED_PARAMS1,\n    GEN_FCN_UNUSED_PARAMS2,\n    GEN_FCN_GET_MODELREF_INTFPARAM_MODEL_ARG_DATA,\n    GEN_FCN_SET_DATA_ALIGNMENT,\n    GEN_FCN_SET_ASYNC_TIMER_ATTRIBUTES,\n    GEN_FCN_SET_ASYNC_TASK_PRIORITIES,\n    GEN_FCN_UNUSED_PARAMS5,\n    GEN_FCN_UNUSED_PARAMS6,\n    GEN_FCN_GET_MODELREF_INTFPARAM_GLOBAL_DATA,\n    GEN_FCN_GET_ELAPSE_TIME,\n    GEN_FCN_GET_ELAPSE_TIME_COUNTER_DTYPE,\n    GEN_FCN_GET_ELAPSE_TIME_COUNTER,\n    GEN_FCN_GET_ELAPSE_TIME_RESOLUTION,\n    GEN_FCN_COMPUTE_OUTPUT,\n    GEN_FCN_SET_OUTPUT_OVERWRITE_INPUT_IDX,\n    GEN_FCN_SET_MODELMAPPINGINFO,\n    GEN_FCN_SET_SF_INIT_OUTPUT,\n    GEN_FCN_GET_PRODHWDEVICEINFO,\n    GEN_FCN_IS_POINTER_DATA_TYPE,\n    GEN_FCN_GET_POINTER_CONTAINED_DATA_TYPE,\n    GEN_FCN_GET_POINTER_CONTAINED_DATA_COMPLEXITY,\n    GEN_FCN_GET_POINTER_CONTAINED_DATA,\n    GEN_FCN_GET_POINTER_CONTAINED_DATA_WIDTH,\n    GEN_FCN_REG_MODELREF_MDL_INFO,\n    GEN_FCN_SET_MODELREF_TO_FILES,\n    GEN_FCN_SET_MODELREF_FROM_FILES,\n    GEN_FCN_UNUSED_65,\n    GEN_FCN_SET_BUS_PROPAGATION,\n    GEN_FCN_SET_BUS_SOURCE_PORT,\n    GEN_FCN_SET_BUS_INPORTS,\n    GEN_FCN_GET_PARAM_NAME,\n    GEN_FCN_SET_BUS_OUTPUT_OBJECT_NAME,\n    GEN_FCN_SET_BUS_OUTPUT_AS_STRUCT,\n    GEN_FCN_UNUSED_50,\n    GEN_FCN_COMPUTE_STATEFLOW_SYMBOL_NAME,\n    GEN_FCN_UNUSED_38,\n    GEN_FCN_REG_MDL_INFO,\n    GEN_FCN_SET_BUS_INPUT_AS_STRUCT,\n    GEN_FCN_UNUSED_17,\n    GEN_FCN_SET_TIME_SOURCE,\n    GEN_FCN_UNUSED_16,\n    GEN_FCN_UNUSED_42,\n    GEN_FCN_UNUSED_29,\n    GEN_FCN_ENABLE_FCN_IS_TRIVIAL,\n    GEN_FCN_DISABLE_FCN_IS_TRIVIAL,\n    GEN_FCN_SET_ASYNC_TIMER_DATA_TYPE,\n    GEN_FCN_GET_CONTEXT_SYS_PTR,\n    GEN_FCN_GET_CONTEXT_TID,\n    GEN_FCN_SET_OUTPUT_FCN_CALLED_MULTIPLE,\n    GEN_FCN_SET_NOT_MULTIPLE_INLINEABLE,\n    GEN_FCN_GET_DATA_STORE_ADDR,\n    GEN_FCN_REGISTER_TYPE_FROM_EXPR,\n    GEN_FCN_REGISTER_TYPE_FROM_EXPR_NO_ERROR,\n    GEN_FCN_GET_ZCSIGNAL_ZCEVENTS,\n    GEN_FCN_REG_MODELREF_NONCONTSIGS,\n    GEN_FCN_UNUSED_27,\n    GEN_FCN_SET_INPUT_PORT_ACCESSED_BY_ADDRESS,\n    GEN_FCN_SET_INPUT_DIMS_MODE,\n    GEN_FCN_SET_OUTPUT_DIMS_MODE,\n    GEN_FCN_REG_SET_INPUT_DIMS_MODE_MTH,\n    GEN_FCN_READ_FROM_DATA_STORE_ELEM,\n    GEN_FCN_WRITE_TO_DATA_STORE_ELEM,\n    GEN_FCN_GET_DATA_STORE_INFO,\n    GEN_FCN_UNUSED_19,\n    GEN_FCN_UNUSED_28,\n    GEN_FCN_UNUSED_60,\n    GEN_FCN_SET_INPUT_DIMS_SAMEAS_OUTPUT,\n    GEN_FCN_CHECK_SFCN_PARAM_VALUE_ATTRIBS,\n    GEN_FCN_SET_EXPORTS_FUNCTION_CALLS,\n    GEN_FCN_SET_EXPORTED_OUTPUT_FCN,\n    GEN_FCN_SET_EXPORTED_ENABLE_FCN,\n    GEN_FCN_SET_EXPORTED_DISABLE_FCN,\n    GEN_FCN_SET_INPORT_LATCHED,\n    GEN_FCN_SET_ALLOW_MORE_THAN_2D_SIGS,\n    GEN_FCN_DEST_FCSS_ENABLED,\n    GEN_FCN_SET_CURR_OUTPUT_DIMS,\n    GEN_FCN_GET_SIM_STATUS,\n    GEN_FCN_UNUSED_52,\n    GEN_FCN_SET_STATE_ATTR,\n    GEN_FCN_GET_STATE_ATTR,\n    GEN_FCN_SET_INPUT_BUS_MODE,\n    GEN_FCN_SET_OUTPUT_BUS_MODE,\n    GEN_FCN_REG_SET_INPUT_BUS_MODE_MTH,\n    GEN_FCN_REG_MDLREF_DWORK_TYPE,\n    GEN_FCN_PRUN_TRAILING_DIMS,\n    GEN_FCN_SET_SIGS_ALLOW_BIG_LONG,\n    GEN_FCN_GET_MDLREF_TYPE,\n    GEN_FCN_UNUSED_43,\n    GEN_FCN_UNUSED_44,\n    GEN_FCN_UNUSED_45,\n    GEN_FCN_UNUSED_46,\n    GEN_FCN_SET_JACOBIAN_FLAG,\n    GEN_FCN_SET_OUTPUT_PORT_DISCRETE_VALUED_OUTPUT,\n    GEN_FCN_SET_OUTPUT_IC_ATTRIBUTES,\n    GEN_FCN_UNUSED_39,\n    GEN_FCN_SET_SUPPORT_RUNTIME_MODEL_API,\n    GEN_FCN_SET_SUPPORT_DATATYPE_BEYOND_32_BITS_IN_RTW,\n    GEN_FCN_SET_FXPU32_BITREGION_COMPLIANT,\n    GEN_FCN_GET_FXPU32_BITREGION_COMPLIANT,\n    GEN_FCN_SET_COMP_VARSIZE_COMPUTE_TYPE,\n    GEN_FCN_ADD_DIMS_DEPEND_RULE,\n    GEN_FCN_GET_TIME_RESOLUTION,\n    GEN_FCN_GET_RTWCG_SUPPORT,\n    GEN_FCN_SET_ARRAYSCOPE_TO_LOCAL,\n    GEN_FCN_ADD_VARDIMS_RUNTIME_CHECKER,\n    GEN_FCN_SET_ASYNC_TASK_PRIORITIES_EL,\n    GEN_FCN_SET_ASYNC_TIMER_RESOLUTION_EL,\n    GEN_FCN_SET_ASYNC_TIMER_DATA_TYPE_EL,\n    GEN_FCN_SET_TIME_SOURCE_EL,\n    GEN_FCN_UNUSED_51,\n    GEN_FCN_REG_MODELREF_SET_DIMS_DEPEND_RULES,\n    GEN_FCN_REG_MODELREF_FINALIZE_DIMS_MTH,\n    GEN_FCN_REGISTER_DATA_MIN_MAX_PRM_INDICES,\n    GEN_FCN_CHECK_DWORK_RANGE,\n    GEN_FCN_ACCEL_CALL_SET_DIMS,\n    GEN_FCN_GET_STATEFLOW_SUBCHART_SIMSTRUCT,\n    GEN_FCN_GET_STATEFLOW_SUBCHART_SYS_INST_INDICES,\n    GEN_FCN_GET_DATATYPE_CHECKSUM,\n    GEN_FCN_REG_CODE_VARIANT_FCNCALL,\n    GEN_FCN_EVAL_CODE_VARIANT_FCNCALL,\n    GEN_FCN_CHECK_STRUCTPARAM_CHECKSUM,\n    GEN_FCN_GET_PARAM_DATATYPE,\n    GEN_FCN_GET_SIMULATIONTYPE,\n    GEN_FCN_GET_NET_SLOPE_VIA_DIVISION,\n    GEN_FCN_SET_MODELREF_ALLOW_IN_STATE_ENABLED_SS_OBSOLETE,\n    GEN_FCN_UNUSED_36,\n    GEN_FCN_GET_IS_INPORT_ELEMENT_CONTINUOUS,\n    GEN_FCN_SET_IS_INPORT_USEDFOR_CONT_ZC,\n    GEN_FCN_CREATE_AND_ADD_ZCSIGNAL_INFO,\n    GEN_FCN_SET_ZCSIGNAL_NAME,\n    GEN_FCN_GET_ZCSIGNAL_NAME,\n    GEN_FCN_SET_ZCSIGNAL_WIDTH,\n    GEN_FCN_GET_ZCSIGNAL_WIDTH,\n    GEN_FCN_SET_ZCSIGNAL_ZCEVENT_TYPE,\n    GEN_FCN_GET_ZCSIGNAL_ZCEVENT_TYPE,\n    GEN_FCN_SET_ZCSIGNAL_TYPE,\n    GEN_FCN_GET_ZCSIGNAL_TYPE,\n    GEN_FCN_SET_ZCSIGNAL_ZCTOL,\n    GEN_FCN_GET_ZCSIGNAL_ZCTOL,\n    GEN_FCN_SET_ZCSIGNAL_NEEDS_EVENT_NOTIFICATION,\n    GEN_FCN_GET_ZCSIGNAL_NEEDS_EVENT_NOTIFICATION,\n    GEN_FCN_GET_NUM_ZCSIGNALS,\n    GEN_FCN_GET_ZCSIGNAL_VECTOR,\n    GEN_FCN_SET_ZCSIGNAL_ISZCELEMEMT_DISC,\n    GEN_FCN_GET_ZCSIGNAL_ISZCELEMEMT_DISC,\n    GEN_FCN_CLONE_AND_ADD_ZCSIGNAL_INFO,\n    GEN_FCN_DATA_STORE_LOG_UPDATE,\n    GEN_FCN_SET_STATES_MODIFIED_ONLY_IN_UPDATE,\n    GEN_FCN_SUP_MULTI_EXEC_INSTANCES,\n    GEN_FCN_REQUEST_IIS_NUM_ITER_DWORK,\n    GEN_FCN_GET_STATEFLOW_RTWCONTEXT,\n    GEN_FCN_GET_NUM_FCNCALL_DEST,\n    GEN_FCN_GET_NUM_VARIANT_CONDITIONS,\n    GEN_FCN_UNUSED_53,\n    GEN_FCN_SET_REQUIRED_STACK_SIZE,\n    GEN_FCN_ACCEL_COPY_STATE_CACHE_FOR_IIS_IN_DESC_SYS_LIST,\n    GEN_FCN_REG_AUTOSAR_CLIENT_BLOCK,\n    GEN_FCN_UNUSED_61,\n    GEN_FCN_SET_MODELREF_STATE_INSIDE_FOREACH,\n    GEN_FCN_CALL_DEFAULT_JACOBIAN,\n    GEN_FCN_CONFIG_DEFAULT_JACOBIAN,\n    GEN_FCN_SET_DATA_MIN_MAX_VALUES,\n    GEN_FCN_LOGGER_CREATE_DATASET_DESCRIPT,\n    GEN_FCN_LOGGER_ADD_ELEMENT_DESCRIPT,\n    GEN_FCN_LOGGER_ADD_TIMESERIES_DESCRIPT,\n    GEN_FCN_LOGGER_CREATE_DATASET_FROM_DESCRIPT,\n    GEN_FCN_LOGGER_ADD_ELEMENT_PROP,\n    GEN_FCN_LOGGER_UPDATE_LOGVAR,\n    GEN_FCN_ACCEL_COPY_STATE_CACHE_FOR_IIS_IN_CG_SYS_LIST,\n    GEN_FCN_GET_DATATYPEOVERRIDEAPPLIESTO,\n    GEN_FCN_READ_FROM_DATA_STORE_REGION,\n    GEN_FCN_WRITE_TO_DATA_STORE_REGION,\n    GEN_FCN_UPDATE_DATA_STORE_DIAGNOSTICS,\n    GEN_FCN_GET_DATA_STORE_DIAGNOSTICS_STATUS,\n    GEN_FCN_CREATE_MEM_REGION_DESC,\n    GEN_FCN_SET_FLAT_MEM_SUB_REGION_DESC,\n    GEN_FCN_DESTROY_MEM_REGION_DESC,\n    GEN_FCN_GET_ZC_CONTROL_DISABLED,\n    GEN_FCN_LOGGER_CREATE_VALUES_DESCIPT,\n    GEN_FCN_LOGGER_SUPPORTS_SIGNAL_LOGGING,\n    GEN_FCN_SET_ACCEPTS_FCNCALL_INPUTS,\n    GEN_FCN_REGISTER_STRING_TYPE,\n    GEN_FCN_IS_STRING_TYPE,\n    GEN_FCN_GET_STRING_TYPE_MAX_LENGTH,\n    GEN_FCN_READ_STRING_INPUT,\n    GEN_FCN_GET_INPUT_STRING_LENGTH,\n    GEN_FCN_WRITE_STRING_OUTPUT,\n    GEN_FCN_UNUSED_63,\n    GEN_FCN_UNUSED_64,\n    GEN_FCN_MODEL_WIDE_EVENT_BEING_PROCESSED,\n    GEN_FCN_GET_REG_SUBMODELS_MDLINFO,\n    GEN_FCN_UNUSED_75,\n    GEN_FCN_UNUSED_76,\n    GEN_FCN_GET_BLK_SUPPORT_CONCURRENT_TASKS,\n    GEN_FCN_SET_BLK_SUPPORT_CONCURRENT_TASKS,\n    GEN_FCN_UNUSED_24,\n    GEN_FCN_ACCEL_CALL_MODEL_FCNCALL_INPUT,\n    GEN_FCN_UNUSED_40,\n    GEN_FCN_UNUSED70,\n    GEN_FCN_UNUSED_77,\n    GEN_FCN_UNUSED_78,\n    GEN_FCN_UNUSED_48,\n    GEN_FCN_UNUSED_79,\n    GEN_FCN_UNUSED_80,\n    GEN_FCN_SET_INPUT_PORT_IS_MESSAGE,\n    GEN_FCN_SET_OUTPUT_PORT_IS_MESSAGE,\n    GEN_FCN_SEND_MESSAGE,\n    GEN_FCN_RECEIVE_MESSAGE,\n    GEN_FCN_CHK_MESSAGE_INPUT,\n    GEN_FCN_NO_MESSAGE_ON_INPUTS,\n    GEN_FCN_CHK_MESSAGE_OUTPUT,\n    GEN_FCN_UNUSED_25,\n    GEN_FCN_UNUSED_32,\n    GEN_FCN_GET_SIZE_OF_PARAMS,\n    GEN_FCN_UNUSED_49,\n    GEN_FCN_UNUSED_81,\n    GEN_FCN_UNUSED_10,\n    GEN_FCN_UNUSED_11,\n    GEN_FCN_UNUSED_12,\n    GEN_FCN_MULTI_INS_NO_SUPPORT_MESSAGE,\n    GEN_FCN_UNUSED_13,\n    GEN_FCN_GET_STRICT_SINGLE,\n    GEN_FCN_UNUSED_70,\n    GEN_FCN_UNUSED_71,\n    GEN_FCN_UNUSED_72,\n    GEN_FCN_UNUSED_69,\n    GEN_FCN_UNUSED_68,\n    GEN_FCN_UNUSED_67,\n    GEN_FCN_UNUSED_14,\n    GEN_FCN_UNUSED_15,\n    GEN_FCN_SET_VARIABLE_SAMPLE_TIME_UID,\n    GEN_FCN_SET_VARTS_MDLREF_SUPPORT,\n    GEN_FCN_IS_SF_OUTPUT_DRIVING_COND_SUBSYS,\n    GEN_FCN_FILE_LOGGING_MANAGER_ADD_ELEMENT,\n    GEN_FCN_FILE_LOGGING_MANAGER_REMOVE_ELEMENT,\n    GEN_FCN_UNUSED_41,\n    GEN_FCN_UNUSED_1,\n    GEN_FCN_UNUSED_2,\n    GEN_FCN_UNUSED_3,\n    GEN_FCN_UNUSED_4,\n    GEN_FCN_UNUSED_5,\n    GEN_FCN_UNUSED_6,\n    GEN_FCN_UNUSED_7,\n    GEN_FCN_UNUSED_8,\n    GEN_FCN_UNUSED_9,\n    GEN_FCN_UNUSED_35,\n    GEN_FCN_UNUSED_62,\n    GEN_FCN_GET_DWORK_SYMBOLIC_DIMS_ID,\n    GEN_FCN_SET_DWORK_SYMBOLIC_DIMS_ID,\n    GEN_FCN_SET_RUN_TIME_PARAM_ACCESSED_BY_ADDRESS,\n    GEN_FCN_SET_SIMULINK_VERSION_GENERATED_IN,\n    GEN_FCN_MDL_UPDATE_IS_EMPTY,\n    GEN_FCN_SET_STATE_EXECUTION_SEMANTICS_SYNCHRONOUS,\n    GEN_FCN_SET_SYMBOLIC_DIMS_SUPPORT,\n    GEN_FCN_REGISTER_SYMBOLIC_DIMS_EXPR,\n    GEN_FCN_REGISTER_SYMBOLIC_DIMS,\n    GEN_FCN_REGISTER_SYMBOLIC_DIMS_STRING,\n    GEN_FCN_REGISTER_SYMBOLIC_DIMS_INT_VALUE,\n    GEN_FCN_REGISTER_SYMBOLIC_DIMS_PLUS,\n    GEN_FCN_REGISTER_SYMBOLIC_DIMS_MINUS,\n    GEN_FCN_REGISTER_SYMBOLIC_DIMS_MULTIPLY,\n    GEN_FCN_REGISTER_SYMBOLIC_DIMS_DIVIDE,\n    GEN_FCN_GET_NUM_SYMBOLIC_DIMS,\n    GEN_FCN_GET_SYMBOLIC_DIM,\n    GEN_FCN_SET_INPUT_PORT_SYMBOLIC_DIMS_ID,\n    GEN_FCN_GET_INPUT_PORT_SYMBOLIC_DIMS_ID,\n    GEN_FCN_GET_COMP_INPUT_PORT_SYMBOLIC_DIMS_ID,\n    GEN_FCN_SET_COMP_INPUT_PORT_SYMBOLIC_DIMS_ID,\n    GEN_FCN_SET_OUTPUT_PORT_SYMBOLIC_DIMS_ID,\n    GEN_FCN_GET_OUTPUT_PORT_SYMBOLIC_DIMS_ID,\n    GEN_FCN_GET_COMP_OUTPUT_PORT_SYMBOLIC_DIMS_ID,\n    GEN_FCN_SET_COMP_OUTPUT_PORT_SYMBOLIC_DIMS_ID,\n    GEN_FCN_GET_COMP_DWORK_SYMBOLIC_DIMS_ID,\n    GEN_FCN_SET_COMP_DWORK_SYMBOLIC_DIMS_ID,\n    GEN_FCN_SET_PRM_TUNING_COMPLIANCE,\n    GEN_FCN_GET_PRM_TUNING_COMPLIANCE,\n    GEN_FCN_GET_ISINTERACTIVESIM,\n    GEN_FCN_UNUSED_83,\n    GEN_FCN_REGISTER_UNIT_FROM_EXPR,\n    GEN_FCN_ACCEL_MDLREF_VM_GET_U_BY_INDEX,\n    GEN_FCN_ACCEL_MDLREF_VM_GET_Y_BY_INDEX,\n    GEN_FCN_ACCEL_MDLREF_BLOCK_SYSTEM_INITIALIZE,\n    GEN_FCN_ACCEL_MDLREF_BLOCK_SYSTEM_RESET,\n    GEN_FCN_SET_STOP_REQUESTED,\n    GEN_FCN_SET_STOP_REQUESTED_SFUN,\n    GEN_FCN_UNUSED_PARAMS3,\n    GEN_FCN_UNUSED_PARAMS4,\n    GEN_FCN_GET_MODELREF_INTFPARAM_BLOCK_ARG_DATA,\n    GEN_FCN_VM_SIMULATION_COMPILE,\n    GEN_FCN_SET_DISALLOW_CONTINUOUS,\n    GEN_FCN_GET_BLOCK_PATH,\n    GEN_FCN_REPORT_DIAGNOSTIC_AS_WARNING,\n    GEN_FCN_IS_POSITIVE_DATA_VALUE,\n    GEN_FCN_SIGN_DATA_VALUE,\n    GEN_FCN_GET_GLOBAL_DATA_TRANSFER_INDICES,\n    GEN_FCN_DATA_TRANSFER_READ,\n    GEN_FCN_DATA_TRANSFER_WRITE,\n    GEN_FCN_DATA_TRANSFER_INIT_BUFFERS,\n    GEN_FCN_QUERY_SIMULINK_FUNCTION,\n    GEN_FCN_DECLARE_SIMULINK_FUNCTION,\n    GEN_FCN_DECLARE_SIMULINK_FUNCTION_CALLER,\n    GEN_FCN_CALL_SIMULINK_FUNCTION,\n    GEN_FCN_SIMULINK_FUNCTION_ARGUMENT,\n    GEN_FCN_SET_DISALLOW_CONTROLLABLE,\n    GEN_FCN_SET_CONTROLLABLE_SAMPLE_TIME,\n    GEN_FCN_SET_CONTROLLABLE_SAMPLE_TIME_UID,\n    GEN_FCN_SET_INPUT_CONTROLLABLE_SAMPLE_TIME,\n    GEN_FCN_SET_INPUT_CONTROLLABLE_SAMPLE_TIME_UID,\n    GEN_FCN_SET_OUTPUT_CONTROLLABLE_SAMPLE_TIME,\n    GEN_FCN_SET_OUTPUT_CONTROLLABLE_SAMPLE_TIME_UID,\n    GEN_FCN_ACCEL_PRE_BLOCK,\n    GEN_FCN_ACCEL_POST_BLOCK,\n    GEN_FCN_SET_DWORK_DIMENSIONS,\n    GEN_FCN_CHK_MODELREF_SFUN_HAS_MODEL_BLOCK,\n    GEN_FCN_DISCARD_DIAGNOSTIC,\n    GEN_FCN_LONGJMP,\n    GEN_FCN_SET_DEEPCOPY_COMPLIANT,\n    GEN_FCN_ADD_OUTPUT_VARDIMS_PORT_INDEX,\n    GEN_FCN_REPORT_DIAGNOSTIC_AS_INFO,\n    GEN_FCN_REGISTER_SYMBOLIC_EQUAL_RELATION,\n    GEN_FCN_REGISTER_SYMBOLIC_EQUAL_VALUE,\n    GEN_FCN_AMEND_LEADING_SYMBOLIC_DIMS,\n    GEN_FCN_AMEND_TRAILING_SYMBOLIC_DIMS\n} GenFcnType;\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n/* following return 1 on success and 0 on failure */\ntypedef int_T (*_WriteRTWStrFcn)(void* writeRTWFcnArg, const char_T* str);\n\ntypedef int_T (*_WriteRTWNameValuePairFcn)(void* writeRTWFcnArg,\n                                           int_T type,\n                                           const char_T* name,\n                                           const void* value,\n                                           DTypeId dataTypeId,\n                                           int_T nRows,\n                                           int_T nCols);\n\ntypedef int_T (*_WriteRTWParameterFcn)(void* writeRTWFcnArg,\n                                       int_T type,\n                                       const char_T* name,\n                                       const char_T* str,\n                                       const void* value,\n                                       DTypeId dataTypeId,\n                                       int_T nRows,\n                                       int_T nCols);\n\ntypedef void (*_AccelRunBlockFcn)(SimStruct* S, int sysidx, int blkidx, int enumFunction);\n\ntypedef int_T (*_GenericFcn)(SimStruct* S, GenFcnType type, int_T arg1, void* arg2);\ntypedef int_T (*_ConstGenericFcn)(const SimStruct* S, GenFcnType type, int_T arg1, void* arg2);\n#endif\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n/*\n * The following return error string on failure, NULL on success.\n * See <matlabroot>/simulink/src/barplot.c for an example of using\n * these functions.\n */\n\n/*\n * Returns an array of output port pointers corresponding to the selected\n * signals in the window that the s-function block resides (i.e., the signals\n * whose lines have selection handles).  There are two options that can\n * be passed to this function (sigSetOpt):\n *    SIGSET_GRAPH: return only the selected signals in the window in\n *                  which the s-function resides.\n *    SIGSET_GRAPH_N_CHILDREN: return selected signals in the window in\n *                             which the s-function resides and all\n *                             children windows.\n */\ntypedef const char* (*SelectedSignalsFcn)(const void* voidBlock,\n                                          const int sigSetOpt,\n                                          void*** voidOutPortObjs, /* the ports           */\n                                          int* outnPortObjs);      /* the number of ports */\n\n/*\n * Given an array of output ports, create a signal list so that the signal\n * data may be accessed (also see sigmapdef.h).  Return an error string on\n * failure or NULL on success.\n */\ntypedef const char* (*SigListCreateFcn)(const void* voidBlock,\n                                        const int nPorts,\n                                        void** voidPortObjs,\n                                        const unsigned int excludeFlags,\n                                        void** voidOutSigList);\n\n/*\n * Destroy a signal list.\n */\ntypedef void (*SigListDestroyFcn)(void* voidSigList);\n\n/*\n * Access into Simulink memory manager's free function.  Used to destroy\n * objects that were created by calling into Simulink (e.g., ssCall..).  This\n * function is accessed via the ssCallGenericDestroyFcn macro.\n */\ntypedef void (*utFreeFcn)(void* ptr);\n\n/*\n * Given a pointer to a port, return it's name (signal label).\n */\ntypedef const char* (*GetPortNameFcn)(void* voidPortObj);\n\n/*\n * Given a signal list, detect and alert users to any signals that\n * are not available for viewing.\n */\ntypedef void (*SigListUnavailSigAlertFcn)(void* voidSigList);\n\n/*\n * Given a port, unselect it's line.\n */\ntypedef void (*UnselectSigFcn)(void* voidPortObj);\n\n/*\n * Given a SigList return ....\n */\n\n/* number of regions comprising the 'listIdx-th' signal in the list */\ntypedef int (*SigListGetNumRegionsFcn)(void* voidSigList, int idx);\n\n/* a pointer to the first region of the 'listIdx-th'signal in the list */\ntypedef void* (*SigListGetFirstRegFcn)(void* voidSigList, int idx);\n\n/* the total num of elements comprising the 'listIdx-th' signal in the list */\ntypedef int (*SigListGetNumElementsFcn)(void* voidSigList, int idx);\n\n/* true if the signal is a tie wrap (see sigmapdef.h) */\ntypedef int (*SigListGetIfTieWrapFcn)(void* voidSigList, int idx);\n\ntypedef struct _SignalAccess_tag {\n    SelectedSignalsFcn SelectedSignals;\n    SigListCreateFcn SigListCreate;\n    SigListDestroyFcn SigListDestroy;\n    SigListUnavailSigAlertFcn SigListUnavailSigAlert;\n\n    SigListGetNumRegionsFcn SigListGetNumRegions;\n    SigListGetFirstRegFcn SigListGetFirstReg;\n    SigListGetNumElementsFcn SigListGetNumElements;\n    SigListGetIfTieWrapFcn SigListGetIfTieWrap;\n\n    utFreeFcn utFree;\n\n    GetPortNameFcn GetPortName;\n    UnselectSigFcn UnselectSig;\n} SignalAccess;\n#endif\n\n/*\n * Call into the s-functions external mode fcn - if it exists.  Returns\n * error string on failure, NULL on success.\n */\ntypedef const char* (*SFunExtModeFcn)(SimStruct* S, const ExtModeLogBlockMeth);\n\n/*\n * Non-continuous (sample time != 0) signals driving derivative ports\n * (e.g. integrand input port of an integrator block) need to be tracked\n * in order to determine when to reset variable step solvers.\n */\ntypedef struct {\n    int sizeInBytes;\n    char* pCurrVal;\n    char* pPrevVal;\n} ssNonContDerivSigInfo;\n\n#if defined(RTW_GENERATED_S_FUNCTION) || SS_SL_INTERNAL\ntypedef struct ssNonContDerivSigFeedingOutports_tag {\n    int sizeInBytes;\n    char* currVal;\n    struct ssNonContDerivSigFeedingOutports_tag* next;\n} ssNonContDerivSigFeedingOutports;\n#endif\n\n/*\n * The _ssMdlInfo structure is \"valid\" in the root SimStruct only.  All child\n * SimStruct's point to the root SimStruct mdlInfo field.  Care must be taken\n * to use the correct mapping of tid's when accessing some of mdlInfo fields\n * (e.g. t, sample hits, sample times, etc). from child SimStruct's (use macros\n * below).\n */\n\nstruct _ssMdlInfo {\n    SS_SimMode simMode; /* This field indicates\n                           whether or not we are running a simulation\n                           or generating the model.rtw file */\n\n    time_T* t; /* The current time for each task. This is\n                  of dimension sizes.numSampleTimes         */\n\n    int_T* sampleHits; /* sample hits - does tid have a hit?  This is\n                          of dimension sizes.numSampleTimes         */\n\n    time_T tStart;           /* Model execution start time                 */\n    time_T tFinal;           /* Final model execution stop time            */\n    time_T timeOfLastOutput; /* Time of last model \"output\"                */\n\n    time_T minStepSize; /* variable step-size is always >= minStepSize */\n\n    void* timingData; /* Data used by execution or simulation engine*/\n\n    SimTimeStep simTimeStep; /* Simulation time step \"mode\"                */\n\n    int_T stopRequested; /* True if a \"stop\" has been requested        */\n    int_T logOutput;     /* Log output?                                */\n\n    time_T* outputTimes;     /* Times at which to log data                 */\n    uint_T outputTimesIndex; /* Where we are in the OutputTimes vector     */\n    uint_T numOutputTimes;   /* Length of OutputTimes                      */\n    int_T outputTimesOnly;   /* Save [t,x,y] & continuous blocks at\n                                specified times only?                      */\n\n    int_T obsoletedNeedOutputAtTPlusTol;\n\n    const char_T* solverName; /* Name of solver/integration algorithm       */\n    int_T variableStepSolver; /* true=variable or false=fixed step solver */\n    void* solverData;         /* Work area for solver                       */\n    time_T solverStopTime;    /* Solver stop time                           */\n    time_T stepSize;          /* The integration step size                  */\n    int_T solverNeedsReset;   /* Do we need to reset the integrator?        */\n    struct {\n        unsigned int zcCacheNeedsReset : 1;    /* recompute zc value left?     */\n        unsigned int derivCacheNeedsReset : 1; /* recompute derivatives?       */\n        unsigned int blkStateChange : 1;       /* did blk state change?        */\n        unsigned int cTimeOutputInconsistentWithStateAtMajorStep : 1;\n        /* block output is inconsistent\n         * with state at major output*/\n        unsigned int forceSfcnExceptionHandling : 1; /* add exception handling *\n                                                      *for all S-function calls*/\n        unsigned int inlineParameters : 1;           /* is inline parameters selected\n                                                      * for the model?       */\n        unsigned int solverAssertCheck : 1;          /* true if consistency checking\n                                                        is enabled and active        */\n        unsigned int minStepViolatedError : 1;       /* what to do if the solver step\n                                                      * size is less than the min step\n                                                      * size: 0 => warn 1 => error */\n        unsigned int blockStateForSolverChangedAtMajorStep : 1;\n        /* block state has changed at\n         * major step*/\n        unsigned int reserved1 : 1;             /* unused mdlInfo flag          */\n        unsigned int computingJacobian : 1;     /* 1 when computing Jacobian    */\n                                                /* for use in ODE solver        */\n        unsigned int solverCheckingCIC : 1;     /* 1 -- ODE solver checks if it */\n                                                /* has consistent initial conds */\n                                                /*  |M*xdot - f| is 'small'     */\n        unsigned int errorStatusIsMsg : 1;      /* 1 SimStruct_tag errorStatus is\n                                                 * void*,\n                                                 * otherwise is const char*    */\n        unsigned int timeTweakWarn : 1;         /* whether to warn when time is tweaked*/\n        unsigned int solverRequestingReset : 1; /* e.g, step ended at discontinuity */\n        unsigned int firstInitCondCalled : 1;   /* initCond Has been called at least once  */\n        unsigned int sparseSlvrJacobian : 1;\n        unsigned int frameUpgradeWarn : 1;\n        unsigned int outputMethodComputed : 1;\n        unsigned int doingParameterInit : 1;\n        unsigned int f0EvaluationForJacobian : 2; /* Solver is computing f(x0) or\n                                                    M(x0) for purposes of J(x0) computation*/\n        unsigned int isRowMajor : 1;              /* true if row major parameter\n                                                    is set on the model*/\n        unsigned int zcEvalForRefine : 1;         /* if zc function is being evaluated on\n                                                     refine */\n        unsigned int reserved8 : 8;               /* remainder are reserved      */\n    } mdlFlags;\n    int_T maxNumMinSteps;          /* Max number of steps taken at minimum       */\n    int_T solverRefineFactor;      /* state & output refinement factor      */\n    real_T solverRelTol;           /* Integration relative tolerance             */\n    real_T* solverAbsTol_Obsolete; /* OBSOLETE: abs tol for each continuous state */\n\n    time_T maxStepSize;   /* variable StepSize is always <= MaxStepSize */\n    int_T solverMaxOrder; /* Maximum order for ode15s                   */\n    time_T fixedStepSize; /* Step size for fixed-step integrators       */\n\n    int_T numNonContDerivSigInfos;\n    ssNonContDerivSigInfo* nonContDerivSigInfos;\n    uint8_T* solverAbsTolControl_Obsolete; /* Solver abs tol control\n                                            * Obsoleted */\n    rtTimingBridge* timingBridge;\n\n    RTWLogInfo* rtwLogInfo;   /* Logging data structure for RTW         */\n    ssSolverInfo* solverInfo; /* Solver information */\n\n    char_T* errorStatusBuffer; /* errStatus string buffer */\n\n    _slexecBlkRTSGateway blkRTSGateway;\n    void* mexApiVoidPtr1; /* reserved for use by Simulink mex api */\n\n    int_T solverExtrapolationOrder;     /* Extrapolation order for ODE14x          */\n    int_T solverNumberNewtonIterations; /* Number of iterations for ODE14x     */\n\n    /*\n     * External mode object\n     */\n    RTWExtModeInfo* extModeInfo;\n\n    /* Base addresses of Block Outputs vector for the whole model   */\n\n    void* blockIO; /* block inputs/outputs                   */\n\n    int* blockIOVarDims; /* block I/O variable dims */\n\n    /* Parameter vectors for use with Real-Time Workshop */\n\n    real_T* defaultParam;    /* Default parameter vector.                   */\n                             /* Note: DefaultParam points to global storage;\n                              *  common to all instances of this model.\n                              *  Used only by Accelerator to point to model\n                              *  wide info.\n                              */\n    const void* mappingInfo; /* Used by RTW for providing external access\n                                to the parameters, block I/O, etc vectors   */\n\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n    /*\n     * Function pointers used in mdlRTW which write fields in the model.rtw file.\n     */\n    _WriteRTWStrFcn writeRTWStrFcn;\n    _WriteRTWNameValuePairFcn writeRTWNameValuePairFcn;\n    _WriteRTWParameterFcn writeRTWParameterFcn;\n\n    void* writeRTWFcnArg;\n\n    _AccelRunBlockFcn accelRunBlock;\n    void* bdRefPtr;\n\n    _GenericFcn genericFcn;\n\n    void* reservedForFutureMLFcns[1];\n    void* reservedForFutureMLArgs[4];\n#endif\n\n    int_T mexApiInt2;          /* for use by Simulink mex api */\n    char_T reservedString[32]; /* IMPORTANT:\n                                  Keep it fixed at 32 characters\n                                  as it is needed for backward\n                                  compatibility */\n\n\n    _ssSetInputPortDimensionInfoFcn regInputPortDimsInfo;\n    _ssSetOutputPortDimensionInfoFcn regOutputPortDimsInfo;\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n    SignalAccess* signalAccess;\n    slDataTypeAccess* dataTypeAccess;\n    void* pathsToModelBlock; /* for internal use by Simulink */\n    void* reservedForFutureVoid[1];\n#endif\n\n    void* reservedForXPC;\n\n#if SS_MULTITASKING || SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n    int_T* perTaskSampleHits; /* Matrix of dimension number of sample times\n                                 by number of sample times giving sample\n                                 hits as viewed in each task. Used by\n                                 ssIsSpecialSampleHit within MEX files. */\n#endif\n\n    SolverMode solverMode; /* Simulation solver mode */\n    RTWGenMode rtwgenMode;\n    void* opModelData; /* C 20210921 G2352059 ABR - Operating Point support object */\n\n    real_T mexApiReal1; /* reserved for use by Simulink mex api */\n    real_T mexApiReal2; /* reserved for use by Simulink mex api */\n\n    real_T* timeOfNextSampleHit;\n    real_T* varNextHitTimesList;\n    boolean_T* tNextWasAdjusted;\n    void* executionInfo;\n\n\n}; /* end struct _ssMdlInfo */\n\nstruct _ssLocalMdlInfo {\n    void* ownerBd;\n    real_T* rtp;\n    void* blockIO;\n    int* blockIOVarDims;\n    void* ownerEbd;\n    void* ownerCbd;\n    uint_T* numRuntimeEvents;\n    uint_T* globalRuntimeEventIndices;\n    void* execSimStructMgr;\n    void* simStruct;\n    void* reserved[22];\n};\n\n/* returns 1 on success and 0 on failure */\ntypedef ssFcnCallErr_T (*SysOutputFcn)(void*, int_T, int_T);\n\n#ifdef __cplusplus\n#define SS_FCNCALL_NO_ERR static_cast<ssFcnCallErr_T>(1)\n#define SS_FCNCALL_ERR static_cast<ssFcnCallErr_T>(0)\n#else\n#define SS_FCNCALL_NO_ERR ((ssFcnCallErr_T)1)\n#define SS_FCNCALL_ERR ((ssFcnCallErr_T)0)\n#endif\n\nstruct _ssCallSys {\n    int_T* outputs;     /* Which output elements call a system    */\n    void** args1;       /* 1st Argument(s) for system output fcn  */\n    int_T* args2;       /* 2nd Argument(s) for system output fcn  */\n    SysOutputFcn* fcns; /* System output functions                */\n};\n\n\n/*------------------------ (S)->states.modelMethods2->resolveCBK ------------*/\n\n/* callback function support type        *\n * returns 1 on success and 0 on failure */\ntypedef int_T (*_ResolveVarFcn)(const SimStruct* S, const char*, mxArray**);\n\n/* callback structure */\nstruct _ssResolveCBK {\n    _ResolveVarFcn Resolver; /* Resolver function                */\n    void* _slBlock;          /* Block context for resolver fcn   */\n};\n\n\n/* callback access methods */\n#define ssGetResolveMLVarCallbackStruct(S) ((ssGetModelMethods2(S))->resolveCBK)\n#define ssSetResolveMLVarCallbackFcn(S, val) (ssGetResolveMLVarCallbackStruct(S)).Resolver = (val)\n#define ssSetResolveMLVarCallbackContext(S, val) \\\n    (ssGetResolveMLVarCallbackStruct(S))._slBlock = (val)\n#define ssResolveMLVarWithCallback(S, Var, mat)                          \\\n    (((ssGetResolveMLVarCallbackStruct(S)).Resolver != NULL)             \\\n         ? (*(ssGetResolveMLVarCallbackStruct(S)).Resolver)(S, Var, mat) \\\n         : (1))\n\n/*---------------------------------------------------------------------------*/\n\ntypedef DTypeId (*OldRegisterDataType)(void*, const char_T*);\ntypedef int_T (*SetDataTypeSize)(void*, DTypeId, int_T);\ntypedef int_T (*GetDataTypeSize)(void*, DTypeId);\ntypedef int_T (*SetDataTypeZero)(void*, DTypeId, void*);\ntypedef const void* (*GetDataTypeZero)(void*, DTypeId);\ntypedef const char_T* (*GetDataTypeName)(void*, DTypeId);\ntypedef int_T (*SetNumDWork)(SimStruct*, int_T);\n\n\nstruct _ssRegDataType {\n    void* arg1;                      /* 1st Argument for Register Data Type  */\n    OldRegisterDataType registerFcn; /* Register Data Type Function          */\n    SetDataTypeSize setSizeFcn;      /* Set Data Type Size Function          */\n    GetDataTypeSize getSizeFcn;      /* Get Data Type Size Function          */\n\n    SetDataTypeZero setZeroFcn; /* Set Data Type Zero representation    */\n    GetDataTypeZero getZeroFcn; /* Get Data Type Zero representation    */\n\n    GetDataTypeName getNameFcn; /* Get Data Type Name Function          */\n    GetDataTypeId getIdFcn;     /* Get Data Type Id   Function          */\n\n    SetNumDWork setNumDWorkFcn; /* Set num data type work vector        */\n};\n\n/* Access the model's boolean data type enabled flag */\ntypedef boolean_T (*StrictBooleanCheckEnabled)(void*);\n\n/*\n * Access to Simulink's data type conversion function.\n */\ntypedef boolean_T (*ConvertBuiltInDTypeFcn)(\n    int nVals,                  /* num vals to convert (*2 if complex)       */\n    boolean_T satOnIntOverFlow, /* sat on overflow?                          */\n    boolean_T doDiff,           /* check for loss of info during conversion? */\n    const int dt1,              /* original data type                        */\n    const void* v1,             /* vals to convert                           */\n    const int dt2,              /* destination data type                     */\n    void* v2);                  /* out: the converted values                 */\n\n\nstruct _ssStInfo {\n    time_T* sampleTimes;      /* Sampling periods in seconds               */\n    time_T* offsetTimes;      /* Task delay for discrete systems\n                                 (0 <= OffsetTime < SampleTime)            */\n    time_T tNext;             /* Time of next hit for M,MEX S-functions    */\n    int_T tNextTid;           /* For M,MEX S-fcns, negative if not present */\n    int_T* sampleTimeTaskIDs; /* Maps local sample time index to the\n                                 root SimStruct task ID (root sti)         */\n};\n\n\n\n/*\n * Level 2 S-function methods:\n *\n * [mdlInitializePropagationPassFcn] - Optional routine. Perform any\n *                                 necessary initialization before the\n *                                 specified propagation pass begins.\n *=> mdlInitializeSizes         -  Initialize SimStruct sizes array\n *   [mdlSetInputPortWidth]     -  Optional routine. Check and set input and\n *                                 optionally other port widths.  Can\n *                                 only be in a C MEX S-function.\n *   [mdlSetOutputPortWidth]    -  Optional routine. Check and set output\n *                                 and optionally other port widths. Can\n *                                 only be in a C MEX S-function.\n *   [mdlSetInputPortFrameData] -  Optional routine. Check and set input and\n *                                 optionally other frame data.  Can\n *                                 only be in a C MEX S-function.\n *=> mdlInitializeSampleTimes   -  Initialize sample times.\n *   [mdlSetWorkWidths]         -  Optional routine. Set the state, iwork,\n *                                 rwork, pwork, etc sizes. Can only be in a\n *                                 C MEX S-function.\n *\n *   [mdlRTW]                   -  Optional routine.  Only called when\n *                                 generating code to add information to the\n *                                 model.rtw file which is used by the\n *                                 Real-Time Workshop.\n *\n *   <<End mdl function calls when generating code by the Real-Time Workshop>>\n *\n *   [mdlInitializeConditions]  -  Initialize model parameters (usually\n *                                 states). Will not be called if your\n *                                 S-function does not have an initialize\n *                                 conditions routine.\n *   [mdlStart]                 -  Optional routine. Perform actions such\n *                                 as allocating memory and attaching to pwork\n *                                 elements.  Can only be in a C MEX\n *                                 S-function.\n *   [mdlCheckParameters]       -  Optional routine. Will be called at\n *                                 any time during the simulation loop when\n *                                 parameters change. Can only be used in a\n *                                 C MEX S-function.\n *   [mdlExtModeExec]           -  Optional routine. Will be called during\n *                                 external mode simulation loop to run the\n *                                 C Mex S-function block.\n *   SimulationLoop:\n *        [mdlProcessParameters]   -  Optional routine. Called during\n *                                    simulation after parameters have been\n *                                    changed and verified to be okay by\n *                                    mdlCheckParameters. The processing is\n *                                    done at the \"top\" of the simulation loop\n *                                    when it is safe to process the changed\n *                                    parameters. Can only be used in a C MEX\n *                                    S-function.\n *        [mdlGetTimeOfNextVarHit] -  Optional routine. If your S-function\n *                                    has a variable step sample time, then\n *                                    this routine will be called.\n *        [mdlInitializeConditions] -  Optional routine. Only called if your\n *                                    S-function resides in an enabled\n *                                    subsystem configured to reset states,\n *                                    and the subsystem has just enabled.\n *     => mdlOutputs               -  Major output call (usually updates\n *                                    output signals).\n *        [mdlUpdate]              -  Update the discrete states, etc.\n *        [mdlDerivatives]         -  Compute the derivatives.\n *   EndLoop\n *   mdlTerminate               -  End of model housekeeping - free memory,\n *                                 etc.\n */\n\ntypedef void (*mdlInitializeSizesFcn)(SimStruct* S);\n\ntypedef void (*mdlInitializePropagationPassFcn)(SimStruct* S, PropagationPassType passType);\n\ntypedef void (*mdlSetInputPortWidthFcn)(SimStruct* S, int_T portIdx, int_T width);\ntypedef void (*mdlSetOutputPortWidthFcn)(SimStruct* S, int_T portIdx, int_T width);\n\ntypedef int_T (*mdlGetInputPortWidthLevel1Fcn)(SimStruct* S, int_T outputWidth);\ntypedef int_T (*mdlGetOutputPortWidthLevel1Fcn)(SimStruct* S, int_T inputWidth);\n\ntypedef void (*mdlSetInputPortDimensionsFcn)(SimStruct* S,\n                                             int_T portIdx,\n                                             const DimsInfo_T* dimsInfo);\n\ntypedef void (*mdlSetOutputPortDimensionsFcn)(SimStruct* S,\n                                              int_T portIdx,\n                                              const DimsInfo_T* dimsInfo);\n\ntypedef void (*mdlSetDefaultPortDimensionsFcn)(SimStruct* S);\n\ntypedef void (*mdlSetInputPortSymbolicDimensionsFcn)(SimStruct* S,\n                                                     int_T portIdx,\n                                                     SymbDimsId symbDimsId);\n\ntypedef void (*mdlSetOutputPortSymbolicDimensionsFcn)(SimStruct* S,\n                                                      int_T portIdx,\n                                                      SymbDimsId symbDimsId);\n\ntypedef void (*mdlSetInputPortDataTypeFcn)(SimStruct* S, int_T portIdx, DTypeId inputPortDataType);\ntypedef void (*mdlSetOutputPortDataTypeFcn)(SimStruct* S,\n                                            int_T portIdx,\n                                            DTypeId outputPortDataType);\ntypedef void (*mdlSetDefaultPortDataTypesFcn)(SimStruct* S);\n\ntypedef void (*mdlSetInputPortComplexSignalFcn)(SimStruct* S,\n                                                int_T portIdx,\n                                                CSignal_T iPortComplexSignal);\ntypedef void (*mdlSetOutputPortComplexSignalFcn)(SimStruct* S,\n                                                 int_T portIdx,\n                                                 CSignal_T oPortComplexSignal);\ntypedef void (*mdlSetDefaultPortComplexSignalsFcn)(SimStruct* S);\n\ntypedef void (*mdlSetInputPortFrameDataFcn)(SimStruct* S, int_T portIdx, Frame_T iPortFrameData);\n\ntypedef void (*RTWGeneratedEnableFcn)(SimStruct* S);\ntypedef void (*RTWGeneratedDisableFcn)(SimStruct* S);\n\ntypedef void (*mdlEnableFcn)(SimStruct* S);\ntypedef void (*mdlDisableFcn)(SimStruct* S);\n\ntypedef void (*mdlInitializeSampleTimesFcn)(SimStruct* S);\n\ntypedef void (*mdlSetInputPortSampleTimeFcn)(SimStruct* S,\n                                             int portIdx,\n                                             real_T sampleTime,\n                                             real_T offsetTime);\ntypedef void (*mdlSetOutputPortSampleTimeFcn)(SimStruct* S,\n                                              int portIdx,\n                                              real_T sampleTime,\n                                              real_T offsetTime);\ntypedef void (*mdlSetWorkWidthsFcn)(SimStruct* S);\ntypedef void (*mdlRTWFcn)(SimStruct* S);\n\ntypedef void (*mdlInitializeConditionsFcn)(SimStruct* S);\ntypedef void (*mdlInitializeConditionsLevel1Fcn)(real_T* x0, SimStruct* S);\n\ntypedef void (*mdlStartFcn)(SimStruct* S);\n\ntypedef void (*mdlSetupRuntimeResourcesFcn)(SimStruct* S);\ntypedef void (*mdlCleanupRuntimeResourcesFcn)(SimStruct* S);\n\ntypedef void (*mdlDataTransferReadFcn)(SimStruct* S, uint32_T dtIdx, void* data);\n\ntypedef void (*mdlDataTransferWriteFcn)(SimStruct* S, uint32_T dtIdx, void* data);\n\ntypedef void (*mdlDataTransferInitBuffersFcn)(SimStruct* S, uint32_T dtIdx, void* data);\n\n\ntypedef void (*mdlInitSystemMatricesFcn)(SimStruct* S);\n\ntypedef void (*mdlCheckParametersFcn)(SimStruct* S);\ntypedef void (*mdlProcessParametersFcn)(SimStruct* S);\n\ntypedef void (*mdlExtModeExecFcn)(SimStruct* S);\n\ntypedef void (*mdlGetTimeOfNextVarHitFcn)(SimStruct* S);\n\ntypedef void (*mdlOutputsFcn)(SimStruct* S, int_T tid);\ntypedef void (\n    *mdlOutputsLevel1Fcn)(real_T* y, const real_T* x, const real_T* u, SimStruct* S, int_T tid);\n\ntypedef void (*mdlUpdateFcn)(SimStruct* S, int_T tid);\ntypedef void (*mdlUpdateLevel1Fcn)(real_T* x, const real_T* u, SimStruct* S, int_T tid);\n\ntypedef void (*mdlDerivativesFcn)(SimStruct* S);\ntypedef void (*mdlDerivativesLevel1Fcn)(real_T* dx,\n                                        const real_T* x,\n                                        const real_T* u,\n                                        SimStruct* S,\n                                        int_T tid);\n\ntypedef void (*mdlJacobianFcn)(SimStruct* S);\ntypedef void (*mdlJacobianIrJcFcn)(SimStruct* S);\n\ntypedef void (*mdlProjectionFcn)(SimStruct* S);\n\ntypedef void RTWCGInterface;\n\ntypedef void (*mdlRTWCGFcn)(SimStruct* S, RTWCGInterface* iObj);\n\ntypedef void (*mdlZeroCrossingsFcn)(SimStruct* S);\n\ntypedef void (*mdlTerminateFcn)(SimStruct* S);\n\ntypedef void (*mdlMassMatrixFcn)(SimStruct* S);\n\nstruct _ssMassMatrixInfo {\n    ssMatrixType type;       /* SS_MATRIX_***, ...                  */\n    ssSparseMatrixInfo info; /* Ir,Jc,Pr, etc.                      */\n};\n\ntypedef void (*mdlForcingFunctionFcn)(SimStruct* S);\n\ntypedef void (*mdlConstraintsFcn)(SimStruct* S);\n\ntypedef void (*mdlPreInitializeFcn)(SimStruct* S);\ntypedef void (*mdlCopyRTPDataFcn)(SimStruct* S, int_T param, void** rtpData);\nstruct _ssConstraintsInfo {\n    int_T numConstraints;             /* length of the constraints vector    */\n    real_T* constraints;              /* constraints vector                  */\n    mdlConstraintsFcn mdlConstraints; /* function evaluating the constraints */\n};\n\ntypedef mxArray* (*mdlGetOperatingPointFcn)(SimStruct* S);\ntypedef void (*mdlSetOperatingPointFcn)(SimStruct* S, const mxArray* op);\n\ntypedef void (*mdlSimStatusChangeFcn)(SimStruct* S, ssSimStatusChangeType mEvent);\n\nstruct _ssSFcnModelMethods {\n\n    mdlInitializeSizesFcn mdlInitializeSizes;\n\n    mdlGetInputPortWidthLevel1Fcn mdlGetInputPortWidthLevel1;\n    mdlGetOutputPortWidthLevel1Fcn mdlGetOutputPortWidthLevel1;\n\n    union {\n        mdlSetInputPortWidthFcn mdlSetInputPortWidth;\n        mdlSetInputPortDimensionsFcn mdlSetInputPortDims;\n    } mdlSetInputPortDimensions;\n\n    union {\n        mdlSetOutputPortWidthFcn mdlSetOutputPortWidth;\n        mdlSetOutputPortDimensionsFcn mdlSetOutputPortDims;\n    } mdlSetOutputPortDimensions;\n\n\n    mdlSetInputPortDataTypeFcn mdlSetInputPortDataType;\n    mdlSetOutputPortDataTypeFcn mdlSetOutputPortDataType;\n\n    mdlInitializeSampleTimesFcn mdlInitializeSampleTimes;\n\n    mdlSetInputPortSampleTimeFcn mdlSetInputPortSampleTime;\n    mdlSetOutputPortSampleTimeFcn mdlSetOutputPortSampleTime;\n    mdlSetWorkWidthsFcn mdlSetWorkWidths;\n    mdlRTWFcn mdlRTW;\n\n    union {\n        mdlInitializeConditionsFcn level2;\n        mdlInitializeConditionsLevel1Fcn level1;\n    } mdlInitializeConditions;\n\n    mdlStartFcn mdlStart;\n\n    mdlCheckParametersFcn mdlCheckParameters;\n    mdlProcessParametersFcn mdlProcessParameters;\n\n    mdlGetTimeOfNextVarHitFcn mdlGetTimeOfNextVarHit;\n\n    union {\n        mdlOutputsFcn level2;\n        mdlOutputsLevel1Fcn level1;\n    } mdlOutputs;\n\n    union {\n        mdlUpdateFcn level2;\n        mdlUpdateLevel1Fcn level1;\n    } mdlUpdate;\n\n    union {\n        mdlDerivativesFcn level2;\n        mdlDerivativesLevel1Fcn level1;\n    } mdlDerivatives;\n    mdlZeroCrossingsFcn mdlZeroCrossings;\n\n    mdlTerminateFcn mdlTerminate;\n\n    union {\n        mdlSetInputPortComplexSignalFcn mdlSetInputPortComplexSignal;\n        RTWGeneratedEnableFcn mdlEnable;\n\n    } fcnInEnable;\n\n    union {\n        mdlSetOutputPortComplexSignalFcn mdlSetOutputPortComplexSignal;\n        RTWGeneratedDisableFcn mdlDisable;\n\n    } fcnOutDisable;\n\n}; /* _ssSFcnModelMethods */\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\ntypedef mxArray* (*mdlGetSimStateFcn)(SimStruct* S);\ntypedef void (*mdlSetSimStateFcn)(SimStruct* S, const mxArray* in);\n#endif\n\nstruct _ssSFcnModelMethods4 {\n    mdlSetInputPortSymbolicDimensionsFcn mdlSetInputPortSymbolicDimensions;\n    mdlSetOutputPortSymbolicDimensionsFcn mdlSetOutputPortSymbolicDimensions;\n    mdlSetupRuntimeResourcesFcn mdlSetupRuntimeResources;\n    mdlCleanupRuntimeResourcesFcn mdlCleanupRuntimeResources;\n    mdlDataTransferReadFcn mdlDataTransferRead;\n    mdlDataTransferWriteFcn mdlDataTransferWrite;\n    mdlDataTransferInitBuffersFcn mdlDataTransferInitBuffers;\n    mdlPreInitializeFcn mdlPreInitialize;\n    mdlCopyRTPDataFcn mdlCopyRTPData;\n    mdlGetOperatingPointFcn mdlGetOperatingPoint;\n    mdlSetOperatingPointFcn mdlSetOperatingPoint;\n    void* reservedForFuture[4];\n};\n\n\nstruct _ssSFcnModelMethods3 {\n\n    /* Embedding the structure -- massMatrix.type and *\n     * massMatrix.info.nzMax must be always available */\n    struct _ssMassMatrixInfo massMatrix;\n    mdlInitSystemMatricesFcn mdlInitSystemMatrices;\n\n    int_T numSlvrJacobianNzmax;\n    SparseHeader* slvrJacobianMatrix;\n    mdlJacobianIrJcFcn mdlJacobianIrJc;\n    void* reservedForFutureUse;\n};\n\nstruct _ssSFcnModelMethods2 {\n\n    mdlProjectionFcn mdlProjection;\n\n    mdlJacobianFcn mdlJacobian;\n\n    mdlSetInputPortFrameDataFcn mdlSetInputPortFrameData;\n\n    StrictBooleanCheckEnabled strictBooleanCheckEnabledFcn;\n\n    /* Default dimensions, data types, and complex signals functions */\n    mdlSetDefaultPortDimensionsFcn mdlSetDefaultPortDimensions;\n    mdlSetDefaultPortDataTypesFcn mdlSetDefaultPortDataTypes;\n    mdlSetDefaultPortComplexSignalsFcn mdlSetDefaultPortComplexSignals;\n\n    /* Reserved for model methods */\n    ConvertBuiltInDTypeFcn ConvertBuiltInDType;\n\n    /* Callback for S-function to resolve a variable from MATLAB workspace *\n     *  using hierarchical scoping                                         */\n    struct _ssResolveCBK resolveCBK;\n\n    SFunExtModeFcn extModeLogFcn;\n\n    mdlExtModeExecFcn mdlExtModeExec;\n\n    mdlRTWCGFcn mdlRTWCG;\n\n    mdlMassMatrixFcn mdlMassMatrix; /* function evaluating the MassMatrix  */\n\n    struct _ssSFcnModelMethods4* modelMethods4;\n\n    mdlForcingFunctionFcn mdlForcingFunction;\n\n    mdlEnableFcn mdlEnable;\n    mdlDisableFcn mdlDisable;\n    mdlSimStatusChangeFcn mdlSimStatusChange;\n\n    mdlInitializePropagationPassFcn mdlInitializePropagationPass;\n\n    struct _ssConstraintsInfo* constraintsInfo;\n\n    struct _ssSFcnModelMethods3* modelMethods3;\n};\n\n/* AlreadyWarned flag for blocks */\n#define ssSetAlreadyWarnedFlag(S) (S)->states.flags.alreadyWarned = 1\n#define ssGetAlreadyWarnedFlag(S) (S)->states.flags.alreadyWarned\n\ntypedef real_T const* const* UPtrsType;\n\ntypedef struct ssPeriodicStatesInfo_T {\n    int_T globalContStateIndex;          /*  */\n    int_T numPeriodicContStates;         /* Number of periodic continuous states */\n    int_T* periodicContStateIndices;     /* */\n    real_T* periodicContStateRanges;     /* */\n    uint32_T* periodicContStateCounters; /* */\n} ssPeriodicStatesInfo;\n\ntypedef struct ssJacobianPerturbationBounds_T {\n    real_T* min;\n    real_T* max;\n\n} ssJacobianPerturbationBounds;\n\nstruct _ssStatesInfo2 {\n    ZCSigState* prevZCSigState; /* Used for detecting zc events     */\n    real_T* absTol;             /* abs tol for each continuous state          */\n    uint8_T* absTolControl;\n    ssPeriodicStatesInfo* periodicStatesInfo;       /*  */\n    ssJacobianPerturbationBounds* jacPerturbBounds; /* Perturbation info */\n    void* reservedForFutureUse[4];                  /* Reserved pointers */\n};\n\n\nstruct _ssStates {\n    union {\n        void* vect; /* not const because of SL1.3 compat*/\n        UPtrsType uPtrs;\n    } U; /* Inputs for level 1 S-functions   */\n\n    void* Y; /* Output for level 1 S-functions   */\n\n    real_T* contStates; /* Continuous state vector          */\n    real_T* discStates; /* Discrete state vector            */\n\n    struct {\n        unsigned int alreadyWarned : 1;                  /* Flag used by a block to\n                                                          * determine if a warning has\n                                                          * already been thrown for this\n                                                          * block */\n        unsigned int skipContStatesConsistencyCheck : 1; /* Should we skip checking for\n                                                            continuous state consistency */\n        /* prevent lint warnings about bit fields greater than 16 bits */\n        unsigned int reserved13 : 13;\n        unsigned int reserved16 : 16;\n    } flags;\n\n    int_T reserved2;\n\n    real_T* dX;                         /* Derivative vector                */\n    boolean_T* contStateDisabled;       /* Entry for each cont state        */\n    struct _ssStatesInfo2* statesInfo2; /* Auxiliary information about states  */\n    real_T* nonsampledZCs;              /* Non-sampled zero crossing signals */\n    ZCDirection* nonsampledZCDirs;      /* Non-sampled zc directions          */\n\n    SparseHeader* jacobian; /* struct containing system Jacobian  */\n    struct _ssSFcnModelMethods2* modelMethods2;\n    int_T reservedSize;\n};\n\n\n\n/*===========*\n * SimStruct *\n *===========*/\n\nstruct SimStruct_tag {\n\n    const char_T* modelName; /* Name of the Simulink model/Sfunc    */\n\n    const char_T* path; /* Full \"Simulink path\" to this s-fcn  */\n\n    SimStruct* parent; /* Parent SimStruct                    */\n    SimStruct* root;   /* Root level SimStruct                */\n\n    union {\n        const char_T* str; /* Execution status. Setting to non-NULL\n                        during any mdlFunction will stop the\n                        simulation and the \"status\" message\n                        will be displayed.                  */\n        void* msg;\n    } errorStatus;\n\n    struct _ssSizes sizes; /* Sizes (returned when flag==0)      */\n\n    struct _ssPortInfo portInfo; /* Input and output port properties\n                                    such as width and direct feedthrough\n                                    setting.                            */\n\n    struct _ssSFcnParams sfcnParams; /* S-function parameters passed in\n                                        P1,...,Pn                           */\n\n    struct _ssStates states; /* Input, output, state, derivative,\n                                etc. vectors                        */\n\n    struct _ssWork work; /* Various work areas (rwork, iwork,\n                            pwork, user data, block I/O,\n                            block params, etc.)                 */\n\n    struct _ssBlkInfo blkInfo; /* Information about S-function blocks */\n\n    struct _ssMdlInfo* mdlInfo; /* Model-wide info. All children\n                                   SimStruct point to root mdlInfo     */\n\n    struct _ssCallSys callSys; /* For use when S-function calls a\n                                  \"function-call\" subsystems          */\n\n    struct _ssRegDataType regDataType; /* For Registering Data type           */\n\n    struct _ssStInfo stInfo; /* Sample time, offset time, etc.      */\n\n    struct {\n        struct _ssSFcnModelMethods sFcn; /* For S-functions                    */\n    } modelMethods;\n\n    struct SimStruct_tag** sFunctions; /* SimStruct's for S-Functions\n                                          referenced via S-Function blocks.\n                                          Used only with RT and NRT.          */\n};\n\n/*\n * Set any S-function options which must be OR'd together.\n * For example:  ssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE |\n *                              SS_OPTION_DISCRETE_VALUED_OUTPUT);\n *\n * The available options are:\n * SS_OPTION_EXCEPTION_FREE_CODE - if your S-function does not use\n *   mexErrMsgTxt, mxCalloc, or any other routines which can throw an\n *   exception when called, you can set this option for improved\n *   performance.\n *\n * SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE - Similar to\n *   SS_OPTION_EXCEPTION_FREE_CODE except it only applies to the \"run-time\"\n *   routines: mdlGetTimeOfNextVarHit, mdlOutputs, mdlUpdate, and\n *   mdlDerivatives.\n *\n * SS_OPTION_DISCRETE_VALUED_OUTPUT - This should be specified if your\n *   S-function has a discrete valued outputs.  This is checked when\n *   your S-function is placed within an algebraic loop. If your S-function\n *   has discrete valued outputs, then its outputs will not be assigned\n *   algebraic variables.\n *\n * SS_OPTION_PLACE_ASAP - This is used to specify that your S-function\n *   should be placed as soon as possible. This is typically used by\n *   devices connecting to hardware.\n *\n * SS_OPTION_ALLOW_INPUT_SCALAR_EXPANSION - This is used to specify\n *   that the input to your S-function input ports can be either 1 or\n *   the size specified by the port which is usually referred to as\n *   the block width.\n *\n * SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME - This is used to disable\n *   your S-function block from inheriting a constant sample time.\n *\n * SS_OPTION_ASYNCHRONOUS - This option applies only to S-functions that\n *   have no input ports during code generation and 1 output port.\n *   During simulation, the S-function may have an input port to provide\n *   a condition on which to execute. The output port must be configured to\n *   perform function calls on every element.  If any of these requirements\n *   are not met, the SS_OPTION_ASYNCHRONOUS is ignored.  Use this option\n *   when driving function-call subsystems that will be attached to\n *   asynchronous tasks. Specifying this\n *     1) Informs Simulink that there is no implied data dependency involving\n *        the data sources or destinations of the function-call subsystem called\n *        by the S-function.\n *     2) Causes the function-call subsystem attached to the S-function to be\n *        colored cyan indicating that it does not execute at a periodic rate.\n *     3) Enables additional checks to verify that the model is\n *        constructed correctly:\n *          a) Simulink validates that the appropriate asynchronous rate\n *             transition blocks reside between the (cyan) function-call\n *             subsystem and period tasks exists. You can always directly\n *             read & write from the function-call subsys by using a block\n *             similar to the 'vxlib/Asynchronous Support/Rate Transition'\n *             block that has no computational overhead (look at the Tag value\n *             on the Outport block within the Rate Transition masked\n *             subsystem). Safe task transitions between period and\n *             asynchronous tasks are created by using the\n *             SS_OPTION_ASYNC_RATE_TRANSITION.\n *             See the 'vxlib/Asynchronous Support' library.\n *          b) For data transfers between two asynchronously executed (cycan)\n *             function-call subsystem, Simulink validates that the appropriate\n *             asynchronous task transition blocks exits.\n *             See the 'vxlib/Asynchronous Support' library.\n *\n * SS_OPTION_ASYNCHRONOUS_INTERRUPT - This option is very similar to\n *   SS_OPTION_ASYNCHRONOUS. This option adds the restriction that the\n *   this S-function and the destination function-call subsystem cannot reside\n *   in conditionally executed subsystems. This option should be used when the\n *   destination function-call subsystem is going to be directly attached to an\n *   interrupt. This added restriction is useful to prevent conceptual modeling\n *   errors. Specifically, if an function-call subsystem resides within an\n *   enabled subsystem, you would assume that it will only execute occur when\n *   the enable signal is > 0, but this would not be the behavior if the\n *   function-call subsystem were to be attached to an interrupt. Therefore\n *   this option prevents this possible source of confusion.\n *   Note, during simulation (and not code generation), Simulink allows the\n *   S-function to reside in a conditionally executed subsystem. See the\n *   VxWorks interrupt block for an example - in simulation we use a\n *   triggered subsystem to simulate the interrupt and during code generation\n *   the trigger port is removed.\n *\n *\n * SS_OPTION_ASYNCHRONOUS_CUSTOM - Similar to SS_OPTION_ASYNCHRONOUS, except\n *   items 3a, 3b are removed.\n *\n * SS_OPTION_ASYNC_RATE_TRANSITION - Use this when your s-function converts a\n *   guarantees data integrity when transferring data to/from an\n *   asynchronously executed function-call subsystem. There are two types\n *   of data transfers: periodic to asynchronous task transitions or\n *   asynchronous to asynchronous task transitions. An asynchronously executed\n *   function-call subsystem is a function-call subsystem driven by an\n *   S-function with the SS_OPTION_ASYNCHRONOUS specified.\n *\n *   Within Simulink, two classes of 'asynchronous rate transitions' are\n *   defined:\n *   1) Read-write pairs. In this scenario, two blocks (using a technique\n *      such as double buffering) ensure data integrity in a multitasking\n *      environment. When creating the read-write pair of blocks, the\n *      S-functions for these blocks should set SS_OPTION_ASYNC_RATE_TRANSITION.\n *      Furthermore, the Mask Type for the read block, must include\n *      the string 'read' and the write block must include the string 'write'.\n *      For example, in the VxWorks library, we have the\n *        Asynchronous Rate Transition (Reader)\n *        Asynchronous Rate Transition (Writer)\n *      pairs.\n *   2) A single (protected or unprotected) block such as the\n *      VxWorks, Unprotected Asynchronous Rate Transition block.\n *      To create a single Protected Rate Transition block, you\n *      need to create a block like:\n *        +-------------------+\n *        |     +-------+     |\n *        | O-->| S-fcn |-->O |--->\n *        |     +-------+     |\n *        +-------------------+\n *      where the outport has a Tag value set to AsyncRateTransition\n *      and the S-function provides the code for the protected\n *      transition. Note, this S-function should not set the\n *      SS_OPTION_ASYNC_RATE_TRANSITION.\n *\n *\n * SS_OPTION_RATE_TRANSITION - Use this while your S-function is behaving\n *   as a unit delay or ZOH. This option is only supported for these two\n *   operations. A unit delay operation is identified by the presence\n *   of mdlUpdate and if not present then the operation is ZOH.\n *\n * SS_OPTION_NONSTANDARD_PORT_WIDTHS - If your S-function has mdl\n *   set input/output port routines with dynamically sized ports and the port\n *   widths don't follow the standard rules of scalar expansion or\n *   vector collapsing, then you may need to set this flag for Simulink.\n *   This usually occurs when the output width is not 1 and not equal to the\n *   maximum of the input widths.\n *\n * SS_OPTION_PORT_SAMPLE_TIMES_ASSIGNED - Use this when you have\n *   registered multiple sample times (ssSetNumSampleTimes > 1) to\n *   specify the rate at when each input and output port is running at.\n *   The simulation engine needs this information when checking for\n *   illegal rate transitions.\n *\n * SS_OPTION_SFUNCTION_INLINED_FOR_RTW - Set this if you have a .tlc file\n *   for your S-function and do not have a mdlRTW method. Setting option\n *   has no effect if you have a mdlRTW method. This option is like an\n *   assertion. During code generation, if this option is set and\n *   Real-Time Workshop cannot locate the TLC-file for the S-function,\n *   Real-Time Workshop will generate and error. If this option is not present\n *   and Real-Time Workshop locates a TLC-file for the S-function, it will be\n *   used.\n *\n * SS_OPTION_ALLOW_PARTIAL_DIMENSIONS_CALL - Use this if the block can\n *   handle partially known dimensions in the mdlSetInputPortDimensionInfo\n *   or mdlSetOutputPortDimensionInfo methods.  By default, Simulink\n *   calls mdlSetInput(Output)PortDimensionInfo methods, if the\n *   candidate port dimensions are fully known. That is, when the number of\n *   dimensions and dimensions are known. If this flag is set, Simulink may\n *   call mdlSetInput(Output)PortDimensionInfo with partial dimension\n *   information.  As an example, the methods may be called when the port\n *   width is known, but the actual dimensions are unknown.\n *\n *\n * SS_OPTION_ADA_S_FUNCTION - Used to interface with Ada Coded S-functions.\n *   Not relevant for C-Mex S-Functions.\n *\n * SS_OPTION_FORCE_NONINLINED_FCNCALL - Use this flag if the block requires\n *   that all function-call subsystems that it calls should be generated as\n *   procedures instead of possibly being generated as inlined code.\n *\n * SS_OPTION_USE_TLC_WITH_ACCELERATOR -  Use this to force the Accelerator\n *   to use the TLC inlining code for a S-function which will speed up\n *   execution of the S-function.  By default, the Accelerator will use\n *   the mex version of the S-function even though a TLC file for the\n *   S-function exists. This option should not be set for device driver\n *   blocks (A/D) or when there is an incompatibility between running the\n *   mex Start/InitializeConditions functions together with the TLC\n *   Outputs/Update/Derivatives.\n *\n * SS_OPTION_SIM_VIEWING_DEVICE - This s-function is a SimViewingDevice.  As\n *   long as it meets the other requirement for this type of block (no states,\n *   no outputs, etc), it will be considered to be an external mode block\n *   (show up in the external mode gui and no code is generated for it).\n *   During an external mode simulation, this block is run on the host only.\n *\n * SS_OPTION_SIM_INPUT_DEVICE - Mark this s-function as a SimInputDevice.  When\n *   this option is set and this s-function registered an mdlExtModeExec fcn,\n *   then it will be run in external mode.\n *\n * SS_OPTION_CALL_TERMINATE_ON_EXIT - Use this to force a call to mdlTerminate\n *   when (a) the S-function block has finished mdlWorkWidths, or (b) the\n *   S-function block is being destroyed.\n *\n * SS_OPTION_REQ_INPUT_SAMPLE_TIME_MATCH - Use this to option to specify\n *   that the input signal sample time(s) match the sample time assigned\n *   to the block input port. For example:\n *\n *      .-----------.           .---------------------------.\n *      |  src (.1) |---------->|  port based Ts S-fcn with |\n *      `-----------'           |  input Ts = 1             |\n *                              `---------------------------'\n *\n *   will generate an error if this option is set. If the block (or input port)\n *   sample time is inherited, then there will be no error generated.\n *\n * SS_OPTION_NONVOLATILE - Use this option to specify whether this s-function\n *   has side effects.  Set this option to request that Simulink remove\n *   this block if it is not needed (dead code).\n *\n * SS_OPTION_CAN_BE_CALLED_CONDITIONALLY - Use this option if the s-function\n *   can be called conditionally by other blocks.\n *\n * SS_OPTION_ALLOW_PORT_SAMPLE_TIME_IN_TRIGSS - Use this to specify that\n *   your port based sample time S-Function can handle being placed in a\n *   triggered like subsystem (e.g. triggered, function call, for, while).\n *   During sample time propagation use the macro ssSampleAndOffsetAreTriggered\n *   to determine if the sample and offset times correspond to the block\n *   being in a triggered subsystem. If the block is triggered, all port\n *   sample times must be either triggered or constant.\n *\n * SS_OPTION_ALLOW_CONSTANT_PORT_SAMPLE_TIME - Use this option to specify\n *   that your port-based sample time S-Function can handle constant sample\n *   times. This option is required whether the S-Function is going to\n *   originate the constant sample time or can have one propagated to it.\n *\n * SS_OPTION_WORKS_WITH_CODE_REUSE - Use this option to specify that your\n *   S-Function will work in a system that is being reused in RTW\n *   generated code.  If this option is not set, then the system that\n *   this S-Function lives in will not be reused.\n *\n * SS_OPTION_SUPPORTS_ALIAS_DATA_TYPES - This is used to state whether\n *   or not this block supports alias data types\n *\n * SS_OPTION_NO_INFLUENCE_ON_DEFAULT_MDL_DIMS - When dimensions propagation\n * to converge to a set of dimensions, blocks are queried individually\n * to setup their default dimensions. In the case of the S-function, this is\n * done by calling the mdlSetDefaultPortDimensions function. If the S-function\n * has no clear means of identifying a default set of dimensions, please\n * use this flag to postpone calls to mdlSetDefaultPortDimensions.\n */\n#if SS_SFCN_LEVEL_1 || !SS_SFCN\n#define SS_OPTION_USING_ssGetUPtrs 0x00000001\n#endif\n\n#define SS_OPTION_EXCEPTION_FREE_CODE 0x00000002\n#define SS_OPTION_DISCRETE_VALUED_OUTPUT 0x00000004\n\n#if !SS_SFCN_LEVEL_1\n#define SS_OPTION_PLACE_ASAP 0x00000008\n#define SS_OPTION_ALLOW_INPUT_SCALAR_EXPANSION 0x00000010\n#define SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME 0x00000020\n#define SS_OPTION_ASYNCHRONOUS 0x00000040\n#define SS_OPTION_ASYNC_RATE_TRANSITION 0x00000080\n#define SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE 0x00000100\n#define SS_OPTION_RATE_TRANSITION 0x00000200\n#define SS_OPTION_NONSTANDARD_PORT_WIDTHS 0x00000400\n#define SS_OPTION_PORT_SAMPLE_TIMES_ASSIGNED 0x00000800\n#define SS_OPTION_SFUNCTION_INLINED_FOR_RTW 0x00001000\n/* !!! 0x00002000 used below !!! */\n#define SS_OPTION_ALLOW_PARTIAL_DIMENSIONS_CALL 0x00004000\n#define SS_OPTION_NO_INFLUENCE_ON_DEFAULT_MDL_DIMS 0x00008000\n#define SS_OPTION_ADA_S_FUNCTION 0x00010000\n#define SS_OPTION_FORCE_NONINLINED_FCNCALL 0x00020000\n/* !!! 0x00040000 used below !!! */\n#define SS_OPTION_USE_TLC_WITH_ACCELERATOR 0x00080000\n#define SS_OPTION_SIM_VIEWING_DEVICE 0x00100000\n#define SS_OPTION_CALL_TERMINATE_ON_EXIT 0x00200000\n#define SS_OPTION_REQ_INPUT_SAMPLE_TIME_MATCH 0x00400000\n#define SS_OPTION_ASYNCHRONOUS_CUSTOM 0x00800000\n#define SS_OPTION_NONVOLATILE 0x01000000\n#define SS_OPTION_CAN_BE_CALLED_CONDITIONALLY 0x02000000\n#define SS_OPTION_ALLOW_PORT_SAMPLE_TIME_IN_TRIGSS 0x04000000\n#define SS_OPTION_ALLOW_CONSTANT_PORT_SAMPLE_TIME 0x08000000\n#define SS_OPTION_ASYNCHRONOUS_INTERRUPT 0x10000000\n#define SS_OPTION_WORKS_WITH_CODE_REUSE 0x20000000\n#define SS_OPTION_SUPPORTS_ALIAS_DATA_TYPES 0x40000000\n#define SS_OPTION_SIM_INPUT_DEVICE 0x80000000\n#endif\n\n/*\n * SS_OPTION_SUPPORTS_MULTITASKING is a flag for Simulink and is *not* to\n * be used by S-functions.\n */\n#define SS_OPTION_SUPPORTS_MULTITASKING 0x00002000\n\n/*\n * SS_OPTION_PROPAGATE_COMPOSITE_SYSTEM is a flag for Simulink and is *not*\n * to be used by S-functions.\n */\n#define SS_OPTION_PROPAGATE_COMPOSITE_SYSTEM 0x00040000\n\n#define SS_HAVEOPT(S, opt) ((ssGetOptions(S) & opt) != 0)\n\n#define ssGetOptions(S) (S)->sizes.options /*   (uint_T)      */\n\n#endif /* __SIMSTRUC__DEF */\n/* LocalWords:  ID's ir Lcs Struct's dstates fcncall Slvr extmode vectorizable SIGSET sigmapdef th\n * LocalWords:  th'signal tid's zc conds nd CBK vals sti iwork rwork pwork nz compat Sfunc NRT OR'd\n * LocalWords:  vxlib ASYNC cycan Async TRIGSS\n */\n"},{"name":"simstruc_implement.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/**\n * @file: simstruc_implement.h\n *\n * @brief Required ssAPIs for simstruc.h and s-function demo examples, but not documented.\n *\n */\n\n#ifndef __SIMSTRUC__IMPLEMENT\n#define __SIMSTRUC__IMPLEMENT\n\n\n#define _ssSafelyCallConstGenericFcnStart(S) \\\n       (((S)->mdlInfo->genericFcn==NULL) ? 0 : ((*((_ConstGenericFcn)(S)->mdlInfo->genericFcn))\n#define _ssSafelyCallGenericFcnEnd ))\n\n#define _ssSafelyCallGenericFcnStart(S) \\\n       (((S)->mdlInfo->genericFcn==NULL) ? 0 : ((*(S)->mdlInfo->genericFcn)\n#define _ssSafelyCallGenericFcnEnd ))\n\n\n#if !SS_SFCN_LEVEL_1\n\n#define _ssGetNumInputPorts(S) \\\n    ((ssGetSfcnUsesNumPorts(S) == 1) ? ((S)->sizes.in.numInputPorts) : 0) /*(int_T) */\n\n#define _ssSetNumInputPorts(S, nInputPorts) (S)->sizes.in.numInputPorts = (nInputPorts)\n\n#define _ssGetNumOutputPorts(S) \\\n    ((ssGetSfcnUsesNumPorts(S) == 1) ? ((S)->sizes.out.numOutputPorts) : 0) /*(int_T) */\n\n\n#define _ssSetNumOutputPorts(S, nOutputPorts) (S)->sizes.out.numOutputPorts = (nOutputPorts)\n\n#endif\n\n\n#if defined(USE_64BIT_FIELDS)\n#define _ssSetCurrentOutputPortDimensions(S, pIdx, dIdx, val) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(pIdx)].portVarDims[(dIdx)] = (val)\n#elif defined(USE_32BIT_FIELDS)\n#define _ssSetCurrentOutputPortDimensions(S, pIdx, dIdx, val) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputs[(pIdx)].portVarDims[(dIdx)] = (val)\n#endif\n\nstruct _ssVarDimsIdxVal_tag {\n    int dIdx;\n    int dVal;\n#if defined(INT64_T) && defined(INT_TYPE_64_IS_SUPPORTED)\n    SLSize dValSLSize;\n#endif\n};\n\n#define _ssGetSFcnParam(S, index) (S)->sfcnParams.dlgParams[index] /*   (mxArray *)   */\n\n#define _ssSetNumRunTimeParams(S, num) (S)->sfcnParams.numRtp.numRtp = (num)\n\n\n#define _ssSetRunTimeParamInfo(S, idx, p) (S)->sfcnParams.rtp[idx] = (p)\n\n/* DWork - This is the number of the data type work vector of your S-function.\n *   The root SimStruct contains the total number of data type work vectors\n *   used within the model.\n */\n#if defined(USE_64BIT_FIELDS)\n#define _ssSetNumDWork(S, nDWork) ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDWork = (nDWork))\n#elif defined(USE_32BIT_FIELDS)\n#define _ssSetNumDWork(S, nDWork) ((S)->sizes.numDWork = (nDWork))\n#endif\n\n\n#define ssIsTIDInStInfo(S, tid)                                                               \\\n    (((tid) >= 0) &&                                                                          \\\n     ((tid) <                                                                                 \\\n      (ssGetParentSS(S) ? ssGetNumSampleTimes(ssGetParentSS(S)) : ssGetNumSampleTimes(S))) && \\\n     (ssGetSampleTimeTaskID(S, tid) < ssGetNumRootSampleTimes(S)))\n\n#define ssGetSampleHitPtr(S) (S)->mdlInfo->sampleHits /*   (int_T *) */\n\n\n#if SS_SL_INTERNAL\n#define ssGetSampleTimeTaskID(S, sti) (S)->stInfo.sampleTimeTaskIDs[sti] /*   (int_T)       */\n#elif TID_EQUALS_SAMPLE_TIME_INDEX\n#define ssGetSampleTimeTaskID(S, sti) (sti) /*   (int_T)       */\n#else\n#define ssGetSampleTimeTaskID(S, sti) (S)->stInfo.sampleTimeTaskIDs[sti] /*   (int_T)       */\n#endif\n\n#if defined(USE_64BIT_FIELDS)\n#define ssGetRegOutputPortDimensionInfoFcn(S) \\\n    ((S)->blkInfo.blkInfo2->mdlInfoSLSize->regOutputPortDimsInfo)\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetRegOutputPortDimensionInfoFcn(S) ((S)->mdlInfo->regOutputPortDimsInfo)\n#endif\n\n\n/* InputPortFrameData -  For each input port or your S-function block, this\n *   is whether or not the incoming signal is frame data, where (-1=either,\n *   0=no, 1=yes).\n */\n\n#define ssSetInputPortFrameData(S, port, val) \\\n    (S)->portInfo.inputs[(port)].attributes.frameData = CONV_INT2BITS(val)\n\n/* OutputPortFrameData - For each input port or your S-function block, this\n *   is whether or not the outgoing signal is frame data, where (-1=either,\n *   0=no, 1=yes).\n */\n\n#define ssSetOutputPortFrameData(S, port, val) \\\n    (S)->portInfo.outputs[(port)].attributes.frameData = CONV_INT2BITS(val)\n\n\n\n#if SS_SFCN_FOR_SIM\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern int_T ssWriteRTWNameValuePair(SimStruct* S,\n                                     int_T type,\n                                     const char_T* name,\n                                     const void* value,\n                                     ...);\n\nextern int_T _ssSetInputPortMatrixDimensions(SimStruct* S, int_T port, int_T m, int_T n);\nextern int_T _ssSetOutputPortMatrixDimensions(SimStruct* S, int_T port, int_T m, int_T n);\nextern int_T _ssSetInputPortVectorDimension(SimStruct* S, int_T port, int_T m);\nextern int_T _ssSetOutputPortVectorDimension(SimStruct* S, int_T port, int_T m);\nextern int_T ssIsRunTimeParamTunable(SimStruct* S, const int_T rtPIdx);\nextern double ssGetSFuncBlockHandle(SimStruct* S);\nextern int_T _ssGetCurrentInputPortWidth(SimStruct* S, int_T pIdx);\nextern int_T _ssGetCurrentOutputPortWidth(SimStruct* S, int_T pIdx);\nextern int_T _ssGetCallSystemNumFcnCallDestinations(SimStruct* S, int_T elemIdx);\nextern boolean_T ssGetParameterTuningCompliance(SimStruct* S);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n\ntypedef struct _ssRTPRegInfoWithType_tag {\n    int dlgIdx;\n    int rtIdx;\n    const char* name;\n    int dtId;\n} ssRTPRegInfoWithType;\n\n\n#if !SS_SFCN_LEVEL_1\n\n#if defined(USE_64BIT_FIELDS)\n#define ssGetRegInputPortDimensionInfoFcn(S) \\\n    ((S)->blkInfo.blkInfo2->mdlInfoSLSize->regInputPortDimsInfo)\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetRegInputPortDimensionInfoFcn(S) ((S)->mdlInfo->regInputPortDimsInfo)\n#endif\n\n#endif\n\n\n/*\n * ssSetCallSystemOutput -\n *   S-functions should use this in mdlInitializeSampleTimes to specify\n *   which output port elements of the first output port are connected\n *   to function-call subsystems. The S-function can then execute\n *   the function-call subsystems via ssCallSystemWithTID\n */\n#define ssGetCallSystemOutputPtr(S) (S)->callSys.outputs /* (int_T*)    */\n#define _ssSetCallSystemOutputPtr(S, ptr) (S)->callSys.outputs = (ptr)\n#if !SS_SFCN\n#define ssSetCallSystemOutputPtr(S, ptr) _ssSetCallSystemOutputPtr(S, ptr)\n#else\n#define ssSetCallSystemOutputPtr(S, ptr) ssSetCallSystemOutputPtr_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetCallSystemOutput(S, element) (S)->callSys.outputs[element] /* (int_T)     */\n\n\n\n/* ================== APIs for zero crossing =================================*/\n\ntypedef struct {\n    int_T _regionIdx;\n    int_T _regionElIdx;\n    boolean_T _result;\n} _ssRegionElementIdxInfo;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern boolean_T ssGetIsZeroCrossControlDisabled(SimStruct* S);\nextern void ssSetIsInputPortUsedForContZcSignal(SimStruct* S, int_T pIdx, boolean_T value);\nextern void ssSetZcSignalIsZcElementDisc(SimStruct* S,\n                                         int_T zcsIdx,\n                                         int_T zcsElIdx,\n                                         boolean_T value);\nextern void ssSetZcSignalName(SimStruct* S, int_T zcsIdx, char* name);\nextern void ssSetZcSignalWidth(SimStruct* S, int_T zcsIdx, int_T width);\nextern void ssSetZcSignalZcEventType(SimStruct* S, int_T zcsIdx, slZcEventType zcEventType);\nextern void ssSetZcSignalType(SimStruct* S, int_T zcsIdx, slZcSignalType zcSignalType);\nextern void ssSetZcSignalZcTol(SimStruct* S, int_T zcsIdx, double zcTol);\nextern void ssSetZcSignalNeedsEventNotification(SimStruct* S,\n                                                int_T zcsIdx,\n                                                boolean_T needsEventNotification);\n\nextern int_T ssCreateAndAddZcSignalInfo(SimStruct* S);\nextern int_T ssCloneAndAddZcSignalInfo(SimStruct* S, int_T zcsIdx);\nextern int_T ssGetNumZcSignals(SimStruct* S);\n\nextern double* ssGetZcSignalVector(SimStruct* S, int_T zcsIdx);\nextern const char* ssGetZcSignalName(SimStruct* S, int_T zcsIdx);\nextern int_T ssGetZcSignalWidth(SimStruct* S, int_T zcsIdx);\nextern slZcEventType ssGetZcSignalZcEventType(SimStruct* S, int_T zcsIdx);\nextern slZcEventType* ssGetZcSignalZcEvents(SimStruct* S, int_T zcsIdx);\nextern slZcSignalType ssGetZcSignalType(SimStruct* S, int_T zcsIdx);\nextern double ssGetZcSignalZcTol(SimStruct* S, int_T zcsIdx);\nextern boolean_T ssGetZcSignalNeedsEventNotification(SimStruct* S,\n\n                                                     int_T zcsIdx);\nextern boolean_T ssGetZcSignalIsZcElementDisc(SimStruct* S, int_T zcsIdx, int_T zcsElIdx);\n\nextern boolean_T ssGetIsInputPortElementContinuous(SimStruct* S, int_T pIdx, int_T eIdx);\n#ifdef __cplusplus\n}\n#endif\n\n\n\n#define ssGetNumRootSampleTimes(S) ssGetNumSampleTimes(ssGetRootSS(S))\n\n\n\n#if SS_SIM\n#define dtaGetDataTypeSize(dta, blockPath, id)                                            \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_SIZE)                   \\\n                   : INVALID_DTYPE_SIZE)\n#else\n#define dtaGetDataTypeSize(dta, blockPath, id) dtaGetDataTypeSize_cannot_be_used_in_RTW\n#endif\n\n\n\n/*\n * The following macro, ssSetTimeOfNextVarHit, will not work in non-inlined\n * S-functions in rapid accelerator or rsim. When using this advanced\n * and undocumented feature, TLC will be required in order to support\n * Rapid Accelerator simulation mode or Simulink Coder code generation\n * (rsim target).\n */\n\n#define _ssSetVarNextHitTime(S, i, value) (S)->mdlInfo->varNextHitTimesList[(i)] = (value)\n#define _ssGetVarNextHitTime(S, i) ((real_T)((S)->mdlInfo->varNextHitTimesList[(i)]))\n\n\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#if defined(RTW_GENERATED_S_FUNCTION)\n#define ssSetTimeOfNextVarHit(S, sti, tNext)                                                      \\\n    {                                                                                             \\\n        _ssSetVarNextHitTime(ssGetRootSS(S), (int)(ssGetOffsetTime(ssGetRootSS(S), sti)), tNext); \\\n        ssSetTNext(S, tNext);                                                                     \\\n    }\n\n#define ssGetTimeOfNextVarHit(S, sti) \\\n    _ssGetVarNextHitTime(ssGetRootSS(S), (int)(ssGetOffsetTime(ssGetRootSS(S), sti)))\n\n#else\n#define ssSetTimeOfNextVarHit(S, sti, tNext)                                                       \\\n    {                                                                                              \\\n        _ssSetVarNextHitTime(                                                                      \\\n            ssGetRootSS(S), (int)(ssGetOffsetTime(ssGetRootSS(S), ssGetSampleTimeTaskID(S, sti))), \\\n            tNext);                                                                                \\\n        ssSetTNext(S, tNext);                                                                      \\\n    }\n\n#define ssGetTimeOfNextVarHit(S, sti)    \\\n    _ssGetVarNextHitTime(ssGetRootSS(S), \\\n                         (int)(ssGetOffsetTime(ssGetRootSS(S), ssGetSampleTimeTaskID(S, sti))))\n\n#endif\n#endif\n\n\n#if SS_MULTITASKING || SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssGetPerTaskSampleHitsPtr(S) (S)->mdlInfo->perTaskSampleHits /*   (int_T *) */\n#endif\n\n\n#if !SS_SFCN_LEVEL_1\n#if SS_SIM\n\ntypedef struct _ssRegisterTypeFromNameType_tag {\n    const char* name;\n    int* dataTypeId;\n} ssRegisterTypeFromNameType;\n\n#endif\n\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern real_T* _ssGetAbsTol(SimStruct* S);\nextern void _ssSetStateAbsTol(SimStruct* S, const int_T idx, const real_T val);\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n#ifndef _DIMSDEPENDINFO_T\n#define _DIMSDEPENDINFO_T\n\n/* Set the current dimension of output port outIdx based on the dims dependent rule ruleIdx */\ntypedef void (*SetOutputDimsFcn)(SimStruct* S, int outIdx, int* inps, int numInps);\n/*\n * RTWCG function of setting the current dimension of output port outIdx based\n * on the dims dependent rule ruleIdx\n */\ntypedef void (*SetOutputDimsRTWCGFcn)(SimStruct* S, void* rtwBlk, int oIdx, int* inps, int nInputs);\n\ntypedef struct {\n    int* inputs;                       /* index to inputs whose dims affect the output dims*/\n    int numInputs;                     /* number of inputs affect the output dims */\n    SetOutputDimsFcn setOutputDimsFcn; /* function to update the output dims\n                                          based on the dims of inputs*/\n    SetOutputDimsRTWCGFcn setOutputDimsRTWCGFcn;\n    /* RTWCG function to update output dims\n       based on the dims of inputs */\n} DimsDependInfo_T;\n\n#endif\n\n\n\ntypedef void (*mdlSetInputPortDimensionsModeFcn)(SimStruct* S,\n                                                 int_T portIdx,\n                                                 DimensionsMode_T dimsMode);\n\n\n\n/* ssSetSFcnParamTunable - This should be used by S-function blocks\n *   to specify when a parameter is tunable or not tunable.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetSFcnParamNotTunable(S, index) \\\n    (S)->sfcnParams.dlgAttribs[index] = ((S)->sfcnParams.dlgAttribs[index] | SFCNPARAM_NOT_TUNABLE)\n#else                                      /* RT or NRT */\n#define ssSetSFcnParamNotTunable(S, index) /* do nothing */\n#endif\n\n\n#define ssSetInputPortSignalWhenNeeded(S, port, val) \\\n    (S)->portInfo.inputs[(port)].attributes.cinId = (val)\n\n\n\n#if SS_SIM\n#define ssComputeInput(S, pIdx) \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_COMPUTE_INPUT, pIdx, NULL) _ssSafelyCallGenericFcnEnd\n#else\n#define ssComputeInput(S, pIdx) ssComputeInput_cannot_be_used_in_RTW\n#endif\n\n\n\n#if SS_SIM\n#define dtaSetErrorString(dta, string) ((dta) != NULL ? (dta)->errorString = (string) : 0)\n#else\n#define dtaSetErrorString(dta, string) dtaSetErrorString_cannot_be_used_in_RTW\n#endif\n\n\n#if SS_SIM\n#define dtaSetConvertBetweenFcn(dta, blockPath, id, fcn)                                         \\\n    ((dta) != NULL ? (dta)->setConvertBetweenFcn((dta)->dataTypeTable, (blockPath), (id), (fcn)) \\\n                   : 0)\n#else\n#define dtaSetConvertBetweenFcn(dta, blockPath, id, fcn) \\\n    dtaSetConvertBetweenFcn_cannot_be_used_in_RTW\n#endif\n\n\n\n#if SS_SIM\n#define dtaSetIsPositiveFcn(dta, blockPath, id, fcn)                                         \\\n    ((dta) != NULL ? (dta)->setGenericDTAUnaryFcnGW((dta)->dataTypeTable, (blockPath), (id), \\\n                                                    (fcn), GEN_DTA_UNARY_FCN_IS_POSITIVE)    \\\n                   : 0)\n#else\n#define dtaSetIsPositiveFcn(dta, blockPath, id, fcn) dtaSetIsPositiveFcn_cannot_be_used_in_RTW\n#endif\n\n\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#ifdef ssGetOwnerBlock\n#define ssSetInputPortBusMode(S, pIdx, value)                                            \\\n    {                                                                                    \\\n        if (ssGetOwnerBlock(S) != NULL) {                                                \\\n            BusMode_T val = value;                                                       \\\n            _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_INPUT_BUS_MODE, pIdx, &val) \\\n                _ssSafelyCallGenericFcnEnd;                                              \\\n        }                                                                                \\\n    }\n\n#define ssSetOutputPortBusMode(S, pIdx, value)                                            \\\n    {                                                                                     \\\n        if (ssGetOwnerBlock(S) != NULL) {                                                 \\\n            BusMode_T val = value;                                                        \\\n            _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_OUTPUT_BUS_MODE, pIdx, &val) \\\n                _ssSafelyCallGenericFcnEnd;                                               \\\n        }                                                                                 \\\n    }\n#else\n#define ssSetInputPortBusMode(S, pIdx, value)\n#define ssSetOutputPortBusMode(S, pIdx, value)\n#endif\n#else\n#define ssSetInputPortBusMode(S, pIdx, value)\n#define ssSetOutputPortBusMode(S, pIdx, value)\n#endif\n\n\n#if SS_SIM\n#define dtaGetDataTypeElementOffset(dta, blockPath, id, eIdx)                                 \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                     (eIdx), GEN_DTA_INT_PROP_ELEMENT_OFFSET) \\\n                   : -1)\n#else\n#define dtaGetDataTypeElementOffset(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementOffset_cannot_be_used_in_RTW\n#endif\n\n\n\n#define ssGetTNextWasAdjusted(S, sti) ((S)->mdlInfo->tNextWasAdjusted[sti]) /* (boolean_T) */\n\n\n/* InputPortAcceptExprInRTW - Specify that the input port signal can be\n * an expression in RTW.  This allows the block to fold an upstream\n * calculation into its own.\n */\n#define ssGetInputPortAcceptExprInRTW(S, port) \\\n    ((S)->portInfo.inputs[(port)].attributes.acceptExprInRTW == 1U)\n#define ssSetInputPortAcceptExprInRTW(S, port, val) \\\n    ((S)->portInfo.inputs[(port)].attributes.acceptExprInRTW = (val) ? 1U : 0U)\n\n/* OutputPortOutputExprInRTW - Specify that the output signal is an expression\n * in RTW (versus a statement).  This allows a downstream block to fold\n * the expression into its calculation.  Note that Simulink may not honor\n * this setting, in which case the block must produce a statement.\n */\n#define ssGetOutputPortOutputExprInRTW(S, port) \\\n    ((S)->portInfo.outputs[(port)].attributes.outputExprInRTW == 1U)\n#define ssSetOutputPortOutputExprInRTW(S, port, val)                                \\\n    ((S)->portInfo.outputs[(port)].attributes.outputExprInRTW =                     \\\n         (val) ? 1U                                                                 \\\n               : ((S)->portInfo.outputs[(port)].attributes.trivialOutputExprInRTW = \\\n                      (S)->portInfo.outputs[(port)].attributes.constOutputExprInRTW = 0U))\n\n#define ssSetmdlOutputs(S, outputs) (S)->modelMethods.sFcn.mdlOutputs.level2 = (outputs)\n\n#if SS_SIM\n#define dtaGetDataTypeIdAliasedThruTo(dta, blockPath, id)                                 \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_ID_ALIASED_THRU_TO)     \\\n                   : INVALID_DTYPE_ID)\n#else\n#define dtaGetDataTypeIdAliasedThruTo(dta, blockPath, id) \\\n    dtaGetDataTypeIdAliasedThruTo_cannot_be_used_in_RTW\n#endif\n\n\n#if SS_SIM\n#define dtaGetErrorString(dta) ((dta) != NULL ? (dta)->errorString : NULL)\n#else\n#define dtaGetErrorString(dta) dtaGetErrorString_cannot_be_used_in_RTW\n#endif\n\n\n\n#if SS_SIM\n#define dtaRegisterDataTypeWithCheck(dta, blockPath, name, idptr)                                  \\\n    ((dta) != NULL ? (dta)->registerFcnWithCheck((dta)->dataTypeTable, (blockPath), (name), idptr) \\\n                   : NULL)\n#else\n#define dtaRegisterDataTypeWithCheck(dta, blockPath, name, idptr) \\\n    dtaRegisterDataType_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaRegisterDataType(dta, blockPath, name)                                  \\\n    ((dta) != NULL ? (dta)->registerFcn((dta)->dataTypeTable, (blockPath), (name)) \\\n                   : INVALID_DTYPE_ID)\n#else\n#define dtaRegisterDataType(dta, blockPath, name) dtaRegisterDataType_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetNumDataTypes(dta) \\\n    ((dta) != NULL ? (dta)->getNumDataTypesFcn((dta)->dataTypeTable) : INVALID_NUM_DTYPES)\n#else\n#define dtaGetNumDataTypes(dta) dtaGetNumDataTypes_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeId(dta, name) \\\n    ((dta) != NULL ? (dta)->getIdFcn((dta)->dataTypeTable, (name)) : INVALID_DTYPE_ID)\n#else\n#define dtaGetDataTypeId(dta, name) dtaGetDataTypeId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeName(dta, blockPath, id)                                             \\\n    ((dta) != NULL ? (dta)->getGenericDTAVoidProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                  GEN_DTA_VOID_PROP_NAME)                  \\\n                   : NULL)\n#else\n#define dtaGetDataTypeName(dta, blockPath, id) dtaGetDataTypeName_cannot_be_used_in_RTW\n#endif\n\n\n\n#if SS_SIM\n#define dtaSetDataTypeSize(dta, blockPath, id, size)                                              \\\n    ((dta) != NULL ? (dta)->setGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), (size), \\\n                                                 GEN_DTA_INT_PROP_SIZE)                           \\\n                   : 0)\n#else\n#define dtaSetDataTypeSize(dta, blockPath, id, size) dtaSetDataTypeSize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeStorageId(dta, blockPath, id)                                       \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_STORAGE_ID)             \\\n                   : INVALID_DTYPE_ID)\n#else\n#define dtaGetDataTypeStorageId(dta, blockPath, id) dtaGetDataTypeStorageId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetDataTypeStorageId(dta, blockPath, id, storageId)                             \\\n    ((dta) != NULL ? (dta)->setGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id),  \\\n                                                 (storageId), GEN_DTA_INT_PROP_STORAGE_ID) \\\n                   : 0)\n#else\n#define dtaSetDataTypeStorageId(dta, blockPath, id, storageId) \\\n    dtaSetDataTypeStorageId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeIdAliasedTo(dta, blockPath, id)                                     \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_ID_ALIASED_TO)          \\\n                   : INVALID_DTYPE_ID)\n#else\n#define dtaGetDataTypeIdAliasedTo(dta, blockPath, id) \\\n    dtaGetDataTypeIdAliasedTo_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetDataTypeIdAliasedTo(dta, blockPath, id, idAliasedTo)                              \\\n    ((dta) != NULL ? (dta)->setGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id),       \\\n                                                 (idAliasedTo), GEN_DTA_INT_PROP_ID_ALIASED_TO) \\\n                   : 0)\n#else\n#define dtaSetDataTypeIdAliasedTo(dta, blockPath, id, idAliasedTo) \\\n    dtaSetDataTypeIdAliasedTo_cannot_be_used_in_RTW\n#endif\n\n\n#if SS_SIM\n#define dtaGetDataTypeZero(dta, blockPath, id)                                             \\\n    ((dta) != NULL ? (dta)->getGenericDTAVoidProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                  GEN_DTA_VOID_PROP_ZERO)                  \\\n                   : NULL)\n#else\n#define dtaGetDataTypeZero(dta, blockPath, id) dtaGetDataTypeZero_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetDataTypeZero(dta, blockPath, id, zero)                                               \\\n    ((dta) != NULL ? (dta)->setGenericDTAVoidProp((dta)->dataTypeTable, (blockPath), (id), (zero), \\\n                                                  GEN_DTA_VOID_PROP_ZERO)                          \\\n                   : 0)\n#else\n#define dtaSetDataTypeZero(dta, blockPath, id, zero) dtaSetDataTypeZero_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeProperties(dta, blockPath, id)                                       \\\n    ((dta) != NULL ? (dta)->getGenericDTAVoidProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                  GEN_DTA_VOID_PROP_PROPERTIES)            \\\n                   : NULL)\n#else\n#define dtaGetDataTypeProperties(dta, blockPath, id) dtaGetDataTypeProperties_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetDataTypeProperties(dta, blockPath, id, properties)                              \\\n    ((dta) != NULL ? (dta)->setGenericDTAVoidProp((dta)->dataTypeTable, (blockPath), (id),    \\\n                                                  (properties), GEN_DTA_VOID_PROP_PROPERTIES) \\\n                   : 0)\n#else\n#define dtaSetDataTypeProperties(dta, blockPath, id, properties) \\\n    dtaSetDataTypeProperties_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeObject(dta, blockPath, id)                                           \\\n    ((dta) != NULL ? (dta)->getGenericDTAVoidProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                  GEN_DTA_VOID_PROP_OBJECT)                \\\n                   : NULL)\n#else\n#define dtaGetDataTypeObject(dta, blockPath, id) dtaGetDataTypeObject_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeCGType(dta, blockPath, id)                                           \\\n    ((dta) != NULL ? (dta)->getGenericDTAVoidProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                  GEN_DTA_VOID_PROP_CGTYPE)                \\\n                   : NULL)\n#else\n#define dtaGetDataTypeCGType(dta, blockPath, id) dtaGetDataTypeCGType_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypePropertiesSize(dta, blockPath, id)                                  \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_PROPERTIES_SIZE)        \\\n                   : INVALID_DTYPE_SIZE)\n#else\n#define dtaGetDataTypePropertiesSize(dta, blockPath, id) \\\n    dtaGetDataTypePropertiesSize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetDataTypePropertiesSize(dta, blockPath, id, size)                                    \\\n    ((dta) != NULL ? (dta)->setGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), (size), \\\n                                                 GEN_DTA_INT_PROP_PROPERTIES_SIZE)                \\\n                   : 0)\n#else\n#define dtaSetDataTypePropertiesSize(dta, blockPath, id, size) \\\n    dtaSetDataTypePropertiesSize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeNumElements(dta, blockPath, id)                                     \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_NUM_ELEMENTS)           \\\n                   : -1)\n#else\n#define dtaGetDataTypeNumElements(dta, blockPath, id) \\\n    dtaGetDataTypeNumElements_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeIsBus(dta, blockPath, id)                                           \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_IS_BUS)                 \\\n                   : -1)\n#else\n#define dtaGetDataTypeIsBus(dta, blockPath, id) dtaGetDataTypeIsBus_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeIsBusWithVarDimsElement(dta, blockPath, id)                              \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id),      \\\n                                                 GEN_DTA_INT_PROP_IS_BUS_WITH_VARDIMS_ELEMENT) \\\n                   : -1)\n#else\n#define dtaGetDataTypeIsBusWithVarDimsElement(dta, blockPath, id) \\\n    dtaGetDataTypeIsBusWithVarDimsElement_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeVarDimsSize(dta, blockPath, id)                                     \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_VARDIMS_SIZE)           \\\n                   : INVALID_DTYPE_SIZE)\n#else\n#define dtaGetDataTypeVarDimsSize(dta, blockPath, id) \\\n    dtaGetDataTypeVarDimsSize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementDataType(dta, blockPath, id, eIdx)                                  \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id),    \\\n                                                     (eIdx), GEN_DTA_INT_PROP_ELEMENT_DATA_TYPE) \\\n                   : INVALID_DTYPE_ID)\n#else\n#define dtaGetDataTypeElementDataType(dta, blockPath, id, eIdx)                            \\\n    ((dta) != NULL && (dta->access64) != NULL                                              \\\n         ? (dta->access64)                                                                 \\\n               ->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                          GEN_DTA_INT_PROP_ELEMENT_DATA_TYPE)              \\\n         : INVALID_DTYPE_ID)\n#endif\n#else\n#define dtaGetDataTypeElementDataType(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementDataType_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementSignalType(dta, blockPath, id, eIdx)                                  \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id),      \\\n                                                     (eIdx), GEN_DTA_INT_PROP_ELEMENT_SIGNAL_TYPE) \\\n                   : INVALID_DTYPE_ID)\n#else\n#define dtaGetDataTypeElementSignalType(dta, blockPath, id, eIdx)                          \\\n    ((dta) != NULL && (dta->access64) != NULL                                              \\\n         ? (dta->access64)                                                                 \\\n               ->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                          GEN_DTA_INT_PROP_ELEMENT_SIGNAL_TYPE)            \\\n         : INVALID_DTYPE_ID)\n#endif\n#else\n#define dtaGetDataTypeElementSignalType(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementSignalType_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementNumDimensions(dta, blockPath, id, eIdx)                        \\\n    ((dta) != NULL                                                                          \\\n         ? (dta)->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                           GEN_DTA_INT_PROP_ELEMENT_NUM_DIMENSIONS)         \\\n         : -1)\n#else\n#define dtaGetDataTypeElementNumDimensions(dta, blockPath, id, eIdx)                       \\\n    ((dta) != NULL && (dta->access64) != NULL                                              \\\n         ? (dta->access64)                                                                 \\\n               ->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                          GEN_DTA_INT_PROP_ELEMENT_NUM_DIMENSIONS)         \\\n         : -1)\n#endif\n#else\n#define dtaGetDataTypeElementNumDimensions(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementNumDimensions_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementDimensionsMode(dta, blockPath, id, eIdx)                       \\\n    ((dta) != NULL                                                                          \\\n         ? (dta)->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                           GEN_DTA_INT_PROP_ELEMENT_DIMENSIONS_MODE)        \\\n         : -1)\n#else\n#define dtaGetDataTypeElementDimensionsMode(dta, blockPath, id, eIdx)                      \\\n    ((dta) != NULL && (dta->access64) != NULL                                              \\\n         ? (dta->access64)                                                                 \\\n               ->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                          GEN_DTA_INT_PROP_ELEMENT_DIMENSIONS_MODE)        \\\n         : -1)\n#endif\n#else\n#define dtaGetDataTypeElementDimensionsMode(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementDimensionsMode_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementVarDimsOffset(dta, blockPath, id, eIdx)                        \\\n    ((dta) != NULL                                                                          \\\n         ? (dta)->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                           GEN_DTA_INT_PROP_ELEMENT_VARDIMS_OFFSET)         \\\n         : -1)\n#else\n#define dtaGetDataTypeElementVarDimsOffset(dta, blockPath, id, eIdx)                       \\\n    ((dta) != NULL && (dta->access64) != NULL                                              \\\n         ? (dta->access64)                                                                 \\\n               ->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                          GEN_DTA_INT_PROP_ELEMENT_VARDIMS_OFFSET)         \\\n         : -1)\n#endif\n#else\n#define dtaGetDataTypeElementVarDimsOffset(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementVarDimsOffset_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementName(dta, blockPath, id, eIdx)                                        \\\n    ((dta) != NULL                                                                                 \\\n         ? ((const char*)(dta)->getGenericDTAVoidElemProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                          (eIdx), GEN_DTA_VOID_PROP_ELEMENT_NAME)) \\\n         : \"\")\n#else\n#define dtaGetDataTypeElementName(dta, blockPath, id, eIdx)                                  \\\n    ((dta) != NULL && (dta->access64) != NULL                                                \\\n         ? ((const char*)(dta->access64)                                                     \\\n                ->getGenericDTAVoidElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                            GEN_DTA_VOID_PROP_ELEMENT_NAME))                 \\\n         : \"\")\n#endif\n#else\n#define dtaGetDataTypeElementName(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementName_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementDimensions(dta, blockPath, id, eIdx)         \\\n    ((dta) != NULL ? ((const int_T*)(dta)->getGenericDTAVoidElemProp(     \\\n                         (dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                         GEN_DTA_VOID_PROP_ELEMENT_DIMENSIONS))           \\\n                   : NULL)\n#else\n#define dtaGetDataTypeElementDimensions(dta, blockPath, id, eIdx)                            \\\n    ((dta) != NULL && (dta->access64) != NULL                                                \\\n         ? ((const int64_T*)(dta->access64)                                                  \\\n                ->getGenericDTAVoidElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                            GEN_DTA_VOID_PROP_ELEMENT_DIMENSIONS_64))        \\\n         : NULL)\n#endif\n#else\n#define dtaGetDataTypeElementDimensions(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementDimensions_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementMin(dta, blockPath, id, eIdx)                                     \\\n    ((dta) != NULL ? (dta)->getGenericDTARealElemProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                      (eIdx), GEN_DTA_REAL_PROP_ELEMENT_MIN)   \\\n                   : -(mxGetInf()))\n#else\n#define dtaGetDataTypeElementMin(dta, blockPath, id, eIdx)                                  \\\n    ((dta) != NULL && (dta->access64) != NULL                                               \\\n         ? (dta->access64)                                                                  \\\n               ->getGenericDTARealElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                           GEN_DTA_REAL_PROP_ELEMENT_MIN)                   \\\n         : -(mxGetInf()))\n#endif\n#else\n#define dtaGetDataTypeElementMin(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementMin_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementMax(dta, blockPath, id, eIdx)                                     \\\n    ((dta) != NULL ? (dta)->getGenericDTARealElemProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                      (eIdx), GEN_DTA_REAL_PROP_ELEMENT_MAX)   \\\n                   : mxGetInf())\n#else\n#define dtaGetDataTypeElementMax(dta, blockPath, id, eIdx)                                  \\\n    ((dta) != NULL && (dta->access64) != NULL                                               \\\n         ? (dta->access64)                                                                  \\\n               ->getGenericDTARealElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                           GEN_DTA_REAL_PROP_ELEMENT_MAX)                   \\\n         : mxGetInf())\n#endif\n#else\n#define dtaGetDataTypeElementMax(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementMax_cannot_be_used_in_RTW\n#endif\n\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetDataTypeElementUnitId(dta, blockPath, id, eIdx)                                  \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id),  \\\n                                                     (eIdx), GEN_DTA_INT_PROP_ELEMENT_UNIT_ID) \\\n                   : -1)\n#else\n#define dtaGetDataTypeElementUnitId(dta, blockPath, id, eIdx)                              \\\n    ((dta) != NULL && (dta->access64) != NULL                                              \\\n         ? (dta->access64)                                                                 \\\n               ->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                          GEN_DTA_INT_PROP_ELEMENT_UNIT_ID)                \\\n         : -1)\n#endif\n#else\n#define dtaGetDataTypeElementUnitId(dta, blockPath, id, eIdx) \\\n    dtaGetDataTypeElementUnitId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataTypeIsEnumType(dta, blockPath, id)                                      \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_IS_ENUMTYPE)            \\\n                   : -1)\n#else\n#define dtaGetDataTypeIsEnumType(dta, blockPath, id) dtaGetDataTypeIsEnumType_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetEnumTypeNumStrings(dta, blockPath, id)                                      \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_ENUMTYPE_NUMSTRINGS)    \\\n                   : -1)\n#else\n#define dtaGetEnumTypeNumStrings(dta, blockPath, id, eIdx) \\\n    dtaGetEnumTypeNumStrings_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetEnumTypeIndexOfDefault(dta, blockPath, id)                                     \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id),    \\\n                                                 GEN_DTA_INT_PROP_ENUMTYPE_INDEX_OF_DEFAULT) \\\n                   : -1)\n#else\n#define dtaGetEnumTypeIndexOfDefault(dta, blockPath, id) \\\n    dtaGetEnumTypeIndexOfDefault_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetEnumTypeAddPrefix(dta, blockPath, id)                                                \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id),          \\\n                                                 GEN_DTA_INT_PROP_ENUMTYPE_ADD_TYPENAME_AS_PREFIX) \\\n                   : -1)\n#else\n#define dtaGetEnumTypeAddPrefix(dta, blockPath, id) dtaGetEnumTypeAddPrefix_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetEnumTypeStorageId(dta, blockPath, id)                                       \\\n    ((dta) != NULL ? (dta)->getGenericDTAIntProp((dta)->dataTypeTable, (blockPath), (id), \\\n                                                 GEN_DTA_INT_PROP_STORAGE_ID)             \\\n                   : -1)\n#else\n#define dtaGetEnumTypeStorageId(dta, blockPath, id) dtaGetEnumTypeStorageId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetEnumTypeIndexFromValue(dta, blockPath, id, eValue)                              \\\n    ((dta) != NULL                                                                            \\\n         ? (dta)->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eValue), \\\n                                           GEN_DTA_INT_PROP_ENUMTYPE_INDEX_FROM_VALUE)        \\\n         : -1)\n#else\n#define dtaGetEnumTypeIndexFromValue(dta, blockPath, id, eValue)                             \\\n    ((dta) != NULL && (dta->access64) != NULL                                                \\\n         ? (dta->access64)                                                                   \\\n               ->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eValue), \\\n                                          GEN_DTA_INT_PROP_ENUMTYPE_INDEX_FROM_VALUE)        \\\n         : -1)\n#endif\n#else\n#define dtaGetEnumTypeIndexFromValue(dta, blockPath, id, eValue) \\\n    dtaGetEnumTypeIndexFromValue_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetEnumTypeValueFromIndex(dta, blockPath, id, eIdx)                              \\\n    ((dta) != NULL                                                                          \\\n         ? (dta)->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                           GEN_DTA_INT_PROP_ENUMTYPE_VALUE_FROM_INDEX)      \\\n         : -1)\n#else\n#define dtaGetEnumTypeValueFromIndex(dta, blockPath, id, eIdx)                             \\\n    ((dta) != NULL && (dta->access64) != NULL                                              \\\n         ? (dta->access64)                                                                 \\\n               ->getGenericDTAIntElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                          GEN_DTA_INT_PROP_ENUMTYPE_VALUE_FROM_INDEX)      \\\n         : -1)\n#endif\n#else\n#define dtaGetEnumTypeValueFromIndex(dta, blockPath, id, eIdx) \\\n    dtaGetEnumTypeValueFromIndex_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetEnumTypeStringFromValue(dta, blockPath, id, eIdx)                              \\\n    ((dta) != NULL                                                                           \\\n         ? (dta)->getGenericDTAVoidElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                            GEN_DTA_VOID_PROP_ENUMTYPE_STRING_FROM_VALUE)    \\\n         : NULL)\n#else\n#define dtaGetEnumTypeStringFromValue(dta, blockPath, id, eIdx)                             \\\n    ((dta->access) != NULL                                                                  \\\n         ? (dta->access)                                                                    \\\n               ->getGenericDTAVoidElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                           GEN_DTA_VOID_PROP_ENUMTYPE_STRING_FROM_VALUE)    \\\n         : NULL)\n#endif\n#else\n#define dtaGetEnumTypeStringFromValue(dta, blockPath, id, eIdx) \\\n    dtaGetEnumTypeStringFromValue_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#if !defined(SFCN64)\n#define dtaGetEnumTypeStringFromIndex(dta, blockPath, id, eIdx)                              \\\n    ((dta) != NULL                                                                           \\\n         ? (dta)->getGenericDTAVoidElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                            GEN_DTA_VOID_PROP_ENUMTYPE_STRING_FROM_INDEX)    \\\n         : NULL)\n#else\n#define dtaGetEnumTypeStringFromIndex(dta, blockPath, id, eIdx)                             \\\n    ((dta) != NULL && (dta->access64) != NULL                                               \\\n         ? (dta->access64)                                                                  \\\n               ->getGenericDTAVoidElemProp((dta)->dataTypeTable, (blockPath), (id), (eIdx), \\\n                                           GEN_DTA_VOID_PROP_ENUMTYPE_STRING_FROM_INDEX)    \\\n         : NULL)\n#endif\n#else\n#define dtaGetEnumTypeStringFromIndex(dta, blockPath, id, eIdx) \\\n    dtaGetEnumTypeStringFromIndex_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetConvertBetweenFcn(dta, blockPath, id) \\\n    ((dta) != NULL ? (dta)->getConvertBetweenFcn((dta)->dataTypeTable, (blockPath), (id)) : NULL)\n#else\n#define dtaGetConvertBetweenFcn(dta, blockPath, id) dtaGetConvertBetweenFcn_cannot_be_used_in_RTW\n#endif\n\n\n\n#if SS_SIM\n#define dtaCallConvertBetweenForSrcId(dta, blockPath, dstId, srcId, numEls, u, options, y) \\\n    (dtaGetConvertBetweenFcn((dta), (blockPath), (srcId)) != NULL                          \\\n         ? dtaGetConvertBetweenFcn((dta), (blockPath), (srcId))(                           \\\n               (dta), (blockPath), (dstId), (srcId), (numEls), (u), (options), (y))        \\\n         : 0)\n#else\n#define dtaCallConvertBetweenForSrcId(dta, blockPath, dstId, srcId, numEls, u, options, y) \\\n    dtaCallConvertBetweenForSrcId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallConvertBetweenForDstId(dta, blockPath, dstId, srcId, numEls, u, options, y) \\\n    (dtaGetConvertBetweenFcn((dta), (blockPath), (dstId)) != NULL                          \\\n         ? dtaGetConvertBetweenFcn((dta), (blockPath), (dstId))(                           \\\n               (dta), (blockPath), (dstId), (srcId), (numEls), (u), (options), (y))        \\\n         : 0)\n#else\n#define dtaCallConvertBetweenForDstId(dta, blockPath, dstId, srcId, numEls, u, options, y) \\\n    dtaCallConvertBetweenForDstId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetConstructFcn(dta, blockPath, id) \\\n    ((dta) != NULL ? (dta)->getConstructFcn((dta)->dataTypeTable, (blockPath), (id)) : NULL)\n#else\n#define dtaGetConstructFcn(dta, blockPath, id) dtaGetConstructFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetConstructFcn(dta, blockPath, id, fcn) \\\n    ((dta) != NULL ? (dta)->setConstructFcn((dta)->dataTypeTable, (blockPath), (id), (fcn)) : 0)\n#else\n#define dtaSetConstructFcn(dta, blockPath, id, fcn) dtaSetConstructFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallConstruct(dta, blockPath, id, u)              \\\n    (dtaGetConstructFcn((dta), (blockPath), (id)) != NULL    \\\n         ? dtaGetConstructFcn((dta), (blockPath), (id))((u)) \\\n         : 0)\n#else\n#define dtaCallConstruct(dta, blockPath, id, u) dtaCallConstruct_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDestructFcn(dta, blockPath, id) \\\n    ((dta) != NULL ? (dta)->getDestructFcn((dta)->dataTypeTable, (blockPath), (id)) : NULL)\n#else\n#define dtaGetDestructFcn(dta, blockPath, id) dtaGetDestructFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetDestructFcn(dta, blockPath, id, fcn) \\\n    ((dta) != NULL ? (dta)->setDestructFcn((dta)->dataTypeTable, (blockPath), (id), (fcn)) : 0)\n#else\n#define dtaSetDestructFcn(dta, blockPath, id, fcn) dtaSetDestructFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallDestruct(dta, blockPath, id, u)              \\\n    (dtaGetDestructFcn((dta), (blockPath), (id)) != NULL    \\\n         ? dtaGetDestructFcn((dta), (blockPath), (id))((u)) \\\n         : 0)\n#else\n#define dtaCallDestruct(dta, blockPath, id, u) dtaCallDestruct_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDeepCopyFcn(dta, blockPath, id) \\\n    ((dta) != NULL ? (dta)->getDeepCopyFcn((dta)->dataTypeTable, (blockPath), (id)) : NULL)\n#else\n#define dtaGetDeepCopyFcn(dta, blockPath, id) dtaGetDeepCopyFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetDeepCopyFcn(dta, blockPath, id, fcn) \\\n    ((dta) != NULL ? (dta)->setDeepCopyFcn((dta)->dataTypeTable, (blockPath), (id), (fcn)) : 0)\n#else\n#define dtaSetDeepCopyFcn(dta, blockPath, id, fcn) dtaSetDeepCopyFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallDeepCopy(dta, blockPath, id, y, u)                \\\n    (dtaGetDeepCopyFcn((dta), (blockPath), (id)) != NULL         \\\n         ? dtaGetDeepCopyFcn((dta), (blockPath), (id))((y), (u)) \\\n         : 0)\n#else\n#define dtaCallDeepCopy(dta, blockPath, id, y, options, u) dtaCallDeepCopy_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetSerializeFcn(dta, id) \\\n    ((dta) != NULL ? (dta)->getSerializeFcn((dta)->dataTypeTable, (id)) : NULL)\n#else\n#define dtaGetSerializeFcn(dta, id) dtaGetSerializeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetSerializeFcn(dta, id, fcn) \\\n    ((dta) != NULL ? (dta)->setSerializeFcn((dta)->dataTypeTable, (id), (fcn)) : 0)\n#else\n#define dtaSetSerializeFcn(dta, id, fcn) dtaSetSerializeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallSerialize(dta, id, y, u, w, o)                                                      \\\n    (dtaGetSerializeFcn((dta), (id)) != NULL ? dtaGetSerializeFcn((dta), (id))((y), (u), (w), (o)) \\\n                                             : 0)\n#else\n#define dtaCallSerialize(dta, id, y, options, u, w, o) dtaCallSerialize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDeserializeFcn(dta, id) \\\n    ((dta) != NULL ? (dta)->getDeserializeFcn((dta)->dataTypeTable, (id)) : NULL)\n#else\n#define dtaGetDeserializeFcn(dta, id) dtaGetDeserializeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetDeserializeFcn(dta, id, fcn) \\\n    ((dta) != NULL ? (dta)->setDeserializeFcn((dta)->dataTypeTable, (id), (fcn)) : 0)\n#else\n#define dtaSetDeserializeFcn(dta, id, fcn) dtaSetDeserializeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallDeserialize(dta, id, y, u, w, o)                  \\\n    (dtaGetDeserializeFcn((dta), (id)) != NULL                   \\\n         ? dtaGetDeserializeFcn((dta), (id))((y), (u), (w), (o)) \\\n         : 0)\n#else\n#define dtaCallDeserialize(dta, id, y, options, u, w, o) dtaCallDeserialize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetSerializeSizeFcn(dta, id) \\\n    ((dta) != NULL ? (dta)->getSerializeSizeFcn((dta)->dataTypeTable, (id)) : NULL)\n#else\n#define dtaGetSerializeSizeFcn(dta, id) dtaGetSerializeSizeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetSerializeSizeFcn(dta, id, fcn) \\\n    ((dta) != NULL ? (dta)->setSerializeSizeFcn((dta)->dataTypeTable, (id), (fcn)) : 0)\n#else\n#define dtaSetSerializeSizeFcn(dta, id, fcn) dtaSetSerializeSizeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallSerializeSize(dta, id, y, u)                                                      \\\n    (dtaGetSerializeSizeFcn((dta), (id)) != NULL ? dtaGetSerializeSizeFcn((dta), (id))((y), (u)) \\\n                                                 : 0)\n#else\n#define dtaCallSerializeSize(dta, id, y, options, u) dtaCallSerializeSize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetIsPositiveFcn(dta, blockPath, id)                                              \\\n    ((dta) != NULL ? (dta)->getGenericDTAUnaryFcnGW((dta)->dataTypeTable, (blockPath), (id), \\\n                                                    GEN_DTA_UNARY_FCN_IS_POSITIVE)           \\\n                   : NULL)\n#else\n#define dtaGetIsPositiveFcn(dta, blockPath, id) dtaGetIsPositiveFcn_cannot_be_used_in_RTW\n#endif\n\n\n\n#if SS_SIM\n#define dtaCallIsPositive(dta, blockPath, id, numEls, u, options, y)                              \\\n    (dtaGetIsPositiveFcn((dta), (blockPath), (id)) != NULL                                        \\\n         ? dtaGetIsPositiveFcn((dta), (blockPath), (id))((dta), (blockPath), (id), (numEls), (u), \\\n                                                         (options), (y))                          \\\n         : 0)\n#else\n#define dtaCallIsPositive(dta, blockPath, id, numEls, u, options, y) \\\n    dtaCallIsPositive_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetIsNegativeFcn(dta, blockPath, id)                                              \\\n    ((dta) != NULL ? (dta)->getGenericDTAUnaryFcnGW((dta)->dataTypeTable, (blockPath), (id), \\\n                                                    GEN_DTA_UNARY_FCN_IS_NEGATIVE)           \\\n                   : NULL)\n#else\n#define dtaGetIsNegativeFcn(dta, blockPath, id) dtaGetIsNegativeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetIsNegativeFcn(dta, blockPath, id, fcn)                                         \\\n    ((dta) != NULL ? (dta)->setGenericDTAUnaryFcnGW((dta)->dataTypeTable, (blockPath), (id), \\\n                                                    (fcn), GEN_DTA_UNARY_FCN_IS_NEGATIVE)    \\\n                   : 0)\n#else\n#define dtaSetIsNegativeFcn(dta, blockPath, id, fcn) dtaSetIsNegativeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallIsNegative(dta, blockPath, id, numEls, u, options, y)                              \\\n    (dtaGetIsNegativeFcn((dta), (blockPath), (id)) != NULL                                        \\\n         ? dtaGetIsNegativeFcn((dta), (blockPath), (id))((dta), (blockPath), (id), (numEls), (u), \\\n                                                         (options), (y))                          \\\n         : 0)\n#else\n#define dtaCallIsNegative(dta, blockPath, id, numEls, u, options, y) \\\n    dtaCallIsNegative_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetGreaterThanFcn(dta, blockPath, id)                                              \\\n    ((dta) != NULL ? (dta)->getGenericDTABinaryFcnGW((dta)->dataTypeTable, (blockPath), (id), \\\n                                                     GEN_DTA_BINARY_FCN_GREATER_THAN)         \\\n                   : NULL)\n#else\n#define dtaGetGreaterThanFcn(dta, blockPath, id) dtaGetGreaterThanFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetGreaterThanFcn(dta, blockPath, id, fcn)                                         \\\n    ((dta) != NULL ? (dta)->setGenericDTABinaryFcnGW((dta)->dataTypeTable, (blockPath), (id), \\\n                                                     (fcn), GEN_DTA_BINARY_FCN_GREATER_THAN)  \\\n                   : 0)\n#else\n#define dtaSetGreaterThanFcn(dta, blockPath, id, fcn) dtaSetGreaterThanFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallGreaterThan(dta, blockPath, id, numEls, u1, u2, options, y)                    \\\n    (dtaGetGreaterThanFcn((dta), (blockPath), (id)) != NULL                                   \\\n         ? dtaGetGreaterThanFcn((dta), (blockPath), (id))((dta), (blockPath), (id), (numEls), \\\n                                                          (u1), (u2), (options), (y))         \\\n         : 0)\n#else\n#define dtaCallGreaterThan(dta, blockPath, id, numEls, u1, u2, options, y) \\\n    dtaCallGreaterThan_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetGreaterEqualFcn(dta, blockPath, id)                                             \\\n    ((dta) != NULL ? (dta)->getGenericDTABinaryFcnGW((dta)->dataTypeTable, (blockPath), (id), \\\n                                                     GEN_DTA_BINARY_FCN_GREATER_EQUAL)        \\\n                   : NULL)\n#else\n#define dtaGetGreaterEqualFcn(dta, blockPath, id) dtaGetGreaterEqualFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaSetGreaterEqualFcn(dta, blockPath, id, fcn)                                        \\\n    ((dta) != NULL ? (dta)->setGenericDTABinaryFcnGW((dta)->dataTypeTable, (blockPath), (id), \\\n                                                     (fcn), GEN_DTA_BINARY_FCN_GREATER_EQUAL) \\\n                   : 0)\n#else\n#define dtaSetGreaterEqualFcn(dta, blockPath, id, fcn) dtaSetGreaterEqualFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaCallGreaterEqual(dta, blockPath, id, numEls, u1, u2, options, y)                    \\\n    (dtaGetGreaterEqualFcn((dta), (blockPath), (id)) != NULL                                   \\\n         ? dtaGetGreaterEqualFcn((dta), (blockPath), (id))((dta), (blockPath), (id), (numEls), \\\n                                                           (u1), (u2), (options), (y))         \\\n         : 0)\n#else\n#define dtaCallGreaterEqual(dta, blockPath, id, numEls, u1, u2, options, y) \\\n    dtaCallGreaterEqual_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataOverflowDiagnostic(dta, blockPath, result)                           \\\n    ((dta) != NULL ? (dta)->getGenericDTADiagnostic((dta)->dataTypeTable, (blockPath), \\\n                                                    GEN_DTA_DATA_OVERFLOW, (result))   \\\n                   : 0)\n#else\n#define dtaGetDataOverflowDiagnostic(dta, blockPath, result) \\\n    dtaGetDataOverflowDiagnostic_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetDataSaturationDiagnostic(dta, blockPath, result)                         \\\n    ((dta) != NULL ? (dta)->getGenericDTADiagnostic((dta)->dataTypeTable, (blockPath), \\\n                                                    GEN_DTA_DATA_SATURATION, (result)) \\\n                   : 0)\n#else\n#define dtaGetDataSaturationDiagnostic(dta, blockPath, result) \\\n    dtaGetDataSaturationDiagnostic_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetInt32ToFloatDiagnostic(dta, blockPath, result)                           \\\n    ((dta) != NULL ? (dta)->getGenericDTADiagnostic((dta)->dataTypeTable, (blockPath), \\\n                                                    GEN_DTA_INT32_TO_FLOAT, (result))  \\\n                   : 0)\n#else\n#define dtaGetInt32ToFloatDiagnostic(dta, blockPath, result) \\\n    dtaGetInt32ToFloatDiagnostic_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetParameterOverflowDiagnostic(dta, blockPath, result)                         \\\n    ((dta) != NULL ? (dta)->getGenericDTADiagnostic((dta)->dataTypeTable, (blockPath),    \\\n                                                    GEN_DTA_PARAMETER_OVERFLOW, (result)) \\\n                   : 0)\n#else\n#define dtaGetParameterOverflowDiagnostic(dta, blockPath, result) \\\n    dtaGetParameterOverflowDiagnostic_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetParameterUnderflowDiagnostic(dta, blockPath, result)                         \\\n    ((dta) != NULL ? (dta)->getGenericDTADiagnostic((dta)->dataTypeTable, (blockPath),     \\\n                                                    GEN_DTA_PARAMETER_UNDERFLOW, (result)) \\\n                   : 0)\n#else\n#define dtaGetParameterUnderflowDiagnostic(dta, blockPath, result) \\\n    dtaGetParameterUnderflowDiagnostic_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetParameterPrecisionLossDiagnostic(dta, blockPath, result)                          \\\n    ((dta) != NULL ? (dta)->getGenericDTADiagnostic((dta)->dataTypeTable, (blockPath),          \\\n                                                    GEN_DTA_PARAMETER_PRECISION_LOSS, (result)) \\\n                   : 0)\n#else\n#define dtaGetParameterPrecisionLossDiagnostic(dta, blockPath, result) \\\n    dtaGetPrecisionLossDiagnostic_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define dtaGetParameterDowncastDiagnostic(dta, blockPath, result)                         \\\n    ((dta) != NULL ? (dta)->getGenericDTADiagnostic((dta)->dataTypeTable, (blockPath),    \\\n                                                    GEN_DTA_PARAMETER_DOWNCAST, (result)) \\\n                   : 0)\n#else\n#define dtaGetParameterDowncastDiagnostic(dta, blockPath, result) \\\n    dtaGetParameterDowncastDiagnostic_cannot_be_used_in_RTW\n#endif\n\n\n\n#endif /* __SIMSTRUC__IMPLEMENT */\n"},{"name":"simstruc_internal.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/**\n * @file: simstruc_internal.h\n *\n * @brief SimStruct access methods for internal use (subject to changes in\n * future releases), and should not be used for authoring S-functions\n *\n */\n\n#ifndef __SIMSTRUC__INTERNAL\n#define __SIMSTRUC__INTERNAL\n\n#include \"simstruc_compcond.h\"\n#include \"simstruc_implement.h\"\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n#include \"simstruc_64_internal.h\"\n#endif\n\n/*======================================*\n * SimStruct Get and Set Access methods *\n *======================================*/\n\n/*-------------------------------- S->modelName -----------------------------*/\n\n/*\n * ModelName - This is the name of the S-function. When the SimStruct\n *   is being used with the Real-Time Workshop, then the \"root\" SimStruct\n *   model name corresponds to the name of the Simulink model.\n */\n\n#define _ssSetModelName(S, name) (S)->modelName = (name)\n#if !SS_SFCN\n#define ssSetModelName(S, name) _ssSetModelName(S, name)\n#else\n#define ssSetModelName(S, name) ssSetModelName_cannot_be_used_in_SFunctions\n#endif\n\n/*-------------------------------- S->path ----------------------------------*/\n/*\n * Path - This is the full path to the S-function. When the SimStruct\n *   is being used with the Real-Time Workshop, then the \"root\" SimStruct\n *   path corresponds to the name of the Simulink model.\n */\n\n#define _ssSetPath(S, pathPtr) (S)->path = (pathPtr)\n#if !SS_SFCN\n#define ssSetPath(S, pathPtr) _ssSetPath(S, pathPtr)\n#else\n#define ssSetPath(S, pathPtr) ssSetPath_cannot_be_used_in_SFunctions\n#endif\n\n/*-------------------------------- S->parent --------------------------------*/\n/*\n * ParentSS - There is one SimStruct for each S-function in your model.\n *   There is also a SimStruct for the model itself. The SimStruct's are\n *   arranged as a tree with the model SimStruct as the root. The ParentSS\n *   field is used to get at the model SimStruct. User written S-functions\n *   should not use the ssGetParentSS macro directly.\n */\n\n#define _ssSetParentSS(S, parentSS) (S)->parent = (parentSS)\n#if !SS_SFCN\n#define ssSetParentSS(S, parentSS) _ssSetParentSS(S, parentSS)\n#else\n#define ssSetParentSS(S, parentSS) ssSetParentSS_cannot_be_used_in_SFunctions\n#endif\n\n/*-------------------------------- S->root ----------------------------------*/\n/*\n * RootSS - This is the \"root\" SimStruct corresponding to the Simulink\n *   model.\n */\n\n#define _ssSetRootSS(S, rootSS) (S)->root = (rootSS)\n#if !SS_SFCN\n#define ssSetRootSS(S, rootSS) _ssSetRootSS(S, rootSS)\n#else\n#define ssSetRootSS(S, rootSS) ssSetRootSS_cannot_be_used_in_SFunctions\n#endif\n\n\n/*-------------------------------- S->errorStatus ---------------------------*/\n\n/* ErrorStatus - For improved performance and error handling, your S-function\n *   should do:\n *      ssSetErrorStatus(S, \"error message\");\n *      return;\n *   as opposed to calling mexErrMsgTxt.\n *\n *   Be careful when using ssSetErrorStatus in your S-function. Sometimes you\n *   may wish to use sprintf to format the message. In this case, you\n *   need to allocate memory for the message as opposed to using the stack.\n *   macros _ss[SG]et_slErrMsg and _ssIsErrorStatusAslErrMsg\n *   are intended for internal use only\n */\n\n\n\n#define _ssGetErrorStatus(S)                                         \\\n    (ssGetRootSS(S)->mdlInfo->mdlFlags.errorStatusIsMsg == 1U ? NULL \\\n                                                              : ssGetRootSS(S)->errorStatus.str)\n#define _ssGetLocalErrorStatus(S)                       \\\n    ((S)->blkInfo.sfcnFlags.localErrorStatusIsMsg == 1U \\\n         ? NULL                                         \\\n         : S->blkInfo.blkInfo2->localErrorStatus.str)\n#define _ssGet_slErrMsg(S)                                           \\\n    (ssGetRootSS(S)->mdlInfo->mdlFlags.errorStatusIsMsg == 0U ? NULL \\\n                                                              : ssGetRootSS(S)->errorStatus.msg)\n#define _ssGet_slLocalErrMsg(S)                         \\\n    ((S)->blkInfo.sfcnFlags.localErrorStatusIsMsg == 0U \\\n         ? NULL                                         \\\n         : S->blkInfo.blkInfo2->localErrorStatus.msg)\n#define _ssSet_slErrMsg(S, msg_arg)                              \\\n    {                                                            \\\n        ssGetRootSS(S)->mdlInfo->mdlFlags.errorStatusIsMsg = 1U; \\\n        ssGetRootSS(S)->errorStatus.msg = (msg_arg);             \\\n    }\n#define _ssSet_slLocalErrMsg(S, msg_arg)                       \\\n    {                                                          \\\n        (S)->blkInfo.sfcnFlags.localErrorStatusIsMsg = 1U;     \\\n        S->blkInfo.blkInfo2->localErrorStatus.msg = (msg_arg); \\\n    }\n#define _ssIsErrorStatusAslErrMsg(S) (ssGetRootSS(S)->mdlInfo->mdlFlags.errorStatusIsMsg == 1U)\n#define _ssIsLocalErrorStatusAslErrMsg(S) ((S)->blkInfo.sfcnFlags.localErrorStatusIsMsg == 1U)\n\n#define _ssReportDiagnosticAsWarning(S, diag)                                           \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REPORT_DIAGNOSTIC_AS_WARNING, 0, diag) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define _ssReportDiagnosticAsInfo(S, diag)                                           \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REPORT_DIAGNOSTIC_AS_INFO, 0, diag) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define _ssDiscardDiagnostic(S, diag)                                         \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_DISCARD_DIAGNOSTIC, 0, diag) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define _ssLongJmp(S, buffer) \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LONGJMP, 0, buffer) _ssSafelyCallGenericFcnEnd\n\n#define SS_ERROR_STATUS_BUFFER_SIZE 1024\n\n#define _ssCopyErrorStatusToBuffer(S, string, size)                        \\\n    {                                                                      \\\n        (void)memcpy(ssGetRootSS(S)->mdlInfo->errorStatusBuffer, (string), \\\n                     ((size) > SS_ERROR_STATUS_BUFFER_SIZE - 1)            \\\n                         ? (SS_ERROR_STATUS_BUFFER_SIZE - 1)               \\\n                         : (size));                                        \\\n        ssSetErrorStatus(S, ssGetRootSS(S)->mdlInfo->errorStatusBuffer);   \\\n    }\n\n#define _ssCopyLocalErrorStatusToBuffer(S, string, size)                         \\\n    {                                                                            \\\n        (void)memcpy((S)->blkInfo.blkInfo2->localErrorStatusBuffer, (string),    \\\n                     ((size) > SS_ERROR_STATUS_BUFFER_SIZE - 1)                  \\\n                         ? (SS_ERROR_STATUS_BUFFER_SIZE - 1)                     \\\n                         : (size));                                              \\\n        ssSetLocalErrorStatus(S, (S)->blkInfo.blkInfo2->localErrorStatusBuffer); \\\n    }\n\n/*-------------------------------- S->sizes ---------------------------------*/\n\n/* SizesPtr - This is an integer pointer of length SIZES_LENGTH. The\n *   fields in the sizes pointers are defined in the _ssSizes structure\n *   (above).\n */\n#define ssGetSizesPtr(S) ((int_T*)&(S)->sizes) /*   (int_T *)     */\n\n\n/* NumTotalStates - This is the number of continuous plus discrete states\n *   within your S-function. The root SimStruct contains the number of\n *   continuous plus discrete states within the model itself (including all\n *   blocks and S-functions).\n */\n#if SS_SFCN_LEVEL_1 || !SS_SFCN\n#define ssGetNumTotalStates(S) (ssGetNumContStates(S) + ssGetNumDiscStates(S)) /*   (int_T) */\n#endif\n\n\n/* NumOutputPorts - This is the number of the output ports of your\n * S-function block.\n */\n#if !SS_SFCN_LEVEL_1\n\n#define ssSetPortInfoForOutputs(S, ptr) (S)->portInfo.outputs = (ptr)\n#define ssGetPortInfoForOutputs(S) (S)->portInfo.outputs\n#endif\n\n\n/* NumInputPorts - This is the number of the input ports of your\n * S-function block.\n */\n#if !SS_SFCN_LEVEL_1\n\n\n#define ssSetPortInfoForInputs(S, ptr) (S)->portInfo.inputs = (ptr)\n#define ssGetPortInfoForInputs(S) (S)->portInfo.inputs\n#endif\n\n\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n/*\n * Set/Get number of DWork elements\n */\n#define ssSetNumDWork(S, num) ((_ssSetNumDWorkSLSize(S, num)) >= -1)\n/* We really should combine these with the above macros\n   for USE_32BIT_AND_64BIT_FIELDS */\n#define _ssSetNumDWork(S, nDWork) ((S)->sizes.numDWork = (nDWork))\n#define _ssSetNumDWorkSLSize(S, nDWork) \\\n    ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDWork = (nDWork))\n#define ssGetNumDWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDWork\n\n/*\n * Set/Get number continuous states\n */\n#define ssGetNumContStates(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numContStates\n#define ssSetNumContStates(S, nContStates) \\\n    ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numContStates = (nContStates))\n\n/* This is needed for codegen in file odesup.h */\n#define ssGetNumContStatesPtr(S) &((S)->sizes.numContStates)\n\n\n/*\n * Set/Get number discrete states\n */\n#define ssGetNumDiscStates(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDiscStates\n#define ssSetNumDiscStates(S, nDiscStates) \\\n    ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDiscStates = (nDiscStates))\n\n/*\n * Set/Get number of nonsampled zero-crossings\n */\n#define ssGetNumNonsampledZCs(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numNonsampledZCs\n#define ssSetNumNonsampledZCs(S, nNonsampledZCs) \\\n    ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numNonsampledZCs = (nNonsampledZCs))\n\n/*\n * Set/Get number of RWork elements\n */\n#define ssGetNumRWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numRWork\n#define ssSetNumRWork(S, nRWork) ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numRWork = (nRWork))\n\n/*\n * Set/Get number of IWork elements\n */\n#define ssGetNumIWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numIWork\n#define ssSetNumIWork(S, nIWork) ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numIWork = (nIWork))\n\n/*\n * Set/Get number of PWork elements\n */\n#define ssGetNumPWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numPWork\n#define ssSetNumPWork(S, nPWork) ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numPWork = (nPWork))\n\n/*\n * Set/Get number of modes\n */\n#define ssGetNumModes(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numModes\n#define ssSetNumModes(S, n) ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numModes = (n))\n\n#endif /* USE_32BIT_AND_64BIT_FIELDS */\n\n/* AsInt macros should only be used in code allocating and initializing 32-bit\n   S-Functions. Currently, this includes simulink engine and sim targets */\n#define ssGetNumContStatesAsInt(S) (S)->sizes.numContStates\n#define ssSetNumContStatesAsInt(S, nContStates) ((S)->sizes.numContStates = (nContStates))\n#define ssGetNumDiscStatesAsInt(S) (S)->sizes.numDiscStates\n#define ssSetNumDiscStatesAsInt(S, nDiscStates) ((S)->sizes.numDiscStates = (nDiscStates))\n#define ssSetNumNonsampledZCsAsInt(S, nNonsampledZCs) \\\n    ((S)->sizes.numNonsampledZCs = (nNonsampledZCs))\n#define ssSetNumRWorkAsInt(S, nRWork) ((S)->sizes.numRWork = (nRWork))\n#define ssSetNumIWorkAsInt(S, nIWork) ((S)->sizes.numIWork = (nIWork))\n#define ssSetNumPWorkAsInt(S, nPWork) ((S)->sizes.numPWork = (nPWork))\n#define ssSetNumModesAsInt(S, n) ((S)->sizes.numModes = (n))\n#define ssSetNumYAsInt(S, ny) ((S)->sizes.out.numY = (ny))\n#define ssSetNumUAsInt(S, nu) ((S)->sizes.in.numU = (nu))\n\n/* CAUTION: this is a temporary macro used for the 64-bit S-Function project.\n   Do not use this macro. */\n#define ssSetNumContStatesSLSize(S, nContStates) \\\n    ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numContStates = (nContStates))\n\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n/* NumY, SizeofY - This is the length of the root output\n * vector, Y, which is the sum of all the widths of the root outport blocks.\n */\n#define ssGetNumY_fwd(S) (S)->sizes.out.numY\n#define ssGetNumYSLSize_fwd(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numY\n#define ssSetNumY_fwd(S, ny) ((S)->sizes.out.numY = (ny))\n#define ssSetNumYSLSize_fwd(S, ny) ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numY = (ny))\n\n#define ssGetSizeofY_fwd(S) (S)->sizes.sizeofY\n#define ssGetSizeofYSLSize_fwd(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.sizeofY\n#define ssSetSizeofY_fwd(S, nbytes) (S)->sizes.sizeofY = (nbytes)\n#define ssSetSizeofYSLSize_fwd(S, nbytes) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.sizeofY = (nbytes)\n\n/* NumU, SizeofU - This is the length of the root input\n * vector, U, which is the sum of all the widths of the root inport blocks.\n */\n#define ssGetNumU_fwd(S) (S)->sizes.in.numU\n#define ssGetNumUSLSize_fwd(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numU\n#define ssSetNumU_fwd(S, nu) ((S)->sizes.in.numU = (nu))\n#define ssSetNumUSLSize_fwd(S, nu) ((S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numU = (nu))\n\n#define ssGetSizeofU_fwd(S) (S)->sizes.sizeofU\n#define ssGetSizeofUSLSize_fwd(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.sizeofU\n#define ssSetSizeofU_fwd(S, nbytes) (S)->sizes.sizeofU = (nbytes)\n#define ssSetSizeofUSLSize_fwd(S, nbytes) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.sizeofU = (nbytes)\n#elif defined(RSIM_WITH_SL_SOLVER) || SS_RTW_INTERNAL || SS_GENERATED_S_FUNCTION\n\n/* NumY, SizeofY - This is the length of the root output\n * vector, Y, which is the sum of all the widths of the root outport blocks.\n */\n#define ssGetNumY(S) (S)->sizes.out.numY /*   (int_T)       */\n#define ssSetNumY(S, ny) (S)->sizes.out.numY = (ny)\n\n#define ssGetSizeofY(S) (S)->sizes.sizeofY /*   (int_T)       */\n#define ssSetSizeofY(S, nbytes) (S)->sizes.sizeofY = (nbytes)\n\n/* NumU, SizeofU - This is the length of the root input\n * vector, U, which is the sum of all the widths of the root inport blocks.\n */\n#define ssGetNumU(S) (S)->sizes.in.numU /*   (int_T)       */\n#define ssSetNumU(S, nu) (S)->sizes.in.numU = (nu)\n\n#define ssGetSizeofU(S) (S)->sizes.sizeofU /*   (int_T)       */\n#define ssSetSizeofU(S, nbytes) (S)->sizes.sizeofU = (nbytes)\n#endif\n\n#if SS_SL_INTERNAL || SS_RTW_INTERNAL || SS_GENERATED_S_FUNCTION\n#define ssGetSizeofParams(S, result)                                              \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_SIZE_OF_PARAMS, 0, (result)) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\n#if SS_RTW_INTERNAL\n/* for backwards compatibility with RTW run-time interface */\n#define ssGetNumInputs(S) ssGetNumU(S)\n#define ssSetNumInputs(S, nInputs) ssSetNumU(S, nInputs)\n#define ssGetNumOutputs(S) ssGetNumY(S)\n#define ssSetNumOutputs(S, nOutputs) ssSetNumY(S, nOutputs)\n#endif\n\n\n#if SS_SFCN_LEVEL_1 || SS_GENERATED_S_FUNCTION\n/* NumOutputs - This is the size of the output port of your S-function.\n */\n#define ssGetNumOutputs(S) (S)->sizes.out.numY /*   (int_T)       */\n#define ssSetNumOutputs(S, nOutputs) (S)->sizes.out.numY = (nOutputs)\n\n/* NumInputs - This is the size of the input port of your S-function.\n */\n#define ssGetNumInputs(S) (S)->sizes.in.numU /*   (int_T)       */\n#define ssSetNumInputs(S, nInputs) (S)->sizes.in.numU = (nInputs)\n\n#elif SS_SFCN_NORMAL\n\n#define ssGetNumOutputs(S) ssGetNumOutputs_cannot_be_used_in_level2_SFunctions\n#define ssSetNumOutputs(S) ssGetNumOutputs_cannot_be_used_in_level2_SFunctions\n#define ssGetNumInputs(S) ssGetNumInputs_cannot_be_used_in_level2_SFunctions\n#define ssSetNumInputs(S) ssSetNumInputs_cannot_be_used_in_level2_SFunctions\n\n#else\n\n#define ssGetNumOutputsLevel1(S) (S)->sizes.out.numY /*   (int_T)       */\n#define ssSetNumOutputsLevel1(S, nOutputs) (S)->sizes.out.numY = (nOutputs)\n\n#define ssGetNumInputsLevel1(S) (S)->sizes.in.numU /*   (int_T)       */\n#define ssSetNumInputsLevel1(S, nInputs) (S)->sizes.in.numU = (nInputs)\n\n#endif\n\n#define ssGetMexApiInt1(S) (S)->sizes.mexApiInt1 /*   (int_T)       */\n#define ssSetMexApiInt1(S, val) (S)->sizes.mexApiInt1 = (val)\n\n#if !SS_SFCN_NORMAL\n/* DirectFeedThrough - Does your Level 1 S-function use ssGetU (i.e. u\n *   argument)in mdlOutputs?  For the root SimStruct, this field indicates\n *   whether or not the external input vector is used when executing the\n *   Output function (i.e. MdlOutputs) for the model.\n */\n#define ssIsDirectFeedThrough(S) (S)->sizes.sysDirFeedThrough /*   (int_T)       */\n#define ssSetDirectFeedThrough(S, dirFeed) (S)->sizes.sysDirFeedThrough = (dirFeed)\n\n#else\n#define ssIsDirectFeedThrough(S) ssIsDirectFeedThrough_cannot_be_used_in_level2_SFunctions\n#define ssSetDirectFeedThrough(S, dirFeed) \\\n    ssSetDirectFeedThrough_cannot_be_used_in_level2_SFunctions\n#endif\n\n/* NumBlockIO - Number of elements in the model-wide Block IO vector. Only\n *   valid for the root SimStruct. S-function blocks should not use this\n *   field (i.e. set it to 0).\n */\n#define ssGetNumBlockIO(S) (S)->sizes.numBlockIO /*   (int_T)       */\n#define ssSetNumBlockIO(S, nBlockIO) (S)->sizes.numBlockIO = (nBlockIO)\n\n/* NumBlockParams - Number of parameter elements in the model-wide parameter\n *   vector. Only valid for the root SimStruct. S-function blocks should not\n *   use this field (i.e. set it to 0).\n */\n#define ssGetNumBlockParams(S) (S)->sizes.numBlockParams /*   (int_T)       */\n#define ssSetNumBlockParams(S, nBlockParams) (S)->sizes.numBlockParams = (nBlockParams)\n\n/* Checksum fields - The checksum fields are primarily used by the root\n *   SimStruct to maintain consistency between Simulink external mode and\n *   the code generated from the Real-Time Workshop. In general, user\n *   written S-function should not use this field.\n */\n#define ssGetChecksums(S) (S)->sizes.checksums\n\n#define ssSetChecksumVal(S, idx, val) (S)->sizes.checksums[idx] = (val)\n#define ssGetChecksumVal(S, idx) (S)->sizes.checksums[idx]\n\n#define ssGetChecksum0(S) (S)->sizes.checksums[0] /*   (uint32_T)    */\n#define ssSetChecksum0(S, val) (S)->sizes.checksums[0] = (val)\n\n#define ssGetChecksum1(S) (S)->sizes.checksums[1] /*   (uint32_T)    */\n#define ssSetChecksum1(S, val) (S)->sizes.checksums[1] = (val)\n\n#define ssGetChecksum2(S) (S)->sizes.checksums[2] /*   (uint32_T)    */\n#define ssSetChecksum2(S, val) (S)->sizes.checksums[2] = (val)\n\n#define ssGetChecksum3(S) (S)->sizes.checksums[3] /*   (uint32_T)    */\n#define ssSetChecksum3(S, val) (S)->sizes.checksums[3] = (val)\n\n/* NumSFunctions - This field is used by the root SimStruct to keep track\n *   of the number of child SimStruct's corresponding to S-function blocks.\n *   This field should not be used by S-function blocks (i.e. should be 0).\n */\n#define ssGetNumSFunctions(S) (S)->sizes.numSFunctions /*   (int_T)       */\n#define ssSetNumSFunctions(S, nSFunctions) (S)->sizes.numSFunctions = (nSFunctions)\n\n/* NumBlocks - This field is used by the root SimStruct to keep track of\n *   the number of non-virtual blocks within the model. This field should\n *   not be used by S-function blocks (i.e. should be 0).\n */\n#define ssGetNumBlocks(S) (S)->sizes.numBlocks /*   (int_T)       */\n#define ssSetNumBlocks(S, nBlocks) (S)->sizes.numBlocks = (nBlocks)\n\n/* Version - This field should not be used by S-function blocks directly.\n *   The the simulink.c include file at the bottom of your S-function block\n *   uses this field. It is also used by root SimStruct for versioning.\n */\n#define ssGetVersion(S) (S)->sizes.simStructVer /*   (int_T)       */\n#define ssSetVersion(S, ver) (S)->sizes.simStructVer = (int32_T)(ver)\n\n#define ssGetSFcnLevel(S) ((S)->sizes.simStructVer == (int32_T)SIMSTRUCT_VERSION_LEVEL2 ? 2 : 1)\n\n\n/* NumZCEvents - This is the number of zero crossing events within your model.\n *   This field is not for use by S-functions (i.e. should be 0).\n */\n#define ssGetNumZCEvents(S) (S)->sizes.numZCEvents /*   (int_T)       */\n#define ssSetNumZCEvents(S, nZCEvents) (S)->sizes.numZCEvents = (nZCEvents)\n\n\n\n/* SizeofBlockIO - This is the size of the block I/O vector in bytes.\n *  These should not be used by S-functions (accelerated models need to\n *  set the size though).\n */\n#define ssGetSizeofBlockIO(S) (S)->sizes.sizeofBlockIO /*   (int_T)       */\n#define ssSetSizeofBlockIO(S, n) (S)->sizes.sizeofBlockIO = (n)\n\n/* SizeofGlobalBlockIO - This is the size of the global block I/O\n * vector in bytes. This is the size of rtB in the generated code.\n *  These should not be used by S-functions (accelerated models need to\n *  set the size though).\n */\n#define ssGetSizeofGlobalBlockIO(S) (S)->sizes.sizeofGlobalBlockIO /*   (int_T)       */\n#define ssSetSizeofGlobalBlockIO(S, n) (S)->sizes.sizeofGlobalBlockIO = (n)\n\n\n/* SizeofDWork - This is the size of the data type work vector in bytes.\n *  These should not be used by S-functions (accelerated models need to\n *  set the size though).\n */\n#define ssGetSizeofDWork(S) (S)->sizes.sizeofDWork /*   (int_T)       */\n#define ssSetSizeofDWork(S, n) (S)->sizes.sizeofDWork = (n)\n\n/* RTWGeneratedSFcn - This is the flag which is set for rtw generated\n * s-function.  Can be removed once all dstates are changed to dworks\n */\n#define ssGetRTWGeneratedSFcn(S) (S)->sizes.RTWGeneratedSFcn /*   (int_T)       */\n#define ssSetRTWGeneratedSFcn(S, n) (S)->sizes.RTWGeneratedSFcn = (n)\n\n/* HasMdlDimensionsFcn - This is the flag which is set if the block\n * has mdlSetInput(output)PortDimensions function. Not for use by S-functions.\n */\n#define ssGetSfcnHasMdlDimensionsFcn(S) \\\n    (S)->sizes.flags.hasMdlDimensionsFcn /*   (unsigned int_T: 1) */\n#define _ssSetSfcnHasMdlDimensionsFcn(S, n) (S)->sizes.flags.hasMdlDimensionsFcn = (n)\n\n/* usesNumPorts - This flag is set by ssSetNumInputPorts and\n * ssSetNumOutputPorts when S is used in Simulink.\n * Not for use by S-functions.\n */\n#define ssGetSfcnUsesNumPorts(S) (S)->sizes.flags.usesNumPorts /*   (unsigned int_T: 1) */\n#define _ssSetSfcnUsesNumPorts(S, n) (S)->sizes.flags.usesNumPorts = (n)\n\n/* VectMode - This flag is used in Simulink set port dimension methods.\n * See ssVectorMode typedef for valid settings.\n */\n#define ssGetVectorMode(S) (S)->sizes.flags.vectMode /*   (unsigned int_T: 4) */\n\n/*\n * ss(Set|Get)TreatAsAtomic - This macro is NOT to be used by\n *                            custom S-Functions.\n */\n#define ssGetTreatAsAtomic(S) (S)->sizes.flags.treatAsAtomic /*   (unsigned int_T: 1) */\n#define ssSetTreatAsAtomic(S, n) (S)->sizes.flags.treatAsAtomic = (n)\n/*\n * ss(Set|Get)HasSubFunctions - This macro is NOT to be used by\n *                              custom S-Functions.\n */\n#define ssGetHasSubFunctions(S) (S)->sizes.flags.hasSubFunctions /*   (unsigned int_T: 1) */\n#define ssSetHasSubFunctions(S, n) (S)->sizes.flags.hasSubFunctions = (n)\n\n/*\n * ss(Set|Get)CallsOutputInInitFcn - This macro is NOT to be used by\n *                                    custom S-Functions.\n */\n#define ssGetCallsOutputInInitFcn(S)                            \\\n    (S)->sizes.flags.callsOutputInInit /*   (unsigned int_T: 1) \\\n                                        */\n#define ssSetCallsOutputInInitFcn(S, n) (S)->sizes.flags.callsOutputInInit = (n)\n\n/* RTWCG - Block supports CGIR code generation for RTW (instead of TLC).\n */\n#define ssGetRTWCG(S) (S)->sizes.flags.rtwcg /*   (unsigned int_T: 1) */\n#define ssSetRTWCG(S, n)                                \\\n    {                                                   \\\n        (S)->sizes.flags.rtwcg = (n);                   \\\n        (S)->blkInfo.sfcnFlags.sRowMajorOptIn = 0U;     \\\n        (S)->blkInfo.sfcnFlags.sReuseAcrossModels = 0U; \\\n    }\n\n/* Block need absolute time. If block requiring absolute does not\n * set this flag. Obsolete absolute time will be used. Obsolete absolute\n * timer cannot support fixed pt blocks.\n */\n#define ssGetNeedAbsoluteTime(S) (S)->sizes.flags.needAbsoluteTime /*   (unsigned int_T: 1) */\n\n\n#define ssGetNeedElapseTime(S) (S)->sizes.flags.needElapseTime /*   (unsigned int_T: 1) */\n#define ssSetNeedElapseTime(S, n) (S)->sizes.flags.needElapseTime = (n)\n\n/*\n * mdlProjection may be present but S-Fcn may not want to call it\n */\n#define ssSetDisableMdlProjection(S, boolVal) \\\n    ((S)->sizes.flags.disableMdlProjection = (boolVal) ? 1U : 0U)\n\n#define ssIsMdlProjectionDisabled(S) ((S)->sizes.flags.disableMdlProjection == 1U)\n\n/*\n * mdlSlvrJacobian may be present but S-Fcn may want to call default\n   method\n */\n#define ssSetDisableMdlSlvrJacobian(S, boolVal) \\\n    ((S)->sizes.flags.disableMdlSlvrJacobian = (boolVal) ? 1U : 0U)\n\n#define ssIsMdlSlvrJacobianDisabled(S) ((S)->sizes.flags.disableMdlSlvrJacobian == 1U)\n\n/*\n * Query to see if rapid accelerator is active\n * Note that rapid accelerator simulation can have\n * simulation mode != rapid hence we need this query\n */\n#define ssSetIsRapidAcceleratorActive(S, boolVal) \\\n    ((!ssGetParentSS(S)) ? ((S)->sizes.flags.isRapidAcceleratorActive = (boolVal) ? 1U : 0U) : 0)\n\n/*\n * Query to see if the simstruc is in VM Simulations\n * boolean_T\n */\n#define ssGetIsVmSimulationCompile(S)                                                             \\\n    ((((S)->mdlInfo->genericFcn == NULL)                                                          \\\n          ? 0                                                                                     \\\n          : ((*(S)->mdlInfo->genericFcn)((S), GEN_FCN_VM_SIMULATION_COMPILE, 0, (void*)NULL))) == \\\n     1)\n/*\n * Query about the VM Simulations compliance\n */\n/*  val is of type (unsigned int: 3) */\n#define ssSetVmSimulationsCompliance(S, val) ((S)->sizes.flags.vmSimulationsCompliance = (val))\n\n/*  returns (unsigned int: 3) */\n#define ssGetVmSimulationsCompliance(S) ((S)->sizes.flags.vmSimulationsCompliance)\n\n\n\n#define ssGetModelReferenceNormalModeSupport(S) \\\n    (ssModelReferenceNormalModeSupport)((S)->sizes.flags.modelRefNormalModeSupport)\n\n\n/* Method to register that an S-function uses the LibSystemOutputCustomCode\n * or LibSystemUpdateCustomCode methods in TLC either directly or indirectly\n */\n#define ssGetUsingTLCCustomCodeFunctions(S) (S)->sizes.flags.usesCustomCodeFcns\n#define ssSetUsingTLCCustomCodeFunctions(S, val) (S)->sizes.flags.usesCustomCodeFcns = (val)\n\n/* Method to register that an S-function block can participate in\n * CRL based block replacement\n */\n#define ssGetCrlReplacementEnabled(S) (S)->sizes.flags.crlReplacementEnabled\n#define ssSetCrlReplacementEnabled(S, val) (S)->sizes.flags.crlReplacementEnabled = (val)\n\n\n\n/* ------------------------------- S->portInfo ------------------------------*/\n\n/* BEGIN long level 1 exclusion */\n#if !SS_SFCN_LEVEL_1\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetRegInputPortDimensionInfoFcn(S, fcn) (S)->mdlInfo->regInputPortDimsInfo = (fcn)\n\n#define ssSetRegOutputPortDimensionInfoFcn(S, fcn) (S)->mdlInfo->regOutputPortDimsInfo = (fcn)\n\n#define ssSetRegInputPortDimensionInfoFcnSLSize(S, fcn) \\\n    (S)->blkInfo.blkInfo2->mdlInfoSLSize->regInputPortDimsInfo = (fcn)\n\n#define ssSetRegOutputPortDimensionInfoFcnSLSize(S, fcn) \\\n    (S)->blkInfo.blkInfo2->mdlInfoSLSize->regOutputPortDimsInfo = (fcn)\n#endif\n\n\n\n/************************************************************\n * Input Port Width/Number of Dimensions/Dimensions Methods *\n ************************************************************/\n/* Number of Dimensions */\n#if defined(USE_64BIT_FIELDS)\n#define _ssSetInputPortNumDimensions(S, port, val)                             \\\n    {                                                                          \\\n        (S)->portInfo.inputs[(port)].numDims = (val);                          \\\n        if (val == 1) {                                                        \\\n            (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims =        \\\n                &((S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].width); \\\n        }                                                                      \\\n    }\n#elif defined(USE_32BIT_FIELDS)\n#define _ssSetInputPortNumDimensions(S, port, val)                                     \\\n    {                                                                                  \\\n        (S)->portInfo.inputs[(port)].numDims = (val);                                  \\\n        if (val == 1) {                                                                \\\n            (S)->portInfo.inputs[(port)].dims = &((S)->portInfo.inputs[(port)].width); \\\n        }                                                                              \\\n    }\n#elif defined(USE_32BIT_AND_64BIT_FIELDS)\n#define _ssSetInputPortNumDimensions(S, port, val)                                             \\\n    {                                                                                          \\\n        (S)->portInfo.inputs[(port)].numDims = (val);                                          \\\n        if (val == 1) {                                                                        \\\n            if ((S)->portInfo.inputs != NULL) {                                                \\\n                (S)->portInfo.inputs[(port)].dims = &((S)->portInfo.inputs[(port)].width);     \\\n            }                                                                                  \\\n            if (ssGetBlkInfo2Ptr(S) != NULL && (S)->blkInfo.blkInfo2->blkInfoSLSize != NULL) { \\\n                (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims =                    \\\n                    &((S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].width);             \\\n            }                                                                                  \\\n        }                                                                                      \\\n    }\n#endif\n\n/*\n *Input dimensions ptr\n */\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n/* varDims */\n#define ssGetCurrentInputPortDimensions(S, pIdx, dIdx) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputs[(pIdx)].portVarDims[(dIdx)]\n#define ssGetCurrentInputPortDimensionsSLSize(S, pIdx, dIdx) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(pIdx)].portVarDims[(dIdx)]\n\n/* portInfo dims */\n#define ssGetInputPortDimensions_fwd(S, port) ((S)->portInfo.inputs[(port)].dims)\n#define ssGetInputPortDimensionsSLSize_fwd(S, port) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims\n#define ssGetInputPortDimensionSize_fwd(S, port, dIdx)                                             \\\n    ((dIdx) < ssGetInputPortNumDimensions((S), (port)) ? (S)->portInfo.inputs[(port)].dims[(dIdx)] \\\n                                                       : 1)\n#define ssGetInputPortDimensionSizeSLSize_fwd(S, port, dIdx)                 \\\n    ((dIdx) < ssGetInputPortNumDimensions((S), (port))                       \\\n         ? (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims[(dIdx)] \\\n         : 1)\n\n/* port dimensions info (DimsInfo_T) */\n#define ssGetRegInputPortDimensionInfoFcn(S) \\\n    ((S)->blkInfo.blkInfo2->mdlInfoSLSize->regInputPortDimsInfo)\n#endif\n\n/* AsInt and SLSize macros should only be used in code allocating and initializing 32-bit\n   and 64-bit S-Functions. Currently, this includes simulink engine and sim targets */\n#define ssGetInputPortDimensionsAsInt(S, port) ((S)->portInfo.inputs[(port)].dims)\n#define ssGetInputPortDimensionsSLSize(S, port) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims\n\n/* Do not make a copy. S-function port dimension = Ptr. */\n#define _ssSetInputPortDimensionsPtr(S, port, ptr) \\\n    { (S)->portInfo.inputs[(port)].dims = (ptr); }\n#define _ssSetInputPortDimensionsPtrSLSize(S, port, ptr) \\\n    { (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims = (ptr); }\n\n/*\n * Copy 'd' to S-function port dimensions. It is assumed that\n * port has enough storage/memory to store the dimensions.\n */\n#define _ssCopyInputPortDimensions(S, port, d)                                        \\\n    {                                                                                 \\\n        int nn = ssGetInputPortNumDimensions(S, port);                                \\\n        if (nn >= 1) {                                                                \\\n            (void)memcpy(((S)->portInfo.inputs[(port)].dims), d, nn * sizeof(int_T)); \\\n        }                                                                             \\\n    }\n#define _ssCopyInputPortDimensionsToSLSize(S, port, d)                                   \\\n    {                                                                                    \\\n        int nn = ssGetInputPortNumDimensions(S, port);                                   \\\n        if (nn >= 1) {                                                                   \\\n            (void)memcpy(((S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims), d, \\\n                         nn * sizeof(int_T));                                            \\\n        }                                                                                \\\n    }\n\n/* Input port width */\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n#define ssGetInputPortWidth_fwd(S, port) (S)->portInfo.inputs[(port)].width\n#define ssGetInputPortWidthSLSize_fwd(S, port) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].width\n#define ssSetInputPortWidth_fwd(S, port, val) ((S)->portInfo.inputs[(port)].width = (val))\n#define ssSetInputPortWidthSLSize_fwd(S, port, val) \\\n    ((S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].width = (val))\n#endif\n\n/* AsInt macros should only be used in code allocating and initializing 32-bit\n   S-Functions. Currently, this includes simulink engine and sim targets */\n#define ssSetInputPortWidthAsInt(S, port, val) ((S)->portInfo.inputs[(port)].width = (val))\n\n/*\n * Set flag that specifies if an S-function can handle\n * Big Long signal\n * ssAllowSignalsHandleBigLong(S) is deprecated.\n * Please use ssFxpSetU32BitRegionCompliant defined in fixedpoint.h instead\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssAllowSignalsHandleBigLong(S)                                           \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_SIGS_ALLOW_BIG_LONG, 1, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssAllowSignalsHandleBigLong(S)\n#endif\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetSupportDataTypeBeyond32BitsInRTW(S, val)                                           \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_SUPPORT_DATATYPE_BEYOND_32_BITS_IN_RTW, val, \\\n                                    NULL) _ssSafelyCallGenericFcnEnd\n#else\n#define ssSetSupportDataTypeBeyond32BitsInRTW(S, val)\n#endif\n\n\n/***************************\n * END of width/dimensions *\n ***************************/\n#define ssGetInputPortSignalWhenNeeded(S, port) ((S)->portInfo.inputs[(port)].attributes.cinId)\n\n#define ssGetOutputPortSignalWhenRefreshed(S, port) ((S)->portInfo.outputs[(port)].attributes.cecId)\n#define ssSetOutputPortSignalWhenRefreshed(S, port, val) \\\n    (S)->portInfo.outputs[(port)].attributes.cecId = (val)\n\n/* InputDimsConstraint - For each input port of your S-function block, this is the\n *   dataflow dims constraint. If unspecified, then the default type is\n * \"SS_DIMS_CONSTRAINT_UNSPECIFIED\" and the default size is 1.\n */\n#define ssGetInputPortDimsConstraintType(S, port) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputDimsConstraint[(port)].type\n#define ssGetInputPortDimsConstraintSize(S, port) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputDimsConstraint[(port)].size\n#define ssSetInputPortDimsConstraint(S, port, t, sz)                          \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputDimsConstraint[(port)].type = (t); \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputDimsConstraint[(port)].size = (sz)\n\n/* InputPortSignalPtrs - This is the pointers to the signal vector for each\n *    input port. This is the default method for accessing the S-Function's\n *    input signals. It is a *bad* error to use this macro if the S-Function\n *    specifies ssSetInputPortRequiredContiguous as true. In that case, use\n *    ssGetInputPortSignal().\n *\n *    The following code demonstrates the use of ssGetInputPortSignalPtrs() :\n *\n *       nInputPorts = ssGetNumInputPorts(S);\n *       for (i = 0; i < nInputPorts; i++) {\n *         InputPtrsType u  = ssGetInputPortSignalPtrs(S,i);\n *         int_T         nu = ssGetInputPortWidth(S,i);\n *         for (j = 0; j < nu; j++) {\n *           UseInputInSomeFunction(*u[i]);\n *         }\n *       }\n *\n *    If you know that the input's are always real_T's signals, then the\n *    ssGetInputPortSignalPtrs line in the above code snippet would be:\n *\n *         InputRealPtrsType u = ssGetInputPortRealSignalPtrs(S,i);\n *\n */\n\n#define _ssSetInputPortSignalPtrs(S, ip, ptr) (S)->portInfo.inputs[(ip)].signal.ptrs = (ptr)\n#if !SS_SFCN\n#define ssSetInputPortSignalPtrs(S, ip, ptr) _ssSetInputPortSignalPtrs(S, ip, ptr)\n#else\n#define ssSetInputPortSignalPtrs(S, ip, ptr) ssSetInputPortSignalPtrs_cannot_be_used_in_SFunctions\n#endif\n\n\n/* InputPortSignal: This macro returns the address of the signal on the\n *    specified input port of the S-Function. In order to use this macro for\n *    accessing the input port signal you need to set the attribute\n *    ssSetInputPortRequiredContiguous to true. If not, this macro returns an\n *    invalid pointer.\n *\n *    The following code demonstrates the use of ssGetInputPortSignal() :\n *\n *       nInputPorts = ssGetNumInputPorts(S);\n *       for (i = 0; i < nInputPorts; i++) {\n *           int_T nu = ssGetInputPortWidth(S,i);\n *\n *           if ( ssGetInputPortRequiredContiguous(S,i) ) {\n *\n *               const void *u = ssGetInputPortSignal(S,i);\n *               UseInputVectorInSomeFunction(u, nu);\n *\n *           } else {\n *\n *               InputPtrsType u  = ssGetInputPortSignalPtrs(S,i);\n *               for (j = 0; j < nu; j++) {\n *                   UseInputInSomeFunction(*u[j]);\n *               }\n *           }\n *       }\n *\n *    If you know that the input's are always real_T's signals, then the\n *    ssGetInputPortSignal line in the above code snippet would be:\n *\n *         const real_T *u = ssGetInputPortRealSignal(S,i);\n *\n */\n\n#define _ssSetInputPortSignal(S, ip, ptr) (S)->portInfo.inputs[(ip)].signal.vect = (ptr)\n#if !SS_SFCN\n#define ssSetInputPortSignal(S, ip, ptr) _ssSetInputPortSignal(S, ip, ptr)\n#else\n#define ssSetInputPortSignal(S, ip, ptr) ssSetInputPortSignal_cannot_be_used_in_SFunctions\n#endif\n\n\n/* InputPortConnected - Is the input connected to a non-virtual block (i.e.\n *   are there signals entering the S-function block)?\n */\n\n#define _ssSetInputPortConnected(S, port, val) (S)->portInfo.inputs[(port)].connected = (val)\n#if !SS_SFCN\n#define ssSetInputPortConnected(S, port, val) _ssSetInputPortConnected(S, port, val)\n#else\n#define ssSetInputPortConnected(S, port, val) ssSetInputPortConnected_cannot_be_used_in_SFunctions\n#endif\n\n\n\n#if defined(RTW_GENERATED_S_FUNCTION) || SS_SL_INTERNAL\n/* InputPortIsNotDerivPort - Specify that the input port signal is not\n * used in mdlDerivative function.  By default this will be false for all input\n * ports when the blocks has continuous states.  This setting is used\n * to determine what noncontinuous signals to track during simulation.\n */\n#define ssGetInputPortIsNotDerivPort(S, port) \\\n    ((S)->portInfo.inputs[(port)].attributes.nonDerivPort == 1U)\n#define ssSetInputPortIsNotDerivPort(S, port, val) \\\n    ((S)->portInfo.inputs[(port)].attributes.nonDerivPort = (val) ? 1U : 0U)\n#endif\n\n\n/*\n * This macro is obsolete, please use ssS(G)etInputPortOptimOpts\n *\n *  InputPortReusable - If this is set to false (which is the default value),\n *  then the memory allocated to the signals driving this input port are both\n *  globally visible and persistent. However, if this is set to true then this\n *  signal may be reused by other block outputs (and hence its value will not\n *  be persistent). For finer control use ssSetInputPortOptimOpts\n *\n */\n#if SS_SFCN_NORMAL\n#define ssGetInputPortReusable(S, port) \\\n    ((S)->portInfo.inputs[(port)].attributes.optimOpts != SS_NOT_REUSABLE_AND_GLOBAL)\n\n#if SS_SFCN_FOR_SIM && !SS_NDEBUG\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern void _ssSetInputPortReusableFcn(SimStruct* S, int port, int val);\n#ifdef __cplusplus\n}\n#endif\n#define ssSetInputPortReusable(S, port, val) _ssSetInputPortReusableFcn(S, port, val)\n#else\n#define ssSetInputPortReusable(S, port, val)             \\\n    ((S)->portInfo.inputs[(port)].attributes.optimOpts = \\\n         (val) ? SS_REUSABLE_AND_LOCAL : SS_NOT_REUSABLE_AND_GLOBAL)\n#endif\n\n#endif\n\n\n/* InputPortOptimizeInIR - This macro allows S-Functions that use the code\n * generation intermediate representation (CGIR) to generate code, to enable\n * optimizations on for the input port that would otherwise be disabled by\n * default. For example, the macro should be used if a S-Function set its\n * input port conservatively as global, because it is accessed in both the\n * output and the update function. It is possible for CGIR to safely optimize\n * the port signal if output and update get combined.\n */\n#define ssGetInputPortOptimizeInIR(S, port) ((S)->portInfo.inputs[(port)].attributes.optimizeInIR)\n#define ssSetInputPortOptimizeInIR(S, port, val) \\\n    ((S)->portInfo.inputs[(port)].attributes.optimizeInIR = (val))\n\n\n/* InputPortBufferDstPort - If an input port and some output port on an\n *   S-Function are *not* test points, and in addition,  if this input port is\n *   over-writable, then one of the \"untest-pointed\" output ports of this\n *   S-Function might reuse the same buffer as the input port! If this happens,\n *   then after compilation, the following macro returns the index of the\n *   output port that reuses the specified input port's buffer. If none of the\n *   S-Function's output ports reuse this input port buffer, then this macro\n *   returns INVALID_PORT_IDX ( = -1).\n */\n\n#define _ssSetInputPortBufferDstPort(S, port, val) \\\n    (S)->portInfo.inputs[(port)].bufferDstPort = (val)\n#if !SS_SFCN\n#define ssSetInputPortBufferDstPort(S, port, val) _ssSetInputPortBufferDstPort(S, port, val)\n#else\n#define ssSetInputPortBufferDstPort(S, port, val) \\\n    ssSetInputPortBufferDstPort_cannot_be_used_in_SFunctions\n#endif\n\n\n#define _ssSetInputPortSampleTimeIndex(S, port, idx) \\\n    (S)->portInfo.inputs[(port)].sampleTimeIndex = (idx) /* (int_T)   */\n#if !SS_SFCN\n#define ssSetInputPortSampleTimeIndex(S, port, idx) _ssSetInputPortSampleTimeIndex(S, port, idx)\n#else\n#define ssSetInputPortSampleTimeIndex(S, port, idx) \\\n    ssSetInputPortSampleTimeIndex_cannot_be_used_in_SFunctions\n#endif\n\n\n\n#if SS_SFCN && SS_SIM\n/* ssSetInputPortAccessedByAddress - This macro should be invoked\n * in the mdlInitializeSizes function if the s-function block requires that,\n * in the generated code, the signal coming into the specified port is\n * always addressable.\n */\n#define ssSetInputPortAccessedByAddress(S, portIdx)                                      \\\n    {                                                                                    \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_INPUT_PORT_ACCESSED_BY_ADDRESS, \\\n                                        (portIdx), NULL) _ssSafelyCallGenericFcnEnd;     \\\n    }\n#endif\n\n\n\n/***********************************\n * Output Port Number of Dimensions *\n ***********************************/\n\n\n#if defined(USE_64BIT_FIELDS)\n#define _ssSetOutputPortNumDimensions(S, port, val)                             \\\n    {                                                                           \\\n        (S)->portInfo.outputs[(port)].numDims = (val);                          \\\n        if (val == 1) {                                                         \\\n            (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims =        \\\n                &((S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].width); \\\n        }                                                                       \\\n    }\n#elif defined(USE_32BIT_FIELDS)\n#define _ssSetOutputPortNumDimensions(S, port, val)                                      \\\n    {                                                                                    \\\n        (S)->portInfo.outputs[(port)].numDims = (val);                                   \\\n        if (val == 1) {                                                                  \\\n            (S)->portInfo.outputs[(port)].dims = &((S)->portInfo.outputs[(port)].width); \\\n        }                                                                                \\\n    }\n#elif defined(USE_32BIT_AND_64BIT_FIELDS)\n#define _ssSetOutputPortNumDimensions(S, port, val)                                            \\\n    {                                                                                          \\\n        (S)->portInfo.outputs[(port)].numDims = (val);                                         \\\n        if (val == 1) {                                                                        \\\n            if ((S)->portInfo.outputs != NULL) {                                               \\\n                (S)->portInfo.outputs[(port)].dims = &((S)->portInfo.outputs[(port)].width);   \\\n            }                                                                                  \\\n            if (ssGetBlkInfo2Ptr(S) != NULL && (S)->blkInfo.blkInfo2->blkInfoSLSize != NULL) { \\\n                (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims =                   \\\n                    &((S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].width);            \\\n            }                                                                                  \\\n        }                                                                                      \\\n    }\n#endif\n\n/*************************\n * Output Port Dimensions *\n *************************/\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n/* varDims */\n#define ssGetCurrentOutputPortDimensions(S, pIdx, dIdx) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputs[(pIdx)].portVarDims[(dIdx)]\n#define ssGetCurrentOutputPortDimensionsSLSize(S, pIdx, dIdx) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(pIdx)].portVarDims[(dIdx)]\n#define _ssSetCurrentOutputPortDimensions(S, pIdx, dIdx, val) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputs[(pIdx)].portVarDims[(dIdx)] = (val)\n#define _ssSetCurrentOutputPortDimensionsSLSize(S, pIdx, dIdx, val) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(pIdx)].portVarDims[(dIdx)] = (val)\n\n/* portInfo dims */\n#define ssGetOutputPortDimensions_fwd(S, port) ((S)->portInfo.outputs[(port)].dims)\n#define ssGetOutputPortDimensionsSLSize_fwd(S, port) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims\n#define ssGetOutputPortDimensionSize_fwd(S, port, dIdx) \\\n    ((dIdx) < ssGetOutputPortNumDimensions((S), (port)) \\\n         ? (S)->portInfo.outputs[(port)].dims[(dIdx)]   \\\n         : 1)\n#define ssGetOutputPortDimensionSizeSLSize_fwd(S, port, dIdx)                 \\\n    ((dIdx) < ssGetOutputPortNumDimensions((S), (port))                       \\\n         ? (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims[(dIdx)] \\\n         : 1)\n\n/* port dimensions info (DimsInfo_T) */\n#define ssGetRegOutputPortDimensionInfoFcn(S) \\\n    ((S)->blkInfo.blkInfo2->mdlInfoSLSize->regOutputPortDimsInfo)\n#endif\n\n/* AsInt and SLSize macros should only be used in code allocating and initializing 32-bit\n   and 64-bit S-Functions. Currently, this includes simulink engine and sim targets */\n#define ssGetOutputPortDimensionsAsInt(S, port) ((S)->portInfo.outputs[(port)].dims)\n#define ssGetOutputPortDimensionsSLSize(S, port) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims\n\n/* Do not make a copy. S-function port dimension = Ptr. */\n#define _ssSetOutputPortDimensionsPtr(S, port, ptr) \\\n    { (S)->portInfo.outputs[(port)].dims = (ptr); }\n#define _ssSetOutputPortDimensionsPtrSLSize(S, port, ptr) \\\n    { (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims = (ptr); }\n\n/*\n * Copy 'd' to S-function port dimensions. It is assumed that\n * port has enough storage/memory to store the dimensions.\n */\n#define _ssCopyOutputPortDimensions(S, port, d)                                        \\\n    {                                                                                  \\\n        int nn = ssGetOutputPortNumDimensions(S, port);                                \\\n        if (nn >= 1) {                                                                 \\\n            (void)memcpy(((S)->portInfo.outputs[(port)].dims), d, nn * sizeof(int_T)); \\\n        }                                                                              \\\n    }\n#define _ssCopyOutputPortDimensionsToSLSize(S, port, d)                                   \\\n    {                                                                                     \\\n        int nn = ssGetOutputPortNumDimensions(S, port);                                   \\\n        if (nn >= 1) {                                                                    \\\n            (void)memcpy(((S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims), d, \\\n                         nn * sizeof(int_T));                                             \\\n        }                                                                                 \\\n    }\n\n/*************************\n * Output Port Width     *\n *************************/\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n#define ssGetOutputPortWidth_fwd(S, port) (S)->portInfo.outputs[(port)].width\n#define ssGetOutputPortWidthSLSize_fwd(S, port) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].width\n#define ssSetOutputPortWidth_fwd(S, port, val) ((S)->portInfo.outputs[(port)].width = (val))\n#define ssSetOutputPortWidthSLSize_fwd(S, port, val) \\\n    ((S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].width = (val))\n#endif\n\n/* AsInt macros should only be used in code allocating and initializing 32-bit\n   S-Functions. Currently, this includes simulink engine and sim targets */\n#define ssGetOutputPortWidthAsInt(S, port) (S)->portInfo.outputs[(port)].width\n#define ssSetOutputPortWidthAsInt(S, port, val) ((S)->portInfo.outputs[(port)].width = (val))\n\n/*\n * This macro is obsolete, please use ssS(G)etOutputPortOptimOpts\n *\n * OutputPortReusable - If this is set to false (which is the default value),\n *  then the memory allocated to this output port is both globally visible,\n *  and persistent. However, if you set this to true in the mdlInitializeSizes\n *  function then the memory allocated for this signal may be reused by other\n *  block outputs (hence its value will not be persistent).\n *  For finer control use ssSetOutputPortOptimOpts\n */\n#if SS_SFCN_NORMAL\n#define ssGetOutputPortReusable(S, port) \\\n    ((S)->portInfo.outputs[(port)].attributes.optimOpts != SS_NOT_REUSABLE_AND_GLOBAL)\n\n#if SS_SFCN_FOR_SIM && !SS_NDEBUG\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern void _ssSetOutputPortReusableFcn(SimStruct* S, int port, int val);\n#ifdef __cplusplus\n}\n#endif\n#define ssSetOutputPortReusable(S, port, val) _ssSetOutputPortReusableFcn(S, port, val)\n#else\n#define ssSetOutputPortReusable(S, port, val)             \\\n    ((S)->portInfo.outputs[(port)].attributes.optimOpts = \\\n         (val) ? SS_REUSABLE_AND_LOCAL : SS_NOT_REUSABLE_AND_GLOBAL)\n#endif\n\n#endif\n\n/* OutputPortOptimizeInIR - This macro allows S-Functions that use the code\n * generation intermediate representation (CGIR) to generate code, to enable\n * optimizations on for the output port that would otherwise be disabled by\n * default. For example, the macro should be used if a S-Function set its\n * output port conservatively as global, because it is accessed in both the\n * output and the update function. It is possible for CGIR to safely optimize\n * the port signal if output and update get combined.\n */\n#define ssGetOutputPortOptimizeInIR(S, port) ((S)->portInfo.outputs[(port)].attributes.optimizeInIR)\n#define ssSetOutputPortOptimizeInIR(S, port, val) \\\n    ((S)->portInfo.outputs[(port)].attributes.optimizeInIR = (val))\n\n\n/* OutputPortBeingMerged - If this output port signal of the S-Function is\n * being merged with other signals (this happens if the S-Function block\n * output port is directly or via connection type blocks is connected to a\n * Merge block), then the macro below will return \"true\". This macro will\n * return the correct answer in and after the S-Function's mdlSetWorkWidths()\n * method.\n */\n\n#define _ssSetOutputPortBeingMerged(S, port, val) \\\n    (S)->portInfo.outputs[(port)].attributes.cToMergeBlk = (val) ? 1U : 0U\n#if !SS_SFCN\n#define ssSetOutputPortBeingMerged(S, port, val) _ssSetOutputPortBeingMerged(S, port, val)\n#else\n#define ssSetOutputPortBeingMerged(S, port, val) \\\n    ssSetOutputPortBeingMerged_cannot_be_used_in_SFunctions\n#endif\n\n/* OutputPortConstOutputExprInRTW - Specify that the output signal is a constant\n * expression in RTW (versus a statement).  This allows a downstream block\n * to fold the expression into its calculation no matter how many destinations\n * the block has.  Note that Simulink may not honor this setting, in which case\n * the block must produce a statement.\n */\n#define ssGetOutputPortConstOutputExprInRTW(S, port) \\\n    ((S)->portInfo.outputs[(port)].attributes.constOutputExprInRTW == 1U)\n#define ssSetOutputPortConstOutputExprInRTW(S, port, val)                            \\\n    ((S)->portInfo.outputs[(port)].attributes.constOutputExprInRTW =                 \\\n         (val) ? ((S)->portInfo.outputs[(port)].attributes.trivialOutputExprInRTW =  \\\n                      (S)->portInfo.outputs[(port)].attributes.outputExprInRTW = 1U) \\\n               : 0U)\n\n\n/* OutputPortTrivialOutputExprInRTW - Specify that the output signal is a trivial\n * expression in RTW (versus a statement).  This allows a downstream block\n * to fold the expression into its calculation no matter how many destinations\n * the block has.  Note that Simulink may not honor this setting, in which case\n * the block must produce a statement.\n */\n#define ssGetOutputPortTrivialOutputExprInRTW(S, port) \\\n    ((S)->portInfo.outputs[(port)].attributes.trivialOutputExprInRTW == 1U)\n#define ssSetOutputPortTrivialOutputExprInRTW(S, port, val)                      \\\n    ((S)->portInfo.outputs[(port)].attributes.trivialOutputExprInRTW =           \\\n         (val) ? ((S)->portInfo.outputs[(port)].attributes.outputExprInRTW = 1U) \\\n               : ((S)->portInfo.outputs[(port)].attributes.constOutputExprInRTW = 0U))\n\n\n\n#if defined(RTW_GENERATED_S_FUNCTION) || SS_SL_INTERNAL\n/* OutputPortIsNonContinuous - Specify that the output port signal is\n * noncontinuous (i.e. has a discontinuity even if the sample time is\n * continuous).  This setting is used to determine what noncontinuous\n * signals to track during simulation.  It is false by default.\n */\n#define ssGetOutputPortIsNonContinuous(S, port) \\\n    ((S)->portInfo.outputs[(port)].attributes.nonContPort)\n#define ssSetOutputPortIsNonContinuous(S, port, val) \\\n    ((S)->portInfo.outputs[(port)].attributes.nonContPort = (val) ? 1U : 0U)\n\n/*\n * Specify that the output port is being driven by a block\n * with modes but no zero-crossings.  We need this for model\n * reference to determine if DerivCacheNeedsReset is true.\n */\n#define ssGetOutputPortIsFedByBlockWithModesNoZCs(S, port) \\\n    ((S)->portInfo.outputs[(port)].attributes.fedByBlockWithModesNoZCs)\n#define ssSetOutputPortIsFedByBlockWithModesNoZCs(S, port, val) \\\n    ((S)->portInfo.outputs[(port)].attributes.fedByBlockWithModesNoZCs = (val) ? 1U : 0U)\n#endif\n\n\n\ntypedef enum {\n    SS_DATA_DESC_OUTPUT,\n    SS_DATA_DESC_INPUT,\n    SS_DATA_DESC_RTP,\n    SS_DATA_DESC_DWORK\n} SSDataDescType;\n\n#define ssRegisterDataMinMaxPrmIndices(S, dataDescType, dataIdx, prmMinIdx, prmMaxIdx)             \\\n    {                                                                                              \\\n        int _moreArgs[3] = {(int)(dataDescType), (prmMinIdx), (prmMaxIdx)};                        \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REGISTER_DATA_MIN_MAX_PRM_INDICES, (dataIdx), \\\n                                        _moreArgs) _ssSafelyCallGenericFcnEnd;                     \\\n    }\n\n/*\n * Register dialog parameters indexed as prmMinIdx and prmMaxIdx as design\n * minimum and maximum for the output port of index portIdx.\n */\n#define ssRegisterOutputPortMinMaxPrmIndices(S, portIdx, prmMinIdx, prmMaxIdx) \\\n    ssRegisterDataMinMaxPrmIndices((S), SS_DATA_DESC_OUTPUT, (portIdx), (prmMinIdx), (prmMaxIdx))\n\n\n/*\n * Set the output port min/max values.  This is used by Stateflow and other S-Functions\n * in which min/max values are not Parameters with indices.  In case of Stateflow,\n * the min/max values are data properties.\n * This API and ssRegisterOutputPortMinMaxPrmIndices() are mutually exclusive!\n */\ntypedef struct outputPortMinMaxStruct_t {\n    int dataDescType;\n    double designMin;\n    double designMax;\n} outputPortMinMaxStruct;\n\n#define ssSetOutputPortMinMaxValues(S, portIdx, minValue, maxValue)                          \\\n    {                                                                                        \\\n        outputPortMinMaxStruct _moreArgs = {(int)(SS_DATA_DESC_OUTPUT), minValue, maxValue}; \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_DATA_MIN_MAX_VALUES, (portIdx),     \\\n                                        (void*)&_moreArgs) _ssSafelyCallGenericFcnEnd;       \\\n    }\n\n/* OutputDimsConstraint - For each output port of your S-function block, this is the\n *   dataflow dims constraint. If unspecified, then the default type is\n * \"SS_DIMS_CONSTRAINT_UNSPECIFIED\" and the default size is 1.\n */\n#define ssGetOutputPortDimsConstraintType(S, port) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputDimsConstraint[(port)].type\n#define ssGetOutputPortDimsConstraintSize(S, port) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputDimsConstraint[(port)].size\n#define ssSetOutputPortDimsConstraint(S, port, t, sz)                          \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputDimsConstraint[(port)].type = (t); \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputDimsConstraint[(port)].size = (sz)\n\n/* OutputPortSignal - This is the pointers to the signal vector for each\n *   output port.  For example to write to all outputs with int16_T data\n *   type:\n *       nOutputPorts = ssGetNumOutputPorts(S);\n *       for (i = 0; i < nOutputPorts; i++) {\n *         int16_T  *y = (int16_T *)ssGetOutputPortSignal(S,i);\n *         int_T ny    = ssGetOutputPortWidth(S,i);\n *         for (j = 0; j < ny; j++) {\n *           SomeFunctionToFillInOutput(y[j]);\n *         }\n *       }\n *   If you know that the output is always a real_T, then the\n *   ssGetOutputPortSignal line would be:\n *       real_T *y  = ssGetOutputPortRealSignal(S,i);\n */\n\n#define _ssSetOutputPortSignal(S, port, vect) (S)->portInfo.outputs[(port)].signalVect = (vect)\n#if !SS_SFCN\n#define ssSetOutputPortSignal(S, port, vect) _ssSetOutputPortSignal(S, port, vect)\n#else\n#define ssSetOutputPortSignal(S, port, vect) ssSetOutputPortSignal_cannot_be_used_in_SFunctions\n#endif\n\n/* OutputPortConnected - Is the output connected to a non-virtual block (i.e.\n *   are the signals leaving the S-function block driving other blocks)?\n */\n\n#define _ssSetOutputPortConnected(S, port, val) (S)->portInfo.outputs[(port)].connected = (val)\n#if !SS_SFCN\n#define ssSetOutputPortConnected(S, port, val) _ssSetOutputPortConnected(S, port, val)\n#else\n#define ssSetOutputPortConnected(S, port, val) ssSetOutputPortConnected_cannot_be_used_in_SFunctions\n#endif\n\n/* OutputPortSampleTime/OutputPortOffsetTime - The sample and offset time of\n *   the output port. This should only be used when PORT_BASED_SAMPLE_TIMES\n *   have been specified for ssSetNumSampleTimes in mdlInitializeSizes.\n * OutputPortSampleTimeIndex - index of the sample time for the port to\n *   be used in mdlOutputs, mdlUpdate when checking for sample hits.\n */\n\n\n\n#define _ssSetOutputPortSampleTimeIndex(S, port, idx) \\\n    (S)->portInfo.outputs[(port)].sampleTimeIndex = (idx) /* (int_T)   */\n#if !SS_SFCN\n#define ssSetOutputPortSampleTimeIndex(S, port, idx) _ssSetOutputPortSampleTimeIndex(S, port, idx)\n#else\n#define ssSetOutputPortSampleTimeIndex(S, port, idx) \\\n    ssSetOutputPortSampleTimeIndex_cannot_be_used_in_SFunctions\n#endif\n\n/*\n * Routines to allow the S-function to map a block IC parameter to\n * its output port.\n */\n#define ssGetOutputPortInitialOutputParamIdx(S, port) \\\n    ((S)->portInfo.outputs[(port)].icPrmIdxPlus1 - 1)\n#define ssSetOutputPortInitialOutputParamIdx(S, port, val) \\\n    (S)->portInfo.outputs[(port)].icPrmIdxPlus1 = ((int_T)val + 1)\n\n/*\n * Routines to setup the fcn and arg which allow the S-function to register\n * the input/output port properties.\n */\n#define ssSetRegNumInputPortsFcn(S, fcn) (S)->portInfo.regNumInputPortsFcn = fcn\n#define ssSetRegNumInputPortsFcnArg(S, arg) (S)->portInfo.regNumInputPortsFcnArg = arg\n#define ssSetRegNumOutputPortsFcn(S, fcn) (S)->portInfo.regNumOutputPortsFcn = fcn\n#define ssSetRegNumOutputPortsFcnArg(S, arg) (S)->portInfo.regNumOutputPortsFcnArg = arg\n#endif\n/* END long level 1 exclusion */\n\n\n\n#define ssGetRTModel(S) (S)->sizes.rtModel\n#define ssSetRTModel(S, rtm) (S)->sizes.rtModel = ((void*)(rtm))\n\n/*-------------------------------- S->sfcnParams ---------------------------*/\n\n/* Macros for manipulating dialog parameters */\n\n\n#define _ssSetSFcnParamsCount(S, n) (S)->sfcnParams.dlgNum = (n)\n#if !SS_SFCN\n#define ssSetSFcnParamsCount(S, n) _ssSetSFcnParamsCount(S, n)\n#else\n#define ssSetSFcnParamsCount(S, n) ssSetSFcnParamsCount_cannot_be_used_in_SFunctions\n#endif\n\n\n/* SFcnParams - This is a list of MyArray pointers corresponding to the\n *   S-function parameters supplied to your S-function. This is not\n *   used by the root SimStruct.\n */\n#define _ssGetSFcnParamsPtr(S) (S)->sfcnParams.dlgParams /*   (mxArray **)  */\n/* GCC 4.X issues warning when using conventional C-style cast in C++ code */\n#ifdef __cplusplus\n#define ssGetSFcnParamsPtr(S) \\\n    (const_cast<const mxArray* const*>(_ssGetSFcnParamsPtr(S))) /* (const mxArray *const *) */\n#else\n#define ssGetSFcnParamsPtr(S) \\\n    ((const mxArray* const*)_ssGetSFcnParamsPtr(S)) /* (const mxArray *const *) */\n#endif\n#define _ssSetSFcnParamsPtr(S, ptr) (S)->sfcnParams.dlgParams = (ptr)\n#if !SS_SFCN\n#define ssSetSFcnParamsPtr(S, ptr) _ssSetSFcnParamsPtr(S, ptr)\n#else\n#define ssSetSFcnParamsPtr(S, ptr) ssSetSFcnParamsPtr_cannot_be_used_in_SFunctions\n#endif\n\n/* Use ssGetSFcnParam(S,index) to access S-function parameters from within\n * S-functions. The index starts at 0, which corresponds to the (index+1)'th\n * parameter.\n */\n\n\n#define _ssSetSFcnParam(S, index, mat) (S)->sfcnParams.dlgParams[index] = (mat)\n#if !SS_SFCN\n#define ssSetSFcnParam(S, index, mat) _ssSetSFcnParam(S, index, mat)\n#else\n#define ssSetSFcnParam(S, index, mat) ssSetSFcnParam_cannot_be_used_in_SFunctions\n#endif\n\n\n\n#define ssGetSFcnParamTunable(S, index) ((S)->sfcnParams.dlgAttribs[index] & SFCNPARAM_TUNABLE)\n\n#define ssGetSFcnParamSimOnlyTunable(S, index) \\\n    ((S)->sfcnParams.dlgAttribs[index] & SFCNPARAM_SIMONLY_TUNABLE)\n\n#if SS_SL_INTERNAL || (SS_SIM && SS_GENERATED_S_FUNCTION)\n#define ssGetSFcnParamsNotTunable(S, index) \\\n    ((S)->sfcnParams.dlgAttribs[index] & SFCNPARAM_NOT_TUNABLE)\n\n#define ssGetSFcnParamAttribsPtr(S) (S)->sfcnParams.dlgAttribs\n#define ssSetSFcnParamAttribsPtr(S, ptr) (S)->sfcnParams.dlgAttribs = (ptr)\n#endif\n\n\n/* Macros for checking values entered for S-Function parameters */\n#define _ssCacheSFcnParamValueAttribs(pName, dtId, nDims, dimsPtr, cplx) \\\n    ssParamRec locPI;                                                    \\\n    locPI.name = pName;                                                  \\\n    locPI.nDimensions = nDims;                                           \\\n    locPI.dimensions = dimsPtr;                                          \\\n    locPI.complexSignal = cplx;                                          \\\n    locPI.dataTypeId = dtId;                                             \\\n    locPI.data = NULL;                                                   \\\n    locPI.dataAttributes = NULL;                                         \\\n    locPI.nDlgParamIndices = 0;                                          \\\n    locPI.dlgParamIndices = NULL;                                        \\\n    locPI.transformed = RTPARAM_NOT_TRANSFORMED;                         \\\n    locPI.outputAsMatrix = false;\n\n#define ssCheckSFcnParamValueAttribs(S, pIdx, pName, dtId, nDims, dimsPtr, cplx)                  \\\n    {                                                                                             \\\n        _ssCacheSFcnParamValueAttribs(                                                            \\\n            pName, dtId, nDims, dimsPtr,                                                          \\\n            cplx) if (!_ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_CHECK_SFCN_PARAM_VALUE_ATTRIBS, \\\n                                                       pIdx, &locPI)                              \\\n                          _ssSafelyCallGenericFcnEnd) return;                                     \\\n    }\n\n\n/* ======================================================================\n *  Macros for manipulating run-time parameters.\n * ======================================================================\n * The most commonly used macros are:\n * - ssSetNumRunTimeParams\n *   ==> To set the number of run-time parameters (before registering run-time parameters)\n *\n * - ssRegAllTunableParamsAsRunTimeParams\n *   ==> To register all tunable SFcnParams as run-time parameters (in mdlSetWorkWidths)\n * - ssRegDlgParamAsRunTimeParam\n *   ==> To register specific SFcnParam as a run-time parameter (in mdlSetWorkWidths)\n *       This macro will perform data type conversion if necessary\n *\n * - ssUpdateAllTunableParamsAsRunTimeParams\n * - ssUpdateDlgParamAsRunTimeParam\n *   ==> To update values of run-time parameters during simulation (in mdlProcessParameters)\n */\n\n\n\n#if SS_SFCN\n#if !SS_RTW\n#define ssSetConstRunTimeParamInfo(S, idx, p)                                           \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REG_CONST_RUN_TIME_PARAM, idx, (void*)p) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n#endif\n\n#if SS_SFCN && SS_SIM\n#define ssSetStateflowIsInlinable(S, p) \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SF_INLINABLE, p, NULL) _ssSafelyCallGenericFcnEnd\n#endif\n\n#if SS_SFCN && SS_SIM\n#define ssSetOutputFcnCalledMultiple(S, p)                                              \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_OUTPUT_FCN_CALLED_MULTIPLE, p, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\n#if SS_SFCN && SS_SIM\n#define ssSetNotMultipleInlinable(S, p)                                              \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_NOT_MULTIPLE_INLINEABLE, p, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\ntypedef struct _ssRTPFromDataInfoWithConv_tag {\n    void* data;\n    int nDataDims;            /* data dimension number       */\n    int* dataDims;            /* data dimensions             */\n    DTypeId dataTypeId;       /* CANNOT be DYNAMICALLY_TYPED */\n    CSignal_T dataComplexity; /* CANNOT be COMPLEX_INHERITED */\n    boolean_T dataIsConst;    /* constant run-time prm?      */\n    int numParams;            /* number dlg prms, could be 0 */\n    int* paramIndices;        /* dlg prms, could be NULL     */\n    int rtpIndex;             /* run-time prm index          */\n    const char* rtpName;      /* run-time prm name           */\n    DTypeId rtpDataTypeId;    /* user-specified rtp datatype */\n    CSignal_T rtpComplexity;  /* user-specified rtp complex  */\n} ssRTPFromDataInfoWithConv;\n\ntypedef struct _ssRTPDataInfo_tag {\n    void* data;               /* data pointer                */\n    DTypeId dataTypeId;       /* CANNOT be DYNAMICALLY_TYPED */\n    CSignal_T dataComplexity; /* CANNOT be COMPLEX_INHERITED */\n} ssRTPDataInfo;\n\n\ntypedef struct _ssRTPRegInfoWithTypeComp_tag {\n    int dlgIdx;\n    int rtIdx;\n    const char* name;\n    int dtId;\n    CSignal_T complexity;\n} ssRTPRegInfoWithTypeComp;\n\n\n\ntypedef struct _ssTimerInfo_tag {\n    double clockTickStepSize;\n    int_T clockTickDtype;\n    slTimeSource timeSource;\n} ssTimerInfo;\n\n#if SS_SFCN && SS_SIM\n\n#define ssRegDlgParamAsRunTimeParamFull(S, dlgIdxArg, rtIdxArg, nameArg, dtIdArg, compArg) \\\n    {                                                                                      \\\n        ssRTPRegInfoWithTypeComp _slConvTypeAndRegParamInfo;                               \\\n        _slConvTypeAndRegParamInfo.dlgIdx = (dlgIdxArg);                                   \\\n        _slConvTypeAndRegParamInfo.rtIdx = (rtIdxArg);                                     \\\n        _slConvTypeAndRegParamInfo.name = (nameArg);                                       \\\n        _slConvTypeAndRegParamInfo.dtId = (dtIdArg);                                       \\\n        _slConvTypeAndRegParamInfo.complexity = (compArg);                                 \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_FULL_REG_AND_CNV_RUN_TIME_PARAM, 0,     \\\n                                        (void*)&_slConvTypeAndRegParamInfo)                \\\n            _ssSafelyCallGenericFcnEnd;                                                    \\\n    }\n\n\n\n/*\n * Register dialog parameters indexed as rtpMinIdx and rtpMaxIdx as design\n * minimum and maximum for the run-time parameter of index rtpIdx.\n */\n#define ssRegisterRunTimeParamMinMaxPrmIndices(S, rtpIdx, rtpMinIdx, rtpMaxIdx) \\\n    ssRegisterDataMinMaxPrmIndices((S), SS_DATA_DESC_RTP, (rtpIdx), (rtpMinIdx), (rtpMaxIdx))\n\n\n\n#define ssCreateRunTimeParamFromData(S, _data, _nDataDims, _dataDims, _dataTypeId,             \\\n                                     _dataComplexity, _dataIsConst, _numParams, _paramIndices, \\\n                                     _RTPIndex, _RTPName, _RTPDataTypeId, _RTPComplexity)      \\\n    {                                                                                          \\\n        ssRTPFromDataInfoWithConv _slConvInfoRTPFromData;                                      \\\n        _slConvInfoRTPFromData.data = (_data);                                                 \\\n        _slConvInfoRTPFromData.nDataDims = (_nDataDims);                                       \\\n        _slConvInfoRTPFromData.dataDims = (_dataDims);                                         \\\n        _slConvInfoRTPFromData.dataTypeId = (_dataTypeId);                                     \\\n        _slConvInfoRTPFromData.dataComplexity = (_dataComplexity);                             \\\n        _slConvInfoRTPFromData.dataIsConst = (_dataIsConst);                                   \\\n        _slConvInfoRTPFromData.numParams = (_numParams);                                       \\\n        _slConvInfoRTPFromData.paramIndices = (_paramIndices);                                 \\\n        _slConvInfoRTPFromData.rtpIndex = (_RTPIndex);                                         \\\n        _slConvInfoRTPFromData.rtpName = (_RTPName);                                           \\\n        _slConvInfoRTPFromData.rtpDataTypeId = (_RTPDataTypeId);                               \\\n        _slConvInfoRTPFromData.rtpComplexity = (_RTPComplexity);                               \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_CREATE_RUN_TIME_PARAM_FROM_DATA, 0,         \\\n                                        (void*)&_slConvInfoRTPFromData)                        \\\n            _ssSafelyCallGenericFcnEnd;                                                        \\\n    }\n\n#define ssUpdateRunTimeParamFromData(S, _rtIdxArg, _data, _dataTypeId, _dataComplexity)          \\\n    {                                                                                            \\\n        ssRTPDataInfo _slRTPDataInfo;                                                            \\\n        _slRTPDataInfo.data = (_data);                                                           \\\n        _slRTPDataInfo.dataTypeId = (_dataTypeId);                                               \\\n        _slRTPDataInfo.dataComplexity = (_dataComplexity);                                       \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_UPDATE_RUN_TIME_PARAM_FROM_DATA, (_rtIdxArg), \\\n                                        (void*)&_slRTPDataInfo) _ssSafelyCallGenericFcnEnd;      \\\n    }\n\n\n\n/*\n * Internal use only.\n *\n * Indicate that the given run-time parameter needs to be accessed in\n * the generated code by address. Unaddressable expression\n * will be collapsed. This macro can only be used for run-time parameters that\n * has an one-on-one mapping with a dialog parameter.\n * This macro should only be called at the beginning of mdlStart.\n */\n#define ssSetRunTimeParamAccessedByAddress(S, rtpIdx)                                              \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_RUN_TIME_PARAM_ACCESSED_BY_ADDRESS, (rtpIdx), \\\n                                    NULL) _ssSafelyCallGenericFcnEnd\n\n/* Result is an int * */\n#define _ssIsRunTimeParamTunable(S, rtPIdx, result)                                      \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_IS_RTPARAM_TUNABLE, (rtPIdx), (result)) \\\n        _ssSafelyCallGenericFcnEnd\n\n/* Result is a double * */\n#define _ssGetSFuncBlockHandle(S, result)                                       \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_BLOCK_HANDLE, 0, (result)) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssSetSFInitOutput(S, val)                                                 \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_SF_INIT_OUTPUT, (val), NULL) \\\n        _ssSafelyCallGenericFcnEnd\n\n#endif\n\n#if SS_SIM\n#define ssSetRequiredStackSize(S, val)                                                 \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_REQUIRED_STACK_SIZE, (val), NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssSetRequiredStackSize(S, val) ssSetRequiredStackSize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SL_INTERNAL || SS_RTW_INTERNAL\n#define ssGetRunTimeParamsPtr(S) (S)->sfcnParams.rtp\n#define ssSetRunTimeParamsPtr(S, ptr) (S)->sfcnParams.rtp = (ptr)\n#endif\n\n\n#if SS_SIM\n#define ssComputeOutput(S, pIdx)                                           \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_COMPUTE_OUTPUT, pIdx, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssComputeOutput(S, pIdx) ssComputeOutput_cannot_be_used_in_RTW\n#endif\n\n/* Result is a pointer to boolean_T */\n#if SS_SIM\n#define ssGetDestFCSSEnabled(S, pIdx, result)                                   \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_DEST_FCSS_ENABLED, pIdx, result) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssGetDestFCSSEnabled(S, dataPtr) ssGetDestFCSSEnabled_cannot_be_used_in_RTW\n#endif\n\n#if SS_SFCN\n#define ssSetAsyncTimerAttributes(S, _clockTickStepSize)                                  \\\n    {                                                                                     \\\n        ssTimerInfo _slTimerInfo;                                                         \\\n        _slTimerInfo.clockTickStepSize = (_clockTickStepSize);                            \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ASYNC_TIMER_ATTRIBUTES, 0,         \\\n                                        (void*)&_slTimerInfo) _ssSafelyCallGenericFcnEnd; \\\n    }\n#define ssSetAsyncTimerResolutionEl(S, _clockTickStepSize, el)                            \\\n    {                                                                                     \\\n        ssTimerInfo _slTimerInfo;                                                         \\\n        _slTimerInfo.clockTickStepSize = (_clockTickStepSize);                            \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ASYNC_TIMER_RESOLUTION_EL, el,     \\\n                                        (void*)&_slTimerInfo) _ssSafelyCallGenericFcnEnd; \\\n    }\n\n\n#define ssSetAsyncTimerDataType(S, _clockTickDataType)                                    \\\n    {                                                                                     \\\n        ssTimerInfo _slTimerInfo;                                                         \\\n        _slTimerInfo.clockTickDtype = (_clockTickDataType);                               \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ASYNC_TIMER_DATA_TYPE, 0,          \\\n                                        (void*)&_slTimerInfo) _ssSafelyCallGenericFcnEnd; \\\n    }\n#define ssSetAsyncTimerDataTypeEl(S, _clockTickDataType, el)                              \\\n    {                                                                                     \\\n        ssTimerInfo _slTimerInfo;                                                         \\\n        _slTimerInfo.clockTickDtype = (_clockTickDataType);                               \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ASYNC_TIMER_DATA_TYPE_EL, el,      \\\n                                        (void*)&_slTimerInfo) _ssSafelyCallGenericFcnEnd; \\\n    }\n\n\n#define ssSetTimeSourceEl(S, _timeSource, el)                                                    \\\n    {                                                                                            \\\n        ssTimerInfo _slTimerInfo;                                                                \\\n        _slTimerInfo.timeSource = (_timeSource);                                                 \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_TIME_SOURCE_EL, el, (void*)&_slTimerInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                          \\\n    }\n#endif\n\n#define ssGetElapseTime(S, dataPtr)                                                  \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_ELAPSE_TIME, 0, (double*)dataPtr) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssGetElapseTimeCounter(S, dataPtr)                                                \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_ELAPSE_TIME_COUNTER, 0, (int*)dataPtr) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssGetElapseTimeCounterDtype(S, dataPtr)                                                 \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_ELAPSE_TIME_COUNTER_DTYPE, 0, (int*)dataPtr) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssGetElapseTimeResolution(S, dataPtr)                                                   \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_ELAPSE_TIME_RESOLUTION, 0, (double*)dataPtr) \\\n        _ssSafelyCallGenericFcnEnd\n\n#if SS_SFCN && SS_SIM\n#define ssGetTimeResolution(S, sti, dataPtr)                                               \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_TIME_RESOLUTION, sti, (double*)dataPtr) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssGetTimeResolution(S, sti, dataPtr) ssGetTimeResolution_cannot_be_used_in_RTW\n#endif\n\n#if SS_SFCN\n#define ssSetAsyncTaskPriorities(S, width, str)                                       \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ASYNC_TASK_PRIORITIES, width, str) \\\n        _ssSafelyCallGenericFcnEnd\n#define ssSetAsyncTaskPrioritiesEl(S, _priority, el)                                    \\\n    {                                                                                   \\\n        int priority = _priority;                                                       \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ASYNC_TASK_PRIORITIES_EL, el,    \\\n                                        (void*)&(priority)) _ssSafelyCallGenericFcnEnd; \\\n    }\n#endif\n\n#if SS_SIM\n#define ssSetEnableFcnIsTrivial(S, trivial)                                              \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ENABLE_FCN_IS_TRIVIAL, (trivial), NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssSetEnableFcnIsTrivial(S, trivial) ssSetEnableFcnIsTrivial_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetDisableFcnIsTrivial(S, trivial)                                              \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_DISABLE_FCN_IS_TRIVIAL, (trivial), NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssSetDisableFcnIsTrivial(S, trivial) ssSetDisableFcnIsTrivial_cannot_be_used_in_RTW\n#endif\n\n\n\n/*\n * Set/Get flag that specifies that an S-function's\n * mdlUpdate is empty\n */\n#if (SS_SL_INTERNAL || SS_SFCN_FOR_SIM) && defined(ssGetOwnerBlock)\n#define ssMdlUpdateIsEmpty(S, value)                                                   \\\n    {                                                                                  \\\n        if (ssGetOwnerBlock(S) != NULL) {                                              \\\n            boolean_T val = value;                                                     \\\n            _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_MDL_UPDATE_IS_EMPTY, 0, &val) \\\n                _ssSafelyCallGenericFcnEnd;                                            \\\n        }                                                                              \\\n    }\n#else\n#define ssMdlUpdateIsEmpty(S, value)\n#endif\n\n/*\n * Register a custom message for not supporting multiple instances.\n * Input msg is a pointer to a char array string.\n */\n#if (SS_SL_INTERNAL || SS_SFCN_FOR_SIM)\n#define ssRegisterMsgForNotSupportingMultiExecInst(S, msg)                                        \\\n    {                                                                                             \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_MULTI_INS_NO_SUPPORT_MESSAGE, 0, (void*)msg) \\\n            _ssSafelyCallGenericFcnEnd;                                                           \\\n    }\n#else\n#define ssRegisterMsgForNotSupportingMultiExecInst(S, _msg)\n#endif\n\n/*\n * Set/Get flag that specifies if an S-function supports\n * multiple execution instances\n */\n#if defined(RTW_GENERATED_S_FUNCTION)\n#if SS_SFCN_FOR_SIM && defined(ssGetOwnerBlock)\n#define ssHasStateInsideForEachSS(S, value)                                                    \\\n    {                                                                                          \\\n        if (ssGetOwnerBlock(S) != NULL) {                                                      \\\n            boolean_T val = value;                                                             \\\n            _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_MODELREF_STATE_INSIDE_FOREACH, 0, \\\n                                            &val) _ssSafelyCallGenericFcnEnd;                  \\\n        }                                                                                      \\\n    }\n#else\n#define ssHasStateInsideForEachSS(S, value)\n#endif\n#endif\n\n#if (SS_SL_INTERNAL || SS_SFCN_FOR_SIM)\n#define ssSetWarnForFrameUpgrade(S) ((S)->mdlInfo->mdlFlags.frameUpgradeWarn = 1U)\n#define _ssGetWarnForFrameUpgrade(S) ((S)->mdlInfo->mdlFlags.frameUpgradeWarn == 1U)\n#endif\n\n/*======================================================================*\n * BUS support for S-Functions\n *======================================================================*/\n/*\n * Also, APIS for bus support via bus expansion. In this case,\n * the s-function block is expanded under the hood into an individual\n * s-function for each signal in the bus and then the outputs re-bused\n * to output a bus.\n *\n * Need to set_param(gcb, 'EnableBusSupport', 'on') for the S-Function block\n *\n * 1) ssSetBusPropagationSupported(S, true)\n *    This indicates that bus expansion is desired.\n *\n * 2) ssSetBusSourcePort(S, portNumber)\n *    This indicates that the bus coming into port number (0-based) of the\n *    block will supply the structure of the outgoing bus. This bus is also\n *    used for getting signal names, signal propagation etc. It is the\n *    defining bus for this block.\n *    Example: Say for the switch block, this would be set to 0.\n *\n * 3) ssSetBusInputPorts(S, int number, int* numbers)\n *    This indicates the ports of the blocks that accept buses. The bus\n *    expansion routine then checks to verify that the incoming buses at these\n *    inports are identical in terms of signal names and compiled attributes\n *    for successful expansion.\n *    Example: For the switch block this is [0 2], so \"number\" is set to 2\n *             and \"numbers\" is an array of ints of length 2 with values\n *             numbers[0] = 0; numbers[1] = 2;\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n\n#define ssSetBusPropagationSupported(S, value)                                     \\\n    {                                                                              \\\n        boolean_T tmp = value;                                                     \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BUS_PROPAGATION, 0, &tmp) \\\n            _ssSafelyCallGenericFcnEnd;                                            \\\n    }\n\n#define ssSetBusSourcePort(S, port)                                                \\\n    {                                                                              \\\n        int tmp = port;                                                            \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BUS_SOURCE_PORT, 0, &tmp) \\\n            _ssSafelyCallGenericFcnEnd;                                            \\\n    }\n\n#define ssSetBusInputPorts(S, numInports, value)                                     \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BUS_INPORTS, numInports, value) \\\n        _ssSafelyCallGenericFcnEnd\n\n#else\n\n#define ssSetBusPropagationSupported(S, value) ssSetBusPropagationSupported_cannot_be_used_in_RTW\n\n#define ssSetBusSourcePort(S, value) ssSetBusSourcePort_cannot_be_used_in_RTW\n\n#define ssSetBusInputPorts(S, numInports, value) ssSetBusInputPorts_cannot_be_used_in_RTW\n\n\n\n#endif\n/*\n * APIS for bus support via bus objects. In this case, the s-function outputs\n * a bus as defined by a bus object (which can be a parameter). The output\n * function should implement the bus output consistent with the bus object.\n *\n * Need to set_param(gcb, 'EnableBusSupport', 'on') for the S-Function block\n *\n * 1)  ssSetBusOutputObjectName(S, int_T portNumber, char* busName)\n *     This specifies the bus object that defines the bus coming out of the\n *     s-function block at output number (0-based) of the block.\n *\n * 2)  ssSetBusInputAsStruct(S, int_T portNumber, boolean_T val)\n *     This specifies if the input bus as specified by the bus object should\n *     be converted to non-virtual if necessary. By setting it to true, an auto-\n *     conversion block is inserted behind the scenes to convert a virtual\n *     bus input to a non-virtual bus\n *\n * 3)  ssSetBusOutputAsStruct(S, int_T portNumber, boolean_T val)\n *     This specifies if the output bus as specified by the bus object should\n *     emerge as a structure (non-virtual) or a virtual bus. By setting it to false,\n *     a Signal Conversion block is automatically inserted behind the scenes to\n *     output a virtual bus.\n *\n *     --------------------------------------------------------------------------\n *     The next set of macros can be used to obtain information for a specific element\n *     of a bus object given the data type index of the bus object and the appropriate\n *     bus element index within the bus object. The data type index of the bus object\n *     is the index returned by Simulink when the bus object was registered in\n *     mdlInitializeSizes() (using ssRegisterTypeFromParameter() for example)\n *     --------------------------------------------------------------------------\n *\n * 4)  ssGetNumBusElements(S, int_T busTypeID)\n *     Get the number of bus elements in the specified bus object. The bus data type\n *     is passed in as the second argument.\n *\n * 5)  ssGetBusElementOffset(S, int_T busTypeID, int_T elemIdx)\n *     Obtain the offset in bytes (int_T) from the start of the bus data type to\n *     the specified bus element. The bus data type is passed in as the second\n *     argument and the bus element index (zero based index) is passed in as the\n *     third argument.\n *\n * 6)  ssGetBusElementDataType(S, int_T busTypeID, int_T elemIdx)\n *     Obtain the data type index (int_T) for the specified bus element. The bus data\n *     type is passed in as the second argument and the bus element index (zero based\n *     index) is passed in as the third argument.\n *\n * 7)  ssGetBusElementComplexSignal(S, int_T busTypeID, int_T elemIdx)\n *     Obtain the complexity (CSignal_T) of the specified bus element. The bus\n *     data type is passed in as the second argument and the bus element index (zero\n *     based index) is passed in as the third argument.\n *\n * 8)  ssGetBusElementNumDimensions(S, int_T busTypeID, int_T elemIdx)\n *     Obtain the number of signal dimensions (int_T) for the specified bus element.\n *     The bus data type is passed in as the second argument and the bus element index\n *     (zero based index) is passed in as the third argument.\n *\n * 9)  ssGetBusElementDimensions(S, int_T busTypeID, int_T elemIdx)\n *     Obtain the dimensions (const int_T*) for the specified bus element. Use in combination\n *     with ssGetBusElementNumDimensions() above to iterate over the integer array\n *     returned by this macro. The bus data type is passed in as the second argument\n *     and the bus element index (zero based index) is passed in as the third argument.\n *\n * 10) ssGetBusElementDimensionsMode(S, int_T busTypeID, int_T elemIdx)\n *     Obtain the dimensions mode (DimensionsMode_T) for the specified bus element.\n *     The bus data type is passed in as the second argument and the bus element index\n *     (zero based index) is passed in as the third argument.\n *\n * 11) ssGetBusElementName(S, int_T busTypeId, int_T elemIdx)\n *     Get the name (const char*) of the specified bus element. The bus data type is passed\n *     in as the second argument and the bus element index (zero based index) is\n *     passed in as the third argument.\n *\n * 12) ssIsDataTypeABus(S, int_T typeID)\n *     Determine if the data type ID passed in is a bus signal. An int_T value is\n *     returned (1 for bus, 0 for non-bus, and -1 when error occurs).\n *\n * 13) ssGetBusElementMin(S, int_T busTypeID, int_T elemIdx)\n *     Obtain the minimum (real_T) for the specified bus element.\n *     The bus data type is passed in as the second argument and the bus element index\n *     (zero based index) is passed in as the third argument.\n *\n * 14) ssGetBusElementMax(S, int_T busTypeID, int_T elemIdx)\n *     Obtain the maximum (real_T) for the specified bus element.\n *     The bus data type is passed in as the second argument and the bus element index\n *     (zero based index) is passed in as the third argument.\n */\n\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n/* Use of ssSetBusObjectName is not recommended. Please use ssSetBusOutputObjectName instead. */\n#define ssSetBusObjectName(S, pIdx, name) (ssSetBusOutputObjectName((S), (pIdx), (name)))\n\n#define ssGetBusElementDimensionsMode(S, busTypeID, elemIdx)                                \\\n    (dtaGetDataTypeElementDimensionsMode(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), \\\n                                         (elemIdx)))\n\n#define ssGetBusElementMin(S, busTypeID, elemIdx) \\\n    (dtaGetDataTypeElementMin(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\n\n#define ssGetBusElementMax(S, busTypeID, elemIdx) \\\n    (dtaGetDataTypeElementMax(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\n\n#define ssGetBusElementUnitId(S, busTypeId, elemIdx) \\\n    (dtaGetDataTypeElementUnitId(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\n\n#else\n\n#define ssSetBusObjectName(S, pIdx, name)\n\n#define ssGetBusElementDimensionsMode(S, busTypeID, elemIdx) \\\n    ssGetBusElementDimensionsMode_cannot_be_used_in_RTW\n\n#define ssGetBusElementMin(S, busTypeID, elemIdx) ssGetBusElementMin_cannot_be_used_in_RTW\n\n#define ssGetBusElementMax(S, busTypeID, elemIdx) ssGetBusElementMax_cannot_be_used_in_RTW\n\n#endif\n\n/*\n * NOTE:\n *     The following bus mode related macros are currently not used\n */\ntypedef void (*mdlSetInputPortBusModeFcn)(SimStruct* S, int_T portIdx, BusMode_T dimsMode);\n\n#define ssRegMdlSetInputPortBusModeFcn(S, fcn)                                             \\\n    {                                                                                      \\\n        mdlSetInputPortBusModeFcn _mdlBusModeFcn = fcn;                                    \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REG_SET_INPUT_BUS_MODE_MTH, 0,        \\\n                                        (void*)_mdlBusModeFcn) _ssSafelyCallGenericFcnEnd; \\\n    }\n\n#define ssGetInputPortBusMode(S, pIdx) \\\n    CONV_BITS2BUSMODE((S)->portInfo.inputs[(pIdx)].attributes.busMode)\n\n#define ssGetOutputPortBusMode(S, pIdx) \\\n    CONV_BITS2BUSMODE((S)->portInfo.outputs[(pIdx)].attributes.busMode)\n\n\n\n/* ============================================================================\n * API to specify that output port is discrete valued\n * ============================================================================*/\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n\n#define ssSetOutputPortDiscreteValuedOutput(S, pIdx, value)                                        \\\n    {                                                                                              \\\n        boolean_T tmp = value;                                                                     \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_OUTPUT_PORT_DISCRETE_VALUED_OUTPUT, pIdx, \\\n                                        &tmp) _ssSafelyCallGenericFcnEnd;                          \\\n    }\n\n#else\n#define ssSetOutputPortDiscreteValuedOutput(S, pIdx, value)\n#endif\n\n\n/* ============================================================================\n * API to identify output ports that can serve as IC source.\n * ==========================================================================*/\n\n#if defined(RTW_GENERATED_S_FUNCTION) || SS_SL_INTERNAL || defined(SS_XPC_SFCN) || SS_SFCN\ntypedef struct _ssICAttribs_tag {\n    boolean_T computeInStart;\n    boolean_T computeInFirstInitialize;\n    boolean_T computeInDisable;\n} _ssICAttribs;\n#define ssSetOutputPortICAttributes(S, pIdx, value1, value2, value3)                       \\\n    {                                                                                      \\\n        _ssICAttribs val = {value1, value2, value3};                                       \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_OUTPUT_IC_ATTRIBUTES, pIdx, &val) \\\n            _ssSafelyCallGenericFcnEnd;                                                    \\\n    }\n#endif\n\n/* ============================================================================\n * API to declare model reference block that can be placed inside state enabled\n * subsystem.\n * ==========================================================================*/\n/*\n * Set flag that specifies if an S-function is strictly updating its states in\n * mdlUpdate.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetStatesModifiedOnlyInUpdate(S, value)                                                 \\\n    {                                                                                             \\\n        boolean_T val = value;                                                                    \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_STATES_MODIFIED_ONLY_IN_UPDATE, 0, &val) \\\n            _ssSafelyCallGenericFcnEnd;                                                           \\\n    }\n#else\n#define ssSetStatesModifiedOnlyInUpdate(S, value)\n#endif\n\n/*\n * Set flag that specifies if an S-function is supporting synchronous semantics\n * besides classic semantics\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetStateSemanticsClassicAndSynchronous(S, value)                                         \\\n    {                                                                                              \\\n        boolean_T val = value;                                                                     \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_STATE_EXECUTION_SEMANTICS_SYNCHRONOUS, 0, \\\n                                        &val) _ssSafelyCallGenericFcnEnd;                          \\\n    }\n#else\n#define ssSetStateSemanticsClassicAndSynchronous(S, value)\n#endif\n\n/* ============================================================================\n * Symbolic dimensions APIs\n * ===========================================================================*/\n#if (SS_SL_INTERNAL || SS_SFCN_FOR_SIM)\n\ntypedef struct _ssSymbolicDimStringOp {\n    const char_T* expr;\n    SymbDimsId returnValue;\n} ssSymbolicDimStringOp;\n\ntypedef struct _ssSymbolicDimMATLABExprOp {\n    const char_T* fMATLABExpr;\n    const DimsInfo_T* fDimsInfo;\n    SymbDimsId returnValue;\n} ssSymbolicDimMatlabExprOp;\n\ntypedef struct _ssSymbolicDimNDOp {\n    const SymbDimsId* dims;\n    size_t numDims;\n    SymbDimsId returnValue;\n} ssSymbolicDimNDOp;\n\n/* For SFcnGeneric call to registerSymbolicMExpr  */\n#define MATLABEXPR 1\n\n#endif\n\n#if (SS_SFCN_FOR_SIM)\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#endif\n\n/*\n * This function is used to specify that an S-function does or doesn't support\n * symbolic dimension (default false).\n */\n#if (SS_SFCN_FOR_SIM)\nextern void _ssSetSymbolicDimsSupport(SimStruct* S, const boolean_T val);\n#define ssSetSymbolicDimsSupport(S, _setting) _ssSetSymbolicDimsSupport(S, _setting)\n#else\n#define ssSetSymbolicDimsSupport(S, _setting)\n#endif\n\n/*\n * This function is used to create a symbolic dimensions id (SymbDimsId) from\n * a expression. Notice that the expression string must form a valid syntax\n * in C.\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssRegisterSymbolicDimsExpr(SimStruct* S, const char_T* aExpr);\n#define ssRegisterSymbolicDimsExpr(S, aExpr) _ssRegisterSymbolicDimsExpr(S, aExpr)\n#else\n#define ssRegisterSymbolicDimsExpr(S, aExpr)\n#endif\n\n/*\n *    This function registers a MATLAB expression string (aMATLABExpr) as a\n *    symbolic dimension and returns its symbolic dimensions id.\n *    Notice that aMATLABExpr should form a valid syntax in MATLAB.\n *    The dimensions parameter (aDimsInfo) allow the client to trim tailing ones,\n *    by defining the number of dimension, that should be converted to symbolic\n *    dimensions. The dimension value of aDimsInfo will be used for elements of\n *    aExpr that are not valid symbolic dimensions.\n *    _ssRegisterSymbolicDimsMATLABExpr returns SL_NOSYMBDIMS if all elements\n *    of aExpr are not symbolic expressions.\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssRegisterSymbolicDimsMATLABExpr(SimStruct* S,\n                                                    const char_T* aMATLABExpr,\n                                                    const DimsInfo_T* aDimsInfo);\n#define ssRegisterSymbolicDimsMATLABExpr(S, aMATLABExpr, aDimsInfo) \\\n    _ssRegisterSymbolicDimsMATLABExpr(S, aMATLABExpr, aDimsInfo)\n#else\n#define ssRegisterSymbolicDimsMATLABExpr(S, aMATLABExpr, aDimsInfo)\n#endif\n\n\n/*\n * This function is used to create n-dimensional symbolic dimensions id\n * (SymbDimsId) from a vector of symbolic dimension ids.\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssRegisterSymbolicDims(SimStruct* S,\n                                          const SymbDimsId* aDimsVec,\n                                          const size_t aNumDims);\n#define ssRegisterSymbolicDims(S, aDimsVec, aNumDims) _ssRegisterSymbolicDims(S, aDimsVec, aNumDims)\n#else\n#define ssRegisterSymbolicDims(S, aDimsVec, aNumDims)\n#endif\n\n/*\n * This function is used to create a symbolic dimensions id (SymbDimsId) from\n * a identifier string.\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssRegisterSymbolicDimsString(SimStruct* S, const char_T* aString);\n#define ssRegisterSymbolicDimsString(S, aString) _ssRegisterSymbolicDimsString(S, aString)\n#else\n#define ssRegisterSymbolicDimsString(S, aString)\n#endif\n\n/*\n * This function is used to create a symbolic dimensions id (SymbDimsId) from\n * a integer value.\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssRegisterSymbolicDimsIntValue(SimStruct* S, const int_T aIntValue);\n#define ssRegisterSymbolicDimsIntValue(S, aIntValue) _ssRegisterSymbolicDimsIntValue(S, aIntValue)\n#else\n#define ssRegisterSymbolicDimsIntValue(S, aIntValue)\n#endif\n\n/*\n * This function is used to add equal relation between two symbolic dimensions\n */\n#if (SS_SFCN_FOR_SIM)\nextern void _ssRegisterSymbolicEqualRelation(SimStruct* S,\n                                             const SymbDimsId aLHS,\n                                             const SymbDimsId aRHS);\n#define ssRegisterSymbolicEqualRelation(S, aLHS, aRHS) \\\n    _ssRegisterSymbolicEqualRelation(S, aLHS, aRHS)\n#else\n#define ssRegisterSymbolicEqualRelation(S, aLHS, aRHS)\n#endif\n\n/*\n * This function is used to add equal relation between a symbolic dimension\n * and integer value\n */\n#if (SS_SFCN_FOR_SIM)\nextern void _ssRegisterSymbolicEqualValue(SimStruct* S, const SymbDimsId aLHS, const int_T aValue);\n#define ssRegisterSymbolicEqualValue(S, aLHS, aValue) _ssRegisterSymbolicEqualValue(S, aLHS, aValue)\n#else\n#define ssRegisterSymbolicEqualValue(S, aLHS, aValue)\n#endif\n\n/*\n * Create a new symbolic dimension by merging an existing one\n * and desired dimension, for handling \"leading 1\" issue\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssAmendLeadingSymbolicDims(SimStruct* S,\n                                              const int_T numDims,\n                                              const SymbDimsId aDimsId);\n#define ssAmendLeadingSymbolicDims(S, numDims, aDimsId) \\\n    _ssAmendLeadingSymbolicDims(S, numDims, aDimsId)\n#else\n#define ssAmendLeadingSymbolicDims(S, numDims, aDimsId)\n#endif\n\n/*\n * Create a new symbolic dimension by merging an existing one\n * and desired dimension, for handling \"trailing 1\" issue\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssAmendTrailingSymbolicDims(SimStruct* S,\n                                               const int_T numDims,\n                                               const SymbDimsId aDimsId);\n#define ssAmendTrailingSymbolicDims(S, numDims, aDimsId) \\\n    _ssAmendTrailingSymbolicDims(S, numDims, aDimsId)\n#else\n#define ssAmendTrailingSymbolicDims(S, numDims, aDimsId)\n#endif\n\n/*\n * This function is used to add two symbolic dimensions\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssRegisterSymbolicDimsPlus(SimStruct* S,\n                                              const SymbDimsId aLHS,\n                                              const SymbDimsId aRHS);\n#define ssRegisterSymbolicDimsPlus(S, aLHS, aRHS) _ssRegisterSymbolicDimsPlus(S, aLHS, aRHS)\n#else\n#define ssRegisterSymbolicDimsPlus(S, aLHS, aRHS)\n#endif\n\n/*\n * This function is used to subtract two symbolic dimensions\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssRegisterSymbolicDimsMinus(SimStruct* S,\n                                               const SymbDimsId aLHS,\n                                               const SymbDimsId aRHS);\n#define ssRegisterSymbolicDimsMinus(S, aLHS, aRHS) _ssRegisterSymbolicDimsMinus(S, aLHS, aRHS)\n#else\n#define ssRegisterSymbolicDimsMinus(S, aLHS, aRHS)\n#endif\n\n/*\n * This function is used to multiply two symbolic dimensions\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssRegisterSymbolicDimsMultiply(SimStruct* S,\n                                                  const SymbDimsId aLHS,\n                                                  const SymbDimsId aRHS);\n#define ssRegisterSymbolicDimsMultiply(S, aLHS, aRHS) _ssRegisterSymbolicDimsMultiply(S, aLHS, aRHS)\n#else\n#define ssRegisterSymbolicDimsMultiply(S, aLHS, aRHS)\n#endif\n\n/*\n * This function is used to divide two symbolic dimensions\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssRegisterSymbolicDimsDivide(SimStruct* S,\n                                                const SymbDimsId aLHS,\n                                                const SymbDimsId aRHS);\n#define ssRegisterSymbolicDimsDivide(S, aLHS, aRHS) _ssRegisterSymbolicDimsDivide(S, aLHS, aRHS)\n#else\n#define ssRegisterSymbolicDimsDivide(S, aLHS, aRHS)\n#endif\n\n/*\n * This function returns the number of dimensions for a given symbolic\n * dimensions id (SymbDimsId);\n */\n#if (SS_SFCN_FOR_SIM)\nextern size_t _ssGetNumSymbolicDims(SimStruct* S, const SymbDimsId aSymbDimsId);\n#define ssGetNumSymbolicDims(S, aSymbDimsId) _ssGetNumSymbolicDims(S, aSymbDimsId)\n#else\n#define ssGetNumSymbolicDims(S, aSymbDimsId)\n#endif\n\n/*\n * This function returns the number of dimensions for a given symbolic\n * dimensions id (SymbDimsId);\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssGetSymbolicDim(SimStruct* S,\n                                    const SymbDimsId aSymbDimsId,\n                                    const int_T aDimsIdx);\n#define ssGetSymbolicDim(S, aSymbDimsId, aDimsIdx) _ssGetSymbolicDim(S, aSymbDimsId, aDimsIdx)\n#else\n#define ssGetSymbolicDim(S, aSymbDimsId, aDimsIdx)\n#endif\n\n/*\n * This function sets the pre compiled symbolic dimensions id (SymbDimsId)\n * of a given input port index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern void _ssSetInputPortSymbolicDimsId(SimStruct* S,\n                                          const int_T aPortIdx,\n                                          const SymbDimsId aSymbDimsId);\n#define ssSetInputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId) \\\n    _ssSetInputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId)\n#else\n#define ssSetInputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId)\n#endif\n\n/*\n * This function returns the compiled symbolic dimensions id (SymbDimsId)\n * for given input port index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssGetCompInputPortSymbolicDimsId(SimStruct* S, const int_T aPortIdx);\n#define ssGetCompInputPortSymbolicDimsId(S, aPortIdx) _ssGetCompInputPortSymbolicDimsId(S, aPortIdx)\n#else\n#define ssGetCompInputPortSymbolicDimsId(S, aPortIdx)\n#endif\n\n/*\n * This function sets the compiled symbolic dimensions id (SymbDimsId)\n * of a given input port index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern void _ssSetCompInputPortSymbolicDimsId(SimStruct* S,\n                                              const int_T aPortIdx,\n                                              const SymbDimsId aSymbDimsId);\n#define ssSetCompInputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId) \\\n    _ssSetCompInputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId)\n#else\n#define ssSetCompInputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId)\n#endif\n\n/*\n * This function sets the pre compiled symbolic dimensions id (SymbDimsId)\n * of a given output port index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern void _ssSetOutputPortSymbolicDimsId(SimStruct* S,\n                                           const int_T aPortIdx,\n                                           const SymbDimsId aSymbDimsId);\n#define ssSetOutputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId) \\\n    _ssSetOutputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId)\n#else\n#define ssSetOutputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId)\n#endif\n\n/*\n * This function returns the compiled symbolic dimensions id (SymbDimsId)\n * for a given output port index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssGetCompOutputPortSymbolicDimsId(SimStruct* S, const int_T aPortIdx);\n#define ssGetCompOutputPortSymbolicDimsId(S, aPortIdx) \\\n    _ssGetCompOutputPortSymbolicDimsId(S, aPortIdx)\n#else\n#define ssGetCompOutputPortSymbolicDimsId(S, aPortIdx)\n#endif\n\n/*\n * This function sets the compiled symbolic dimensions id (SymbDimsId) of\n * a given output port index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern void _ssSetCompOutputPortSymbolicDimsId(SimStruct* S,\n                                               const int_T aPortIdx,\n                                               const SymbDimsId aSymbDimsId);\n#define ssSetCompOutputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId) \\\n    _ssSetCompOutputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId)\n#else\n#define ssSetCompOutputPortSymbolicDimsId(S, aPortIdx, aSymbDimsId)\n#endif\n\n/*\n * This function sets the symbolic dimensions id (SymbDimsId)\n * of a given dwork index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssGetDWorkSymbolicDimsId(SimStruct* S, const int_T aDWorkIdx);\n#define ssGetDWorkSymbolicDimsId(S, aDWorkIdx) _ssGetDWorkSymbolicDimsId(S, aDWorkIdx)\n#else\n#define ssGetDWorkSymbolicDimsId(S, aDWorkIdx)\n#endif\n\n/*\n * This function sets the symbolic dimensions id (SymbDimsId)\n * of a given dwork index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern void _ssSetDWorkSymbolicDimsId(SimStruct* S,\n                                      const int_T aDWorkIdx,\n                                      const SymbDimsId aSymbDimsId);\n#define ssSetDWorkSymbolicDimsId(S, aDWorkIdx, aSymbDimsId) \\\n    _ssSetDWorkSymbolicDimsId(S, aDWorkIdx, aSymbDimsId)\n#else\n#define ssSetDWorkSymbolicDimsId(S, aDWorkIdx, aSymbDimsId)\n#endif\n\n/*\n * This function gets the compiled symbolic dimensions id (SymbDimsId)\n * of a given dwork index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern SymbDimsId _ssGetCompDWorkSymbolicDimsId(SimStruct* S, const int_T aDWorkIdx);\n#define ssGetCompDWorkSymbolicDimsId(S, aDWorkIdx) _ssGetCompDWorkSymbolicDimsId(S, aDWorkIdx)\n#else\n#define ssGetCompDWorkSymbolicDimsId(S, aDWorkIdx)\n#endif\n\n/*\n * This function sets the compiled symbolic dimensions id (SymbDimsId)\n * of a given dwork index.\n */\n#if (SS_SFCN_FOR_SIM)\nextern void _ssSetCompDWorkSymbolicDimsId(SimStruct* S,\n                                          const int_T aPortIdx,\n                                          const SymbDimsId aSymbDimsId);\n#define ssSetCompDWorkSymbolicDimsId(S, aDWorkIdx, aSymbDimsId) \\\n    _ssSetCompDWorkSymbolicDimsId(S, aDWorkIdx, aSymbDimsId)\n#else\n#define ssSetCompDWorkSymbolicDimsId(S, aDWorkIdx, aSymbDimsId)\n#endif\n\n#if (SS_SFCN_FOR_SIM)\n#ifdef __cplusplus\n}\n#endif\n#endif\n\n/* ============================================================================\n * Variable dimensions APIs\n * ==========================================================================*/\n\n\n#define ssGetDWorkRequireResetForSignalSize(S, index) \\\n    (SS_VariableSizeStateResetType)((S)->work.dWorkAux[(index)].flags.ensureResetForSizeVary)\n\n\n\ntypedef void (*SetOutputDimsRuleFcn)(SimStruct* S, int outIdx, int ruleIdx);\n\ntypedef struct {\n    int numRules;\n    int* numInpsRule;\n    int* inpIndices;\n    SetOutputDimsRuleFcn setOutputDimsRuleFcn;\n} MdlRefOutDimsInfo_T;\n\ntypedef void (*MdlRefFinalizeDimsFcn)(SimStruct* S);\n\ntypedef struct {\n    MdlRefFinalizeDimsFcn finalizeDimsFcn;\n} MdlRefFinalizeDimsInfo_T;\n\ntypedef struct {\n    int _sysIdx;\n    int _blkIdx;\n    int _outIdx;\n    int _ruleIdx;\n} VarDimsAccelSetDims_T;\n\ntypedef struct {\n    int _sysIdx;\n    int _blkIdx;\n    int _portIdx;\n    int _tid;\n    int _function;\n} ModelBlockFcnCallInput_T;\n\ntypedef struct {\n    const char* name;\n    const uint32_T** elements;\n} DataTypeChecksumInfo_T;\n\n#if SS_SFCN && SS_SIM\n\n#define ssRegMdlRefSetOutputDimsMethods(S, outIdx, ruleInfo)                                       \\\n    {                                                                                              \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REG_MODELREF_SET_DIMS_DEPEND_RULES, (outIdx), \\\n                                        (ruleInfo)) _ssSafelyCallGenericFcnEnd;                    \\\n    }\n\n#define ssRegMdlRefFinalizeDimsMethod(S, finalizeDimsFcnPtr)                                   \\\n    {                                                                                          \\\n        MdlRefFinalizeDimsInfo_T info;                                                         \\\n        info.finalizeDimsFcn = finalizeDimsFcnPtr;                                             \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REG_MODELREF_FINALIZE_DIMS_MTH, 0, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                                        \\\n    }\n\n\n#define ssCallAccelSetDims(S, sysIdx, blkIdx, outIdx, ruleIdx)                                  \\\n    {                                                                                           \\\n        VarDimsAccelSetDims_T accelSetDimsInfo;                                                 \\\n        accelSetDimsInfo._sysIdx = sysIdx;                                                      \\\n        accelSetDimsInfo._blkIdx = blkIdx;                                                      \\\n        accelSetDimsInfo._outIdx = outIdx;                                                      \\\n        accelSetDimsInfo._ruleIdx = ruleIdx;                                                    \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ACCEL_CALL_SET_DIMS, 0, &accelSetDimsInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                         \\\n    }\n\n\n#define ssCallAccelModelBlockFcnCallInput(S, sysIdx, blkIdx, portIdx, tid, function)             \\\n    {                                                                                            \\\n        ModelBlockFcnCallInput_T accelModelBlockFcnCallInfo;                                     \\\n        accelModelBlockFcnCallInfo._sysIdx = sysIdx;                                             \\\n        accelModelBlockFcnCallInfo._blkIdx = blkIdx;                                             \\\n        accelModelBlockFcnCallInfo._portIdx = portIdx;                                           \\\n        accelModelBlockFcnCallInfo._tid = tid;                                                   \\\n        accelModelBlockFcnCallInfo._function = function;                                         \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ACCEL_CALL_MODEL_FCNCALL_INPUT, 0,          \\\n                                        &accelModelBlockFcnCallInfo) _ssSafelyCallGenericFcnEnd; \\\n    }\n\n#define ssCallAccelCopyCacheForIISBasedOnDescSysList(S, sysIdx, fromCache)                   \\\n    {                                                                                        \\\n        _ssSafelyCallGenericFcnStart(S)(                                                     \\\n            (S), GEN_FCN_ACCEL_COPY_STATE_CACHE_FOR_IIS_IN_DESC_SYS_LIST, sysIdx, fromCache) \\\n            _ssSafelyCallGenericFcnEnd;                                                      \\\n    }\n\n#define ssCallAccelCopyCacheForIISBasedOnCGSysList(S, sysIdx, fromCache)                   \\\n    {                                                                                      \\\n        _ssSafelyCallGenericFcnStart(S)(                                                   \\\n            (S), GEN_FCN_ACCEL_COPY_STATE_CACHE_FOR_IIS_IN_CG_SYS_LIST, sysIdx, fromCache) \\\n            _ssSafelyCallGenericFcnEnd;                                                    \\\n    }\n\n#define ssCallGetDataTypeChecksum(S, dtName, els)                                           \\\n    {                                                                                       \\\n        DataTypeChecksumInfo_T chksumInfo;                                                  \\\n        chksumInfo.name = dtName;                                                           \\\n        chksumInfo.elements = els;                                                          \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_DATATYPE_CHECKSUM, 0, &chksumInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                     \\\n    }\n\n#define ssCheckStructParamChecksum(S, index, chksum)                                      \\\n    {                                                                                     \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_CHECK_STRUCTPARAM_CHECKSUM, (index), \\\n                                        (chksum)) _ssSafelyCallGenericFcnEnd;             \\\n    }\n\n#define ssCallSetRegCodeVariantFcnCall(S, numParams, paramIdxs)                           \\\n    {                                                                                     \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REG_CODE_VARIANT_FCNCALL, numParams, \\\n                                        paramIdxs) _ssSafelyCallGenericFcnEnd;            \\\n    }\n\n#define ssCallSetRegAutosarClientBlock(S, isClientBlock)                                      \\\n    {                                                                                         \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REG_AUTOSAR_CLIENT_BLOCK, isClientBlock, \\\n                                        NULL) _ssSafelyCallGenericFcnEnd;                     \\\n    }\n\n#define ssCallGetNumVariantConditions(S, conditionIndex, result)                                 \\\n    {                                                                                            \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_NUM_VARIANT_CONDITIONS, conditionIndex, \\\n                                        result) _ssSafelyCallGenericFcnEnd;                      \\\n    }\n\n#define ssCallGetEvalCodeVariantFcnCall(S, numParams, paramIdxs)                           \\\n    {                                                                                      \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_EVAL_CODE_VARIANT_FCNCALL, numParams, \\\n                                        paramIdxs) _ssSafelyCallGenericFcnEnd;             \\\n    }\n\n#endif\n\n#define _ssGetBlkInfo2STInfo2Ptr(S) (S)->blkInfo.blkInfo2->stInfo2\n\n#define _ssSetBlkInfo2STInfo2Ptr(S, ptr) (S)->blkInfo.blkInfo2->stInfo2 = (ptr)\n\n#define _ssGetBlkInfo2PortInfo2Ptr(S) (S)->blkInfo.blkInfo2->portInfo2\n\n#define _ssSetBlkInfo2PortInfo2Ptr(S, ptr) (S)->blkInfo.blkInfo2->portInfo2 = (ptr)\n\n#define _ssSetPortInfo2ForInputs(S, ptr) (S)->blkInfo.blkInfo2->portInfo2->inputs = (ptr)\n\n#define _ssGetPortInfo2ForInputs(S) (S)->blkInfo.blkInfo2->portInfo2->inputs\n\n#define _ssSetPortInfo2ForOutputs(S, ptr) (S)->blkInfo.blkInfo2->portInfo2->outputs = (ptr)\n\n#define _ssGetPortInfo2ForOutputs(S) (S)->blkInfo.blkInfo2->portInfo2->outputs\n\n#define _ssSetPortInfo2ForInputUnits(S, ptr) (S)->blkInfo.blkInfo2->portInfo2->inputUnits = (ptr)\n\n#define _ssGetPortInfo2ForInputUnits(S) (S)->blkInfo.blkInfo2->portInfo2->inputUnits\n\n#define _ssSetPortInfo2ForOutputUnits(S, ptr) (S)->blkInfo.blkInfo2->portInfo2->outputUnits = (ptr)\n\n#define _ssGetPortInfo2ForOutputUnits(S) (S)->blkInfo.blkInfo2->portInfo2->outputUnits\n\n#define _ssSetPortInfo2ForInputDimsConstraint(S, ptr) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputDimsConstraint = (ptr)\n\n#define _ssGetPortInfo2ForInputDimsConstraint(S) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputDimsConstraint\n\n#define _ssSetPortInfo2ForOutputDimsConstraint(S, ptr) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputDimsConstraint = (ptr)\n\n#define _ssGetPortInfo2ForOutputDimsConstraint(S) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputDimsConstraint\n\n#define _ssSetPortInfo2ForInputCoSimAttribute(S, ptr) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputCoSimAttribute = (ptr)\n\n#define _ssSetPortInfo2ForOutputCoSimAttribute(S, ptr) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputCoSimAttribute = (ptr)\n\n#define _ssGetPortInfo2ForInputCoSimAttribute(S) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputCoSimAttribute\n\n#define _ssGetPortInfo2ForOutputCoSimAttribute(S) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputCoSimAttribute\n\n#if defined(USE_64BIT_FIELDS)\n#define _ssSetInputPortVariableDimsPtr(S, pIdx, uDims) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(pIdx)].portVarDims = (uDims)\n#elif defined(USE_32BIT_FIELDS)\n#define _ssSetInputPortVariableDimsPtr(S, pIdx, uDims) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputs[(pIdx)].portVarDims = (uDims)\n#elif defined(USE_32BIT_AND_64BIT_FIELDS)\n#define _ssSetInputPortVariableDimsPtr(S, pIdx, uDims) \\\n    (S)->blkInfo.blkInfo2->portInfo2->inputs[(pIdx)].portVarDims = (uDims)\n#define _ssSetInputPortVariableDimsPtrSLSize(S, pIdx, uDims) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(pIdx)].portVarDims = (uDims)\n#endif\n\n#if defined(USE_64BIT_FIELDS)\n#define _ssSetOutputPortVariableDimsPtr(S, pIdx, yDims) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(pIdx)].portVarDims = (yDims)\n#elif defined(USE_32BIT_FIELDS)\n#define _ssSetOutputPortVariableDimsPtr(S, pIdx, yDims) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputs[(pIdx)].portVarDims = (yDims)\n#elif defined(USE_32BIT_AND_64BIT_FIELDS)\n#define _ssSetOutputPortVariableDimsPtr(S, pIdx, yDims) \\\n    (S)->blkInfo.blkInfo2->portInfo2->outputs[(pIdx)].portVarDims = (yDims)\n#define _ssSetOutputPortVariableDimsPtrSLSize(S, pIdx, yDims) \\\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(pIdx)].portVarDims = (yDims)\n#endif\n\n#if !SS_SFCN\n\n#define _ssSetBlockIOVarDims(S, ptr) (S)->mdlInfo->blockIOVarDims = (ptr)\n\n#define _ssGetBlockIOVarDims(S) (S)->mdlInfo->blockIOVarDims\n#endif\n\n\n/*============================================================================*/\n\n/*\n * Data Store API\n *\n * This API is for internal MathWorks use only and is not intended for use\n * by user written S-functions. Accessing Data Stores is not\n * yet supported for user written S-functions. This API WILL change in\n * a future release.\n */\n\n#if SS_SFCN && SS_SIM\n#define ssSetNumDataStores(S, numDataStores)                                                     \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REGISTER_NUM_DATA_STORE, (numDataStores), NULL) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\n\ntypedef enum { SS_READER_ONLY, SS_WRITER_ONLY, SS_READER_AND_WRITER } SS_ReaderOrWriter;\n\ntypedef struct {\n    const char* name;\n    SS_ReaderOrWriter readerOrWriter;\n    boolean_T elementAccess;\n    boolean_T expectGlobal;\n    boolean_T* success;\n} SFcnDataStoreNameInfo;\n\n#if SS_SFCN && SS_SIM\n#define ssRegisterGlobalDataStoreFromName(S, dsmIdx, dsmName, dsmReadOrWrite, dsmElemAccess, \\\n                                          dsmSuccess)                                        \\\n    {                                                                                        \\\n        SFcnDataStoreNameInfo locPI;                                                         \\\n        locPI.name = dsmName;                                                                \\\n        locPI.readerOrWriter = dsmReadOrWrite;                                               \\\n        locPI.elementAccess = dsmElemAccess;                                                 \\\n        locPI.expectGlobal = true;                                                           \\\n        locPI.success = dsmSuccess;                                                          \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REGISTER_DATA_STORE_FROM_NAME, dsmIdx,  \\\n                                        &locPI) _ssSafelyCallGenericFcnEnd;                  \\\n    }\n#endif\n\n#if SS_SFCN && SS_SIM\n#define ssRegisterDataStoreFromName(S, dsmIdx, dsmName, dsmReadOrWrite, dsmElemAccess, dsmSuccess) \\\n    {                                                                                              \\\n        SFcnDataStoreNameInfo locPI;                                                               \\\n        locPI.name = dsmName;                                                                      \\\n        locPI.readerOrWriter = dsmReadOrWrite;                                                     \\\n        locPI.elementAccess = dsmElemAccess;                                                       \\\n        locPI.expectGlobal = false;                                                                \\\n        locPI.success = dsmSuccess;                                                                \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REGISTER_DATA_STORE_FROM_NAME, dsmIdx,        \\\n                                        &locPI) _ssSafelyCallGenericFcnEnd;                        \\\n    }\n#endif\n\n/* The dsmInfo in ssGetDataStoreInfo is of type SFcnDataStoreInfo */\ntypedef struct {\n    double sample_time;\n    double offset_time;\n    int dataTypeId;\n    int numDims;\n    int* dims;\n    int complex;\n} SFcnDataStoreInfo;\n#if SS_SFCN && SS_SIM\n#define ssGetDataStoreInfo(S, dsmIdx, dsmInfo)                                         \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_DATA_STORE_INFO, dsmIdx, dsmInfo) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\ntypedef struct {\n    const char* bpath;\n    void* addr;\n} SFcnDataStoreBPathAddr;\n/* Structure for passing data store info into Simulink */\n\n#if SS_SFCN && SS_SIM\n/* Note that the dsmBPath must be persistent and constant\n * i.e. inside Simulink the pointer is cached, we do not make a deep copy\n */\n#define ssReadFromDataStoreWithPath(S, dsmIdx, dsmBPath, dataAddr)                         \\\n    {                                                                                      \\\n        SFcnDataStoreBPathAddr locPI;                                                      \\\n        locPI.bpath = dsmBPath;                                                            \\\n        locPI.addr = dataAddr;                                                             \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_READ_FROM_DATA_STORE, dsmIdx, &locPI) \\\n            _ssSafelyCallGenericFcnEnd;                                                    \\\n    }\n#define ssReadFromDataStore(S, dsmIdx, dataAddr) \\\n    ssReadFromDataStoreWithPath(S, dsmIdx, NULL, dataAddr)\n#endif\n\ntypedef struct {\n    const char* bpath;\n    const void* addr;\n} SFcnDataStoreBPathConstAddr;\n\n#if SS_SFCN && SS_SIM\n/* Note that the dsmBPath must be persistent and constant\n * i.e. inside Simulink the pointer is cached, we do not make a deep copy\n */\n#define ssWriteToDataStoreWithPath(S, dsmIdx, dsmBPath, dataAddr)                         \\\n    {                                                                                     \\\n        SFcnDataStoreBPathConstAddr locPI;                                                \\\n        locPI.bpath = dsmBPath;                                                           \\\n        locPI.addr = dataAddr;                                                            \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_WRITE_TO_DATA_STORE, dsmIdx, &locPI) \\\n            _ssSafelyCallGenericFcnEnd;                                                   \\\n    }\n#define ssWriteToDataStore(S, dsmIdx, dataAddr) \\\n    ssWriteToDataStoreWithPath(S, dsmIdx, NULL, dataAddr)\n#endif\n\n\n#if SS_SFCN && SS_SIM\n\n/* Update Data Store Memory logs after writing data.\n */\n#define ssUpdateDataStoreLog(S, dsmIdx)                                                   \\\n    {                                                                                     \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_DATA_STORE_LOG_UPDATE, dsmIdx, NULL) \\\n            _ssSafelyCallGenericFcnEnd;                                                   \\\n    }\n\n#endif\n\n/* Remember: storage is column major order if accessing element of a matrix */\ntypedef struct {\n    const char* bpath;\n    void* addr;\n    int elem;\n} SFcnDataStoreBPathAddrElem;\n\n#if SS_SFCN && SS_SIM\n/* Note that the dsmBPath must be persistent and constant\n * i.e. inside Simulink the pointer is cached, we do not make a deep copy\n */\n#define ssReadFromDataStoreElementWithPath(S, dsmIdx, dsmBPath, dataAddr, dsmElem)              \\\n    {                                                                                           \\\n        SFcnDataStoreBPathAddrElem locPI;                                                       \\\n        locPI.bpath = dsmBPath;                                                                 \\\n        locPI.addr = dataAddr;                                                                  \\\n        locPI.elem = dsmElem;                                                                   \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_READ_FROM_DATA_STORE_ELEM, dsmIdx, &locPI) \\\n            _ssSafelyCallGenericFcnEnd;                                                         \\\n    }\n#define ssReadFromDataStoreElement(S, dsmIdx, dataAddr, dsmElem) \\\n    ssReadFromDataStoreElementWithPath(S, dsmIdx, NULL, dataAddr, dsmElem)\n#endif\n\ntypedef struct {\n    const char* bpath;\n    const void* addr;\n    int elem;\n} SFcnDataStoreBPathConstAddrElem;\n\n#if SS_SFCN && SS_SIM\n/* Note that the dsmBPath must be persistent and constant\n * i.e. inside Simulink the pointer is cached, we do not make a deep copy\n */\n#define ssWriteToDataStoreElementWithPath(S, dsmIdx, dsmBPath, dataAddr, dsmElem)              \\\n    {                                                                                          \\\n        SFcnDataStoreBPathConstAddrElem locPI;                                                 \\\n        locPI.bpath = dsmBPath;                                                                \\\n        locPI.addr = dataAddr;                                                                 \\\n        locPI.elem = dsmElem;                                                                  \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_WRITE_TO_DATA_STORE_ELEM, dsmIdx, &locPI) \\\n            _ssSafelyCallGenericFcnEnd;                                                        \\\n    }\n#define ssWriteToDataStoreElement(S, dsmIdx, dataAddr, dsmElem) \\\n    ssWriteToDataStoreElementWithPath(S, dsmIdx, NULL, dataAddr, dsmElem)\n#endif\n\n\ntypedef struct {\n    const char* name;\n    char* dataTypeName;\n    boolean_T expectGlobal;\n    const char* sharedLocalDSMInfo;\n    int* idx;\n    void** addr;\n} SFcnDataStoreNameAddrIdx;\n\n#if SS_SFCN && SS_SIM\n#define ssGetSFcnDataStoreNameAddrIdx(S, dsmName, dsmAddr, dsmIdx)                   \\\n    {                                                                                \\\n        SFcnDataStoreNameAddrIdx locPI;                                              \\\n        locPI.name = dsmName;                                                        \\\n        locPI.dataTypeName = NULL;                                                   \\\n        locPI.expectGlobal = false;                                                  \\\n        locPI.sharedLocalDSMInfo = \"\";                                               \\\n        locPI.idx = dsmIdx;                                                          \\\n        locPI.addr = dsmAddr;                                                        \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_DATA_STORE_ADDR, 0, &locPI) \\\n            _ssSafelyCallGenericFcnEnd;                                              \\\n    }\n#endif\n\n#if SS_SFCN && SS_SIM\n#define ssGetSFcnGlobalDataStoreNameAddrIdx(S, dsmName, dsmDTName, dsmAddr, dsmIdx, dsmInfo) \\\n    {                                                                                        \\\n        SFcnDataStoreNameAddrIdx locPI;                                                      \\\n        locPI.name = dsmName;                                                                \\\n        locPI.dataTypeName = dsmDTName;                                                      \\\n        locPI.expectGlobal = true;                                                           \\\n        locPI.sharedLocalDSMInfo = dsmInfo;                                                  \\\n        locPI.idx = dsmIdx;                                                                  \\\n        locPI.addr = dsmAddr;                                                                \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_DATA_STORE_ADDR, 0, &locPI)         \\\n            _ssSafelyCallGenericFcnEnd;                                                      \\\n    }\n#endif\n\n/* Region-wise memory access API */\ntypedef enum {\n    MEM_REGION_SELECT_ALL = 0,\n    MEM_REGION_STARTIDX_INCR_ENDIDX,\n    MEM_REGION_VECTOR,\n    MEM_REGION_VECTOR_FLATIDX,\n    MEM_REGION_DYNAMIC_IDX\n} SFcnMemRegionIndexMode_T;\n\ntypedef struct {\n    SFcnMemRegionIndexMode_T indexMode;\n    int numIndices;\n    int* indices;\n} SFcnSubMemRegionIndexInfo;\n\ntypedef struct {\n    int busElementIdx;\n    int numDims;\n    SFcnSubMemRegionIndexInfo* subMemRegionIndexInfos;\n} SFcnSubMemRegionInfo;\n\ntypedef struct {\n    int numSubMemRegions;\n    SFcnSubMemRegionInfo* subMemRegionInfos;\n    /* Following fields for Simulink use only */\n    boolean_T cacheSlMemRootRegion;\n    void* slMemRootRegion;\n    char* memRegionExpr;\n    boolean_T reserved;\n} SFcnMemRegionInfo;\n\ntypedef struct {\n    const char* bpath;\n    void* addr;\n    SFcnMemRegionInfo* regionDescriptor;\n} SFcnDataStoreMemRegionArg;\n\ntypedef struct {\n    const char* bpath;\n    const void* addr;\n    SFcnMemRegionInfo* regionDescriptor;\n} SFcnDataStoreMemRegionConstArg;\n\ntypedef struct {\n    int busElemIdx;\n    int numFlatElems;\n    int* flatElemIndices;\n    SFcnMemRegionInfo* regionDescriptor;\n} SFcnDataStoreFlatSubMemRegionArg;\n\ntypedef struct {\n    const char* bpath;\n    int startOffset;\n    int endOffset;\n    boolean_T doRead; /* true: updates diagnostics for read operations,\n                         false: updates diagnostics for write operations */\n} SFcnDataStoreUpdateMemRegionArg;\n\n/* APIs to create/destroy region descriptors */\n#if SS_SFCN && SS_SIM\n#define ssMemRegionCreateDescriptor(S, numSubMemRegions, memRegionDescriptor)                   \\\n    {                                                                                           \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_CREATE_MEM_REGION_DESC, numSubMemRegions,  \\\n                                        (void*)memRegionDescriptor) _ssSafelyCallGenericFcnEnd; \\\n    }\n\n#define ssMemRegionSetFlatSubElement(S, memRegionDescriptor, subRegionIdx, busElementIdx,        \\\n                                     numFlatIdx, flatIdxs)                                       \\\n    {                                                                                            \\\n        SFcnDataStoreFlatSubMemRegionArg locPI;                                                  \\\n        locPI.regionDescriptor = memRegionDescriptor;                                            \\\n        locPI.busElemIdx = busElementIdx;                                                        \\\n        locPI.numFlatElems = numFlatIdx;                                                         \\\n        locPI.flatElemIndices = flatIdxs;                                                        \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_FLAT_MEM_SUB_REGION_DESC, subRegionIdx, \\\n                                        &locPI) _ssSafelyCallGenericFcnEnd;                      \\\n    }\n\n#define ssMemRegionDestroyDescriptor(S, memRegionDescriptor)                                    \\\n    {                                                                                           \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_DESTROY_MEM_REGION_DESC, 0,                \\\n                                        (void*)memRegionDescriptor) _ssSafelyCallGenericFcnEnd; \\\n    }\n#endif\n\n/* APIs to perform region-wise read/write */\n#if SS_SFCN && SS_SIM\n#define ssReadFromDataStoreRegionWithPath(S, dsmIdx, dsmBPath, dataAddr, dsmRegionDescriptor)     \\\n    {                                                                                             \\\n        SFcnDataStoreMemRegionArg locPI;                                                          \\\n        locPI.bpath = dsmBPath;                                                                   \\\n        locPI.addr = dataAddr;                                                                    \\\n        locPI.regionDescriptor = dsmRegionDescriptor;                                             \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_READ_FROM_DATA_STORE_REGION, dsmIdx, &locPI) \\\n            _ssSafelyCallGenericFcnEnd;                                                           \\\n    }\n#define ssReadFromDataStoreRegion(S, dsmIdx, dataAddr, dsmRegionDescriptor) \\\n    ssReadFromDataStoreRegionWithPath(S, dsmIdx, NULL, dataAddr, dsmRegionDescriptor)\n#endif\n\n#if SS_SFCN && SS_SIM\n#define ssWriteToDataStoreRegionWithPath(S, dsmIdx, dsmBPath, dataAddr, dsmRegionDescriptor)     \\\n    {                                                                                            \\\n        SFcnDataStoreMemRegionConstArg locPI;                                                    \\\n        locPI.bpath = dsmBPath;                                                                  \\\n        locPI.addr = dataAddr;                                                                   \\\n        locPI.regionDescriptor = dsmRegionDescriptor;                                            \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_WRITE_TO_DATA_STORE_REGION, dsmIdx, &locPI) \\\n            _ssSafelyCallGenericFcnEnd;                                                          \\\n    }\n#define ssWriteToDataStoreRegion(S, dsmIdx, dataAddr, dsmRegionDescriptor) \\\n    ssWriteToDataStoreRegionWithPath(S, dsmIdx, NULL, dataAddr, dsmRegionDescriptor)\n#endif\n\n/* API to notify Simulink of region-wise read/write */\n#if SS_SFCN && SS_SIM\n#define ssUpdateDataStoreRegionDiagnostics(S, dsmIdx, dsmBPath, startOffset, endOffset, doRead) \\\n    {                                                                                           \\\n        SFcnDataStoreUpdateMemRegionArg locPI;                                                  \\\n        locPI.bpath = dsmBPath;                                                                 \\\n        locPI.startOffset = startOffset;                                                        \\\n        locPI.endOffset = endOffset;                                                            \\\n        locPI.doRead = doRead;                                                                  \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_UPDATE_DATA_STORE_DIAGNOSTICS, dsmIdx,     \\\n                                        &locPI) _ssSafelyCallGenericFcnEnd;                     \\\n    }\n#endif\n\n/* API to detect if read/write diagnostics are ON on a given data store memory */\n#if SS_SFCN && SS_SIM\n#define ssGetDataStoreRWDiagnosticsStatus(S, dsmIdx, dsmDiagStatus)                             \\\n    {                                                                                           \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_DATA_STORE_DIAGNOSTICS_STATUS, dsmIdx, \\\n                                        dsmDiagStatus) _ssSafelyCallGenericFcnEnd;              \\\n    }\n#endif\n\n/* end  Data Store API (internal Simulink use only) */\n/*============================================================================*/\n\n#if SS_SFCN && SS_SIM\n#define ssGetRegSubmodelsMdlinfo(S, result)                                                \\\n    {                                                                                      \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_REG_SUBMODELS_MDLINFO, 0, result) \\\n            _ssSafelyCallGenericFcnEnd;                                                    \\\n    }\n#endif\n\n\n/* ================================================================= */\n\ntypedef enum { MDLREF_UNKNOWN = 0, MDLREF_ACCEL_SIM, MDLREF_NORMAL_SIM, MDLREF_RTW } ssMdlRefType;\n\n#if SS_SFCN && SS_SIM\n#ifdef ssGetOwnerBlock\n#define ssGetModelReferenceType(S, val)                                         \\\n    {                                                                           \\\n        *(val) = MDLREF_UNKNOWN;                                                \\\n        if (!((ssGetOwnerBlock(S) == NULL) && (ssGetParentSS(S) != NULL))) {    \\\n            _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_MDLREF_TYPE, 0, val) \\\n                _ssSafelyCallGenericFcnEnd;                                     \\\n        }                                                                       \\\n    }\n#endif\n#else\n#define ssGetModelReferenceType(S, val) ssGetModelReferenceType_cannot_be_used_in_RTW\n#endif\n\n\n/* =======================================\n * Model reference definitions and macros.\n * =======================================*/\n\n/* Structure for mdl info from reference models */\ntypedef struct {\n    const char* id;          /* identifier associated with info */\n    MdlInfoType infoType;    /* info type                       */\n    boolean_T extra_bool;    /* boolean value for arbitrary use */\n    int_T extra_int;         /* int value for arbitrary use     */\n    const void* extra_voidp; /* pointer for arbitrary use       */\n} RegMdlInfo;\n\n/* Structure for set of mdl info from reference models */\ntypedef struct {\n    char* modelName;       /* model name                      */\n    RegMdlInfo* modelInfo; /* info                            */\n    int numModelInfo;      /* number of records               */\n} ModelRefMdlInfoSet;\n\n/* Structure for referenced models info. mrBlk  is NULL when this structure\n * is registered by model reference accelerated target.\n */\ntypedef struct {\n    char* name;\n    char* path;\n    boolean_T isSingleInst;\n} MdlRefChildMdlRec;\n\n/* Only used in MODELREF S-functions */\ntypedef enum {\n    SS_OK_TO_MERGE_AUTO = 0, /* default */\n    SS_OK_TO_MERGE,\n    SS_NOT_OK_TO_MERGE,\n    SS_OK_TO_MERGE_CONDITIONAL\n} ssOkToMergeFlag;\n\n#define ssGetOutputPortOkToMerge(S, port) \\\n    ((ssOkToMergeFlag)((S)->portInfo.outputs[(port)].attributes.okToMerge))\n\n#if !SS_SFCN_LEVEL_1\n#if SS_SIM\n#define _ssMdlInfoInit(name, infoTypeUsed, b, i, vp) \\\n    RegMdlInfo locPI;                                \\\n    locPI.id = name;                                 \\\n    locPI.infoType = infoTypeUsed;                   \\\n    locPI.extra_bool = b;                            \\\n    locPI.extra_int = i;                             \\\n    locPI.extra_voidp = vp;\n\n#define ssRegMdlInfo(S, id, infoType, b, i, vp)                                            \\\n    {                                                                                      \\\n        _ssMdlInfoInit(id, infoType, b, i, vp) if (!_ssSafelyCallGenericFcnStart(S)(       \\\n                                                       S, GEN_FCN_REG_MDL_INFO, 0, &locPI) \\\n                                                       _ssSafelyCallGenericFcnEnd) return; \\\n    }\n#else\n#define ssRegMdlInfo(S, id, infoType, b, i, vp)\n#endif\n#endif\n\ntypedef enum {\n    SS_MDLREF_FUND_SAMPLETYPE_INFO_STR = 0,\n    SS_MDLREF_FUND_SAMPLETYPE_INFO_VAL\n} _ssMdlRefFundamentalSampleTimeInfoType;\n\n\n#if SS_SFCN && SS_SIM\n\n#define ssSetOutputPortOkToMerge(S, port, val) \\\n    (S)->portInfo.outputs[(port)].attributes.okToMerge = (ssOkToMergeFlag)(val)\n\n#define ssRegMdlRefDWorkType(S, type)                                          \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REG_MDLREF_DWORK_TYPE, 0, type) \\\n        _ssSafelyCallGenericFcnEnd\n\n\n/* Names of the ToFile's for a submodel*/\n#define ssSetModelRefToFiles(S, num, str)                                       \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_MODELREF_TO_FILES, num, str) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssFileLoggingManagerAddElement(S, ptr)                                           \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_FILE_LOGGING_MANAGER_ADD_ELEMENT, 0, ptr) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssFileLoggingManagerRemoveElement(S, ptr)                                           \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_FILE_LOGGING_MANAGER_REMOVE_ELEMENT, 0, ptr) \\\n        _ssSafelyCallGenericFcnEnd\n\n/* Names of the FromFile's for a submodel*/\n#define ssSetModelRefFromFiles(S, num, str)                                       \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_MODELREF_FROM_FILES, num, str) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssSetModelMappingInfoPtr(S, ptr)                                     \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_MODELMAPPINGINFO, 0, ptr) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define _ssMdlInfoSetInit(name, info, num) \\\n    ModelRefMdlInfoSet locPI;              \\\n    locPI.modelName = (name);              \\\n    locPI.modelInfo = (info);              \\\n    locPI.numModelInfo = (num);\n\n#define ssRegModelRefMdlInfo(S, name, info, num)                                              \\\n    {                                                                                         \\\n        _ssMdlInfoSetInit((name), (info), (num)) if (!_ssSafelyCallGenericFcnStart(S)(        \\\n                                                         S, GEN_FCN_REG_MODELREF_MDL_INFO, 0, \\\n                                                         &locPI)                              \\\n                                                         _ssSafelyCallGenericFcnEnd) return;  \\\n    }\n\n#define ssGetModelRefModelArgData(S, pIdx, dataPtr)                                         \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_MODELREF_INTFPARAM_MODEL_ARG_DATA, pIdx, \\\n                                    (void*)dataPtr) _ssSafelyCallGenericFcnEnd\n\n#define ssGetModelRefBlockArgData(S, pIdx, dataPtr)                                         \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_MODELREF_INTFPARAM_BLOCK_ARG_DATA, pIdx, \\\n                                    (void*)dataPtr) _ssSafelyCallGenericFcnEnd\n\n#define ssGetModelRefGlobalParamData(S, pIdx, dataPtr)                                   \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_MODELREF_INTFPARAM_GLOBAL_DATA, pIdx, \\\n                                    (void*)dataPtr) _ssSafelyCallGenericFcnEnd\n\n#endif\n\n#define ssGetModelReferenceSampleTimeInheritanceRule(S) (S)->sizes.flags.modelRefTsInhSupLevel\n\n\n\n#define ssGetSimStateCompliance(S) ((ssSimStateCompliance)((S)->sizes.flags.simStateCompliance))\n\n#define ssGetOperatingPointCompliance(S) \\\n    ((ssOperatingPointCompliance)((S)->sizes.flags.simStateCompliance))\n\n#define ssGetSimStateVisibility(S) ((S)->sizes.flags.simStateVisibility)\n\n#define ssSetSimStateCompliance(S, set) (S)->sizes.flags.simStateCompliance = (set)\n\n#define ssSetSimStateVisibility(S, vis) (S)->sizes.flags.simStateVisibility = (vis)\n\n/*-------------------------------- S->states --------------------------------*/\n\n/* U - This is the input to your S-function providing you have not specified\n *   the SS_OPTION_USING_ssGetUPtrs. For the root SimStruct this\n *   is the external input vector.\n */\n#if SS_SFCN_LEVEL_1 && SS_SIM && !SS_NDEBUG\nextern void* _ssGetUFcn(const SimStruct* S);\n#define _ssGetU(S) ((real_T*)_ssGetUFcn(S))\n#else\n#define _ssGetU(S) ((real_T*)(S)->states.U.vect) /* (const real_T *) */\n#endif\n\n#if !SS_SFCN_NORMAL\n#define ssGetU(S) _ssGetU(S)\n#define _ssSetU(S, u) (S)->states.U.vect = (u)\n#endif\n#if !SS_SFCN\n#define ssSetU(S, u) _ssSetU(S, u)\n#else\n#define ssSetU(S, u) ssSetU_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN\n#define ssGetExternalU(S) ((S)->states.U.vect)\n#endif\n\n#define ssGetUByIndex(S, portIndex, pReturnValue)                                         \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_ACCEL_MDLREF_VM_GET_U_BY_INDEX, portIndex, \\\n                                    pReturnValue) _ssSafelyCallGenericFcnEnd;\n\n\n#define ssGetYByIndex(S, portIndex, pReturnValue)                                         \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_ACCEL_MDLREF_VM_GET_Y_BY_INDEX, portIndex, \\\n                                    pReturnValue) _ssSafelyCallGenericFcnEnd;\n\n#define ssSlMrAccelRunBlockSystemInitialize(S, sysIdx, blkIdxPtr)                            \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_ACCEL_MDLREF_BLOCK_SYSTEM_INITIALIZE, sysIdx, \\\n                                    blkIdxPtr) _ssSafelyCallGenericFcnEnd;\n\n#define ssSlMrAccelRunBlockSystemReset(S, sysIdx, blkIdxPtr)                                       \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_ACCEL_MDLREF_BLOCK_SYSTEM_RESET, sysIdx, blkIdxPtr) \\\n        _ssSafelyCallGenericFcnEnd;\n\ntypedef struct {\n    int_T sysIdx;\n    int_T blkIdx;\n    char_T** path;\n} BlockPathInfo;\n\n#define _ssGetBlockPath(S, inSysIdx, inBlkIdx, inPath)                       \\\n    {                                                                        \\\n        BlockPathInfo info;                                                  \\\n        info.sysIdx = (inSysIdx);                                            \\\n        info.blkIdx = (inBlkIdx);                                            \\\n        info.path = (inPath);                                                \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_BLOCK_PATH, 0, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                      \\\n    }\n\n#define _ssGetGlobalDataTransferIndices(S, indices)                                              \\\n    {                                                                                            \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_GLOBAL_DATA_TRANSFER_INDICES, 0, indices) \\\n            _ssSafelyCallGenericFcnEnd;                                                          \\\n    }\n\n#define _ssDataTransferRead(S, dtIdx, data)                                         \\\n    {                                                                               \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_DATA_TRANSFER_READ, dtIdx, data) \\\n            _ssSafelyCallGenericFcnEnd;                                             \\\n    }\n\n#define _ssDataTransferWrite(S, dtIdx, data)                                         \\\n    {                                                                                \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_DATA_TRANSFER_WRITE, dtIdx, data) \\\n            _ssSafelyCallGenericFcnEnd;                                              \\\n    }\n\n#define _ssDataTransferInitBuffers(S, dtIdx, data)                                          \\\n    {                                                                                       \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_DATA_TRANSFER_INIT_BUFFERS, dtIdx, data) \\\n            _ssSafelyCallGenericFcnEnd;                                                     \\\n    }\n\ntypedef struct {\n    int _sysIdx;\n    int _blkIdx;\n    int _function;\n} PrePostRunBlock_T;\n\n#define ssCallAccelPreBlock(S, sysIdx, blkIdx, function)                               \\\n    {                                                                                  \\\n        PrePostRunBlock_T prePostInfo;                                                 \\\n        prePostInfo._sysIdx = sysIdx;                                                  \\\n        prePostInfo._blkIdx = blkIdx;                                                  \\\n        prePostInfo._function = function;                                              \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ACCEL_PRE_BLOCK, 0, &prePostInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                \\\n    }\n\n#define ssCallAccelPostBlock(S, sysIdx, blkIdx, function)                               \\\n    {                                                                                   \\\n        PrePostRunBlock_T prePostInfo;                                                  \\\n        prePostInfo._sysIdx = sysIdx;                                                   \\\n        prePostInfo._blkIdx = blkIdx;                                                   \\\n        prePostInfo._function = function;                                               \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ACCEL_POST_BLOCK, 0, &prePostInfo) \\\n            _ssSafelyCallGenericFcnEnd;                                                 \\\n    }\n\n/* UPtrs - This returns an array of input pointers (UPtrsType) to your\n *   S-function block. This should only be used when using the\n *   SS_OPTION_USING_ssGetUPtrs (level 1 S-functions only).\n */\n#if !SS_SFCN_NORMAL\n#define ssGetUPtrs(S) (S)->states.U.uPtrs /* (UPtrsType)      */\n#define _ssSetUPtrs(S, uptrs) (S)->states.U.uPtrs = (uptrs)\n#endif\n#if !SS_SFCN\n#define ssSetUPtrs(S, uptrs) _ssSetUPtrs(S, uptrs)\n#else\n#define ssSetUPtrs(S, uptrs) ssSetUPtrs_cannot_be_used_in_SFunctions\n#endif\n\n\n/* Y - This is the output vector for your S-function block. For the root\n *   SimStruct, this is the external output vector. The length of this\n *   vector is ssGetNumOutputs.\n */\n#define _ssGetY(S) ((real_T*)((S)->states.Y)) /*   (real_T *)    */\n\n#if !SS_SFCN_NORMAL\n#define ssGetY(S) _ssGetY(S)\n#define _ssSetY(S, y) (S)->states.Y = ((void*)(y))\n#endif\n#if !SS_SFCN\n#define ssSetY(S, y) _ssSetY(S, y)\n#else\n#define ssSetY(S, y) ssSetY_cannot_be_used_in_SFunctions\n#endif\n\n\n#if !SS_SFCN\n#define ssGetExternalY(S) (S)->states.Y\n#endif\n\n\n\n#if SS_SFCN_LEVEL_1\n/* X - This is the state vector for your S-function block. The length of\n *  vector is ssGetNumTotalStates. The first part of the vector\n *  is for the continuous state elements consisting of ssGetNumContStates\n *  and the second part of the vector is the discrete state elements\n *  consisting of ssGetNumDiscStates. For the root model, SimStruct, this\n *  contains the states of all blocks with in the model.\n */\n#define ssGetX(S) (S)->states.contStates /*   (real_T *)    */\n#define _ssSetX(S, x) (S)->states.contStates = (x)\n\n#else\n\n/*\n * ContStates - continuous state vector for your S-function. There is\n *   no guarantee that if you have both continuous and discrete states\n *   that they will be contiguous\n */\n#define _ssSetContStates(S, contX) (S)->states.contStates = (contX)\n#if !SS_SFCN\n#define ssGetX(S) ssGetContStates(S)\n#define ssSetContStates(S, contX) _ssSetContStates(S, contX)\n#else\n#define ssSetContStates(S, x) ssSetContStates_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssSetDiscStates(S, discX) (S)->states.discStates = (discX)\n#if !SS_SFCN\n#define ssSetDiscStates(S, discX) _ssSetDiscStates(S, discX)\n#else\n#define ssSetDiscStates(S, x) ssSetDiscStates_cannot_be_used_in_SFunctions\n#endif\n\n#endif\n\n\n/*\n * By default Simulink monitors continuous state changes within S-function and\n * issues warning for changes which are not notified to ODE/DAE solver via\n * ssSetSolverNeedsReset. Continuous states changes without solver resets are\n * unsafe and may be ignored in future releases. This check can be skipped for\n * efficiency if S-function is written correctly to reset the solver for all\n * state changes by using ssSetSkipContStatesConsistencyCheck(S,1)\n */\n\n\n#define ssGetSkipContStatesConsistencyCheck(S) (S)->states.flags.skipContStatesConsistencyCheck\n\n/* dX - This is the continuous state derivative vector for your S-function\n *  block. The length of this vector is ssGetNumContStates. This pointer\n *  changes as the solver evaluates different integration stages to compute\n *  the integral. For the root model SimStruct, this contains the derivatives\n *  for all continuous states of all blocks with in the model.\n */\n\n#define _ssSetdX(S, dx) (S)->states.dX = (dx)\n#if !SS_SFCN\n#define ssSetdX(S, dx) _ssSetdX(S, dx)\n#else\n#define ssSetdX(S, dx) ssSetdX_cannot_be_used_in_SFunctions\n#endif\n\n\n/* slvrJacobian */\n/* mdlSlvrJacobian was removed for R2012b) */\n/* slvrJacobian - This struct contains the slvrJacobian matrix for your S-function\n *   block.  The size of this matrix is (nxc + ny) x (nxc + nu).\n *   All of the storage involved will be allocated automatically, provided\n *   that nzmax is set to the correct value (or a number larger than the\n *   correct value).  Setting nzmax == -1 will construct a full matrix.  It\n *   is then your responsibility to fill in correct values for *pr, *ir, *jc.\n */\n\n#define ssGetSlvrJacobianNzMax(S) ((S)->states.modelMethods2->modelMethods3->numSlvrJacobianNzmax)\n#define ssSetSlvrJacobianNzMax(S, n) \\\n    ((S)->states.modelMethods2->modelMethods3->numSlvrJacobianNzmax = (n))\n\n#define ssGetSlvrJacobianHeader(S) ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix)\n#define _ssSetSlvrJacobianHeader(S, p) \\\n    ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix = (p))\n\n#if !SS_SFCN\n#define ssSetSlvrJacobianHeader(S, p) _ssSetSlvrJacobianHeader(S, p)\n#else\n#define ssSetSlvrJacobianHeader(S, p) ssSetSlvrJacobianHeader_cannot_be_used_in_SFunctions\n#endif\n\n\n#define ssGetSlvrJacobianPr(S) ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->Pr)\n#define _ssSetSlvrJacobianPr(S, pr) \\\n    ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->Pr = (pr))\n\n#if !SS_SFCN\n#define ssSetSlvrJacobianPr(S, pr) _ssSetSlvrJacobianPr(S, pr)\n#else\n#define ssSetSlvrJacobianPr(S, pr) ssSetSlvrJacobian_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSlvrJacobianIr(S) ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->Ir)\n#define _ssSetSlvrJacobianIr(S, ir) \\\n    ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->Ir = (ir))\n#if !SS_SFCN\n#define ssSetSlvrJacobianIr(S, ir) _ssSetSlvrJacobianIr(S, ir)\n#else\n#define ssSetSlvrJacobianIr(S, ir) ssSetSlvrJacobianIr_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSlvrJacobianJc(S) ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->Jc)\n#define _ssSetSlvrJacobianJc(S, jc) \\\n    ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->Jc = (jc))\n#if !SS_SFCN\n#define ssSetSlvrJacobianJc(S, jc) _ssSetSlvrJacobianJc(S, jc)\n#else\n#define ssSetSlvrJacobianJc(S, jc) ssSetSlvrJacobianJc_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSlvrJacobianM(S) ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->mRows)\n#define _ssSetSlvrJacobianM(S, m) \\\n    ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->mRows)\n#if !SS_SFCN\n#define ssSetSlvrJacobianM(S, m) _ssSetSlvrJacobianM(S, m)\n#else\n#define ssSetSlvrJacobianM(S, m) ssSetSlvrJacobianM_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSlvrJacobianN(S) ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->nCols)\n#define _ssSetSlvrJacobianN(S, n) \\\n    ((S)->states.modelMethods2->modelMethods3->slvrJacobianMatrix->nCols = (n))\n#if !SS_SFCN\n#define ssSetSlvrJacobianN(S, n) _ssSetSlvrJacobianN(S, n)\n#else\n#define ssSetSlvrJacobianN(S, n) ssSetSlvrJacobianN_cannot_be_used_in_SFunctions\n#endif\n\n\n/* Jacobian - This struct contains the Jacobian matrix for your S-function\n *   block.  The size of this matrix is (nxc + nxd + ny) x (nxc + ndx + nu).\n *   All of the storage involved will be allocated automatically, provided\n *   that nzmax is set to the correct value (or a number larger than the\n *   correct value).  Setting nzmax == -1 will construct a full matrix.  It\n *   is then your responsibility to fill in correct values for *pr, *ir, *jc.\n *   The values for *ir and *jc should be initialized in function mdlJacobianIrJc.\n */\n\n#define ssGetJacobianNzMax(S) ((S)->sizes.numJacobianNzMax)\n#define ssSetJacobianNzMax(S, n) ((S)->sizes.numJacobianNzMax = (n))\n\n#define ssGetJacobianHeader(S) (S)->states.jacobian /* (SparseHeader *) */\n#define _ssSetJacobianHeader(S, p) (S)->states.jacobian = (p)\n#if !SS_SFCN\n#define ssSetJacobianHeader(S, p) _ssSetJacobianHeader(S, p)\n#else\n#define ssSetJacobianHeader(S, p) ssSetJacobianHeader_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetJacobianPr(S) (S)->states.jacobian->Pr /*   (real_T *)    */\n#define _ssSetJacobianPr(S, pr) (S)->states.jacobian->Pr = (pr)\n#if !SS_SFCN\n#define ssSetJacobianPr(S, pr) _ssSetJacobianPr(S, pr)\n#else\n#define ssSetJacobianPr(S, pr) ssSetJacobian_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetJacobianIr(S) (S)->states.jacobian->Ir /*   (int_T *)    */\n#define _ssSetJacobianIr(S, ir) (S)->states.jacobian->Ir = (ir)\n#if !SS_SFCN\n#define ssSetJacobianIr(S, ir) _ssSetJacobianIr(S, ir)\n#else\n#define ssSetJacobianIr(S, ir) ssSetJacobianIr_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetJacobianJc(S) (S)->states.jacobian->Jc /*   (int_T *)    */\n#define _ssSetJacobianJc(S, jc) (S)->states.jacobian->Jc = (jc)\n#if !SS_SFCN\n#define ssSetJacobianJc(S, jc) _ssSetJacobianJc(S, jc)\n#else\n#define ssSetJacobianJc(S, jc) ssSetJacobianJc_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetJacobianM(S) (S)->states.jacobian->mRows /*   (int_T *)    */\n#define _ssSetJacobianM(S, m) (S)->states.jacobian->mRows = (m)\n#if !SS_SFCN\n#define ssSetJacobianM(S, m) _ssSetJacobianM(S, m)\n#else\n#define ssSetJacobianM(S, m) ssSetJacobianM_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetJacobianN(S) (S)->states.jacobian->nCols /*   (int_T *)    */\n#define _ssSetJacobianN(S, n) (S)->states.jacobian->nCols = (n)\n#if !SS_SFCN\n#define ssSetJacobianN(S, n) _ssSetJacobianN(S, n)\n#else\n#define ssSetJacobianN(S, n) ssSetJacobianN_cannot_be_used_in_SFunctions\n#endif\n\ntypedef enum {\n    SS_JACOBIAN_NOT_SUPPORTED = 0,\n    SS_JACOBIAN_EXACT,\n    SS_JACOBIAN_CUSTOMIZED\n} SFcnJacobianType;\n\n#define _ssSetJacobianTypeAndMsg(S, type, msg)                                     \\\n    {                                                                              \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_JACOBIAN_FLAG, type, msg) \\\n            _ssSafelyCallGenericFcnEnd;                                            \\\n    }\n\n#define ssSetJacobianTypeAndMsg(S, type, msg) _ssSetJacobianTypeAndMsg(S, type, msg)\n#define ssSetJacobianType(S, type) _ssSetJacobianTypeAndMsg(S, type, NULL)\n\n#define ssCallDefaultJacobianMethod(S)                                               \\\n    {                                                                                \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_CALL_DEFAULT_JACOBIAN, 0, NULL) \\\n            _ssSafelyCallGenericFcnEnd;                                              \\\n    }\n\n#define ssConfigDefaultJacobian(S)                                                     \\\n    {                                                                                  \\\n        ssSetJacobianNzMax(S, -1);                                                     \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_CONFIG_DEFAULT_JACOBIAN, 0, NULL) \\\n            _ssSafelyCallGenericFcnEnd;                                                \\\n    }\n\n\n/* SupportRunTimeModelAPI - Runtime model API refers to the model function with\n'outputs', 'derivs' and 'update' command. If the S-function block writes to\nany persistent memory during mdlOutputs function, e.g., either dWork or a\npersistent variable, it is likely that these block may need to set this\nflag to false.\n\nSimilarly, if the S-function block writes to any persistent memory other than dX\nin the mdlDerivatives, or if the S-function block writes to any persistent memory\nother than the discrete states in mdlUpdate, it is likely that this flag needs\nto be set to false.\n\nThe default value for the flag is true.\n */\n#define ssSetSupportRunTimeModelAPI(S, arg)                                                    \\\n    {                                                                                          \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_SUPPORT_RUNTIME_MODEL_API, arg, NULL) \\\n            _ssSafelyCallGenericFcnEnd;                                                        \\\n    }\n/* MassMatrix - This struct contains the MassMatrix for your S-function\n *   block.  The size of this matrix is nx x nx.\n *   All of the storage involved will be allocated automatically, provided\n *   that nzmax is set to the correct value (or a number larger than the\n *   correct value).\n */\n\n#define ssGetMassMatrixType(S) \\\n    (S)->states.modelMethods2->modelMethods3->massMatrix.type /*   (ssMatrixType)  */\n#define ssSetMassMatrixType(S, t) (S)->states.modelMethods2->modelMethods3->massMatrix.type = (t)\n\n#define ssGetMassMatrixNzMax(S) \\\n    (S)->states.modelMethods2->modelMethods3->massMatrix.info.nzMax /*   (int_T)    */\n#define ssSetMassMatrixNzMax(S, n) \\\n    (S)->states.modelMethods2->modelMethods3->massMatrix.info.nzMax = (n)\n\n#define ssGetMassMatrixIr(S) \\\n    (S)->states.modelMethods2->modelMethods3->massMatrix.info.Ir /*   (int_T *)    */\n#define _ssSetMassMatrixIr(S, ir) \\\n    (S)->states.modelMethods2->modelMethods3->massMatrix.info.Ir = (ir)\n#if !SS_SFCN\n#define ssSetMassMatrixIr(S, ir) _ssSetMassMatrixIr(S, ir)\n#else\n#define ssSetMassMatrixIr(S, ir) ssSetMassMatrixIr_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetMassMatrixJc(S) \\\n    (S)->states.modelMethods2->modelMethods3->massMatrix.info.Jc /*   (int_T *)    */\n#define _ssSetMassMatrixJc(S, jc) \\\n    (S)->states.modelMethods2->modelMethods3->massMatrix.info.Jc = (jc)\n#if !SS_SFCN\n#define ssSetMassMatrixJc(S, jc) _ssSetMassMatrixJc(S, jc)\n#else\n#define ssSetMassMatrixJc(S, jc) ssSetMassMatrixJc_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetMassMatrixPr(S) \\\n    (S)->states.modelMethods2->modelMethods3->massMatrix.info.Pr /*   (real_T *)    */\n#define _ssSetMassMatrixPr(S, pr) \\\n    (S)->states.modelMethods2->modelMethods3->massMatrix.info.Pr = (pr)\n#if !SS_SFCN\n#define ssSetMassMatrixPr(S, pr) _ssSetMassMatrixPr(S, pr)\n#else\n#define ssSetMassMatrixPr(S, pr) ssSetMassMatrix_cannot_be_used_in_SFunctions\n#endif\n\n\n/* Constraints - This struct contains the Constraints info\n *   for your S-function block.\n */\n#define _ssGetConstraintsInfo(S) \\\n    (S)->states.modelMethods2->constraintsInfo /* (_ssConstraintsInfo *) */\n#if !SS_SFCN\n#define ssGetConstraintsInfo(S) _ssGetConstraintsInfo(S)\n#else\n#define ssGetConstraintsInfo(S) ssGetConstraintsInfo_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssSetConstraintsInfo(S, p) (S)->states.modelMethods2->constraintsInfo = (p)\n#if !SS_SFCN\n#define ssSetConstraintsInfo(S, p) _ssSetConstraintsInfo(S, p)\n#else\n#define ssSetConstraintsInfo(S, p) ssSetConstraintsInfo_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssSetConstraints(S, p) (S)->states.modelMethods2->constraintsInfo->constraints = (p)\n#if !SS_SFCN\n#define ssSetConstraints(S, p) _ssSetConstraints(S, p)\n#else\n#define ssSetConstraints(S, p) ssSetConstraints_cannot_be_used_in_SFunctions\n#endif\n\n/* These are only used in command line model API, they do nothing in the generated code */\n/* The constraintInfo data structure is not created/present in generated code           */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetNumConstraints(S, n) (S)->states.modelMethods2->constraintsInfo->numConstraints = (n)\n#define ssGetNumConstraints(S) \\\n    (S)->states.modelMethods2->constraintsInfo->numConstraints /*  (int_T)     */\n#define ssGetConstraints(S) \\\n    (S)->states.modelMethods2->constraintsInfo->constraints /*  (real_T *)  */\n#else                                                       /* RT or NRT */\n#define ssSetNumConstraints(S, n)                           /* do nothing */\n#define ssGetNumConstraints(S) -1                           /* silently return invalid value */\n#define ssGetConstraints(S) NULL                            /* silently return invalid value */\n#endif\n\n\n/* ContStateDisabled - This vector is of length ssGetNumContStates and\n *   is a boolean vector indicating whether or not the states in your\n *   S-function block should be integrated. Generally this should not\n *   be modified by your S-function. It will automatically be set and\n *   cleared when your block is within an enabled subsystem during\n *   disables and enables of the subsystem block. For the root model\n *   SimStruct, this contains the boolean values for all continuous states\n *   with in the model.\n */\n#define ssGetContStateDisabled(S) (S)->states.contStateDisabled /* (boolean_T *) */\n#define _ssSetContStateDisabled(S, ptr) (S)->states.contStateDisabled = (ptr)\n#if !SS_SFCN\n#define ssSetContStateDisabled(S, ptr) _ssSetContStateDisabled(S, ptr)\n#else\n#define ssSetContStateDisabled(S, ptr) ssSetContStateDisabled_cannot_be_used_in_SFunctions\n#endif\n\n/*  Auxiliary state related information\n *\n */\n\n#define _ssSetStatesInfo2(S, ptr) ((S)->states.statesInfo2) = (ptr)\n#if (SS_GENERATED_S_FUNCTION || SS_SL_INTERNAL || SS_RTW_INTERNAL)\n#define ssSetStatesInfo2(S, ptr) _ssSetStatesInfo2(S, ptr)\n#define ssGetStatesInfo2(S) ((S)->states.statesInfo2)\n#endif\n\n/* PrevZCSigState - This vector is of length ssGetNumZCEvents. It is\n *   provided for the root model SimStruct. S-function must specify\n *   NumZCEvents as 0.\n */\n#define _ssGetPrevZCSigState(S) ((S)->states.statesInfo2)->prevZCSigState /* (int_T *)       */\n#if !SS_SFCN\n#define ssGetPrevZCSigState(S) _ssGetPrevZCSigState(S)\n#else\n#define ssGetPrevZCSigState(S) ssGetPrevZCSigState_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetPrevZCSigState(S, ptr) ((S)->states.statesInfo2)->prevZCSigState = (ptr)\n#if !SS_SFCN\n#define ssSetPrevZCSigState(S, ptr) _ssSetPrevZCSigState(S, ptr)\n#else\n#define ssSetPrevZCSigState(S, ptr) ssSetPrevZCSigState_cannot_be_used_in_SFunctions\n#endif\n\n/* NonsampledZCs - This is vector is of length ssGetNumNonsampledZCs and\n *  is the vector for the nonsampled zero crossings in your S-function.\n *  The mdlZeroCrossings method is used to fill in the nonsampled\n *  zero crossings. For the root SimStruct, this vector contains all\n *  nonsampled zero crossings in the model.\n */\n\n#define _ssSetNonsampledZCs(S, ptr) (S)->states.nonsampledZCs = (ptr)\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssSetNonsampledZCs(S, ptr) _ssSetNonsampledZCs(S, ptr)\n#else\n#define ssSetNonsampledZCs(S, ptr) ssSetNonsampledZCs_cannot_be_used_in_SFunctions\n#endif\n\n/* NonsampledZCDirs - This is the zero crossing direction for the nonsampled\n *  zero crossings. It is of length ssGetNumNonsampledZCs. The default\n *  is ANY_ZERO_CROSSING.\n */\n#define ssGetNonsampledZCDirs(S) (S)->states.nonsampledZCDirs /* (ZCDirection*)  */\n#define _ssSetNonsampledZCDirs(S, ptr) (S)->states.nonsampledZCDirs = (ptr)\n#if !SS_SFCN\n#define ssSetNonsampledZCDirs(S, ptr) _ssSetNonsampledZCDirs(S, ptr)\n#else\n#define ssSetNonsampledZCDirs(S, ptr) ssSetNonsampledZCDirs_cannot_be_used_in_SFunctions\n#endif\n\n#define ssSetModelMethods2(S, ptr) (S)->states.modelMethods2 = (ptr)\n#define ssGetModelMethods2(S) (S)->states.modelMethods2\n\n#define ssSetModelMethods3(S, ptr) ((S)->states.modelMethods2)->modelMethods3 = (ptr)\n#define ssGetModelMethods3(S) ((S)->states.modelMethods2)->modelMethods3\n\n#define ssSetModelMethods4(S, ptr) ((S)->states.modelMethods2)->modelMethods4 = (ptr)\n#define ssGetModelMethods4(S) ((S)->states.modelMethods2)->modelMethods4\n\n\n/* External Mode Function */\n\n/**\n * @brief ssSetExternalModeFcn\n *\n * Specify the external mode function for an S-function\n * @param  S      SimStruct representing an S-function block or a Simulink model.\n * @param  fcn    External mode function.\n */\n#if SS_SFCN_FOR_SIM\n#define ssSetExternalModeFcn(S, fcn) (S)->states.modelMethods2->extModeLogFcn = (fcn)\n#endif\n\n/**\n * @brief ssCallExternalModeFcn\n *\n * Invoke the external model function for an S-function\n * @param  S     SimStruct pointer\n * @param  meth  External mode method\n * @return An error character vector on failure, and NULL if successful.\n */\n#if SS_SL_INTERNAL\n#define ssCallExternalModeFcn(S, meth)                          \\\n    ((S)->states.modelMethods2->extModeLogFcn != NULL)          \\\n        ? (S)->states.modelMethods2->extModeLogFcn((S), (meth)) \\\n        : NULL\n#endif\n\n\n/*\n * Jacobian perturbation bounds\n */\n#define _ssSetJacobianPerturbationBounds(S, ptr) (S)->states.statesInfo2->jacPerturbBounds = (ptr)\n#define ssGetJacobianPerturbationBounds(S) (S)->states.statesInfo2->jacPerturbBounds\n\n#if (SS_GENERATED_S_FUNCTION || SS_SL_INTERNAL || SS_RTW_INTERNAL)\n#define ssSetJacobianPerturbationBounds(S, ptr) _ssSetJacobianPerturbationBounds(S, ptr)\n#define ssGetJacobianPerturbationBounds(S) (S)->states.statesInfo2->jacPerturbBounds\n#endif\n\n\n/*\n * JacobianPerturbationBoundMinVec\n */\n#define ssGetJacobianPerturbationBoundsMinVec(S) (S)->states.statesInfo2->jacPerturbBounds->min\n#define _ssSetJacobianPerturbationBoundsMinVec(S, ptr) \\\n    (S)->states.statesInfo2->jacPerturbBounds->min = (ptr)\n#if !SS_SFCN\n#define ssSetJacobianPerturbationBoundsMinVec(S, ptr) _ssSetJacobianPerturbationBoundsMinVec(S, ptr)\n#else\n#define ssSetJacobianPerturbationBoundsMinVec(S, ptr) \\\n    ssSetJacobianPerturbationBoundsMinVec_cannot_be_used_in_SFunctions\n#endif\n\n/*\n * JacobianPerturbationBoundMaxVec\n *\n */\n#define ssGetJacobianPerturbationBoundsMaxVec(S) (S)->states.statesInfo2->jacPerturbBounds->max\n#define _ssSetJacobianPerturbationBoundsMaxVec(S, ptr) \\\n    (S)->states.statesInfo2->jacPerturbBounds->max = (ptr)\n#if !SS_SFCN\n#define ssSetJacobianPerturbationBoundsMaxVec(S, ptr) _ssSetJacobianPerturbationBoundsMaxVec(S, ptr)\n#else\n#define ssSetJacobianPerturbationBoundsMaxVec(S, ptr) \\\n    ssSetJacobianPerturbationBoundsMaxVec_cannot_be_used_in_SFunctions\n#endif\n\n\n#define _ssSetPeriodicStatesInfo(S, ptr) (S)->states.statesInfo2->periodicStatesInfo = (ptr)\n#if (SS_GENERATED_S_FUNCTION || SS_SL_INTERNAL || SS_RTW_INTERNAL)\n#define ssSetPeriodicStatesInfo(S, ptr) _ssSetPeriodicStatesInfo(S, ptr)\n#define ssGetPeriodicStatesInfo(S) (S)->states.statesInfo2->periodicStatesInfo\n#endif\n\n/*\n * globalContStateIndex\n * This is the global continuous state index within the model.\n */\n#define ssGetGlobalContStateIndex(S) \\\n    (S)->states.statesInfo2->periodicStatesInfo->globalContStateIndex /* int_T */\n#define ssSetGlobalContStateIndex(S, num) \\\n    (S)->states.statesInfo2->periodicStatesInfo->globalContStateIndex = (num)\n\n/*\n * numPeriodicContStates\n * This is the number of periodic continuous states within\n * your S-function. The root SimStruct contains the number of periodic continuous\n * states within the model itself (including all blocks and S-functions).\n */\n#define ssGetNumPeriodicContStates(S) \\\n    (S)->states.statesInfo2->periodicStatesInfo->numPeriodicContStates /* int_T */\n#define ssSetNumPeriodicContStates(S, num) \\\n    (S)->states.statesInfo2->periodicStatesInfo->numPeriodicContStates = (num)\n\n/*\n * periodicContStateIndices\n * Periodic continuous state indices for your S-function.\n */\n#define ssGetPeriodicContStateIndices(S) \\\n    (S)->states.statesInfo2->periodicStatesInfo->periodicContStateIndices /* int_T* */\n#if !SS_SFCN\n#define ssSetPeriodicContStateIndices(S, ptr) \\\n    (S)->states.statesInfo2->periodicStatesInfo->periodicContStateIndices = (ptr)\n#else\n#define ssSetPeriodicContStateIndices(S, ptr) \\\n    ssSetPeriodicContStateIndices_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetPeriodicContStateRanges(S) \\\n    (S)->states.statesInfo2->periodicStatesInfo->periodicContStateRanges /* real_T* */\n#if !SS_SFCN\n#define ssSetPeriodicContStateRanges(S, ptr) \\\n    (S)->states.statesInfo2->periodicStatesInfo->periodicContStateRanges = (ptr)\n#else\n#define ssSetPeriodicContStateRanges(S, ptr) \\\n    ssSetPeriodicContStateRanges_cannot_be_used_in_SFunctions\n#endif\n\n/*\n * periodicContState\n * Periodic continuous state vector for your S-function.\n */\n#define ssSetPeriodicContState(S, idx, cont, lval, rval)                                       \\\n    (S)->states.statesInfo2->periodicStatesInfo->periodicContStateIndices[(idx)] =             \\\n        (S)->states.statesInfo2->periodicStatesInfo->globalContStateIndex + (cont),            \\\n    (S)->states.statesInfo2->periodicStatesInfo->periodicContStateRanges[(idx) << 1] = (lval), \\\n    (S)->states.statesInfo2->periodicStatesInfo->periodicContStateRanges[((idx) << 1) + 1] =   \\\n        (rval)\n\n/*-------------------------------- S->work ----------------------------------*/\n\n\n/* IWork - This is the integer work vector of length ssGetNumIWork for your\n *   S-function. For the root SimStruct, this is the integer work vector\n *   for all blocks in the model.\n */\n\n#define _ssSetIWork(S, iwork) (S)->work.iWork = (iwork)\n#if !SS_SFCN\n#define ssSetIWork(S, iwork) _ssSetIWork(S, iwork)\n#else\n#define ssSetIWork(S, iwork) ssSetIWork_cannot_be_used_in_SFunctions\n#endif\n\n\n\n/* RWork - This is the real work vector of length ssGetNumRWork for your\n *   S-function. For the root SimStruct, this is the real work vector\n *   for all blocks in the model.\n */\n#define _ssSetRWork(S, rwork) (S)->work.rWork = (rwork)\n#if !SS_SFCN\n#define ssSetRWork(S, rwork) _ssSetRWork(S, rwork)\n#else\n#define ssSetRWork(S, rwork) ssSetRWork_cannot_be_used_in_SFunctions\n#endif\n\n\n\n/* PWork - This is the pointer work vector of length ssGetNumPWork for your\n *   S-function. For the root SimStruct, this is the pointer work vector\n *   for all blocks in the model.\n */\n\n#define _ssSetPWork(S, pwork) (S)->work.pWork = (pwork)\n#if !SS_SFCN\n#define ssSetPWork(S, pwork) _ssSetPWork(S, pwork)\n#else\n#define ssSetPWork(S, pwork) ssSetPWork_cannot_be_used_in_SFunctions\n#endif\n\n\n\n/*\n * DWork - This is the data type work vector of length ssGetNumDWork for the\n *         S-Function. User written S-Functions should not access this array\n *         directly, they should use the macros (see below) to get/set the\n *         specific fields of the dWork structure.\n */\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetSFcnDWork(S) ((S)->work.dWork.sfcn) /* (_ssDWorkRecord *) */\n#define ssSetSFcnDWork(S, dwork) (S)->work.dWork.sfcn = (dwork)\n#define ssGetSFcnDWorkAux(S) ((S)->work.dWorkAux) /* (_ssDWorkAuxRecord *) */\n#define ssSetSFcnDWorkAux(S, dworkAux) (S)->work.dWorkAux = (dworkAux)\n#endif\n\n/*\n * Get the DWork data array\n */\n\n#define _ssSetDWork(S, index, addr) (S)->work.dWork.sfcn[index].array = (addr)\n#if !SS_SFCN\n#define ssSetDWork(S, index, dwork) _ssSetDWork(S, index, dwork)\n#else\n#define ssSetDWork(S, index, dwork) ssSetDWork_cannot_be_used_in_SFunctions\n#endif\n\n/*\n * Get/Set DWork data array width\n */\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n#define ssGetDWorkWidth_fwd(S, index) ((S)->work.dWork.sfcn[(index)].width)\n#define ssGetDWorkWidthSLSize_fwd(S, index) ((S)->work.dWorkAux[(index)].widthSLSize)\n#define ssSetDWorkWidth_fwd(S, index, val) ((S)->work.dWork.sfcn[index].width = (val))\n#define ssSetDWorkWidthSLSize_fwd(S, index, val) ((S)->work.dWorkAux[(index)].widthSLSize = (val))\n#endif\n\n/* AsInt macros should only be used in code allocating and initializing 32-bit\n   S-Functions. Currently, this includes simulink engine and sim targets */\n#define ssSetDWorkWidthAsInt(S, index, val) ((S)->work.dWork.sfcn[index].width = (val))\n\n/*\n * Set the dimensions vector in the S-Function Simulink block\n * for the DWork at the given index.\n * Inputs: Simstruct *S, int aDWorkIndex, int aDimsVector[]\n *\n * Where aDimsVector's first element is the number of elements.\n */\n#define ssSetDWorkDimensions(S, aDWorkIndex, aDimsVector)                                          \\\n    {                                                                                              \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_DWORK_DIMENSIONS, aDWorkIndex, aDimsVector) \\\n            _ssSafelyCallGenericFcnEnd;                                                            \\\n    }\n\n/*\n * Register dialog parameters indexed as prmMinIdx and prmMaxIdx as design\n * minimum and maximum for the DWork of index dworkIdx.\n */\n#define ssRegisterDWorkMinMaxPrmIndices(S, dworkIdx, prmMinIdx, prmMaxIdx) \\\n    ssRegisterDataMinMaxPrmIndices((S), SS_DATA_DESC_DWORK, (dworkIdx), (prmMinIdx), (prmMaxIdx))\n\n/*\n * Specify when the DWork minimum and maximum range checking should be\n * performed.\n */\ntypedef enum {\n    DWORK_MIN_MAX_CHECKING_USER_INITIATED = 0x0,\n    DWORK_MIN_MAX_CHECKING_OUTPUT_ONLY = 0x1,\n    DWORK_MIN_MAX_CHECKING_UPDATE_ONLY = 0x2,\n    DWORK_MIN_MAX_CHECKING_OUTPUT_AND_UPDATE = 0x3\n} DWorkMinMaxCheckpoint;\n#define ssGetDWorkMinMaxCheckpoint(S, dworkIdx) \\\n    ((S)->work.dWorkAux[(dworkIdx)].flags.minMaxCheckpoint)\n#define ssSetDWorkMinMaxCheckpoint(S, dworkIdx, checkpoint) \\\n    (S)->work.dWorkAux[(dworkIdx)].flags.minMaxCheckpoint = (checkpoint)\n\n/*\n * Perform explicit range checking of the DWork against the associated\n * design minimum and maximum\n */\n#define ssCheckDWorkRange(S, dworkIdx)                                                  \\\n    {                                                                                   \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_CHECK_DWORK_RANGE, (dworkIdx), NULL) \\\n            _ssSafelyCallGenericFcnEnd;                                                 \\\n    }\n\n\n\n/* DWorkOptimizeInIR - This macro allows S-Functions that use the code\n * generation intermediate representation (CGIR) to generate code, to enable\n * optimizations that would otherwise be disabled by default. For example,\n * the macro should be used if a S-Function set its DWork conservatively as\n * global, because it is accessed in both the\n * output and the update function. It is possible for CGIR to safely optimize\n * the DWork if output and update get combined.\n */\n#define ssGetDWorkOptimizeInIR(S, index) ((S)->work.dWorkAux[(index)].flags.optimizeInIR)\n#define ssSetDWorkOptimizeInIR(S, index, val) (S)->work.dWorkAux[(index)].flags.optimizeInIR = val\n\n/*\n * G(S)et the DWork \"disable bounds checking\" attribute.\n *\n *   Currently not supported.\n */\n#define ssGetDWorkDisableBoundsChecking(S, index) (0)\n\n/*\n * G(S)et the DWork \"upload dwork in extmode\" attribute.\n */\n#define ssGetDWorkExtModeUpload(S, index) \\\n    (S)->work.dWorkAux[index].flags.ExtModeUpload /* (unsigned int_T: 1) */\n#define ssSetDWorkExtModeUpload(S, index, n) \\\n    (S)->work.dWorkAux[index].flags.ExtModeUpload = (n) /* (unsigned int_T: 1) */\n\n/*\n * G(S)et the DWork \"upload dwork in extmode\" attribute.\n */\n#define ssGetDWorkExtModeUpload(S, index) \\\n    (S)->work.dWorkAux[index].flags.ExtModeUpload /* (unsigned int_T: 1) */\n#define ssSetDWorkExtModeUpload(S, index, n) \\\n    (S)->work.dWorkAux[index].flags.ExtModeUpload = (n) /* (unsigned int_T: 1) */\n\n\n\n/*\n * Routines to allow the S-function to map a block IC parameter to its dwork.\n */\n#define ssGetDWorkInitialConditionParamIdx(S, index) ((S)->work.dWorkAux[(index)].icPrmIdxPlus1 - 1)\n#define ssSetDWorkInitialConditionParamIdx(S, index, val) \\\n    (S)->work.dWorkAux[index].icPrmIdxPlus1 = ((int_T)val + 1)\n\n/*\n * Routines to allow the S-function to map a dwork to a bit-field\n */\n#define ssGetDWorkBitFieldWidth(S, index) ((S)->work.dWorkAux[(index)].bitFieldWidth)\n#define ssSetDWorkBitFieldWidth(S, index, val) \\\n    (S)->work.dWorkAux[index].bitFieldWidth = ((int_T)val)\n\n/*\n * RootDWork - For use by Simulink/RTW. User written S-Functions should not use\n *             this macro.\n *\n */\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetRootDWork(S) ((S)->work.dWork.root)\n#define ssSetRootDWork(S, val) (S)->work.dWork.root = (val)\n#endif\n\n\n\n/* ModeVector - This is the mode vector of length ssGetNumModes for your\n *   S-function. For the root SimStruct, this is the mode vector\n *   for all blocks in the model.\n */\n\n#define _ssSetModeVector(S, vect) (S)->work.modeVector = (vect)\n#if !SS_SFCN\n#define ssSetModeVector(S, vect) _ssSetModeVector(S, vect)\n#else\n#define ssSetModeVector(S, vect) ssSetModeVector_cannot_be_used_in_SFunctions\n#endif\n\n\n\n/* LocalMdlInfo - Internal use only\n * This is a void pointer to the owning block diagram.\n */\n#define _ssSetLocalMdlInfo(S, locMdlInfo) (S)->work.localMdlInfo = (locMdlInfo)\n#define _ssGetLocalMdlInfo(S) (S)->work.localMdlInfo /*   (_ssLocalMdlInfo*)    */\n\n#if !SS_SFCN\n#define ssSetLocalMdlInfo(S, locMdlInfo) _ssSetLocalMdlInfo(S, locMdlInfo)\n#else\n#define ssSetLocalMdlInfo(S, locMdlInfo) ssSetLocalMdlInfo_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetLocalMdlInfo(S) _ssGetLocalMdlInfo(S)\n#else\n#define ssGetLocalMdlInfo(S) ssGetLocalMdlInfo_cannot_be_used_in_SFunctions\n#endif\n\n/* OwnerBd - Internal use only\n * This is a void pointer to the owning block diagram.\n */\n#define _ssSetOwnerBd(S, bd) (S)->work.localMdlInfo->ownerBd = ((void*)bd)\n#define _ssGetOwnerBd(S) (S)->work.localMdlInfo->ownerBd /*   (void*)    */\n\n#if !SS_SFCN\n#define ssSetOwnerBd(S, bd) _ssSetOwnerBd(S, bd)\n#else\n#define ssSetOwnerBd(S, bd) ssSetOwnerBd_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetOwnerBd(S) _ssGetOwnerBd(S)\n#else\n#define ssGetOwnerBd(S) ssGetOwnerBd_cannot_be_used_in_SFunctions\n#endif\n\n/* CompBd - Internal use only\n * This is a void pointer to the owning compiled block diagram.\n */\n#define _ssSetOwnerCbd(S, cbd) (S)->work.localMdlInfo->ownerCbd = ((void*)cbd)\n#define _ssGetOwnerCbd(S)                                             \\\n    (ssGetParentSS(S) ? ssGetParentSS(S)->work.localMdlInfo->ownerCbd \\\n                      : (S)->work.localMdlInfo->ownerCbd)\n\n#if !SS_SFCN\n#define ssSetOwnerCbd(S, cbd) _ssSetOwnerCbd(S, cbd)\n#else\n#define ssSetOwnerCbd(S, cbd) ssSetOwnerCbd_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetOwnerCbd(S) _ssGetOwnerCbd(S)\n#else\n#define ssGetOwnerCbd(S) ssGetOwnerCbd_cannot_be_used_in_SFunctions\n#endif\n\n\n/* ExecBd - Internal use only\n* This is a void pointer to the owning Exec block diagram. Since there can be\n   multiple ExecBds corresponding to one SimStruct, it will be swapped appropriately.\n*/\n#define _ssSetOwnerEbd(S, ebd) (S)->work.localMdlInfo->ownerEbd = ((void*)ebd)\n#define _ssGetOwnerEbd(S)                                             \\\n    (ssGetParentSS(S) ? ssGetParentSS(S)->work.localMdlInfo->ownerEbd \\\n                      : (S)->work.localMdlInfo->ownerEbd)\n\n#if !SS_SFCN\n#define ssSetOwnerEbd(S, ebd) _ssSetOwnerEbd(S, ebd)\n#else\n#define ssSetOwnerEbd(S, cbd) ssSetOwnerEbd_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetOwnerEbd(S) _ssGetOwnerEbd(S)\n#else\n#define ssGetOwnerEbd(S) ssGetOwnerEbd_cannot_be_used_in_SFunctions\n#endif\n\n/* ExecSimStructManager - Internal use only\n * This is a void pointer to the ExecSimStructManager. This\n * manager class is used to store exec SimStruct related information\n */\n#define _ssSetExecSimStructMgr(S, mgr) (S)->work.localMdlInfo->execSimStructMgr = ((void*)mgr)\n#define _ssGetExecSimStructMgr(S) (S)->work.localMdlInfo->execSimStructMgr\n\n#if !SS_SFCN\n#define ssSetExecSimStructMgr(S, mgr) _ssSetExecSimStructMgr(S, mgr)\n#else\n#define ssSetExecSimStructMgr(S, ebd) ssSetExecSimStructMgr_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetExecSimStructMgr(S) _ssGetExecSimStructMgr(S)\n#else\n#define ssGetExecSimStructMgr(S) ssGetExecSimStructMgr_cannot_be_used_in_SFunctions\n#endif\n\n/* Model RTP - Internal use only\n * This is a void pointer to the RTP of a model.\n */\n#define _ssSetModelRtp(S, ptr) (S)->work.localMdlInfo->rtp = (ptr)\n#define _ssGetModelRtp(S) (S)->work.localMdlInfo->rtp /*   (real_T*)    */\n#if !SS_SFCN\n#define ssSetModelRtp(S, ptr) _ssSetModelRtp(S, ptr)\n#else\n#define ssSetModelRtp(S, ptr) ssSetModelRtp_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetModelRtp(S) _ssGetModelRtp(S)\n#else\n#define ssGetModelRtp(S) ssGetModelRtp_cannot_be_used_in_SFunctions\n#endif\n\n/* Model BlockIO - Internal use only\n * This is a void pointer to the BlockIO of a model.\n */\n#define _ssSetModelBlockIO(S, ptr) (S)->work.localMdlInfo->blockIO = ((void*)(ptr))\n#define _ssGetModelBlockIO(S) ((void*)((S)->work.localMdlInfo->blockIO)) /*   (void*)    */\n#if !SS_SFCN\n#define ssSetModelBlockIO(S, ptr) _ssSetModelBlockIO(S, ptr)\n#define ssGetModelBlockIO(S) _ssGetModelBlockIO(S)\n#else\n#define ssSetModelBlockIO(S, ptr) ssSetModelBlockIO_cannot_be_used_in_SFunctions\n#define ssGetModelBlockIO(S) ssGetModelBlockIO_cannot_be_used_in_SFunctions\n#endif\n\n/*  - Internal use only\n * This is a uint_T pointer to the NumRuntimeEvents of a model.\n */\n#define _ssSetNumRuntimeEventsPtr(S, ptr) (S)->work.localMdlInfo->numRuntimeEvents = (ptr)\n#define _ssGetNumRuntimeEventsPtr(S) (S)->work.localMdlInfo->numRuntimeEvents /*   (uint_T*)    */\n#if !SS_SFCN\n#define ssSetNumRuntimeEventsPtr(S, ptr) _ssSetNumRuntimeEventsPtr(S, ptr)\n#else\n#define ssSetNumRuntimeEventsPtr(S, ptr) ssSet_cannot_be_used_in_SFunctions\n#endif\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetNumRuntimeEventsPtr(S) _ssGetNumRuntimeEventsPtr(S)\n#else\n#define ssGetNumRuntimeEventsPtr(S) ssGet_cannot_be_used_in_SFunctions\n#endif\n\n\n/*  - Internal use only\n * This is uint_T value of the NumRuntimeEvents of a model.\n */\n#define _ssSetNumRuntimeEvents(S, num) *(S)->work.localMdlInfo->numRuntimeEvents = (num)\n#define _ssGetNumRuntimeEvents(S) *(S)->work.localMdlInfo->numRuntimeEvents /*   (uint_T)    */\n#if !SS_SFCN\n#define ssSetNumRuntimeEvents(S, num) _ssSetNumRuntimeEvents(S, num)\n#else\n#define ssSetNumRuntimeEvents(S, num) ssSetNumRuntimeEvents_cannot_be_used_in_SFunctions\n#endif\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetNumRuntimeEvents(S) _ssGetNumRuntimeEvents(S)\n#else\n#define ssGetNumRuntimeEvents(S) ssGetNumRuntimeEvents_cannot_be_used_in_SFunctions\n#endif\n\n\n/*  - Internal use only\n * This is a uint_T pointer to the GlobalRuntimeEventIndices of a model.\n */\n#define _ssSetGlobalRuntimeEventIndices(S, ptr) \\\n    (S)->work.localMdlInfo->globalRuntimeEventIndices = (ptr)\n#define _ssGetGlobalRuntimeEventIndices(S) \\\n    (S)->work.localMdlInfo->globalRuntimeEventIndices /*   (uint_T*)    */\n#if !SS_SFCN\n#define ssSetGlobalRuntimeEventIndices(S, ptr) _ssSetGlobalRuntimeEventIndices(S, ptr)\n#else\n#define ssSetGlobalRuntimeEventIndices(S, ptr) \\\n    ssSetGlobalRuntimeEventIndices_cannot_be_used_in_SFunctions\n#endif\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetGlobalRuntimeEventIndices(S) _ssGetGlobalRuntimeEventIndices(S)\n#else\n#define ssGetGlobalRuntimeEventIndices(S) \\\n    ssGetGlobalRuntimeEventIndices_cannot_be_used_in_SFunctions\n#endif\n\n\n/*  - Internal use only\n * This is a uint_T GlobalRuntimeEventIndex corresponding to localIndex of a model.\n */\n#define _ssSetGlobalRuntimeEventIndex(S, localIndex, globalIndex)                        \\\n    if ((S)->work.localMdlInfo != NULL) {                                                \\\n        (S)->work.localMdlInfo->globalRuntimeEventIndices[(localIndex)] = (globalIndex); \\\n    }\n#define _ssGetGlobalRuntimeEventIndex(S, localIndex)                       \\\n    ((S)->work.localMdlInfo != NULL                                        \\\n         ? (S)->work.localMdlInfo->globalRuntimeEventIndices[(localIndex)] \\\n         : (localIndex)) /*   (uint_T)    */\n#if !SS_SFCN\n#define ssSetGlobalRuntimeEventIndex(S, localIndex, globalIndex) \\\n    _ssSetGlobalRuntimeEventIndex(S, localIndex, globalIndex)\n#else\n#define ssSetGlobalRuntimeEventIndex(S, localIndex, globalIndex) \\\n    ssSetGlobalRuntimeEventIndex_cannot_be_used_in_SFunctions\n#endif\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetGlobalRuntimeEventIndex(S, localIndex) _ssGetGlobalRuntimeEventIndex(S, localIndex)\n#else\n#define ssGetGlobalRuntimeEventIndex(S, localIndex) \\\n    ssGetGlobalRuntimeEventIndex_cannot_be_used_in_SFunctions\n#endif\n\n\n/* Model BlockIOVarDims - Internal use only\n * This is a void pointer to the BlockIOVarDims of a model.\n *\n * No one uses this.\n *\n * It is noted here as the corresponding BlockIOVarDims field still exits\n * in _ssMdlInfo\n */\n\n/*-------------------------------- S->blkInfo -------------------------------*/\n\n/* InputConnected - True/false are any inputs to the S-function connected\n *   to non-virtual blocks?\n */\n#if SS_SFCN_LEVEL_1 || SS_SL_INTERNAL\n#define ssGetInputConnected(S) (S)->blkInfo.inputConnected /* (int_T)      */\n#define _ssSetInputConnected(S, setting) (S)->blkInfo.inputConnected = (setting)\n#else\n#define ssGetInputConnected(S) ssGetInputConnected_cannot_be_used_in_Level2_SFunctions\n#endif\n\n#if !SS_SFCN\n#define ssSetInputConnected(S, setting) _ssSetInputConnected(S, setting)\n#else\n#define ssSetInputConnected(S, setting) ssSetInputConnected_cannot_be_used_in_SFunctions\n#endif\n\n\n/* OutputConnected - True/false are any outputs of the S-function connected\n *   to non-virtual blocks?\n */\n#define ssGetOutputConnected(S) (S)->blkInfo.outputConnected /* (int_T)      */\n#define _ssSetOutputConnected(S, setting) (S)->blkInfo.outputConnected = (setting)\n#if !SS_SFCN\n#define ssSetOutputConnected(S, setting) _ssSetOutputConnected(S, setting)\n#else\n#define ssSetOutputConnected(S, setting) ssSetOutputConnected_cannot_be_used_in_SFunctions\n#endif\n\n\n\n/*----------------------------------------------------------------------------*/\n\n\n#define ssSetBlkInfo2Ptr(S, ptr) (S)->blkInfo.blkInfo2 = (ptr)\n#define ssGetBlkInfo2Ptr(S) (S)->blkInfo.blkInfo2\n#define ssSetBlkInfoSLSizePtr(S, ptr) (S)->blkInfo.blkInfo2->blkInfoSLSize = (ptr)\n#define ssGetBlkInfoSLSizePtr(S, ptr) (S)->blkInfo.blkInfo2->blkInfoSLSize\n#define ssSetRTWSfcnInfo(S, ptr) ((S)->blkInfo.blkInfo2)->rtwSfcnInfo = ((void*)ptr)\n#define ssGetRTWSfcnInfo(S) ((S)->blkInfo.blkInfo2)->rtwSfcnInfo\n\n/* Impulse Response Length - Integer impulse response length of a\n * block. Currently, it is used only in the dataflow domain.\n */\n\n/**\n * @brief  ssSetImpulseResponseLength\n *\n * Call this in mdlInitializeSizes or mdlSetWorkWidths callback to set the\n * impulse response length during pre-compile or post-propagation stage,\n * respectively.\n *\n * Specify impulse response length of the block.\n * @param    S             SimStruct representing an S-Function block.\n * @param    val           An int_T value specifying the impulse response length of S-Function block\n * S.\n */\n#define ssSetImpulseResponseLength(S, val) ((S)->blkInfo.blkInfo2)->impulseResponseLength = (val)\n\n/**\n * @brief  ssGetImpulseResponseLength\n *\n * Get impulse response length of the block.\n * @param    S             SimStruct representing an S-Function block.\n * @return   An int_T value indicating the impulse response length of the S-Function block S.\n */\n#define ssGetImpulseResponseLength(S) ((S)->blkInfo.blkInfo2)->impulseResponseLength /* (int_T) */\n\n/*-------------------------------- S->mdlInfo -------------------------------*/\n#define ssGetMdlInfoPtr(S) (S)->mdlInfo /* (struct _ssMdlInfo *) */\n#define _ssSetMdlInfoPtr(S, ptr) (S)->mdlInfo = (ptr)\n#if !SS_SFCN\n#define ssSetMdlInfoPtr(S, ptr) _ssSetMdlInfoPtr(S, ptr)\n#else\n#define ssSetMdlInfoPtr(S, ptr) ssSetMdlInfoPtr_cannot_be_used_in_SFunctions\n#endif\n\n\n#define _ssSetSimMode(S, mode) (S)->mdlInfo->simMode = (mode)\n#if !SS_SFCN\n#define ssSetSimMode(S, mode) _ssSetSimMode(S, mode)\n#else\n#define ssSetSimMode(S, mode) ssSetSimMode_cannot_be_used_in_SFunctions\n#endif\n\n\n\n#define ssGetRTWCGSupport(S, result)                                               \\\n    {                                                                              \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_RTWCG_SUPPORT, 0, result) \\\n            _ssSafelyCallGenericFcnEnd;                                            \\\n    }\n\n#define ssSetStateAttr(S, pMxa)                                               \\\n    {                                                                         \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_STATE_ATTR, 0, pMxa) \\\n            _ssSafelyCallGenericFcnEnd;                                       \\\n    }\n\n#define ssGetStateAttr(S, ppMxa)                                               \\\n    {                                                                          \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_STATE_ATTR, 0, ppMxa) \\\n            _ssSafelyCallGenericFcnEnd;                                        \\\n    }\n\n\n\n#if !SS_SFCN && SS_SIM\n#define ssSetRTWGenMode(S, mode) (S)->mdlInfo->rtwgenMode = (mode)\n#define ssGetRTWGenMode(S) ((S)->mdlInfo->rtwgenMode)\n#endif\n\n\n#define ssGetTPtr(S) (S)->mdlInfo->t /*   (time_T *)    */\n#define _ssSetTPtr(S, t_ptr) (S)->mdlInfo->t = (t_ptr)\n\n#if !SS_SFCN\n#define ssSetTPtr(S, t_ptr) _ssSetTPtr(S, t_ptr)\n#else\n#define ssSetTPtr(S, t_ptr) ssSetTPtr_cannot_be_used_in_SFunctions\n#endif\n\n\n#define _ssSetT(S, time) (S)->mdlInfo->t[0] = (time)\n\n#if !SS_SFCN\n#define ssSetT(S, time) _ssSetT(S, time)\n#else\n#define ssSetT(S, time) ssSetT_cannot_be_used_in_SFunctions\n#endif\n\n\n#define _ssSetTaskTime(S, sti, time) (S)->mdlInfo->t[sti] = (time)\n\n#if !SS_SFCN\n#define ssSetTaskTime(S, sti, time) _ssSetTaskTime(S, sti, time)\n#else\n#define ssSetTaskTime(S, sti, time) ssSetTaskTime_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssSetSampleHit(S, sti, v) (S)->mdlInfo->sampleHits[sti] = (v)\n#define _ssSetSampleHitPtr(S, ptr) (S)->mdlInfo->sampleHits = (ptr)\n\n#if !SS_SFCN\n#define ssSetSampleHitPtr(S, ptr) _ssSetSampleHitPtr(S, ptr)\n#else\n#define ssSetSampleHitPtr(S, ptr) ssSetSampleHitPtr_cannot_be_used_in_SFunctions\n#endif\n\n\n#define _ssSetTStart(S, tstart) (S)->mdlInfo->tStart = (tstart)\n#if !SS_SFCN\n#define ssSetTStart(S, tstart) _ssSetTStart(S, tstart)\n#else\n#define ssSetTStart(S, tstart) ssSetTStart_cannot_be_used_in_SFunctions\n#endif\n\n\n#define _ssSetTFinal(S, tfinal) (S)->mdlInfo->tFinal = (tfinal)\n#if !SS_SFCN\n#define ssSetTFinal(S, tfinal) _ssSetTFinal(S, tfinal)\n#else\n#define ssSetTFinal(S, tfinal) ssSetTFinal_cannot_be_used_in_SFunctions\n#endif\n\n/* TimeOfLastOutput - This is reserved for use by RTW and Simulink. However,\n *   S-function can look at this within their continuous task. It is\n *   the time of the last output for the model - not the s-function\n *   itself.\n */\n#define ssGetTimeOfLastOutput(S) (S)->mdlInfo->timeOfLastOutput /*   (time_T)      */\n#define _ssSetTimeOfLastOutput(S, tlast) (S)->mdlInfo->timeOfLastOutput = (tlast)\n#if !SS_SFCN\n#define ssSetTimeOfLastOutput(S, tlast) _ssSetTimeOfLastOutput(S, tlast)\n#else\n#define ssSetTimeOfLastOutput(S, tlast) ssSetTimeOfLastOutput_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetTimingData(S) (S)->mdlInfo->timingData /*   (void *)      */\n#if !SS_SFCN\n#define ssGetTimingData(S) _ssGetTimingData(S)\n#else\n#define ssGetTimingData(S) ssGetTimingData_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetTimingData(S, d) (S)->mdlInfo->timingData = (d)\n#if !SS_SFCN\n#define ssSetTimingData(S, d) _ssSetTimingData(S, d)\n#else\n#define ssSetTimingData(S, d) ssSetTimingData_cannot_be_used_in_SFunctions\n#endif\n\n/*\n * TimingBridge is introduced in R14. This provides access to the timing\n * information which is stored in different data structures in Simulink\n * and the various RTW code formats.\n */\n#define ssGetTimingBridge(S) ((S)->mdlInfo->timingBridge)\n#if !SS_SFCN\n#define ssSetTimingBridge(S, d) (S)->mdlInfo->timingBridge = (d)\n#else\n#define ssSetTimingBridge(S, d) ssSetTimingBridge_cannot_be_used_in_SFunctions\n#endif\n\n\n#define ssGetClockTick(S, sti) \\\n    (*((S)->mdlInfo->timingBridge->clockTick[ssGetSampleTimeTaskID(S, sti)]))\n\n#define ssGetClockTickH(S, sti) \\\n    (*((S)->mdlInfo->timingBridge->clockTickH[ssGetSampleTimeTaskID(S, sti)]))\n\n\n#define ssGetSimTimeStep(S) (S)->mdlInfo->simTimeStep /*  (SimTimeStep)  */\n#define _ssSetSimTimeStep(S, stepType) (S)->mdlInfo->simTimeStep = (stepType)\n#if !SS_SFCN\n#define ssSetSimTimeStep(S, stepType) _ssSetSimTimeStep(S, stepType)\n#else\n#define ssSetSimTimeStep(S, stepType) ssSetSimTimeStep_cannot_be_used_in_SFunctions\n#endif\n\n\n#define ssGetLogOutput(S) (S)->mdlInfo->logOutput /*    (int_T)  */\n#define _ssSetLogOutput(S, setting) (S)->mdlInfo->logOutput = setting\n#if !SS_SFCN\n#define ssSetLogOutput(S, setting) _ssSetLogOutput(S, setting)\n#else\n#define ssSetLogOutput(S, setting) ssSetLogOutput_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetOutputTimes(S) (S)->mdlInfo->outputTimes /*   (time_T*)     */\n#if !SS_SFCN\n#define ssGetOutputTimes(S) _ssGetOutputTimes(S)\n#else\n#define ssGetOutputTimes(S) ssGetOutputTimes_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetOutputTimes(S, ptr) (S)->mdlInfo->outputTimes = (ptr)\n#if !SS_SFCN\n#define ssSetOutputTimes(S, ptr) _ssSetOutputTimes(S, ptr)\n#else\n#define ssSetOutputTimes(S, ptr) ssSetOutputTimes_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetNextOutputTime(S) \\\n    (S)->mdlInfo->outputTimes[(S)->mdlInfo->outputTimesIndex] /*   (time_T)      */\n#if !SS_SFCN\n#define ssGetNextOutputTime(S) _ssGetNextOutputTime(S)\n#else\n#define ssGetNextOutputTime(S) ssGetNextOutputTime_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetOutputTimesIndex(S) (S)->mdlInfo->outputTimesIndex /*   (int_T)       */\n#if !SS_SFCN\n#define ssGetOutputTimesIndex(S) _ssGetOutputTimesIndex(S)\n#else\n#define ssGetOutputTimesIndex(S) ssGetOutputTimesIndex_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetOutputTimesIndex(S, index) (S)->mdlInfo->outputTimesIndex = (index)\n#if !SS_SFCN\n#define ssSetOutputTimesIndex(S, index) _ssSetOutputTimesIndex(S, index)\n#else\n#define ssSetOutputTimesIndex(S, index) ssSetOutputTimesIndex_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetNumOutputTimes(S) (S)->mdlInfo->numOutputTimes /*   (int_T)       */\n#if !SS_SFCN\n#define ssGetNumOutputTimes(S) _ssGetNumOutputTimes(S)\n#else\n#define ssGetNumOutputTimes(S) ssGetNumOutputTimes_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetNumOutputTimes(S, n) (S)->mdlInfo->numOutputTimes = (n)\n#if !SS_SFCN\n#define ssSetNumOutputTimes(S, n) _ssSetNumOutputTimes(S, n)\n#else\n#define ssSetNumOutputTimes(S, n) ssSetNumOutputTimes_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetOutputTimesOnly(S) (S)->mdlInfo->outputTimesOnly /*   (int_T)   */\n#if !SS_SFCN\n#define ssGetOutputTimesOnly(S) _ssGetOutputTimesOnly(S)\n#else\n#define ssGetOutputTimesOnly(S) ssGetOutputTimesOnly_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetOutputTimesOnly(S, setting) (S)->mdlInfo->outputTimesOnly = (setting)\n#if !SS_SFCN\n#define ssSetOutputTimesOnly(S, setting) _ssSetOutputTimesOnly(S, setting)\n#else\n#define ssSetOutputTimesOnly(S, setting) ssSetOutputTimesOnly_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetNeedOutputAtTPlusTol(S) (S)->mdlInfo->obsoletedNeedOutputAtTPlusTol /*   (int_T) */\n#if !SS_SFCN\n#define ssGetNeedOutputAtTPlusTol(S) _ssGetNeedOutputAtTPlusTol(S)\n#else\n#define ssGetNeedOutputAtTPlusTol(S) ssGetNeedOutputAtTPlusTol_cannot_be_used_in_SFunctions\n#endif\n\n\n#define _ssSetSolverName(S, name) (S)->mdlInfo->solverName = (name)\n#if !SS_SFCN\n#define ssSetSolverName(S, name) _ssSetSolverName(S, name)\n#else\n#define ssSetSolverName(S, name) ssSetSolverName_cannot_be_used_in_SFunctions\n#endif\n\n\n#define _ssSetVariableStepSolver(S, s) (S)->mdlInfo->variableStepSolver = (s)\n#if !SS_SFCN\n#define ssSetVariableStepSolver(S, s) _ssSetVariableStepSolver(S, s)\n#else\n#define ssSetVariableStepSolver(S, s) ssSetVariableStepSolver_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetSolverData(S) (S)->mdlInfo->solverData /*   (void *)      */\n#if !SS_SFCN\n#define ssGetSolverData(S) _ssGetSolverData(S)\n#else\n#define ssGetSolverData(S) ssGetSolverData_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetSolverData(S, solverDataPtr) (S)->mdlInfo->solverData = (solverDataPtr)\n#if !SS_SFCN\n#define ssSetSolverData(S, solverDataPtr) _ssSetSolverData(S, solverDataPtr)\n#else\n#define ssSetSolverData(S, solverDataPtr) ssSetSolverData_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSolverStopTime(S) (S)->mdlInfo->solverStopTime /*   (time_T)      */\n#define _ssSetSolverStopTime(S, stoptime) (S)->mdlInfo->solverStopTime = (stoptime)\n#if !SS_SFCN\n#define ssSetSolverStopTime(S, stoptime) _ssSetSolverStopTime(S, stoptime)\n#else\n#define ssSetSolverStopTime(S, stoptime) ssSetSolverStopTime_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetStepSize(S) (S)->mdlInfo->stepSize /*   (time_T)      */\n#define _ssSetStepSize(S, size) (S)->mdlInfo->stepSize = (size)\n#if !SS_SFCN\n#define ssSetStepSize(S, size) _ssSetStepSize(S, size)\n#else\n#define ssSetStepSize(S, size) ssSetStepSize_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSolverNeedsReset(S) (S)->mdlInfo->solverNeedsReset /*  (int_T)    */\n#define ssSetSolverNeedsResetWithReason(S, resetReason) \\\n    (S)->mdlInfo->solverNeedsReset = ((S)->mdlInfo->solverNeedsReset | resetReason)\n#define _ssClearSolverNeedsReset(S) (S)->mdlInfo->solverNeedsReset = ((int_T)0)\n\n#if !SS_SFCN\n#define ssClearSolverNeedsReset(S) _ssClearSolverNeedsReset(S)\n#else\n#define ssClearSolverNeedsReset(S) ssClearSolverNeedsReset_cannot_be_used_in_SFunctions\n#endif\n\n#define ssIsSolverRequestingReset(S) ((S)->mdlInfo->mdlFlags.solverRequestingReset == 1U)\n#define _ssSetSolverRequestingReset(S, boolVal) \\\n    (S)->mdlInfo->mdlFlags.solverRequestingReset = ((boolVal) ? 1U : 0U)\n#if !SS_SFCN\n#define ssSetSolverRequestingReset(S, boolVal) _ssSetSolverRequestingReset(S, boolVal)\n#else\n#define ssSetSolverRequestingReset(S, boolVal) \\\n    ssSetSolverRequestingReset_cannot_be_used_in_SFunctions\n#endif\n\n#define ssIsSolverCheckingCIC(S) ((S)->mdlInfo->mdlFlags.solverCheckingCIC == 1U)\n#define _ssSetSolverCheckingCIC(S, boolVal) \\\n    (S)->mdlInfo->mdlFlags.solverCheckingCIC = ((boolVal) ? 1U : 0U)\n#if !SS_SFCN\n#define ssSetSolverCheckingCIC(S, boolVal) _ssSetSolverCheckingCIC(S, boolVal)\n#else\n#define ssSetSolverCheckingCIC(S, boolVal) ssSetSolverCheckingCIC_cannot_be_used_in_SFunctions\n#endif\n\n\n#define ssGetZCCacheNeedsReset(S) (S)->mdlInfo->mdlFlags.zcCacheNeedsReset /*  (uint_T)    */\n#define ssSetZCCacheNeedsReset(S, setting) (S)->mdlInfo->mdlFlags.zcCacheNeedsReset = (setting)\n\n#define ssGetDerivCacheNeedsReset(S) (S)->mdlInfo->mdlFlags.derivCacheNeedsReset /*  (uint_T) */\n#define ssSetDerivCacheNeedsReset(S, setting) \\\n    (S)->mdlInfo->mdlFlags.derivCacheNeedsReset = (setting)\n\n#define _ssGetForceSfcnExceptionHandling(S) \\\n    ((S)->mdlInfo->mdlFlags.forceSfcnExceptionHandling == 1U)\n#define _ssSetForceSfcnExceptionHandling(S, boolVal) \\\n    (S)->mdlInfo->mdlFlags.forceSfcnExceptionHandling = ((boolVal) ? 1U : 0U)\n\n#define ssIsComputingJacobian(S) ((S)->mdlInfo->mdlFlags.computingJacobian == 1U)\n#define _ssSetComputingJacobian(S, boolVal) \\\n    (S)->mdlInfo->mdlFlags.computingJacobian = ((boolVal) ? 1U : 0U)\n\n#define ssGetEvaluatingF0ForJacobian(S) (S)->mdlInfo->mdlFlags.f0EvaluationForJacobian\n#define _ssSetEvaluatingF0ForJacobian(S, val) (S)->mdlInfo->mdlFlags.f0EvaluationForJacobian = val\n#define _ssClearEvaluatingF0ForJacobian(S) (S)->mdlInfo->mdlFlags.f0EvaluationForJacobian = 0\n\n#if (!SS_SFCN || defined(RTW_GENERATED_S_FUNCTION))\n#define ssGetIsZCEvaluationForRefine(S) ((S)->mdlInfo->mdlFlags.zcEvalForRefine == 1U)\n#define _ssSetIsZCEvaluationForRefine(S, val) (S)->mdlInfo->mdlFlags.zcEvalForRefine = val\n#define _ssClearIsZCEvaluationForRefine(S) (S)->mdlInfo->mdlFlags.zcEvalForRefine = 0U\n#endif\n\n#define ssIsSolverComputingJacobian(S) ssIsComputingJacobian(S)\n\n#if !SS_SFCN\n#define ssSetComputingJacobian(S, boolVal) _ssSetComputingJacobian(S, boolVal)\n#else\n#define ssSetComputingJacobian(S, boolVal) ssSetComputingJacobian_cannot_be_used_in_SFunctions\n#endif\n\n#define ssIsSparseSlvrJacobian(S) ((S)->mdlInfo->mdlFlags.sparseSlvrJacobian == 1U)\n#define _ssSetSparseSlvrJacobian(S, boolVal) \\\n    (S)->mdlInfo->mdlFlags.sparseSlvrJacobian = ((boolVal) ? 1U : 0U)\n#if !SS_SFCN\n#define ssSetSparseSlvrJacobian(S, boolVal) _ssSetSparseSlvrJacobian(S, boolVal)\n#else\n#define ssSetSparseSlvrJacobian(S, boolVal) ssSetSparseSlvrJacobian_cannot_be_used_in_SFunctions\n#endif\n\n#define ssIsOutputMethodComputed(S) ((S)->mdlInfo->mdlFlags.outputMethodComputed == 1U)\n#define _ssSetOutputMethodComputed(S, boolVal) \\\n    (S)->mdlInfo->mdlFlags.outputMethodComputed = ((boolVal) ? 1U : 0U)\n#define ssIsSolverOutputMethodComputed(S) ssIsOutputMethodComputed(S)\n\n#if !SS_SFCN\n#define ssSetOutputMethodComputed(S, boolVal) _ssSetOutputMethodComputed(S, boolVal)\n#else\n#define ssSetOutputMethodComputed(S, boolVal) ssSetOutputMethodComputed_cannot_be_used_in_SFunctions\n#endif\n\n\n#define ssGetInlineParameters(S) ((S)->mdlInfo->mdlFlags.inlineParameters == 1U)\n#define _ssSetInlineParameters(S, boolVal) \\\n    (S)->mdlInfo->mdlFlags.inlineParameters = ((boolVal) ? 1U : 0U)\n\n#define ssGetDoingParameterInit(S) ((S)->mdlInfo->mdlFlags.doingParameterInit == 1U)\n#define ssSetDoingParameterInit(S, boolVal) \\\n    (S)->mdlInfo->mdlFlags.doingParameterInit = ((boolVal) ? 1U : 0U)\n\n#if !SS_SFCN\n#define ssSetInlineParameters(S, boolVal) _ssSetInlineParameters(S, boolVal)\n#else\n#define ssSetInlineParameters(S, boolVal) ssSetInlineParameters_cannot_be_used_in_SFunctions\n#endif\n\n/*\n * Only needed for accelerator mode simulation.\n */\n#define ssSetReinitializeEventBeingProcessed(S, reinitId)                                 \\\n    {                                                                                     \\\n                                                                                          \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_MODEL_WIDE_EVENT_BEING_PROCESSED, 0, \\\n                                        reinitId) _ssSafelyCallGenericFcnEnd;             \\\n    }\n\n/* solver assert check to be used by accelerator only */\n#define _ssGetSolverAssertCheck(S) ((S)->mdlInfo->mdlFlags.solverAssertCheck == 1U)\n#define _ssSetSolverAssertCheck(S, boolVal) \\\n    (S)->mdlInfo->mdlFlags.solverAssertCheck = ((boolVal) ? 1U : 0U)\n\n#define ssGetBlkStateChange(S) (S)->mdlInfo->mdlFlags.blkStateChange /*  (uint_T)    */\n#define ssSetBlkStateChange(S) (S)->mdlInfo->mdlFlags.blkStateChange = 1U\n#define ssClearBlkStateChange(S) (S)->mdlInfo->mdlFlags.blkStateChange = 0U\n\n#define ssIsMinorTimeStepWithModeChange(S) \\\n    (S)->mdlInfo->solverInfo->isMinorTimeStepWithModeChange /*  (boolean_T)  */\n#define ssSetIsMinorTimeStepWithModeChange(S) \\\n    (S)->mdlInfo->solverInfo->isMinorTimeStepWithModeChange = 1U\n#define ssClearIsMinorTimeStepWithModeChange(S) \\\n    (S)->mdlInfo->solverInfo->isMinorTimeStepWithModeChange = 0U\n\n#define ssIsModeUpdateTimeStep(S) \\\n    ((S)->mdlInfo->simTimeStep == MAJOR_TIME_STEP || ssIsMinorTimeStepWithModeChange(S))\n\n#define ssGetContTimeOutputInconsistentWithStateAtMajorStep(S) \\\n    (S)->mdlInfo->mdlFlags.cTimeOutputInconsistentWithStateAtMajorStep\n\n#if (!SS_SFCN || defined(RTW_GENERATED_S_FUNCTION))\n#define ssClearContTimeOutputInconsistentWithStateAtMajorStep(S) \\\n    (S)->mdlInfo->mdlFlags.cTimeOutputInconsistentWithStateAtMajorStep = 0U\n#endif\n\n#define ssGetBlockStateForSolverChangedAtMajorStep(S) \\\n    (S)->mdlInfo->mdlFlags.blockStateForSolverChangedAtMajorStep\n\n#if (!SS_SFCN || defined(RTW_GENERATED_S_FUNCTION))\n#define ssClearBlockStateForSolverChangedAtMajorStep(S) \\\n    (S)->mdlInfo->mdlFlags.blockStateForSolverChangedAtMajorStep = 0U\n#endif\n\n#define ssGetSolverRefineFactor(S) (S)->mdlInfo->solverRefineFactor /*   (int_T)       */\n#define _ssSetSolverRefineFactor(S, fact) (S)->mdlInfo->solverRefineFactor = (fact)\n#if !SS_SFCN\n#define ssSetSolverRefineFactor(S, fact) _ssSetSolverRefineFactor(S, fact)\n#else\n#define ssSetSolverRefineFactor(S, fact) ssSetSolverRefineFactor_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSolverRelTol(S) (S)->mdlInfo->solverRelTol /*   (real_T)      */\n#define _ssSetSolverRelTol(S, rtol) (S)->mdlInfo->solverRelTol = (rtol)\n#if !SS_SFCN\n#define ssSetSolverRelTol(S, rtol) _ssSetSolverRelTol(S, rtol)\n#else\n#define ssSetSolverRelTol(S, rtol) ssSetSolverRelTol_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSolverMaxOrder(S) (S)->mdlInfo->solverMaxOrder /*   (int_T)       */\n#define _ssSetSolverMaxOrder(S, maxOrder) (S)->mdlInfo->solverMaxOrder = (maxOrder)\n#if !SS_SFCN\n#define ssSetSolverMaxOrder(S, maxOrder) _ssSetSolverMaxOrder(S, maxOrder)\n#else\n#define ssSetSolverMaxOrder(S, maxOrder) ssSetSolverMaxOrder_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSolverExtrapolationOrder(S) \\\n    (S)->mdlInfo->solverExtrapolationOrder /*    (int_T)       */\n#define _ssSetSolverExtrapolationOrder(S, extrapOrder) \\\n    (S)->mdlInfo->solverExtrapolationOrder = (extrapOrder)\n#if !SS_SFCN\n#define ssSetSolverExtrapolationOrder(S, extrapOrder) _ssSetSolverExtrapolationOrder(S, extrapOrder)\n#else\n#define ssSetSolverExtrapolationOrder(S, extrapOrder) \\\n    ssSetSolverExtrapolationOrder_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSolverNumberNewtonIterations(S) \\\n    (S)->mdlInfo->solverNumberNewtonIterations /*    (int_T)   */\n#define _ssSetSolverNumberNewtonIterations(S, numIter) \\\n    (S)->mdlInfo->solverNumberNewtonIterations = (numIter)\n#if !SS_SFCN\n#define ssSetSolverNumberNewtonIterations(S, numIter) _ssSetSolverNumberNewtonIterations(S, numIter)\n#else\n#define ssSetSolverNumberNewtonIterations(S, numIter) \\\n    ssSetSolverNumberNewtonIterations_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetMaxZcBracketingIterations(S) \\\n    (S)->mdlInfo->solverInfo->maxZcBracketingIterations /*    (int_T)   */\n#define _ssSetMaxZcBracketingIterations(S, numZc) \\\n    (S)->mdlInfo->solverInfo->maxZcBracketingIterations = (numZc)\n#if !SS_SFCN\n#define ssSetMaxZcBracketingIterations(S, numZc) _ssSetMaxZcBracketingIterations(S, numZc)\n#else\n#define ssSetMaxZcBracketingIterations(S, numIter) \\\n    ssSetMaxZcBracketingIterations_cannot_be_used_in_SFunctions\n#endif\n\n\n#define ssGetMaxZcPerStep(S) (S)->mdlInfo->solverInfo->maxZcPerStep /*    (int_T)   */\n#define _ssSetMaxZcPerStep(S, numZc) (S)->mdlInfo->solverInfo->maxZcPerStep = (numZc)\n#if !SS_SFCN\n#define ssSetMaxZcPerStep(S, numZc) _ssSetMaxZcPerStep(S, numZc)\n#else\n#define ssSetMaxZcPerStep(S, numIter) ssSetMaxZcPerStep_cannot_be_used_in_SFunctions\n#endif\n\n\n\n#define _ssSetSolverMode(S, mode) (S)->mdlInfo->solverMode = (mode)\n\n#if !SS_SFCN\n#define ssSetSolverMode(S, mode) _ssSetSolverMode(S, mode)\n#else\n#define ssSetSolverMode(S, mode) ssSetSolverMode_cannot_be_used_in_SFunctions\n#endif\n\n\n#define ssGetMaxStepSize(S) (S)->mdlInfo->maxStepSize /*   (time_T)      */\n#define _ssSetMaxStepSize(S, size) (S)->mdlInfo->maxStepSize = (size)\n#if !SS_SFCN\n#define ssSetMaxStepSize(S, size) _ssSetMaxStepSize(S, size)\n#else\n#define ssSetMaxStepSize(S, size) ssSetMaxStepSize_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetMinStepSize(S) (S)->mdlInfo->minStepSize /*   (time_T)      */\n#define _ssSetMinStepSize(S, size) (S)->mdlInfo->minStepSize = (size)\n#if !SS_SFCN\n#define ssSetMinStepSize(S, size) _ssSetMinStepSize(S, size)\n#else\n#define ssSetMinStepSize(S, size) ssSetMinStepSize_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetMinStepViolatedError(S) ((S)->mdlInfo->mdlFlags.minStepViolatedError == 1U)\n#define _ssSetMinStepViolatedError(S, val) \\\n    (S)->mdlInfo->mdlFlags.minStepViolatedError = (val) ? 1U : 0U;\n\n#if !SS_SFCN\n#define ssSetMinStepViolatedError(S, val) _ssSetMinStepViolatedError(S, val)\n#else\n#define ssSetMinStepViolatedError(S, val) ssSetMinStepViolatedError_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetConsecutiveZCsError(S) (ssGetSolverConsecutiveZCsError(S) == 2)\n#define _ssSetConsecutiveZCsError(S, val) ssSetSolverConsecutiveZCsError(S, val + 1)\n#if !SS_SFCN\n#define ssSetConsecutiveZCsError(S, val) _ssSetConsecutiveZCsError(S, val)\n#else\n#define ssSetConsecutiveZCsError(S, val) ssSetConsecutiveZCsError_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetMaxNumMinSteps(S) (S)->mdlInfo->maxNumMinSteps /*   (in_T)        */\n#define _ssSetMaxNumMinSteps(S, num) (S)->mdlInfo->maxNumMinSteps = (num)\n#if !SS_SFCN\n#define ssSetMaxNumMinSteps(S, num) _ssSetMaxNumMinSteps(S, num)\n#else\n#define ssSetMaxNumMinSteps(S, min) ssSetMaxNumMinSteps_cannot_be_used_in_SFunctions\n#endif\n\n\n\n#define _ssSetFixedStepSize(S, size) (S)->mdlInfo->fixedStepSize = (size)\n#if !SS_SFCN\n#define ssSetFixedStepSize(S, size) _ssSetFixedStepSize(S, size)\n#else\n#define ssSetFixedStepSize(S, size) ssSetFixedStepSize_cannot_be_used_in_SFunctions\n#endif\n\n#if SS_MULTITASKING || SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n\n\n\n#define _ssSetPerTaskSampleHitsPtr(S, hitsMatrix) (S)->mdlInfo->perTaskSampleHits = (hitsMatrix)\n\n#if !SS_SFCN\n#define ssSetPerTaskSampleHitsPtr(S, hitsMatrix) _ssSetPerTaskSampleHitsPtr(S, hitsMatrix)\n#else\n#define ssSetPerTaskSampleHitsPtr(S, hitsMatrix) \\\n    ssSetPerTaskSampleHitsPtr_cannot_be_used_in_SFunctions\n#endif\n\n#endif\n\n#define ssGetSolverIsAtLeftPostOfContZcEvent(S) \\\n    ((S)->mdlInfo->solverInfo->isAtLeftPostOfContZcEvent == 1U)\n\n#define ssGetSolverIsAtRightPostOfContZcEvent(S) \\\n    ((S)->mdlInfo->solverInfo->isAtRightPostOfContZcEvent == 1U)\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n\n#define ssSetSolverInfo(S, ptr) (S)->mdlInfo->solverInfo = (ptr)\n#define ssGetSolverInfo(S) ((S)->mdlInfo->solverInfo)\n\n#define ssSetSolverZcSignalVector(S, ptr) ssGetSolverInfo(S)->zcSignalVector = (ptr)\n#define ssGetSolverZcSignalVector(S) (ssGetSolverInfo(S)->zcSignalVector)\n\n#define ssSetSolverZcEventsVector(S, ptr) ssGetSolverInfo(S)->zcEventsVector = (ptr)\n#define ssGetSolverZcEventsVector(S) (ssGetSolverInfo(S)->zcEventsVector)\n\n#define _ssGetSolverZcEventsVector(S) ssGetSolverZcEventsVector(S)\n#define _ssSetSolverZcEventsVector(S, ptr) ssSetSolverZcEventsVector(S, ptr)\n\n\n#define ssSetSolverZcSignalAttrib(S, ptr) ssGetSolverInfo(S)->zcSignalAttrib = (ptr)\n#define ssGetSolverZcSignalAttrib(S) (ssGetSolverInfo(S)->zcSignalAttrib)\n\n#define ssSetSolverZcSignalVectorLength(S, n) ssGetSolverInfo(S)->zcSignalVectorLength = (n)\n#define ssGetSolverZcSignalVectorLength(S) (ssGetSolverInfo(S)->zcSignalVectorLength)\n\n#define ssSetSolverFoundContZcEvents(S, val) ssGetSolverInfo(S)->foundContZcEvents = (val)\n#define ssGetSolverFoundContZcEvents(S) (ssGetSolverInfo(S)->foundContZcEvents)\n\n#define ssSetSolverIsAtLeftPostOfContZcEvent(S, val) \\\n    ssGetSolverInfo(S)->isAtLeftPostOfContZcEvent = (val)\n\n#define ssSetSolverIsAtRightPostOfContZcEvent(S, val) \\\n    ssGetSolverInfo(S)->isAtRightPostOfContZcEvent = (val)\n\n#define ssSetSolverZcPrevStateVector(S, val) ssSetPrevZCSigState(S, val)\n#define ssGetSolverZcPrevStateVector(S) ssGetPrevZCSigState(S)\n\n#define _ssGetSolverZcPrevStateVector(S) _ssGetPrevZCSigState(S)\n#define _ssSetSolverZcPrevStateVector(S, ptr) _ssSetPrevZCSigState(S, ptr)\n\n#define ssSetSolverAdaptiveZcDetection(S, val) ssGetSolverInfo(S)->adaptiveZcDetection = (val)\n#define ssGetSolverAdaptiveZcDetection(S) (ssGetSolverInfo(S)->adaptiveZcDetection)\n\n#define ssSetSolverNumZcSignals(S, n) ssGetSolverInfo(S)->numZcSignals = (n)\n#define ssGetSolverNumZcSignals(S) (ssGetSolverInfo(S)->numZcSignals)\n\n#define ssSetSolverStateProjection(S, val) ssGetSolverInfo(S)->stateProjection = (val)\n#define ssGetSolverStateProjection(S) (ssGetSolverInfo(S)->stateProjection)\n\n#define ssSetSolverMassMatrixType(S, val) ssGetSolverInfo(S)->massMatrixType = (val)\n#define ssGetSolverMassMatrixType(S) (ssGetSolverInfo(S)->massMatrixType)\n\n#define ssSetSolverMassMatrixNzMax(S, val) ssGetSolverInfo(S)->massMatrixNzMax = (val)\n#define ssGetSolverMassMatrixNzMax(S) (ssGetSolverInfo(S)->massMatrixNzMax)\n\n#define ssSetSolverMassMatrixIr(S, val) ssGetSolverInfo(S)->massMatrixIr = (val)\n#define ssGetSolverMassMatrixIr(S) (ssGetSolverInfo(S)->massMatrixIr)\n\n#define ssSetSolverMassMatrixJc(S, val) ssGetSolverInfo(S)->massMatrixJc = (val)\n#define ssGetSolverMassMatrixJc(S) (ssGetSolverInfo(S)->massMatrixJc)\n\n#define ssSetSolverMassMatrixPr(S, val) ssGetSolverInfo(S)->massMatrixPr = (val)\n#define ssGetSolverMassMatrixPr(S) (ssGetSolverInfo(S)->massMatrixPr)\n\n#define ssSetSolverConsistencyChecking(S, val) ssGetSolverInfo(S)->consistencyChecking = (val)\n#define ssGetSolverConsistencyChecking(S) (ssGetSolverInfo(S)->consistencyChecking)\n\n#define ssSetSolverRobustResetMethod(S, val) ssGetSolverInfo(S)->robustResetMethod = (val)\n#define ssGetSolverRobustResetMethod(S) (ssGetSolverInfo(S)->robustResetMethod)\n\n#define _ssSetSolverUpdateJacobianAtReset(S, val) ssGetSolverInfo(S)->updateJacobianAtReset = (val)\n#define ssSetSolverUpdateJacobianAtReset(S) \\\n    _ssSetSolverUpdateJacobianAtReset(S, (boolean_T)(1)) /* sticky */\n#define ssGetSolverUpdateJacobianAtReset(S) \\\n    (ssGetSolverInfo(S)->updateJacobianAtReset) /* boolean_T */\n\n#define ssSetSolverZcThreshold(S, val) ssGetSolverInfo(S)->zcThreshold = (val)\n#define ssGetSolverZcThreshold(S) ssGetSolverInfo(S)->zcThreshold\n\n#define ssSetSolverConsecutiveZCsStepRelTol(S, val) \\\n    ssGetSolverInfo(S)->solverConsecutiveZCsStepRelTol = (val)\n#define ssGetSolverConsecutiveZCsStepRelTol(S) ssGetSolverInfo(S)->solverConsecutiveZCsStepRelTol\n\n#define ssSetSolverMaxConsecutiveZCs(S, val) ssGetSolverInfo(S)->solverMaxConsecutiveZCs = (val)\n#define ssGetSolverMaxConsecutiveZCs(S) ssGetSolverInfo(S)->solverMaxConsecutiveZCs\n\n#define ssSetSolverMaxConsecutiveMinStep(S, val) \\\n    ssGetSolverInfo(S)->solverMaxConsecutiveMinStep = (val)\n#define ssGetSolverMaxConsecutiveMinStep(S) ssGetSolverInfo(S)->solverMaxConsecutiveMinStep\n\n#define ssSetSolverShapePreserveControl(S, val) \\\n    ssGetSolverInfo(S)->solverShapePreserveControl = (val)\n#define ssGetSolverShapePreserveControl(S) ssGetSolverInfo(S)->solverShapePreserveControl\n\n#define ssSetSolverJacobianMethodControl(S, val) \\\n    ssGetSolverInfo(S)->solverJacobianMethodControl = (val)\n#define ssGetSolverJacobianMethodControl(S) ssGetSolverInfo(S)->solverJacobianMethodControl\n\n#define ssGetSolverConsecutiveZCsError(S) ssGetSolverInfo(S)->consecutiveZCsError\n#define ssSetSolverConsecutiveZCsError(S, val) ssGetSolverInfo(S)->consecutiveZCsError = (val)\n\n#define ssGetSolverMaskedZcDiagnostic(S) ssGetSolverInfo(S)->maskedZcDiagnostic\n#define ssSetSolverMaskedZcDiagnostic(S, val) ssGetSolverInfo(S)->maskedZcDiagnostic = (val)\n\n#define ssGetSolverIgnoredZcDiagnostic(S) ssGetSolverInfo(S)->ignoredZcDiagnostic\n#define ssSetSolverIgnoredZcDiagnostic(S, val) ssGetSolverInfo(S)->ignoredZcDiagnostic = (val)\n\n\n/* Support old name RTWSolverInfo */\n\n#define ssGetRTWSolverInfo(S) ssGetSolverInfo(S)\n#define ssSetRTWSolverInfo(S, ptr) ssSetSolverInfo(S, ptr)\n\n#endif\n\n#if !SS_SFCN\n/*\n * The following logging macros are for use by the Real-Time Workshop and\n * should not be used by S-functions.\n */\n#define ssSetRTWLogInfo(S, ptr) (S)->mdlInfo->rtwLogInfo = (ptr) /* (RTWLogInfo *)  */\n\n#define ssGetRTWLogInfo(S) (S)->mdlInfo->rtwLogInfo /* (RTWLogInfo *)  */\n\n/* Maintained for xPC */\n#define ssGetLogT(S) rtliGetLogT((S)->mdlInfo->rtwLogInfo)\n#define ssGetLogX(S) rtliGetLogX((S)->mdlInfo->rtwLogInfo)\n#define ssGetLogY(S) rtliGetLogY((S)->mdlInfo->rtwLogInfo)\n\n#endif /* !SS_SFCN */\n\n\n#if !SS_SFCN\n/*\n * The following external mode macros are for use by the Real-Time Workshop and\n * should not be used by S-functions.\n */\n#define ssSetRTWExtModeInfo(S, ptr) (S)->mdlInfo->extModeInfo = (ptr)\n\n#define ssGetRTWExtModeInfo(S) (S)->mdlInfo->extModeInfo\n\n#endif /* !SS_SFCN */\n\n\n/* BlockIO vector - used by the Real-Time Workshop and Simulink. This\n *  is starting address of the block input/output vector. All non-virtual\n *  output ports have a slot into which they write their output.\n *\n *  User written S-functions should not access this field.\n */\n#define _ssGetBlockIO(S) ((real_T*)((S)->mdlInfo->blockIO)) /*  (real_T *)       */\n#if !SS_SFCN\n#define ssGetBlockIO(S) _ssGetBlockIO(S)\n#else\n#define ssGetBlockIO(S) ssGetBlockIO_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetBlockIO(S, io) (S)->mdlInfo->blockIO = ((void*)(io))\n#if !SS_SFCN\n#define ssSetBlockIO(S, io) _ssSetBlockIO(S, io)\n#else\n#define ssSetBlockIO(S, io) ssSetBlockIO_cannot_be_used_in_SFunctions\n#endif\n\n/* ReservedForXPC\n *\n *  User written S-functions should not access this field.\n */\n#define _ssGetReservedForXPC(S) ((S)->mdlInfo->reservedForXPC)\n#if !SS_SFCN\n#define ssGetReservedForXPC(S) _ssGetReservedForXPC(S)\n#else\n#define ssGetReservedForXPC(S) ssGetReservedForXPC_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssSetReservedForXPC(S, rxpc) (S)->mdlInfo->reservedForXPC = ((void*)(rxpc))\n#if !SS_SFCN\n#define ssSetReservedForXPC(S, rxpc) _ssSetReservedForXPC(S, rxpc)\n#else\n#define ssSetReservedForXPC(S, rxpc) ssSetReservedForXPC_cannot_be_used_in_SFunctions\n#endif\n\n/* ConstBlockIO vector - used by the Real-Time Workshop.\n *\n *  User written S-functions should not access this field.\n */\n#define _ssGetConstBlockIO(S) ((const void*)((S)->sizes.constBlockIO)) /* (const void *) */\n#if !SS_SFCN\n#define ssGetConstBlockIO(S) _ssGetConstBlockIO(S)\n#else\n#define ssGetConstBlockIO(S) ssGetConstBlockIO_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetConstBlockIO(S, io) (S)->sizes.constBlockIO = ((const void*)(io))\n#if !SS_SFCN\n#define ssSetConstBlockIO(S, io) _ssSetConstBlockIO(S, io)\n#else\n#define ssSetConstBlockIO(S, io) ssSetConstBlockIO_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN || defined(RTW_GENERATED_S_FUNCTION)\n#define ssGetTimeOfNextSampleHitPtr(S) (S)->mdlInfo->timeOfNextSampleHit\n#endif\n\n#if !SS_SFCN\n#define ssSetTimeOfNextSampleHitPtr(S, ptr) (S)->mdlInfo->timeOfNextSampleHit = (ptr)\n#endif\n\n/* varNextHitTimesList vector - used by Simulink.\n *\n *  User written S-functions should not access this field.\n */\n\n#if !SS_SFCN\n#define ssGetVarNextHitTime(S, i) _ssGetVarNextHitTime(S, i)\n#else\n#define ssGetVarNextHitTime(S, i) ssGetVarNextHitTime_cannot_be_used_in_SFunctions\n#endif\n\n\n#if !SS_SFCN\n#define ssSetVarNextHitTime(S, i, value) _ssSetVarNextHitTime(S, i, value)\n#else\n#define ssSetVarNextHitTime(S, i, value) ssSetVarNextHitTime_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetVarNextHitTimesListPtr(S) (S)->mdlInfo->varNextHitTimesList /* (real_T *) */\n\n#define _ssSetVarNextHitTimesListPtr(S, listPtr) \\\n    (S)->mdlInfo->varNextHitTimesList = ((real_T*)(listPtr))\n\n#if !SS_SFCN\n#define ssSetVarNextHitTimesListPtr(S, listPtr) _ssSetVarNextHitTimesListPtr(S, listPtr)\n#else\n#define ssSetVarNextHitTimesListPtr(S, listPtr) \\\n    ssSetVarNextHitTimesListPtr_cannot_be_used_in_SFunctions\n#endif\n\n/* tNextWasAdjusted vector - used by Simulink.\n *\n *  User written S-functions should not access this field.\n */\n\n#define ssGetTNextWasAdjusted(S, sti) ((S)->mdlInfo->tNextWasAdjusted[sti]) /* (boolean_T) */\n#if !SS_SFCN\n#define _ssSetTNextWasAdjusted(S, sti, val) (S)->mdlInfo->tNextWasAdjusted[sti] = (val)\n#define ssSetTNextWasAdjustedPtr(S, ptr) (S)->mdlInfo->tNextWasAdjusted = (ptr)\n#endif\n\n#define _ssGetDefaultParam(S) (S)->mdlInfo->defaultParam /*   (real_T *)    */\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetDefaultParam(S) _ssGetDefaultParam(S)\n#else\n#define ssGetDefaultParam(S) ssGetDefaultParam_cannot_be_used_in_SFunctions\n#endif\n\n/*\n * ssSetDefaultParam - Used by the Real-Time Workshop. This contains\n * a pointer to all the model's parameters.\n */\n\n#define _ssSetDefaultParam(S, paramVector) (S)->mdlInfo->defaultParam = (paramVector)\n#if !SS_SFCN\n#define ssSetDefaultParam(S, paramVector) _ssSetDefaultParam(S, paramVector)\n#else\n#define ssSetDefaultParam(S, paramVector) ssSetDefaultParam_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetDefaultParamValue(S, paramIdx) \\\n    (S)->mdlInfo->defaultParam[paramIdx] /*   (real_T)      */\n#if !SS_SFCN\n#define ssGetDefaultParamValue(S, paramIdx) _ssGetDefaultParamValue(S, paramIdx)\n#else\n#define ssGetDefaultParamValue(S, paramIdx) ssGetDefaultParamValue_cannot_be_used_in_SFunctions\n#endif\n#define _ssSetDefaultParamValue(S, paramIdx, paramValue) \\\n    (S)->mdlInfo->defaultParam[paramIdx] = (paramValue)\n#if !SS_SFCN\n#define ssSetDefaultParamValue(S, paramIdx, paramValue) \\\n    _ssSetDefaultParamValue(S, paramIdx, paramValue)\n#else\n#define ssSetDefaultParamValue(S, paramIdx, paramValue) \\\n    ssSetDefaultParamValue_cannot_be_used_in_SFunctions\n#endif\n\n/*\n * ssSetModelMappingInfo - Used by the Real-Time Workshop. This contains\n * a pointer to all the model's mapping information which is used by\n * external applications to \"probe\" the models, parameter, block I/O, etc\n * vectors.\n */\n\n#define _ssSetModelMappingInfo(S, mapInfo) (S)->mdlInfo->mappingInfo = (void*)(mapInfo)\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssSetModelMappingInfo(S, mapInfo) _ssSetModelMappingInfo(S, mapInfo)\n#else\n#define ssSetModelMappingInfo(S, paramVector) ssSetModelMappingInfo_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssGetModelMappingInfo(S) (S)->mdlInfo->mappingInfo /*   (void*)    */\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetModelMappingInfo(S) _ssGetModelMappingInfo(S)\n#else\n#define ssGetModelMappingInfo(S) ssGetModelMappingInfo_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetContextSysRanBCPtr(S, ptr)                                       \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_CONTEXT_SYS_PTR, 0, (ptr)) \\\n        _ssSafelyCallGenericFcnEnd\n#else\n#define ssGetContextSysRanBCPtr(S) ssGetContextSysRanBCPtr_cannot_be_used_in_SFunctions\n#endif\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetContextSysTid(S, tid) \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_CONTEXT_TID, 0, (tid)) _ssSafelyCallGenericFcnEnd\n#else\n#define ssGetContextSysTid(S) ssGetContextSysTid_cannot_be_used_in_SFunctions\n#endif\n\n#define ssCallAccelRunBlock(S, sysIdx, blkIdx, function) \\\n    (*(S)->mdlInfo->accelRunBlock)(S, sysIdx, blkIdx, function);\n\n#define _ssSetAccelRunBlockFcn(S, fcn) (S)->mdlInfo->accelRunBlock = (fcn)\n#define _ssSetBdRefPtr(S, ptr) (S)->mdlInfo->bdRefPtr = ((void*)ptr)\n#define _ssGetBdRefPtr(S) (S)->mdlInfo->bdRefPtr /*   (void*)    */\n\n#if !SS_SFCN\n#define ssSetAccelRunBlockFcn(S, fcn) _ssSetAccelRunBlockFcn(S, fcn)\n#define ssSetBdRefPtr(S, ptr) _ssSetBdRefPtr(S, ptr)\n#define ssGetBdRefPtr(S) _ssGetBdRefPtr(S)\n#else\n#define ssSetAccelRunBlockFcn(S, fcn) ssSetAccelRunBlockFcn_cannot_be_used_in_SFunctions\n#define ssSetBdRefPtr(S, ptr) ssSetBdRefPtr_cannot_be_used_in_SFunctions\n#define ssGetBdRefPtr(S) ssGetBdRefPtr_cannot_be_used_in_SFunctions\n#endif\n\n#if SS_SL_INTERNAL\n#define ssSetWriteRTWStrFcn(S, fcn) (S)->mdlInfo->writeRTWStrFcn = (fcn)\n#define ssSetWriteRTWNameValuePairFcn(S, fcn) (S)->mdlInfo->writeRTWNameValuePairFcn = (fcn)\n#define ssSetWriteRTWParameterFcn(S, fcn) (S)->mdlInfo->writeRTWParameterFcn = (fcn)\n#define ssSetWriteRTWFcnArg(S, fcnarg) (S)->mdlInfo->writeRTWFcnArg = (fcnarg)\n#define ssSetGenericFcn(S, fcn) (S)->mdlInfo->genericFcn = (fcn)\n#endif\n\n/* ===--------------------------------------------------------------------=== */\n/*              SLCG string context access functions                          */\n/* ===--------------------------------------------------------------------=== */\n#if (SS_SFCN_FOR_SIM)\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#endif\n#if (SS_SFCN_FOR_SIM)\nextern int_T _ssCreateSLCGStringBuffer(SimStruct* S);\n#define ssCreateSLCGStringBuffer(S) _ssCreateSLCGStringBuffer(S)\n#else\n#define ssCreateSLCGStringBuffer(S)\n#endif\n#if (SS_SFCN_FOR_SIM)\nextern void _ssAddToSLCGStringBuffer(SimStruct* S, int_T aStringBufferIdx, char* aString);\n#define ssAddToSLCGStringBuffer(S, aStringBufferIdx, aString) \\\n    _ssAddToSLCGStringBuffer(S, aStringBufferIdx, aString)\n#else\n#define ssAddToSLCGStringBuffer(S, aStringBufferIdx, aString)\n#endif\n#if (SS_SFCN_FOR_SIM)\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* ===--------------------------------------------------------------------=== */\n/*              End of SLCG string context access functions                   */\n/* ===--------------------------------------------------------------------=== */\n\n/*\n * Signal Access.\n */\n#if SS_SL_INTERNAL\n#define ssSetSignalAccess(S, ptr) (S)->mdlInfo->signalAccess = (ptr)\n\n#define ssGetSignalAccess(S) ((S)->mdlInfo->signalAccess)\n\n#define ssSetSelectedSignalsFcn(S, fcn) (S)->mdlInfo->signalAccess->SelectedSignals = (fcn)\n\n#define ssSetSigListCreateFcn(S, fcn) (S)->mdlInfo->signalAccess->SigListCreate = (fcn)\n\n#define ssSetSigListDestroyFcn(S, fcn) (S)->mdlInfo->signalAccess->SigListDestroy = (fcn)\n\n#define ssSetSigListUnavailSigAlertFcn(S, fcn) \\\n    (S)->mdlInfo->signalAccess->SigListUnavailSigAlert = (fcn)\n\n#define ssSetGenericDestroyFcn(S, fcn) (S)->mdlInfo->signalAccess->utFree = (fcn)\n\n#define ssSetGetPortNameFcn(S, fcn) (S)->mdlInfo->signalAccess->GetPortName = (fcn)\n\n#define ssSetUnselectSigFcn(S, fcn) (S)->mdlInfo->signalAccess->UnselectSig = (fcn)\n\n#define ssSetSigListGetNumRegionsFcn(S, fcn) \\\n    (S)->mdlInfo->signalAccess->SigListGetNumRegions = (fcn)\n\n#define ssSetSigListGetFirstRegFcn(S, fcn) (S)->mdlInfo->signalAccess->SigListGetFirstReg = (fcn)\n\n#define ssSetSigListGetNumElementsFcn(S, fcn) \\\n    (S)->mdlInfo->signalAccess->SigListGetNumElements = (fcn)\n\n#define ssSetSigListGetIfTieWrapFcn(S, fcn) (S)->mdlInfo->signalAccess->SigListGetIfTieWrap = (fcn)\n#endif\n\n/*\n * Data type Access.\n */\n#if !SS_SFCN_LEVEL_1\n\n#if SS_SL_INTERNAL\n#define ssSetDataTypeAccess(S, dta) (S)->mdlInfo->dataTypeAccess = (dta)\n\n#define dtaGetDataTypeTable(dta) ((dta)->dataTypeTable)\n#define dtaSetDataTypeTable(dta, table) (dta)->dataTypeTable = (table)\n\n#define dtaGetRegisterDataTypeFcn(dta) ((dta)->registerFcn)\n#define dtaSetRegisterDataTypeFcn(dta, fcn) (dta)->registerFcn = (fcn)\n\n#define dtaGetRegisterDataTypeFcnWithCheck(dta) ((dta)->registerFcnWithCheck)\n#define dtaSetRegisterDataTypeFcnWithCheck(dta, fcn) (dta)->registerFcnWithCheck = (fcn)\n\n#define dtaGetNumDataTypesFcn(dta) ((dta)->getNumDataTypesFcn)\n#define dtaSetGetNumDataTypesFcn(dta, fcn) (dta)->getNumDataTypesFcn = (fcn)\n\n#define dtaGetDataTypeIdFcn(dta) ((dta)->getIdFcn)\n#define dtaSetGetDataTypeIdFcn(dta, fcn) (dta)->getIdFcn = (fcn)\n\n#define dtaGetGetGenericDTAIntProp(dta) ((dta)->getGenericDTAIntProp)\n#define dtaSetGetGenericDTAIntProp(dta, fcn) (dta)->getGenericDTAIntProp = (fcn)\n#define dtaGetSetGenericDTAIntProp(dta) ((dta)->setGenericDTAIntProp)\n#define dtaSetSetGenericDTAIntProp(dta, fcn) (dta)->setGenericDTAIntProp = (fcn)\n\n#define dtaGetGetGenericDTAIntElemProp(dta) ((dta)->getGenericDTAIntElemProp)\n#define dtaSetGetGenericDTAIntElemProp(dta, fcn) (dta)->getGenericDTAIntElemProp = (fcn)\n#define dtaGetSetGenericDTAIntElemProp(dta) ((dta)->setGenericDTAIntElemProp)\n#define dtaSetSetGenericDTAIntElemProp(dta, fcn) (dta)->setGenericDTAIntElemProp = (fcn)\n\n#define dtaGetGetGenericDTARealElemProp(dta) ((dta)->getGenericDTARealElemProp)\n#define dtaSetGetGenericDTARealElemProp(dta, fcn) (dta)->getGenericDTARealElemProp = (fcn)\n#define dtaGetSetGenericDTARealElemProp(dta) ((dta)->setGenericDTARealElemProp)\n#define dtaSetSetGenericDTARealElemProp(dta, fcn) (dta)->setGenericDTARealElemProp = (fcn)\n\n#define dtaGetGetGenericDTAVoidProp(dta) ((dta)->getGenericDTAVoidProp)\n#define dtaSetGetGenericDTAVoidProp(dta, fcn) (dta)->getGenericDTAVoidProp = (fcn)\n#define dtaGetSetGenericDTAVoidProp(dta) ((dta)->setGenericDTAVoidProp)\n#define dtaSetSetGenericDTAVoidProp(dta, fcn) (dta)->setGenericDTAVoidProp = (fcn)\n\n#define dtaGetGetGenericDTAVoidElemProp(dta) ((dta)->getGenericDTAVoidElemProp)\n#define dtaSetGetGenericDTAVoidElemProp(dta, fcn) (dta)->getGenericDTAVoidElemProp = (fcn)\n#define dtaGetSetGenericDTAVoidElemProp(dta) ((dta)->setGenericDTAVoidElemProp)\n#define dtaSetSetGenericDTAVoidElemProp(dta, fcn) (dta)->setGenericDTAVoidElemProp = (fcn)\n\n#define dtaGetGetConvertBetweenFcn(dta) ((dta)->getConvertBetweenFcn)\n#define dtaSetGetConvertBetweenFcn(dta, fcn) (dta)->getConvertBetweenFcn = (fcn)\n#define dtaGetSetConvertBetweenFcn(dta) ((dta)->setConvertBetweenFcn)\n#define dtaSetSetConvertBetweenFcn(dta, fcn) (dta)->setConvertBetweenFcn = (fcn)\n\n#define dtaGetGetConstructFcn(dta) ((dta)->getConstructFcn)\n#define dtaSetGetConstructFcn(dta, fcn) (dta)->getConstructFcn = (fcn)\n#define dtaGetSetConstructFcn(dta) ((dta)->setConstructFcn)\n#define dtaSetSetConstructFcn(dta, fcn) (dta)->setConstructFcn = (fcn)\n\n#define dtaGetGetDestructFcn(dta) ((dta)->getDestructFcn)\n#define dtaSetGetDestructFcn(dta, fcn) (dta)->getDestructFcn = (fcn)\n#define dtaGetSetDestructFcn(dta) ((dta)->setDestructFcn)\n#define dtaSetSetDestructFcn(dta, fcn) (dta)->setDestructFcn = (fcn)\n\n#define dtaGetGetDeepCopyFcn(dta) ((dta)->getDeepCopyFcn)\n#define dtaSetGetDeepCopyFcn(dta, fcn) (dta)->getDeepCopyFcn = (fcn)\n#define dtaGetSetDeepCopyFcn(dta) ((dta)->setDeepCopyFcn)\n#define dtaSetSetDeepCopyFcn(dta, fcn) (dta)->setDeepCopyFcn = (fcn)\n\n#define dtaGetGetSizeOfFcn(dta) ((dta)->getSizeOfFcn)\n#define dtaSetGetSizeOfFcn(dta, fcn) (dta)->getSizeOfFcn = (fcn)\n#define dtaGetSetSizeOfFcn(dta) ((dta)->setSizeOfFcn)\n#define dtaSetSetSizeOfFcn(dta, fcn) (dta)->setSizeOfFcn = (fcn)\n\n#define dtaGetGetContainedDataFcn(dta) ((dta)->getContainedDataFcn)\n#define dtaSetGetContainedDataFcn(dta, fcn) (dta)->getContainedDataFcn = (fcn)\n#define dtaGetSetContainedDataFcn(dta) ((dta)->setContainedDataFcn)\n#define dtaSetSetContainedDataFcn(dta, fcn) (dta)->setContainedDataFcn = (fcn)\n\n#define dtaGetGetContainedDataDimsFcn(dta) ((dta)->getContainedDataDimsFcn)\n#define dtaSetGetContainedDataDimsFcn(dta, fcn) (dta)->getContainedDataDimsFcn = (fcn)\n#define dtaGetSetContainedDataDimsFcn(dta) ((dta)->setContainedDataDimsFcn)\n#define dtaSetSetContainedDataDimsFcn(dta, fcn) (dta)->setContainedDataDimsFcn = (fcn)\n\n#define dtaGetGetDataConstructFcn(dta) ((dta)->getDataConstructFcn)\n#define dtaSetGetDataConstructFcn(dta, fcn) (dta)->getDataConstructFcn = (fcn)\n#define dtaGetSetDataConstructFcn(dta) ((dta)->setDataConstructFcn)\n#define dtaSetSetDataConstructFcn(dta, fcn) (dta)->setDataConstructFcn = (fcn)\n\n#define dtaGetGetSerializeFcn(dta) ((dta)->getSerializeFcn)\n#define dtaSetGetSerializeFcn(dta, fcn) (dta)->getSerializeFcn = (fcn)\n#define dtaGetSetSerializeFcn(dta) ((dta)->setSerializeFcn)\n#define dtaSetSetSerializeFcn(dta, fcn) (dta)->setSerializeFcn = (fcn)\n\n#define dtaGetGetDeserializeFcn(dta) ((dta)->getDeserializeFcn)\n#define dtaSetGetDeserializeFcn(dta, fcn) (dta)->getDeserializeFcn = (fcn)\n#define dtaGetSetDeserializeFcn(dta) ((dta)->setDeserializeFcn)\n#define dtaSetSetDeserializeFcn(dta, fcn) (dta)->setDeserializeFcn = (fcn)\n\n#define dtaGetGetSerializeSizeFcn(dta) ((dta)->getSerializeSizeFcn)\n#define dtaSetGetSerializeSizeFcn(dta, fcn) (dta)->getSerializeSizeFcn = (fcn)\n#define dtaGetSetSerializeSizeFcn(dta) ((dta)->setSerializeSizeFcn)\n#define dtaSetSetSerializeSizeFcn(dta, fcn) (dta)->setSerializeSizeFcn = (fcn)\n\n#define dtaGetGetGenericDTAUnaryFcnGW(dta) ((dta)->getGenericDTAUnaryFcnGW)\n#define dtaSetGetGenericDTAUnaryFcnGW(dta, fcn) (dta)->getGenericDTAUnaryFcnGW = (fcn)\n#define dtaGetSetGenericDTAUnaryFcnGW(dta) ((dta)->setGenericDTAUnaryFcnGW)\n#define dtaSetSetGenericDTAUnaryFcnGW(dta, fcn) (dta)->setGenericDTAUnaryFcnGW = (fcn)\n\n#define dtaGetGetGenericDTABinaryFcnGW(dta) ((dta)->getGenericDTABinaryFcnGW)\n#define dtaSetGetGenericDTABinaryFcnGW(dta, fcn) (dta)->getGenericDTABinaryFcnGW = (fcn)\n#define dtaGetSetGenericDTABinaryFcnGW(dta) ((dta)->setGenericDTABinaryFcnGW)\n#define dtaSetSetGenericDTABinaryFcnGW(dta, fcn) (dta)->setGenericDTABinaryFcnGW = (fcn)\n\n#define dtaSetGetDTADiagnostic(dta, fcn) (dta)->getGenericDTADiagnostic = (fcn)\n\n#endif\n\n/* Fixed-Point license manager access*/\n\n#if SS_SIM\n#define ssSetFixedPointLicenseAccess(S, idx, d)                            \\\n    _ssSafelyCallGenericFcnStart(S)(S, GENFCNFIXPT_LICENSE, idx, (void*)d) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\n\n\n#endif\n\ntypedef struct {\n    void* data;\n    int_T dtId;\n    int8_T* result;\n} DataQueryInfo;\n\n#define _ssIsPositiveDataValue(S, inData, inDtId, inResult)                          \\\n    {                                                                                \\\n        DataQueryInfo info;                                                          \\\n        info.data = (inData);                                                        \\\n        info.dtId = (inDtId);                                                        \\\n        info.result = (inResult);                                                    \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_IS_POSITIVE_DATA_VALUE, 0, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                              \\\n    }\n\n#define _ssSignDataValue(S, inData, inDtId, inResult)                         \\\n    {                                                                         \\\n        DataQueryInfo info;                                                   \\\n        info.data = (inData);                                                 \\\n        info.dtId = (inDtId);                                                 \\\n        info.result = (inResult);                                             \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SIGN_DATA_VALUE, 0, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                       \\\n    }\n\n/*\n * User-defined datatypes\n */\n\n#if !SS_SFCN_LEVEL_1\n#if SS_SIM\n#define ssRegisterTypeFromExpr(S, n, id)                                       \\\n    {                                                                          \\\n        ssRegisterTypeFromNameType _slRegisterTypeFromNameInfo;                \\\n        _slRegisterTypeFromNameInfo.name = (n);                                \\\n        _slRegisterTypeFromNameInfo.dataTypeId = (id);                         \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REGISTER_TYPE_FROM_EXPR, 0, \\\n                                        (void*)&_slRegisterTypeFromNameInfo)   \\\n            _ssSafelyCallGenericFcnEnd;                                        \\\n    }\n#define ssRegisterTypeFromExprNoError(S, n, id)                                         \\\n    {                                                                                   \\\n        ssRegisterTypeFromNameType _slRegisterTypeFromNameInfo;                         \\\n        _slRegisterTypeFromNameInfo.name = (n);                                         \\\n        _slRegisterTypeFromNameInfo.dataTypeId = (id);                                  \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REGISTER_TYPE_FROM_EXPR_NO_ERROR, 0, \\\n                                        (void*)&_slRegisterTypeFromNameInfo)            \\\n            _ssSafelyCallGenericFcnEnd;                                                 \\\n    }\n\n\n#else\n#define ssRegisterTypeFromExpr(S, name, id)\n#define ssRegisterTypeFromExprNoError(S, name, id)\n\n\n#endif\n\n#endif\n\n\n\n/*\n * mexApiInt2/MexApiReal1/MexApiReal2\n * used by the mex api (simulink.c)\n */\n#define ssGetMexApiInt2(S) (S)->mdlInfo->mexApiInt2 /*   (int_T)       */\n#define ssSetMexApiInt2(S, val) (S)->mdlInfo->mexApiInt2 = (val)\n\n#define ssGetMexApiReal1(S) (S)->mdlInfo->mexApiReal1              /*   (real_T)      */\n#define ssSetMexApiReal1(S, val) (S)->mdlInfo->mexApiReal1 = (val) /*   (real_T)      */\n\n#define ssGetMexApiReal2(S) (S)->mdlInfo->mexApiReal2              /*   (real_T)      */\n#define ssSetMexApiReal2(S, val) (S)->mdlInfo->mexApiReal2 = (val) /*   (real_T)      */\n\n#define ssGetMexApiVoidPtr1(S) (S)->mdlInfo->mexApiVoidPtr1 /*   (void *)      */\n#define ssSetMexApiVoidPtr1(S, val) (S)->mdlInfo->mexApiVoidPtr1 = (void*)(val)\n\n/*\n * Set data alignment\n */\n#define ssSetDataAlignment(S, num)                                            \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_DATA_ALIGNMENT, num, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n\n/*---------------------------- get system level setting ---------------------*/\n\n#include \"sl_prodhwdevicetype.h\"\n\n/* Get whether net slope corrections can use division\n */\n#define ssGetNetSlopeViaDivision(S, result)                                             \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_NET_SLOPE_VIA_DIVISION, 0, result) \\\n        _ssSafelyCallGenericFcnEnd\n\n/* Get whether use strict single or double upcasting when necessary\n */\n#define ssGetSupportStrictSingle(S, result)                                    \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_STRICT_SINGLE, 0, result) \\\n        _ssSafelyCallGenericFcnEnd\n\n/*================================================*\n * Running simulation type                        *\n *================================================*/\n\n#define ssGetSimType(S, result)                                                 \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_SIMULATIONTYPE, 0, result) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssGetIsInteractiveSim(S, result)                                          \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_ISINTERACTIVESIM, 0, result) \\\n        _ssSafelyCallGenericFcnEnd\n\n/* get the double override setting of current system\n */\n#define ssGetDataTypeOverride(S, result)                                          \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_DATATYPEOVERRIDE, 0, result) \\\n        _ssSafelyCallGenericFcnEnd\n\n/* get the datatype override applies to setting of current system\n */\n#define ssGetDataTypeOverrideAppliesTo(S, result)                                          \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_DATATYPEOVERRIDEAPPLIESTO, 0, result) \\\n        _ssSafelyCallGenericFcnEnd\n\n\n/* The term Doubles-Override is outdated and misleading.\n * Instead, the terms Data-Type-Override and Scaled-Doubles should be used\n * as appropriate.\n * The follow definition is provided for backwards compatibility\n */\n#define ssGetDblOverride(S, result) (ssGetDataTypeOverride((S), (result)))\n\n#define ssGetMinMaxOverflowLogging(S, result)                              \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_MINMAXLOG, 0, result) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssGetMinMaxOverflowArchiveMode(S, result)                              \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_MINMAXARCHIVE, 0, result) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssGetProdHWDeviceInfo(S, result)                                          \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_PRODHWDEVICEINFO, 0, result) \\\n        _ssSafelyCallGenericFcnEnd\n\n/*---------------------------- S->callSys  ----------------------------------*/\n\n#define _ssSetSFcnExportsFunctionCalls(S)                                                    \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_EXPORTS_FUNCTION_CALLS, 0, (void*)NULL) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssSetAcceptsFcnCallInputs(S)                                                         \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_ACCEPTS_FCNCALL_INPUTS, 0, (void*)NULL) \\\n        _ssSafelyCallGenericFcnEnd\n\n/*\n * ssExportOutputFcn,\n * ssExportEnableFcn,\n * ssExportDisableFcn -\n *   S-functions which export function calls use this in\n *   mdlInitializeSizes to specify the custom user functions\n *   which are exported to Simulink by means of the input ports\n *   of the S-function.\n */\n#if defined(SS_SFCN) && defined(S_FUNCTION_EXPORTS_FUNCTION_CALLS)\n\n#define ssExportOutputFcn(S, pIdx, oFcn)                                              \\\n    {                                                                                 \\\n        SysOutputFcn _oFcn = (SysOutputFcn)oFcn;                                      \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_EXPORTED_OUTPUT_FCN, (pIdx), \\\n                                        (void*)&_oFcn) _ssSafelyCallGenericFcnEnd;    \\\n    }\n\n#define ssExportEnableFcn(S, pIdx, oFcn)                                              \\\n    {                                                                                 \\\n        SysOutputFcn _oFcn = (SysOutputFcn)oFcn;                                      \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_EXPORTED_ENABLE_FCN, (pIdx), \\\n                                        (void*)&_oFcn) _ssSafelyCallGenericFcnEnd;    \\\n    }\n\n#define ssExportDisableFcn(S, pIdx, oFcn)                                              \\\n    {                                                                                  \\\n        SysOutputFcn _oFcn = (SysOutputFcn)oFcn;                                       \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_EXPORTED_DISABLE_FCN, (pIdx), \\\n                                        (void*)&_oFcn) _ssSafelyCallGenericFcnEnd;     \\\n    }\n\n#define ssInportIsLatched(S, pIdx)                                                 \\\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_INPORT_LATCHED, (pIdx), NULL) \\\n        _ssSafelyCallGenericFcnEnd\n\n#endif\n\n\n\n/*\n * ssGetCallSystemNumFcnCallDestinations:\n *   Return number of fcn-call destinations called by S-function's\n *   first output port and elemIdx-th element\n */\n/* GenericFcn implementation */\n#define ssGetNumFcnCallDestinations(S, elemIdx, result)                                   \\\n    {                                                                                     \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_NUM_FCNCALL_DEST, elemIdx, result) \\\n            _ssSafelyCallGenericFcnEnd;                                                   \\\n    }\n\n\n\n/*\n * ssCallSystem -\n *  Provided for backwards compatibility. Here, tid is hardcoded is 0.\n */\n#define ssCallSystem(S, element) ssCallSystemWithTid(S, element, 0)\n\n#define _ssSetCallSystemOutputArg1List(S, list) (S)->callSys.args1 = (list)\n\n#define _ssSetCallSystemOutputArg2List(S, list) (S)->callSys.args2 = (list)\n\n#define _ssSetCallSystemOutputFcnList(S, list) (S)->callSys.fcns = (list)\n\n#if SS_SL_INTERNAL || SS_RTW || SS_GENERATED_S_FUNCTION\n/*\n * The following cannot be used in S-functions\n */\n#define ssGetCallSystemOutputArg1List(S) (S)->callSys.args1 /* (void**)        */\n#define ssSetCallSystemOutputArg1List(S, list) _ssSetCallSystemOutputArg1List(S, list)\n\n#define ssGetCallSystemOutputArg2List(S) (S)->callSys.args2 /* (int_T*)        */\n#define ssSetCallSystemOutputArg2List(S, list) _ssSetCallSystemOutputArg2List(S, list)\n\n#define ssGetCallSystemOutputFcnList(S) (S)->callSys.fcns /* (SysOutputFcn*) */\n#define ssSetCallSystemOutputFcnList(S, list) _ssSetCallSystemOutputFcnList(S, list)\n#else\n#define ssSetCallSystemOutputArg1List(S, list) \\\n    ssSetCallSystemOutputArg1List_cannot_be_used_in_SFunctions\n#define ssSetCallSystemOutputArg2List(S, list) \\\n    ssSetCallSystemOutputArg2List_cannot_be_used_in_SFunctions\n#define ssSetCallSystemOutputFcnList(S, list) \\\n    ssSetCallSystemOutputFcnList_cannot_be_used_in_SFunctions\n#endif\n\n\n#define ssGetBlkSupportConcurrentTasks(S, result)                                         \\\n    {                                                                                     \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_BLK_SUPPORT_CONCURRENT_TASKS, 0, \\\n                                        (result)) _ssSafelyCallGenericFcnEnd;             \\\n    }\n\n#define ssSetBlkSupportConcurrentTasks(S, value)                                                  \\\n    {                                                                                             \\\n        int_T val = value;                                                                        \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BLK_SUPPORT_CONCURRENT_TASKS, 0, (&val)) \\\n            _ssSafelyCallGenericFcnEnd;                                                           \\\n    }\n#if SS_SIM\n#define ssGetConcurrentTasks(S) ((S)->sizes.flags.isConcurrentTasks == 1U)\n\n#define ssSetConcurrentTasks(S, boolVal) ((S)->sizes.flags.isConcurrentTasks = (boolVal) ? 1U : 0U)\n#else\n#define ssGetConcurrentTasks(S) ssGetConcurrentTasks_cannot_be_used_in_RTW\n\n#define ssSetConcurrentTasks(S) ssSetConcurrentTasks_cannot_be_used_in_RTW\n\n#endif\n\n/*---------------------------- S->regDataType  ------------------------------*/\n\n#if !SS_SFCN\n/*\n * The following cannot be used in S-functions\n */\n#define ssGetDataTypeFcnsArg1(S) (S)->regDataType.arg1 /* (void*)        */\n#define ssSetDataTypeFcnsArg1(S, ptr1) (S)->regDataType.arg1 = ((void*)(ptr1))\n\n#define ssGetRegisterDataTypeFcn(S) (S)->regDataType.registerFcn /* (RegisterDataType) */\n#define ssSetRegisterDataTypeFcn(S, val) (S)->regDataType.registerFcn = (val)\n\n#define ssGetDataTypeSizeFcn(S) (S)->regDataType.getSizeFcn /* (GetDataTypeSize) */\n#define ssSetGetDataTypeSizeFcn(S, val) (S)->regDataType.getSizeFcn = (val)\n\n#define ssGetSetDataTypeSizeFcn(S) (S)->regDataType.setSizeFcn /* (SetDataTypeSize) */\n#define ssSetDataTypeSizeFcn(S, val) (S)->regDataType.setSizeFcn = (val)\n\n#define ssGetDataTypeZeroFcn(S) (S)->regDataType.getZeroFcn /* (GetDataTypeZero) */\n#define ssSetGetDataTypeZeroFcn(S, val) (S)->regDataType.getZeroFcn = (val)\n\n#define ssGetSetDataTypeZeroFcn(S) (S)->regDataType.setZeroFcn /* (SetDataTypeZero) */\n#define ssSetDataTypeZeroFcn(S, val) (S)->regDataType.setZeroFcn = (val)\n\n#define ssGetDataTypeNameFcn(S) (S)->regDataType.getNameFcn /* (GetDataTypeName) */\n#define ssSetGetDataTypeNameFcn(S, val) (S)->regDataType.getNameFcn = (val)\n\n#define ssGetDataTypeIdFcn(S) (S)->regDataType.getIdFcn /* (GetDataTypeId) */\n#define ssSetGetDataTypeIdFcn(S, val) (S)->regDataType.getIdFcn = (val)\n\n/*ssGetSetNumDWorkFcn*/\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n#define ssGetSetNumDWorkFcn(S) ((S)->regDataType.setNumDWorkFcn) /* (SetNumDWork)     */\n#define ssGetSetNumDWorkFcnSLSize(S) \\\n    ((S)->blkInfo.blkInfo2->blkInfoSLSize->regDataType.setNumDWorkFcn)\n#elif defined(USE_32BIT_FIELDS)\n#define ssGetSetNumDWorkFcn(S) ((S)->regDataType.setNumDWorkFcn) /* (SetNumDWork)     */\n#endif\n/*end ssGetSetNumDWorkFcn*/\n\n/*ssSetNumDWorkFcn*/\n#if defined(USE_32BIT_AND_64BIT_FIELDS)\n#define ssSetNumDWorkFcn(S, val) ((S)->regDataType.setNumDWorkFcn = (val))\n#define ssSetNumDWorkFcnSLSize(S, val) \\\n    ((S)->blkInfo.blkInfo2->blkInfoSLSize->regDataType.setNumDWorkFcn = (val))\n#elif defined(USE_32BIT_FIELDS)\n#define ssSetNumDWorkFcn(S, val) ((S)->regDataType.setNumDWorkFcn = (val))\n#endif\n/*end ssSetNumDWorkFcn*/\n\n#define ssStrictBooleanCheckEnabledFcn(S) \\\n    (S)->states.modelMethods2->strictBooleanCheckEnabledFcn /* (StrictBooleanCheckEnabledFcn) */\n#define ssSetStrictBooleanCheckEnabledFcn(S, val) \\\n    (S)->states.modelMethods2->strictBooleanCheckEnabledFcn = (val)\n\n#define ssSetConvertBuiltInDTypeFcn(S, fcn) (S)->states.modelMethods2->ConvertBuiltInDType = (fcn)\n\n#endif\n\n#if !SS_SFCN_LEVEL_1\n\n#if SS_SIM\n#define ssGetDataTypeProperties(S, id) \\\n    (dtaGetDataTypeProperties(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetDataTypeProperties(S, id) ssGetDataTypeProperties_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetDataTypeProperties(S, id, properties) \\\n    dtaSetDataTypeProperties(ssGetDataTypeAccess(S), (S)->path, (id), (properties))\n#else\n#define ssSetDataTypeProperties(S, id, properties) ssSetDataTypeProperties_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssGetDataTypePropertiesSize(S, id) \\\n    (dtaGetDataTypePropertiesSize(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetDataTypePropertiesSize(S, id) ssGetDataTypePropertiesSize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetDataTypePropertiesSize(S, id, size) \\\n    dtaSetDataTypePropertiesSize(ssGetDataTypeAccess(S), (S)->path, (id), (size))\n#else\n#define ssSetDataTypePropertiesSize(S, id, size) ssSetDataTypePropertiesSize_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssStrictBooleanCheckEnabled(S)                                                       \\\n    (((S)->states.modelMethods2->strictBooleanCheckEnabledFcn != NULL)                       \\\n         ? (*(S)->states.modelMethods2->strictBooleanCheckEnabledFcn)((S)->regDataType.arg1) \\\n         : (false))\n#else\n#define ssStrictBooleanCheckEnabled(S) ssStrictBooleanCheckEnabled_cannot_be_used_in_RTW\n#endif\n\n/*  ssCallConvertBuiltInDType\n *  Options:\n *      satOnIntOverFlow:\n *          If true, saturate.  If false, the conversion is undefined when\n *          values are out of range (platform dependent conversion).\n *      doDiff:\n *          If true, compare original values and converted values and return\n *          true if they are different (e.g., value was saturated, etc).  If\n *          doDiff is false, this function always returns true.\n */\n#if SS_SIM\n#define ssCallConvertBuiltInDType(S, nVals, satOnIntOverFlow, doDiff, dt1, v1, dt2, v2)           \\\n    (S)->states.modelMethods2->ConvertBuiltInDType(nVals, satOnIntOverFlow, doDiff, dt1, v1, dt2, \\\n                                                   v2)\n#else\n#define ssCallConvertBuiltInDType(S, nVals, satOnIntOverFlow, doDiff, dt1, v1, dt2, v2) \\\n    ssCallConvertBuiltInDType_cannot_be_used_in_RTW\n#endif\n\n\n\n#if SS_SIM\n#define ssGetDataTypeStorageId(S, id) \\\n    (dtaGetDataTypeStorageId(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetDataTypeStorageId(S, id) ssGetDataTypeStorageId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetDataTypeStorageId(S, id, storageId) \\\n    dtaSetDataTypeStorageId(ssGetDataTypeAccess(S), (S)->path, (id), (storageId))\n#else\n#define ssSetDataTypeStorageId(S, id, storageId) ssSetDataTypeStorageId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssGetDataTypeIdAliasedTo(S, id) \\\n    (dtaGetDataTypeIdAliasedTo(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetDataTypeIdAliasedTo(S, id) ssGetDataTypeIdAliasedTo_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetDataTypeIdAliasedTo(S, id, idAliasedTo) \\\n    dtaSetDataTypeIdAliasedTo(ssGetDataTypeAccess(S), (S)->path, (id), (idAliasedTo))\n#else\n#define ssSetDataTypeIdAliasedTo(S, id, idAliasedTo) ssSetDataTypeIdAliasedTo_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssGetConvertBetweenFcn(S, id) \\\n    (dtaGetConvertBetweenFcn(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetConvertBetweenFcn(S, id) ssGetConvertBetweenFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetConvertBetweenFcn(S, id, fcn) \\\n    dtaSetConvertBetweenFcn(ssGetDataTypeAccess(S), (S)->path, (id), (fcn))\n#else\n#define ssSetConvertBetweenFcn(S, id, fcn) ssSetConvertBetweenFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssCallConvertBetweenForSrcId(S, dstId, srcId, numEls, u, options, y)                \\\n    (ssGetConvertBetweenFcn((S), (srcId)) != NULL                                           \\\n         ? ssGetConvertBetweenFcn((S), (srcId))(ssGetDataTypeAccess(S), (S)->path, (dstId), \\\n                                                (srcId), (numEls), (u), (options), (y))     \\\n         : 0)\n#else\n#define ssCallConvertBetweenForSrcId(S, dstId, srcId, numEls, u, options, y) \\\n    ssCallConvertBetweenForSrcId_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssCallConvertBetweenForDstId(S, dstId, srcId, numEls, u, options, y)                \\\n    (ssGetConvertBetweenFcn((S), (dstId)) != NULL                                           \\\n         ? ssGetConvertBetweenFcn((S), (dstId))(ssGetDataTypeAccess(S), (S)->path, (dstId), \\\n                                                (srcId), (numEls), (u), (options), (y))     \\\n         : 0)\n#else\n#define ssCallConvertBetweenForDstId(S, dstId, srcId, numEls, u, options, y) \\\n    ssCallConvertBetweenForDstId_cannot_be_used_in_RTW\n#endif\n\n\n#if SS_SIM\n#define ssGetConstructFcn(S, id) (dtaGetConstructFcn(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetConstructFcn(S, id) ssGetConstructFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetConstructFcn(S, id, fcn) \\\n    dtaSetConstructFcn(ssGetDataTypeAccess(S), (S)->path, (id), (fcn))\n#else\n#define ssSetConstructFcn(S, id, fcn) ssSetConstructFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssCallConstruct(S, id, u)                                                     \\\n    (ssGetConstructFcn((S), (id)) != NULL                                             \\\n         ? ssGetConstructFcn((S), (id))(ssGetDataTypeAccess(S), (S)->path, (id), (u)) \\\n         : 0)\n#else\n#define ssCallConstruct(S, id, u) ssCallConstruct_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssGetDestructFcn(S, id) (dtaGetDestructFcn(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetDestructFcn(S, id) ssGetDestructFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetDestructFcn(S, id, fcn) \\\n    dtaSetDestructFcn(ssGetDataTypeAccess(S), (S)->path, (id), (fcn))\n#else\n#define ssSetDestructFcn(S, id, fcn) ssSetDestructFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssCallDestruct(S, id, u)                                                     \\\n    (ssGetDestructFcn((S), (id)) != NULL                                             \\\n         ? ssGetDestructFcn((S), (id))(ssGetDataTypeAccess(S), (S)->path, (id), (u)) \\\n         : 0)\n#else\n#define ssCallDestruct(S, id, u) ssCallDestruct_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssGetDeepCopyFcn(S, id) (dtaGetDeepCopyFcn(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetDeepCopyFcn(S, id) ssGetDeepCopyFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetDeepCopyFcn(S, id, fcn) \\\n    dtaSetDeepCopyFcn(ssGetDataTypeAccess(S), (S)->path, (id), (fcn))\n#else\n#define ssSetDeepCopyFcn(S, id, fcn) ssSetDeepCopyFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssCallDeepCopy(S, id, y, u)                                                          \\\n    (ssGetDeepCopyFcn((S), (srcId)) != NULL                                                  \\\n         ? ssGetDeepCopyFcn((S), (srcId))(ssGetDataTypeAccess(S), (S)->path, (id), (y), (u)) \\\n         : 0)\n#else\n#define ssCallDeepCopy(S, id, y, u) ssCallDeepCopy_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssGetIsPositiveFcn(S, id) (dtaGetIsPositiveFcn(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetIsPositiveFcn(S, id) ssGetIsPositiveFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetIsPositiveFcn(S, id, fcn) \\\n    dtaSetIsPositiveFcn(ssGetDataTypeAccess(S), (S)->path, (id), (fcn))\n#else\n#define ssSetIsPositiveFcn(S, id, fcn) ssSetIsPositiveFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssCallIsPositive(S, id, numEls, u, options, y)                                           \\\n    (ssGetIsPositiveFcn((S), (id)) != NULL                                                       \\\n         ? ssGetIsPositiveFcn((S), (id))(ssGetDataTypeAccess(S), (S)->path, (id), (numEls), (u), \\\n                                         (options), (y))                                         \\\n         : 0)\n#else\n#define ssCallIsPositive(S, id, numEls, u, options, y) ssCallIsPositive_cannot_be_used_in_RTW\n#endif\n\n\n#if SS_SIM\n#define ssGetIsNegativeFcn(S, id) (dtaGetIsNegativeFcn(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetIsNegativeFcn(S, id) ssGetIsNegativeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetIsNegativeFcn(S, id, fcn) \\\n    dtaSetIsNegativeFcn(ssGetDataTypeAccess(S), (S)->path, (id), (fcn))\n#else\n#define ssSetIsNegativeFcn(S, id, fcn) ssSetIsNegativeFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssCallIsNegative(S, id, numEls, u, options, y)                                           \\\n    (ssGetIsNegativeFcn((S), (id)) != NULL                                                       \\\n         ? ssGetIsNegativeFcn((S), (id))(ssGetDataTypeAccess(S), (S)->path, (id), (numEls), (u), \\\n                                         (options), (y))                                         \\\n         : 0)\n#else\n#define ssCallIsNegative(S, id, numEls, u, options, y) ssCallIsNegative_cannot_be_used_in_RTW\n#endif\n\n\n#if SS_SIM\n#define ssGetGreaterThanFcn(S, id) (dtaGetGreaterThanFcn(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetGreaterThanFcn(S, id) ssGetGreaterThanFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetGreaterThanFcn(S, id, fcn) \\\n    dtaSetGreaterThanFcn(ssGetDataTypeAccess(S), (S)->path, (id), (fcn))\n#else\n#define ssSetGreaterThanFcn(S, id, fcn) ssSetGreaterThanFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssCallGreaterThan(S, id, numEls, u1, u2, options, y)                                       \\\n    (ssGetGreaterThanFcn((S), (id)) != NULL                                                        \\\n         ? ssGetGreaterThanFcn((S), (id))(ssGetDataTypeAccess(S), (S)->path, (id), (numEls), (u1), \\\n                                          (u2), (options), (y))                                    \\\n         : 0)\n#else\n#define ssCallGreaterThan(S, id, numEls, u1, u2, options, y) ssCallGreaterThan_cannot_be_used_in_RTW\n#endif\n\n\n#if SS_SIM\n#define ssGetGreaterEqualFcn(S, id) (dtaGetGreaterEqualFcn(ssGetDataTypeAccess(S), (S)->path, (id)))\n#else\n#define ssGetGreaterEqualFcn(S, id) ssGetGreaterEqualFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssSetGreaterEqualFcn(S, id, fcn) \\\n    dtaSetGreaterEqualFcn(ssGetDataTypeAccess(S), (S)->path, (id), (fcn))\n#else\n#define ssSetGreaterEqualFcn(S, id, fcn) ssSetGreaterEqualFcn_cannot_be_used_in_RTW\n#endif\n\n#if SS_SIM\n#define ssCallGreaterEqual(S, id, numEls, u1, u2, options, y)                                 \\\n    (ssGetGreaterEqualFcn((S), (id)) != NULL                                                  \\\n         ? ssGetGreaterEqualFcn((S), (id))(ssGetDataTypeAccess(S), (S)->path, (id), (numEls), \\\n                                           (u1), (u2), (options), (y))                        \\\n         : 0)\n#else\n#define ssCallGreaterEqual(S, id, numEls, u1, u2, options, y) \\\n    ssCallGreaterEqual_cannot_be_used_in_RTW\n#endif\n\n#endif /* NOT level 1 S-function */\n\n/*-------------------------------- S->stInfo --------------------------------*/\n#define ssGetSampleTimePtr(S) (S)->stInfo.sampleTimes /*   (time_T *)    */\n#define ssSetSampleTimePtr(S, ptr) (S)->stInfo.sampleTimes = (ptr)\n#define ssGetOffsetTimePtr(S) (S)->stInfo.offsetTimes /*   (time_T *)    */\n#define ssSetOffsetTimePtr(S, ptr) (S)->stInfo.offsetTimes = (ptr)\n\n\n\n/*-------------------- For Variable Sample Time Unique ID -------------------*/\n#if defined(RTW_GENERATED_S_FUNCTION)\n#define ssSetVariableSampleTimeUID(S, sti, val)                                        \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_VARIABLE_SAMPLE_TIME_UID, sti, val) \\\n        _ssSafelyCallGenericFcnEnd\n#endif\n\n/* Only the S-Functions need to call the ssSupportVarTsInMdlRef*/\n#if (SS_SL_INTERNAL || SS_SFCN_FOR_SIM) && defined(ssGetOwnerBlock)\n#define ssSupportVarTsInMdlRef(S, flag)                                                     \\\n    {                                                                                       \\\n        if (ssGetOwnerBlock(S) != NULL) {                                                   \\\n            boolean_T val = flag;                                                           \\\n            _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_VARTS_MDLREF_SUPPORT, val, NULL) \\\n                _ssSafelyCallGenericFcnEnd;                                                 \\\n        }                                                                                   \\\n    }\n#else\n#define ssSupportVarTsInMdlRef(S, flag)\n#endif\n\n\n/*\n * These APIs are used during compilation, and they are no-op during runtime.\n */\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n\n#define ssSetDisallowContinuous(S, flag)                                            \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_DISALLOW_CONTINUOUS, flag, NULL) \\\n        _ssSafelyCallGenericFcnEnd\n\n#define ssSetDisallowControllableSampleTime(S, flag)                                   \\\n    {                                                                                  \\\n        boolean_T tmp = flag;                                                          \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_DISALLOW_CONTROLLABLE, 0, &tmp) \\\n            _ssSafelyCallGenericFcnEnd;                                                \\\n    }\n\n#define ssSetControllableSampleTimeUID(S, sti, uid)                                             \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_CONTROLLABLE_SAMPLE_TIME_UID, (int)sti, uid) \\\n        _ssSafelyCallGenericFcnEnd;\n\n#else\n\n\n\n#define ssSetDisallowContinuous(S, flag)\n\n#define ssSetDisallowControllableSampleTime(S, flag)\n\n#define ssSetControllableSampleTimeUID(S, sti, uid)\n\n#endif\n\n#if defined(RTW_GENERATED_S_FUNCTION)\n#define ssSetInputPortControllableSampleTime(S, portIdx, base)                          \\\n    {                                                                                   \\\n        real_T tmp = base;                                                              \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_INPUT_CONTROLLABLE_SAMPLE_TIME,  \\\n                                        (int)portIdx, &tmp) _ssSafelyCallGenericFcnEnd; \\\n    }\n\n#define ssSetInputPortControllableSampleTimeUID(S, portIdx, uid)                       \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_INPUT_CONTROLLABLE_SAMPLE_TIME_UID, \\\n                                    (int)portIdx, uid) _ssSafelyCallGenericFcnEnd\n\n\n#define ssSetOutputPortControllableSampleTime(S, portIdx, base)                         \\\n    {                                                                                   \\\n        real_T tmp = base;                                                              \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_OUTPUT_CONTROLLABLE_SAMPLE_TIME, \\\n                                        (int)portIdx, &tmp) _ssSafelyCallGenericFcnEnd; \\\n    }\n\n\n#define ssSetOutputPortControllableSampleTimeUID(S, portIdx, uid)                       \\\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_OUTPUT_CONTROLLABLE_SAMPLE_TIME_UID, \\\n                                    (int)portIdx, uid) _ssSafelyCallGenericFcnEnd\n\n#else\n\n#define ssSetInputPortControllableSampleTime(S, portIdx, base)\n\n#define ssSetInputPortControllableSampleTimeUID(S, portIdx, uid)\n\n#define ssSetOutputPortControllableSampleTime(S, portIdx, base)\n\n#define ssSetOutputPortControllableSampleTimeUID(S, portIdx, uid)\n\n#endif\n\n\n\n#define _ssSetSampleTimeTaskIDPtr(S, tids) (S)->stInfo.sampleTimeTaskIDs = (tids)\n\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION || defined(USE_RTMODEL)\n/*\n * The following are not for use in S-functions\n */\n#define ssGetTNextTid(S) (S)->stInfo.tNextTid /*   (int_T)   */\n#define ssSetTNextTid(S, setting) (S)->stInfo.tNextTid = (setting)\n#define ssGetSampleTimeTaskIDPtr(S) (S)->stInfo.sampleTimeTaskIDs /*   (int_T *)     */\n#define ssSetSampleTimeTaskIDPtr(S, tids) _ssSetSampleTimeTaskIDPtr(S, tids)\n#else\n#define ssSetSampleTimeTaskIDPtr(S, tids) ssSetSampleTimeTaskIDPtr_cannot_be_used_in_SFunctions\n#endif\n\n#define _ssSetSampleTimeTaskID(S, sti, tid) (S)->stInfo.sampleTimeTaskIDs[sti] = (tid)\n#if !SS_SFCN\n#define ssSetSampleTimeTaskID(S, sti, tid) _ssSetSampleTimeTaskID(S, sti, tid)\n#else\n#define ssSetSampleTimeTaskID(S, sti, tid) ssSetSampleTimeTaskID_cannot_be_used_in_SFunctions\n#endif\n\n/*--------------------------- S->modelMethods.sFcn --------------------------*/\n/*\n * Macros are used to call an S-function block methods. These should not\n * be used by an S-function directly.\n */\n#define ssSetmdlInitializeSizes(S, initSizes) \\\n    (S)->modelMethods.sFcn.mdlInitializeSizes = (initSizes)\n#define sfcnInitializeSizes(S) (*(S)->modelMethods.sFcn.mdlInitializeSizes)(S)\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssGetmdlInitializePropagationPass(S) \\\n    ((S)->states.modelMethods2)->mdlInitializePropagationPass\n#define ssSetmdlInitializePropagationPass(S, mdlInitializePropagationPass) \\\n    {                                                                      \\\n        ((S)->states.modelMethods2)->mdlInitializePropagationPass =        \\\n            (mdlInitializePropagationPass);                                \\\n        _ssSetSfcnHasMdlDimensionsFcn(S, 1);                               \\\n    }\n#define sfcnInitializePropagationPass(S, passType) \\\n    (*((S)->states.modelMethods2)->mdlInitializePropagationPass)(S, passType)\n\n\n#define ssGetmdlGetInputPortWidthLevel1(S) (S)->modelMethods.sFcn.mdlGetInputPortWidthLevel1\n#define ssSetmdlGetInputPortWidthLevel1(S, getInputPortWidth) \\\n    (S)->modelMethods.sFcn.mdlGetInputPortWidthLevel1 = (getInputPortWidth)\n#define sfcnGetInputPortWidthLevel1(S, outputPortWidth) \\\n    (*(S)->modelMethods.sFcn.mdlGetInputPortWidthLevel1)(S, outputPortWidth)\n\n#define ssGetmdlGetOutputPortWidthLevel1(S) (S)->modelMethods.sFcn.mdlGetOutputPortWidthLevel1\n#define ssSetmdlGetOutputPortWidthLevel1(S, getOutputPortWidth) \\\n    (S)->modelMethods.sFcn.mdlGetOutputPortWidthLevel1 = (getOutputPortWidth)\n#define sfcnGetOutputPortWidthLevel1(S, inputPortWidth) \\\n    (*(S)->modelMethods.sFcn.mdlGetOutputPortWidthLevel1)(S, inputPortWidth)\n\n#define ssGetmdlSetInputPortWidth(S)   \\\n    ((ssGetSfcnHasMdlDimensionsFcn(S)) \\\n         ? NULL                        \\\n         : ((S)->modelMethods.sFcn.mdlSetInputPortDimensions.mdlSetInputPortWidth))\n\n#define ssSetmdlSetInputPortWidth(S, setInputPortWidth)                         \\\n    {                                                                           \\\n        (S)->modelMethods.sFcn.mdlSetInputPortDimensions.mdlSetInputPortWidth = \\\n            (setInputPortWidth);                                                \\\n        _ssSetSfcnHasMdlDimensionsFcn(S, 0);                                    \\\n    }\n\n#define sfcnSetInputPortWidth(S, portIdx, width) \\\n    (*(S)->modelMethods.sFcn.mdlSetInputPortDimensions.mdlSetInputPortWidth)(S, portIdx, width)\n\n#define ssGetmdlSetOutputPortWidth(S)  \\\n    ((ssGetSfcnHasMdlDimensionsFcn(S)) \\\n         ? NULL                        \\\n         : (S)->modelMethods.sFcn.mdlSetOutputPortDimensions.mdlSetOutputPortWidth)\n\n#define ssSetmdlSetOutputPortWidth(S, setOutputPortWidth)                         \\\n    {                                                                             \\\n        (S)->modelMethods.sFcn.mdlSetOutputPortDimensions.mdlSetOutputPortWidth = \\\n            (setOutputPortWidth);                                                 \\\n        _ssSetSfcnHasMdlDimensionsFcn(S, 0);                                      \\\n    }\n\n#define sfcnSetOutputPortWidth(S, portIdx, width) \\\n    (*(S)->modelMethods.sFcn.mdlSetOutputPortDimensions.mdlSetOutputPortWidth)(S, portIdx, width)\n\n#define ssGetmdlSetInputPortDimensions(S)                                         \\\n    ((ssGetSfcnHasMdlDimensionsFcn(S))                                            \\\n         ? ((S)->modelMethods.sFcn.mdlSetInputPortDimensions.mdlSetInputPortDims) \\\n         : NULL)\n\n#define ssSetmdlSetInputPortDimensions(S, setInputPortDimensions)              \\\n    {                                                                          \\\n        (S)->modelMethods.sFcn.mdlSetInputPortDimensions.mdlSetInputPortDims = \\\n            (setInputPortDimensions);                                          \\\n        _ssSetSfcnHasMdlDimensionsFcn(S, 1);                                   \\\n    }\n#define sfcnSetInputPortDimensionInfo(S, portIdx, dimsInfo) \\\n    (*(S)->modelMethods.sFcn.mdlSetInputPortDimensions.mdlSetInputPortDims)(S, portIdx, dimsInfo)\n\n#define ssGetmdlSetOutputPortDimensions(S)                                          \\\n    ((ssGetSfcnHasMdlDimensionsFcn(S))                                              \\\n         ? ((S)->modelMethods.sFcn.mdlSetOutputPortDimensions.mdlSetOutputPortDims) \\\n         : NULL)\n\n#define ssSetmdlSetOutputPortDimensions(S, setOutputPortDimensions)              \\\n    {                                                                            \\\n        (S)->modelMethods.sFcn.mdlSetOutputPortDimensions.mdlSetOutputPortDims = \\\n            (setOutputPortDimensions);                                           \\\n        _ssSetSfcnHasMdlDimensionsFcn(S, 1);                                     \\\n    }\n\n#define sfcnSetOutputPortDimensionInfo(S, portIdx, dimsInfo) \\\n    (*(S)->modelMethods.sFcn.mdlSetOutputPortDimensions.mdlSetOutputPortDims)(S, portIdx, dimsInfo)\n\n#define ssGetmdlSetDefaultPortDimensions(S) ((S)->states.modelMethods2)->mdlSetDefaultPortDimensions\n#define ssSetmdlSetDefaultPortDimensions(S, setDefaultPortDimensions) \\\n    ((S)->states.modelMethods2)->mdlSetDefaultPortDimensions = setDefaultPortDimensions\n#define sfcnSetDefaultPortDimensionInfo(S) \\\n    (*((S)->states.modelMethods2)->mdlSetDefaultPortDimensions)(S)\n\n#define ssGetmdlSetInputPortSymbolicDimensions(S) \\\n    (ssGetModelMethods4(S)->mdlSetInputPortSymbolicDimensions)\n#define ssSetmdlSetInputPortSymbolicDimensions(S, setInputPortSymbolicDimensions) \\\n    ssGetModelMethods4(S)->mdlSetInputPortSymbolicDimensions = setInputPortSymbolicDimensions\n#define sfcnSetInputPortSymbolicDimensions(S, aPortIdx, aSymbDimsId) \\\n    ssGetmdlSetInputPortSymbolicDimensions(S)(S, aPortIdx, aSymbDimsId)\n\n#define ssGetmdlSetOutputPortSymbolicDimensions(S) \\\n    (ssGetModelMethods4(S)->mdlSetOutputPortSymbolicDimensions)\n#define ssSetmdlSetOutputPortSymbolicDimensions(S, setOutputPortSymbolicDimensions) \\\n    ssGetModelMethods4(S)->mdlSetOutputPortSymbolicDimensions = setOutputPortSymbolicDimensions\n#define sfcnSetOutputPortSymbolicDimensions(S, aPortIdx, aSymbDimsId) \\\n    ssGetmdlSetOutputPortSymbolicDimensions(S)(S, aPortIdx, aSymbDimsId)\n\n#define ssGetmdlSetInputPortDataType(S) (S)->modelMethods.sFcn.mdlSetInputPortDataType\n#define ssSetmdlSetInputPortDataType(S, setInputPortDataType) \\\n    (S)->modelMethods.sFcn.mdlSetInputPortDataType = (setInputPortDataType)\n#define sfcnSetInputPortDataType(S, portIdx, inputPortDataType) \\\n    (*(S)->modelMethods.sFcn.mdlSetInputPortDataType)(S, portIdx, inputPortDataType)\n\n#define ssGetmdlSetOutputPortDataType(S) (S)->modelMethods.sFcn.mdlSetOutputPortDataType\n#define ssSetmdlSetOutputPortDataType(S, setOutputPortDataType) \\\n    (S)->modelMethods.sFcn.mdlSetOutputPortDataType = (setOutputPortDataType)\n#define sfcnSetOutputPortDataType(S, portIdx, outputPortDataType) \\\n    (*(S)->modelMethods.sFcn.mdlSetOutputPortDataType)(S, portIdx, outputPortDataType)\n\n#define ssGetmdlSetDefaultPortDataTypes(S) ((S)->states.modelMethods2)->mdlSetDefaultPortDataTypes\n#define ssSetmdlSetDefaultPortDataTypes(S, setDefaultPortDataTypes) \\\n    ((S)->states.modelMethods2)->mdlSetDefaultPortDataTypes = setDefaultPortDataTypes\n#define sfcnSetDefaultPortDataTypes(S) (*((S)->states.modelMethods2)->mdlSetDefaultPortDataTypes)(S)\n\n#define ssGetmdlSetInputPortComplexSignal(S) \\\n    (S)->modelMethods.sFcn.fcnInEnable.mdlSetInputPortComplexSignal\n#define ssSetmdlSetInputPortComplexSignal(S, setInputPortComplexSignal) \\\n    (S)->modelMethods.sFcn.fcnInEnable.mdlSetInputPortComplexSignal = (setInputPortComplexSignal)\n#define sfcnSetInputPortComplexSignal(S, portIdx, val) \\\n    (*(S)->modelMethods.sFcn.fcnInEnable.mdlSetInputPortComplexSignal)(S, portIdx, val)\n\n#define ssGetmdlSetOutputPortComplexSignal(S) \\\n    (S)->modelMethods.sFcn.fcnOutDisable.mdlSetOutputPortComplexSignal\n#define ssSetmdlSetOutputPortComplexSignal(S, setOutputPortComplexSignal) \\\n    (S)->modelMethods.sFcn.fcnOutDisable.mdlSetOutputPortComplexSignal =  \\\n        (setOutputPortComplexSignal)\n#define sfcnSetOutputPortComplexSignal(S, portIdx, val) \\\n    (*(S)->modelMethods.sFcn.fcnOutDisable.mdlSetOutputPortComplexSignal)(S, portIdx, val)\n\n#define ssGetmdlSetDefaultPortComplexSignals(S) \\\n    ((S)->states.modelMethods2)->mdlSetDefaultPortComplexSignals\n#define ssSetmdlSetDefaultPortComplexSignals(S, setDefaultPortComplexSignals) \\\n    ((S)->states.modelMethods2)->mdlSetDefaultPortComplexSignals = setDefaultPortComplexSignals\n#define sfcnSetDefaultPortComplexSignals(S) \\\n    (*((S)->states.modelMethods2)->mdlSetDefaultPortComplexSignals)(S)\n\n#define ssGetmdlSetInputPortFrameData(S) ((S)->states.modelMethods2)->mdlSetInputPortFrameData\n#define ssSetmdlSetInputPortFrameData(S, setInputPortFrameData) \\\n    ((S)->states.modelMethods2)->mdlSetInputPortFrameData = (setInputPortFrameData)\n#define sfcnSetInputPortFrameData(S, portIdx, frameData) \\\n    (*((S)->states.modelMethods2)->mdlSetInputPortFrameData)(S, portIdx, frameData)\n\n#endif\n\n#define _ssGetRTWGeneratedEnable(S) (S)->modelMethods.sFcn.fcnInEnable.mdlEnable\n#define _ssSetRTWGeneratedEnable(S, setEnable) \\\n    (S)->modelMethods.sFcn.fcnInEnable.mdlEnable = (setEnable)\n#define _sfcnRTWGeneratedEnable(S) (*(S)->modelMethods.sFcn.fcnInEnable.mdlEnable)(S)\n\n#define _ssGetRTWGeneratedDisable(S) (S)->modelMethods.sFcn.fcnOutDisable.mdlDisable\n#define _ssSetRTWGeneratedDisable(S, setDisable) \\\n    (S)->modelMethods.sFcn.fcnOutDisable.mdlDisable = (setDisable)\n#define _sfcnRTWGeneratedDisable(S) (*(S)->modelMethods.sFcn.fcnOutDisable.mdlDisable)(S)\n\n#if !SS_SFCN || SS_GENERATED_S_FUNCTION\n#define ssGetRTWGeneratedEnable(S) _ssGetRTWGeneratedEnable(S)\n#define ssSetRTWGeneratedEnable(S, setEnable) _ssSetRTWGeneratedEnable(S, setEnable)\n#define sfcnRTWGeneratedEnable(S) _sfcnRTWGeneratedEnable(S)\n\n#define ssGetRTWGeneratedDisable(S) _ssGetRTWGeneratedDisable(S)\n#define ssSetRTWGeneratedDisable(S, setDisable) _ssSetRTWGeneratedDisable(S, setDisable)\n#define sfcnRTWGeneratedDisable(S) _sfcnRTWGeneratedDisable(S)\n\n#else\n/* User S-Functions */\n#define ssGetRTWGeneratedEnable(S) ssGetRTWGeneratedEnable_cannot_be_used_in_SFunctions\n#define ssSetRTWGeneratedEnable(S, setEnable) ssGetRTWGeneratedEnable_cannot_be_used_in_SFunctions\n#define sfcnRTWGeneratedEnable(S) sfcnRTWGeneratedEnable_cannot_be_used_in_SFunctions\n\n#define ssGetRTWGeneratedDisable(S) ssGetRTWGeneratedDisable_cannot_be_used_in_SFunctions\n#define ssSetRTWGeneratedDisable(S, setDisable) \\\n    ssSetRTWGeneratedDisable_cannot_be_used_in_SFunctions\n#define sfcnRTWGeneratedDisable(S) sfcnRTWGeneratedDisable_cannot_be_used_in_SFunctions\n#endif\n\n#define ssSetmdlInitializeSampleTimes(S, initSampleTimes) \\\n    (S)->modelMethods.sFcn.mdlInitializeSampleTimes = (initSampleTimes)\n#define sfcnInitializeSampleTimes(S) (*(S)->modelMethods.sFcn.mdlInitializeSampleTimes)(S)\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n\n#define ssGetmdlSetInputPortSampleTime(S) (S)->modelMethods.sFcn.mdlSetInputPortSampleTime\n#define ssSetmdlSetInputPortSampleTime(S, fcn) \\\n    (S)->modelMethods.sFcn.mdlSetInputPortSampleTime = (fcn)\n#define sfcnSetInputPortSampleTime(S, portIdx, sampleTime, offsetTime) \\\n    (*(S)->modelMethods.sFcn.mdlSetInputPortSampleTime)(S, portIdx, sampleTime, offsetTime)\n\n#define ssGetmdlSetOutputPortSampleTime(S) (S)->modelMethods.sFcn.mdlSetOutputPortSampleTime\n#define ssSetmdlSetOutputPortSampleTime(S, fcn) \\\n    (S)->modelMethods.sFcn.mdlSetOutputPortSampleTime = (fcn)\n#define sfcnSetOutputPortSampleTime(S, portIdx, sampleTime, offsetTime) \\\n    (*(S)->modelMethods.sFcn.mdlSetOutputPortSampleTime)(S, portIdx, sampleTime, offsetTime)\n\n#define ssGetmdlSetWorkWidths(S) (S)->modelMethods.sFcn.mdlSetWorkWidths\n#define ssSetmdlSetWorkWidths(S, setWorkWidths) \\\n    (S)->modelMethods.sFcn.mdlSetWorkWidths = (setWorkWidths)\n#define sfcnSetWorkWidths(S) (*(S)->modelMethods.sFcn.mdlSetWorkWidths)(S)\n\n#define ssGetmdlRTW(S) (S)->modelMethods.sFcn.mdlRTW\n#define ssSetmdlRTW(S, rtw) (S)->modelMethods.sFcn.mdlRTW = (rtw)\n#define sfcnRTW(S) (*(S)->modelMethods.sFcn.mdlRTW)(S)\n#endif\n\n#define ssGetmdlEnable(S) ((S)->states.modelMethods2)->mdlEnable\n#define ssSetmdlEnable(S, enab) ((S)->states.modelMethods2)->mdlEnable = (enab)\n#define sfcnEnable(S)                                                                       \\\n    ((S)->states.modelMethods2)->mdlEnable ? (*((S)->states.modelMethods2)->mdlEnable)((S)) \\\n                                           : (void)(S);\n\n#define ssGetmdlDisable(S) ((S)->states.modelMethods2)->mdlDisable\n#define ssSetmdlDisable(S, disab) ((S)->states.modelMethods2)->mdlDisable = (disab)\n#define sfcnDisable(S)                                                                        \\\n    ((S)->states.modelMethods2)->mdlDisable ? (*((S)->states.modelMethods2)->mdlDisable)((S)) \\\n                                            : (void)(S);\n\n#define ssSetmdlInitializeConditions(S, initConds) \\\n    (S)->modelMethods.sFcn.mdlInitializeConditions.level2 = (initConds)\n#define ssGetmdlInitializeConditions(S) (S)->modelMethods.sFcn.mdlInitializeConditions.level2\n\n#define sfcnInitializeConditions(S) (*(S)->modelMethods.sFcn.mdlInitializeConditions.level2)(S)\n\n#define ssSetmdlInitializeConditionsLevel1(S, initConds) \\\n    (S)->modelMethods.sFcn.mdlInitializeConditions.level1 = (initConds)\n#define sfcnInitializeConditionsLevel1(x0, S) \\\n    (*(S)->modelMethods.sFcn.mdlInitializeConditions.level1)(x0, S)\n\n#define ssGetmdlStart(S) (S)->modelMethods.sFcn.mdlStart\n#define ssSetmdlStart(S, start) (S)->modelMethods.sFcn.mdlStart = (start)\n#define sfcnStart(S) (*(S)->modelMethods.sFcn.mdlStart)(S)\n\n#define ssGetmdlDataTransferRead(S) ((S)->states.modelMethods2->modelMethods4->mdlDataTransferRead)\n#define ssSetmdlDataTransferRead(S, function) \\\n    ((S)->states.modelMethods2->modelMethods4->mdlDataTransferRead = (function))\n#define sfcnDataTransferRead(S, dtIdx, data) \\\n    ((*(S)->states.modelMethods2->modelMethods4->mdlDataTransferRead)(S, dtIdx, data))\n\n#define ssGetmdlDataTransferWrite(S) \\\n    ((S)->states.modelMethods2->modelMethods4->mdlDataTransferWrite)\n#define ssSetmdlDataTransferWrite(S, function) \\\n    ((S)->states.modelMethods2->modelMethods4->mdlDataTransferWrite = (function))\n#define sfcnDataTransferWrite(S, dtIdx, data) \\\n    ((*(S)->states.modelMethods2->modelMethods4->mdlDataTransferWrite)(S, dtIdx, data))\n\n#define ssGetmdlDataTransferInitBuffers(S) \\\n    ((S)->states.modelMethods2->modelMethods4->mdlDataTransferInitBuffers)\n#define ssSetmdlDataTransferInitBuffers(S, function) \\\n    ((S)->states.modelMethods2->modelMethods4->mdlDataTransferInitBuffers = (function))\n#define sfcnDataTransferInitBuffers(S, dtIdx, data) \\\n    ((*(S)->states.modelMethods2->modelMethods4->mdlDataTransferInitBuffers)(S, dtIdx, data))\n\n\n#define ssGetmdlSetupRuntimeResources(S) \\\n    ((S)->states.modelMethods2->modelMethods4->mdlSetupRuntimeResources)\n#define ssSetmdlSetupRuntimeResources(S, function) \\\n    ((S)->states.modelMethods2->modelMethods4->mdlSetupRuntimeResources = (function))\n#define sfcnSetupRuntimeResources(S) \\\n    ((*(S)->states.modelMethods2->modelMethods4->mdlSetupRuntimeResources)(S))\n\n#define ssGetmdlCleanupRuntimeResources(S) \\\n    ((S)->states.modelMethods2->modelMethods4->mdlCleanupRuntimeResources)\n#define ssSetmdlCleanupRuntimeResources(S, function) \\\n    ((S)->states.modelMethods2->modelMethods4->mdlCleanupRuntimeResources = (function))\n#define sfcnCleanupRuntimeResources(S) \\\n    ((*(S)->states.modelMethods2->modelMethods4->mdlCleanupRuntimeResources)(S))\n\n#define ssSetOKtoCallStartTerminateOnSimRestart(S) \\\n    (S)->blkInfo.sfcnFlags.okToCallStartTerminateOnSimRestart = 1\n\n#define ssGetOKtoCallStartTerminateOnSimRestart(S) \\\n    (S)->blkInfo.sfcnFlags.okToCallStartTerminateOnSimRestart\n\n#define ssSetmdlInitSystemMatrices(S, initSystemMatrices) \\\n    ((S)->states.modelMethods2->modelMethods3)->mdlInitSystemMatrices = (initSystemMatrices)\n#define ssGetmdlInitSystemMatrices(S) \\\n    ((S)->states.modelMethods2->modelMethods3)->mdlInitSystemMatrices\n#define sfcnInitSystemMatrices(S) \\\n    (*(((S)->states.modelMethods2)->modelMethods3)->mdlInitSystemMatrices)(S)\n\n#define ssGetmdlJacobianIrJc(S) ((S)->states.modelMethods2->modelMethods3)->mdlJacobianIrJc\n#define ssSetmdlJacobianIrJc(S, JacobianIrJc) \\\n    ((S)->states.modelMethods2->modelMethods3)->mdlJacobianIrJc = (JacobianIrJc)\n#define sfcnJacobianIrJc(S) (*(((S)->states.modelMethods2)->modelMethods3)->mdlJacobianIrJc)(S)\n\n#define ssGetmdlPreInitialize(S) (S)->states.modelMethods2->modelMethods4->mdlPreInitialize\n#define ssSetmdlPreInitialize(S, preinit) \\\n    (S)->states.modelMethods2->modelMethods4->mdlPreInitialize = (preinit)\n#define sfcnPreInitialize(S) ((*(S)->states.modelMethods2->modelMethods4->mdlPreInitialize)(S))\n\n#define ssGetmdlCopyRTPData(S) (S)->states.modelMethods2->modelMethods4->mdlCopyRTPData\n#define ssSetmdlCopyRTPData(S, copyRTPData) \\\n    (S)->states.modelMethods2->modelMethods4->mdlCopyRTPData = (copyRTPData)\n#define sfcnCopyRTPData(S, param, rtpData) \\\n    ((*(S)->states.modelMethods2->modelMethods4->mdlCopyRTPData)(S, param, rtpData))\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssGetmdlCheckParameters(S) (S)->modelMethods.sFcn.mdlCheckParameters\n#define ssSetmdlCheckParameters(S, checkParameters) \\\n    (S)->modelMethods.sFcn.mdlCheckParameters = (checkParameters)\n#define sfcnCheckParameters(S) (*(S)->modelMethods.sFcn.mdlCheckParameters)(S)\n\n#define ssGetmdlProcessParameters(S) (S)->modelMethods.sFcn.mdlProcessParameters\n#define ssSetmdlProcessParameters(S, fcnptr) (S)->modelMethods.sFcn.mdlProcessParameters = (fcnptr)\n#define sfcnProcessParameters(S) (*(S)->modelMethods.sFcn.mdlProcessParameters)(S)\n#endif\n\n#define ssGetmdlExtModeExec(S) ((S)->states.modelMethods2)->mdlExtModeExec\n#define ssSetmdlExtModeExec(S, extModeExec) \\\n    ((S)->states.modelMethods2)->mdlExtModeExec = (extModeExec)\n#define sfcnExtModeExec(S) (*((S)->states.modelMethods2)->mdlExtModeExec)(S)\n\n#if !SS_RT || defined(RSIM_WITH_SL_SOLVER)\n#define ssSetmdlGetTimeOfNextVarHit(S, getTimeOfNextVarHit) \\\n    (S)->modelMethods.sFcn.mdlGetTimeOfNextVarHit = (getTimeOfNextVarHit)\n#define sfcnGetTimeOfNextVarHit(S) (*(S)->modelMethods.sFcn.mdlGetTimeOfNextVarHit)(S)\n#endif\n\n#define sfcnOutputs(S, tid) (*(S)->modelMethods.sFcn.mdlOutputs.level2)(S, tid)\n\n#define ssSetmdlOutputsLevel1(S, outputs) (S)->modelMethods.sFcn.mdlOutputs.level1 = (outputs)\n#define sfcnOutputsLevel1(y, x, u, S, tid) \\\n    (*(S)->modelMethods.sFcn.mdlOutputs.level1)(y, x, u, S, tid)\n\n#define ssSetmdlUpdate(S, update) (S)->modelMethods.sFcn.mdlUpdate.level2 = (update)\n#define ssGetmdlUpdate(S) (S)->modelMethods.sFcn.mdlUpdate.level2\n#define sfcnUpdate(S, tid) (*(S)->modelMethods.sFcn.mdlUpdate.level2)(S, tid)\n\n#define ssSetmdlUpdateLevel1(S, update) (S)->modelMethods.sFcn.mdlUpdate.level1 = (update)\n#define sfcnUpdateLevel1(x, u, S, tid) (*(S)->modelMethods.sFcn.mdlUpdate.level1)(x, u, S, tid)\n\n#define ssSetmdlDerivatives(S, derivs) (S)->modelMethods.sFcn.mdlDerivatives.level2 = (derivs)\n#define ssGetmdlDerivatives(S) (S)->modelMethods.sFcn.mdlDerivatives.level2\n#define sfcnDerivatives(S) (*(S)->modelMethods.sFcn.mdlDerivatives.level2)(S)\n\n#define ssSetmdlDerivativesLevel1(S, derivs) (S)->modelMethods.sFcn.mdlDerivatives.level1 = (derivs)\n#define sfcnDerivativesLevel1(dx, x, u, S, tid) \\\n    (*(S)->modelMethods.sFcn.mdlDerivatives.level1)(dx, x, u, S, tid)\n\n#if !SS_RT\n#define ssSetmdlZeroCrossings(S, zeroCrossings) \\\n    (S)->modelMethods.sFcn.mdlZeroCrossings = (zeroCrossings)\n#define sfcnZeroCrossings(S) (*(S)->modelMethods.sFcn.mdlZeroCrossings)(S)\n#endif\n\n#define ssSetmdlTerminate(S, terminate) (S)->modelMethods.sFcn.mdlTerminate = (terminate)\n#define sfcnTerminate(S) (*(S)->modelMethods.sFcn.mdlTerminate)(S)\n\n#define ssSetmdlGetOperatingPoint(S, fcn) \\\n    (S)->states.modelMethods2->modelMethods4->mdlGetOperatingPoint = (fcn)\n#define sfcnSetGetOperatingPoint(S) \\\n    (*(S)->states.modelMethods2->modelMethods4->mdlGetOperatingPoint)(S)\n#define ssSetmdlProjection(S, projection) ((S)->states.modelMethods2)->mdlProjection = (projection)\n#define ssGetmdlProjection(S) ((S)->states.modelMethods2)->mdlProjection\n#define sfcnProjection(S) (*((S)->states.modelMethods2)->mdlProjection)(S)\n\n#define ssSetmdlSetOperatingPoint(S, fcn) \\\n    (S)->states.modelMethods2->modelMethods4->mdlSetOperatingPoint = (fcn)\n#define sfcnSetOperatingPoint(S, op) \\\n    (*(S)->states.modelMethods2->modelMethods4->mdlSetOperatingPoint)(S, op)\n\n\n#define ssSetmdlMassMatrix(S, massMatrixFcn) \\\n    ((S)->states.modelMethods2)->mdlMassMatrix = (massMatrixFcn)\n#define ssGetmdlMassMatrix(S) ((S)->states.modelMethods2)->mdlMassMatrix\n#define sfcnMassMatrix(S) (*((S)->states.modelMethods2)->mdlMassMatrix)(S)\n\n#define ssSetmdlForcingFunction(S, forcingFunction) \\\n    ((S)->states.modelMethods2)->mdlForcingFunction = (forcingFunction)\n#define ssGetmdlForcingFunction(S) ((S)->states.modelMethods2)->mdlForcingFunction\n#define sfcnForcingFunction(S) (*((S)->states.modelMethods2)->mdlForcingFunction)(S)\n\n#define ssSetmdlConstraints(S, constraintsFcn) \\\n    (((S)->states.modelMethods2)->constraintsInfo)->mdlConstraints = (constraintsFcn)\n#define ssGetmdlConstraints(S) (((S)->states.modelMethods2)->constraintsInfo)->mdlConstraints\n#define sfcnConstraints(S) (*((S)->states.modelMethods2)->constraintsInfo->mdlConstraints)(S)\n\n#define ssSetmdlRTWCG(S, rtwcg) ((S)->states.modelMethods2)->mdlRTWCG = (rtwcg)\n#define ssGetmdlRTWCG(S) ((S)->states.modelMethods2)->mdlRTWCG\n#define sfcnRTWCG(S, iObj) (*((S)->states.modelMethods2)->mdlRTWCG)((S), (iObj))\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define ssSetmdlJacobian(S, jacobian) ((S)->states.modelMethods2)->mdlJacobian = (jacobian)\n#define ssGetmdlJacobian(S) ((S)->states.modelMethods2)->mdlJacobian\n#define sfcnJacobian(S) (*((S)->states.modelMethods2)->mdlJacobian)(S)\n\n#define ssSetmdlSimStatusChange(S, simStatusChange) \\\n    ((S)->states.modelMethods2)->mdlSimStatusChange = (simStatusChange)\n#define ssGetmdlSimStatusChange(S) ((S)->states.modelMethods2)->mdlSimStatusChange\n#define sfcnSimStatusChange(S, simStatusChange) \\\n    (*((S)->states.modelMethods2)->mdlSimStatusChange)(S, (simStatusChange))\n\n#endif\n\n\n#if SS_SL_INTERNAL\n\ntypedef void (*voidFcnIntType)(int);\ntypedef void (*voidFcnVoidType)(void);\ntypedef void (*voidFcnVoidStarType)(void*, void*);\ntypedef void (*voidFcnVoidStarIntType)(void*, void*, boolean_T);\n\n#ifdef __cplusplus\n#define incompatibleFunctionCast(ToType, FunctionPtr) \\\n    (reinterpret_cast<ToType>(reinterpret_cast<size_t>(FunctionPtr)))\n#else\n#define incompatibleFunctionCast(ToType, FunctionPtr) (ToType)(FunctionPtr)\n#endif\n\n#define ssSetModelOutputs(S, fcn) \\\n    (S)->modelMethods.sFcn.mdlOutputs.level2 = incompatibleFunctionCast(mdlOutputsFcn, fcn)\n\n#define ssRunModelOutputs(S, tid) \\\n    (*(incompatibleFunctionCast(voidFcnIntType, (S)->modelMethods.sFcn.mdlOutputs.level2)))(tid)\n\n#define ssSetModelUpdate(S, fcn) \\\n    (S)->modelMethods.sFcn.mdlUpdate.level2 = incompatibleFunctionCast(mdlUpdateFcn, fcn)\n\n#define ssRunModelUpdate(S, tid) \\\n    (*(incompatibleFunctionCast(voidFcnIntType, (S)->modelMethods.sFcn.mdlUpdate.level2)))(tid)\n\n#define ssSetModelLogData(S, fcn) (S)->mdlInfo->rtwLogInfo->mdlLogData = (voidFcnVoidStarType)(fcn)\n#define ssRunModelLogData(S, tp) \\\n    (*((S)->mdlInfo->rtwLogInfo->mdlLogData))((S)->mdlInfo->rtwLogInfo, tp)\n\n#define ssSetModelLogDataIfInInterval(S, fcn) \\\n    (S)->mdlInfo->rtwLogInfo->mdlLogDataIfInInterval = (voidFcnVoidStarIntType)(fcn)\n#define ssRunModelLogDataIfInInterval(S, tp, isInInterval)                              \\\n    (*((S)->mdlInfo->rtwLogInfo->mdlLogDataIfInInterval))((S)->mdlInfo->rtwLogInfo, tp, \\\n                                                          isInInterval)\n\n#define ssSetModelDerivatives(S, fcn) \\\n    (S)->modelMethods.sFcn.mdlDerivatives.level2 = (mdlDerivativesFcn)(fcn)\n#define ssRunModelDerivatives(S) \\\n    (*((voidFcnVoidType)((S)->modelMethods.sFcn.mdlDerivatives.level2)))()\n\n\n#define ssSetModelProjection(S, fcn) \\\n    (S)->states.modelMethods2->mdlProjection = (mdlProjectionFcn)(fcn)\n#define ssRunModelProjection(S) (*((voidFcnVoidType)((S)->states.modelMethods2->mdlProjection)))()\n\n\n#define ssSetModelForcingFunction(S, fcn) \\\n    (S)->states.modelMethods2->mdlForcingFunction = (mdlForcingFunctionFcn)(fcn)\n#define ssRunModelForcingFunction(S) \\\n    (*((voidFcnVoidType)((S)->states.modelMethods2->mdlForcingFunction)))()\n\n\n#define ssSetModelMassMatrix(S, fcn) \\\n    (S)->states.modelMethods2->mdlMassMatrix = (mdlMassMatrixFcn)(fcn)\n#define ssRunModelMassMatrix(S) (*((voidFcnVoidType)((S)->states.modelMethods2->mdlMassMatrix)))()\n\n#define ssSetModelInitSystemMatrices(S, fcn)                            \\\n    ((S)->states.modelMethods2->modelMethods3)->mdlInitSystemMatrices = \\\n        (mdlInitSystemMatricesFcn)(fcn)\n#define ssRunModelInitSystemMatrices(S) \\\n    (*((voidFcnVoidType)(((S)->states.modelMethods2)->mdlInitSystemMatrices)))()\n\n#define ssSetModelRTWCG(S, fcn) (S)->states.modelMethods2->mdlRTWCG = (mdlRTWCGFcn)(fcn)\n#define ssRunModelRTWCG(S, iObj) (*((voidFcnVoidType)((S)->states.modelMethods2->mdlRTWCG)))((iObj))\n\n\n#define ssSetModelZeroCrossings(S, fcn) \\\n    (S)->modelMethods.sFcn.mdlZeroCrossings = (mdlZeroCrossingsFcn)(fcn)\n#define ssRunModelZeroCrossings(S) (*((voidFcnVoidType)((S)->modelMethods.sFcn.mdlZeroCrossings)))()\n\n\n#define ssGetNumNonContDerivSigInfos(S) ((S)->mdlInfo->numNonContDerivSigInfos)\n#define ssSetNumNonContDerivSigInfos(S, n) (S)->mdlInfo->numNonContDerivSigInfos = (n)\n\n\n#define ssGetNonContDerivSigInfos(S) ((S)->mdlInfo->nonContDerivSigInfos)\n#define ssSetNonContDerivSigInfos(S, p) (S)->mdlInfo->nonContDerivSigInfos = (p)\n\n#endif\n\n/*-------------------------------- S->sFunctions ----------------------------*/\n\n#define _ssGetSFunctions(S) (S)->sFunctions /* (SimStruct **)    */\n#define _ssSetSFunctions(S, SFunPtr) (S)->sFunctions = (SFunPtr)\n#if !SS_SFCN\n#define ssSetSFunctions(S, SFunPtr) _ssSetSFunctions(S, SFunPtr)\n#else\n#define ssSetSFunctions(S, SFunPtr) ssSetSFunctions_cannot_be_used_in_SFunctions\n#endif\n\n#define ssGetSFunction(S, sfun) ((S)->sFunctions[sfun]) /* (SimStruct *)     */\n#define _ssSetSFunction(S, sfunid, simStruc) (S)->sFunctions[sfunid] = (simStruc)\n#if !SS_SFCN\n#define ssSetSFunction(S, sfunid, simStruc) _ssSetSFunction(S, sfunid, simStruc)\n#else\n#define ssSetSFunction(S, sfunid, simStruc) ssSetSFunction_cannot_be_used_in_SFunctions\n#endif\n\n/*==============================*\n * Miscellaneous access methods *\n *==============================*/\n\n\n/*------------------------- ssIsContinuousTask ------------------------------*/\n\n\n#define ssIsAsyncTID(S, sti) (ssGetSampleTimeTaskID(S, sti) >= ssGetNumRootSampleTimes(S))\n\n\n\n/*------------------------- ssSetSampleHitInTask ----------------------------*/\n#if SS_MULTITASKING || SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#define _ssSetSampleHitInTask(S, task_j, task_i, hit) \\\n    (S)->mdlInfo->perTaskSampleHits[(task_j) + ((task_i) * (ssGetNumSampleTimes(S)))] = (hit)\n#if !SS_SFCN\n#define ssSetSampleHitInTask(S, task_j, task_i, hit) _ssSetSampleHitInTask(S, task_j, task_i, hit)\n#else\n#define ssSetSampleHitInTask(S, task_j, task_i, hit) \\\n    ssSetSampleHitInTask_cannot_be_used_in_SFunctions\n#endif\n#endif\n\n/*----------------------- ssIsSpecialSampleHit ------------------------------*/\n\n\n\n/* --------------set/get methods for firstInitCondCalled-------------------- */\n#define _ssSetFirstInitCondCalled(S, val) \\\n    (ssGetRootSS(S)->mdlInfo->mdlFlags).firstInitCondCalled = (val)\n\n#if !SS_SFCN\n#define ssSetFirstInitCondCalled(S) _ssSetFirstInitCondCalled(S, 1U)\n#define ssClearFirstInitCondCalled(S) _ssSetFirstInitCondCalled(S, 0U)\n#else\n#define ssSetFirstInitCondCalled(S) ssSetFirstInitCondCalled_cannot_be_used_in_SFunctions\n#define ssClearFirstInitCondCalled(S) ssClearFirstInitCondCalled_cannot_be_used_in_SFunctions\n#endif\n\n\n\n/*----------------------- rowMajor ------------------------------*/\n\n#define ssGetArrayLayoutForCodeGen(S) \\\n    ((S)->blkInfo.sfcnFlags.sCodeGenArrayLayout) /* SSArrayLayout */\n\n#define ssSetSupportedForRowMajorCodeGen(S, val) (S)->blkInfo.sfcnFlags.sRowMajorOptIn = val\n#define ssGetSupportedForRowMajorCodeGen(S) ((S)->blkInfo.sfcnFlags.sRowMajorOptIn)\n\n/* Get/Set for Model Param 'RowMajorDimensionSupport */\n#define ssIsModelRowMajor(S) (ssGetRootSS(S)->mdlInfo->mdlFlags.isRowMajor)\n\n/*----------------------- representation ------------------------*/\n/* This determines how an s-function is used in accelerated simulations (i.e.,\n * whether the s-function is inlined or whether its binary is used etc.)\n */\n#define ssGetSFcnRepresentation(S, result)                                                 \\\n    {                                                                                      \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_SFCN_REPRESENTATION, 0, (result)) \\\n            _ssSafelyCallGenericFcnEnd;                                                    \\\n    }\n\n#define ssSetSFcnRepresentation(S, val)                                               \\\n    {                                                                                 \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_SFCN_REPRESENTATION, val, 0) \\\n            _ssSafelyCallGenericFcnEnd;                                               \\\n    }\n\n/*----------------------- Reuse Across Models---------------------*/\n\n#define ssSetSupportedForCodeReuseAcrossModels(S, val) \\\n    (S)->blkInfo.sfcnFlags.sReuseAcrossModels = val\n#define ssGetSupportedForCodeReuseAcrossModels(S) ((S)->blkInfo.sfcnFlags.sReuseAcrossModels)\n\n#define ssSetSupportsMultipleExecInstancesForModelRefNormalMode(S, boolVal)        \\\n    ((S)->blkInfo.sfcnFlags.ssSupportsMultipleExecInstancesForModelRefNormalMode = \\\n         (boolVal) ? 1U : 0U)\n#define ssIsMultipleExecInstancesForModelRefNormalModeSupported(S) \\\n    ((S)->blkInfo.sfcnFlags.ssSupportsMultipleExecInstancesForModelRefNormalMode == 1U)\n\n#define ssSetUserDataInvariantPostCompile(S, boolVal) \\\n    ((S)->blkInfo.sfcnFlags.ssUserDataInvariantPostCompile = (boolVal) ? 1U : 0U)\n#define ssIsUserDataInvariantPostCompile(S) \\\n    ((S)->blkInfo.sfcnFlags.ssUserDataInvariantPostCompile == 1U)\n\n#define ssSetCombineCompExecUserData(S, boolVal) \\\n    ((S)->blkInfo.sfcnFlags.ssCombineCompExecUserData = (boolVal) ? 1U : 0U)\n#define ssIsCombineCompExecUserData(S) ((S)->blkInfo.sfcnFlags.ssCombineCompExecUserData == 1U)\n\n/*===========================================================================*\n * The following are for backward compatibility for user written S-functions *\n *===========================================================================*/\n\n#if SS_SFCN_LEVEL_1\n\n#define SS_OPTION_NOT_USING_mexErrMsgTxt SS_OPTION_EXCEPTION_FREE_CODE\n\n#define ssGetChecksum(S) ssGetChecksum0(S)\n#define ssSetChecksum(S, val) ssSetChecksum0(S, val)\n\n#define ssGetParamChecksum(S) ssGetChecksum3(S)\n\n\n/* Macros from Simulink 1.3, Simulink 2.0 */\n\n#define ssGetStatus(S) ssGetErrorStatus(S)\n#define ssSetStatus(S, msg) ssSetErrorStatus(S, msg)\n\n#define ssGetSizes(S) ssGetSizesPtr(S)\n\n\n#define ssGetNumScopes(S) (0.0 /*no-op*/)\n#define ssSetNumScopes(S, nScopes) /*do nothing*/\n\n#define ssGetIntgStopTime(S) ssGetSolverStopTime(S)\n#define ssSetIntgStopTime(S, stoptime) ssSetSolverStopTime(S, stoptime)\n\n#define ssSetMinorTimeStep(S, b) \\\n     ssSetSimTimeStep(S,((b)? MINOR_TIME_STEP, MAJOR_TIME_STEP))\n\n#define ssGetPresentTimeEvent(S, sti) ssGetTaskTime(S, sti)\n#define ssSetPresentTimeEvent(rootS, sti, t) ssSetTaskTime(rootS, sti, t)\n\n#define ssGetSampleHitEventPtr(S) ssGetSampleHitPtr(S)\n#define ssSetSampleHitEventPtr(S, ptr) ssSetSampleHitPtr(S, ptr)\n\n#define ssSetSampleHitEvent(S, sti, hit) ssSetSampleHit(S, sti, hit)\n\n#define ssGetSampleTimeEventPtr(S) ssGetSampleTimePtr(S)\n#define ssSetSampleTimeEventPtr(S, ptr) ssSetSampleTimePtr(S, ptr)\n\n#define ssGetSampleTimeEvent(S, sti) ssGetSampleTime(S, sti)\n#define ssSetSampleTimeEvent(S, sti, t) ssSetSampleTime(S, sti, t)\n\n#define ssGetOffsetTimeEventPtr(S) ssGetOffsetTimePtr(S)\n#define ssSetOffsetTimeEventPtr(S, ptr) ssSetOffsetTimePtr(S, ptr)\n\n#define ssGetOffsetTimeEvent(S, sti) ssGetOffsetTime(S, sti)\n#define ssSetOffsetTimeEvent(S, sti, t) ssSetOffsetTime(S, sti, t)\n\n#define ssIsSampleHitEvent(S, sti, tid) ssIsSampleHit(S, sti, tid)\n\n#define ssSetSampleHitEventInTask(rootS, task_j, task_i, hit) \\\n    ssSetSampleHitInTask(rootS, task_j, task_i, hit)\n\n#define ssIsSpecialSampleHitEvent(S, my_sti, promoted_sti, tid) \\\n    ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid)\n\n\n#define ssGetNumInputArgs(S) ssGetNumSFcnParams(S)\n#define ssSetNumInputArgs(S, numInputArgs) ssSetNumSFcnParams(S, numInputArgs)\n\n#define ssGetNumArgs(S) ssGetSFcnParamsCount(S)\n#define ssSetNumArgs(S, numArgs) ssSetSFcnParamsCount(S, numArgs)\n\n#define ssGetArgPtr(S) ssGetSFcnParamsPtr(S)\n#define ssSetArgPtr(S, args) ssSetSFcnParamsPtr(S, args)\n\n#define ssGetArg(S, argNum) ssGetSFcnParam(S, argNum)\n#define ssSetArg(S, argIdx, argMat) ssSetSFcnParam(S, argIdx, argMat)\n\n#endif\n\n\n/*===========================================================================*\n * Dataset Format Logging                                                    *\n *===========================================================================*/\n\ntypedef struct {\n    void* mmi;\n    int_T numRefModelPath;\n    const char_T** refModelPath;\n    const char_T* name;\n    boolean_T forObserver;\n    void** ppRet;\n} SFcnLoggerCreateDatasetDescriptInfo;\n\ntypedef struct {\n    int_T hierInfoIdx;\n    void** ppRet;\n} SFcnLoggerCreateValuesDescriptInfo;\n\ntypedef struct {\n    void** ppDatasetDesc;\n    const char_T* className;\n    const char_T* name;\n    const char_T* bpath;\n    const char_T* chartPath;\n    int_T portIdx;\n    int_T max_points;\n    int_T decimation_val;\n    void** ppValDesc;\n    void** ppRet;\n    const char_T* prop_name;\n} SFcnLoggerAddElementDescriptInfo;\n\ntypedef struct {\n    void** ppDatasetDesc;\n    void** ppElementDesc;\n    const char_T* name;\n    int_T nDims;\n    const int_T* dims;\n    DTypeId dataType;\n    boolean_T complexity;\n    SSLoggerInterpMethod interp;\n} SFcnLoggerAddTimeseriesDescInfo;\n\ntypedef struct {\n    void** ppDatasetDesc;\n    void** ppRetElementArray;\n    const char_T* busName;\n    unsigned int* sfOffsets;\n    unsigned int sfOffsetsSize;\n} SFcnLoggerCreateDatasetFromDescptInfo;\n\ntypedef struct {\n    const char* propName;\n    mxArray* propVal;\n    void* pElement;\n} SFcnLoggerAddElementPropInfo;\n\ntypedef struct {\n    void* pwork;\n    real_T inputTime;\n    const char* inputData;\n} SFcnLoggerUpdateLogVarInfo;\n\n#if SS_SFCN && SS_SIM\n\n/** Determine if S-Function Signal Logging is Supported **/\n#define ssLoggerSupportsDatasetSignalLogging(S, pFlag)                                         \\\n    {                                                                                          \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_SUPPORTS_SIGNAL_LOGGING, 0, pFlag) \\\n            _ssSafelyCallGenericFcnEnd;                                                        \\\n    }\n\n/** CREATION STEP 1:  Create a dataset description **/\n#define ssLoggerCreateDatasetDescription(S, datasetName, ppSetDesc) \\\n    _ssLoggerCreateDatasetDescriptWithMMI(S, NULL, 0, NULL, datasetName, ppSetDesc)\n\n#define ssLoggerGetSignalLoggingDatasetDescription(S, ppSetDesc) \\\n    _ssLoggerCreateDatasetDescriptWithMMI(S, NULL, 0, NULL, NULL, ppSetDesc)\n\n/** For sil/pil logging (start) - Use refPath to specify relative path inside the component **/\n#define ssLoggerCreateMdlRefDatasetDescription(S, nRefModelPath, refPath, datasetName, ppSetDesc) \\\n    _ssLoggerCreateDatasetDescriptWithMMI(S, NULL, nRefModelPath, refPath, datasetName, ppSetDesc)\n\n#define ssLoggerGetMdlRefSignalLoggingDatasetDescription(S, nRefModelPath, refPath, ppSetDesc) \\\n    _ssLoggerCreateDatasetDescriptWithMMI(S, NULL, nRefModelPath, refPath, NULL, ppSetDesc)\n\n#define ssObserverGetMdlRefObserverDatasetDescription(S, nRefModelPath, refPath, ppSetDesc) \\\n    _ssCreateObserverDatasetDescriptWithMMI(S, NULL, nRefModelPath, refPath, ppSetDesc)\n\n/** For sil/pil logging (end) **/\n\n#define _ssLoggerCreateDatasetDescriptWithMMI(S, modelMappingInfo, nRefModelPath, refPath,     \\\n                                              datasetName, ppSetDesc)                          \\\n    {                                                                                          \\\n        SFcnLoggerCreateDatasetDescriptInfo info;                                              \\\n        info.mmi = modelMappingInfo;                                                           \\\n        info.numRefModelPath = nRefModelPath;                                                  \\\n        info.refModelPath = refPath;                                                           \\\n        info.name = datasetName;                                                               \\\n        info.forObserver = false;                                                              \\\n        info.ppRet = ppSetDesc;                                                                \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_CREATE_DATASET_DESCRIPT, 0, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                                        \\\n    }\n\n\n/** CREATION STEP 2 (optional):  Create values description (i.e. bus) **/\n#define ssLoggerCreateBusValuesDescription(S, busHierInfoIdx, ppValuesDesc)                  \\\n    {                                                                                        \\\n        SFcnLoggerCreateValuesDescriptInfo info;                                             \\\n        info.hierInfoIdx = busHierInfoIdx;                                                   \\\n        info.ppRet = ppValuesDesc;                                                           \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_CREATE_VALUES_DESCIPT, 0, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                                      \\\n    }\n\n\n/** CREATION STEP 3:  Add element descriptions to dataset description **/\n#define ssLoggerAddSignalDescription(S, ppSetDesc, elementName, propName, blockPath, portIndex, \\\n                                     maxPoints, decimation, ppElementDesc)                      \\\n    {                                                                                           \\\n        SFcnLoggerAddElementDescriptInfo info;                                                  \\\n        info.ppDatasetDesc = ppSetDesc;                                                         \\\n        info.className = NULL;                                                                  \\\n        info.name = elementName;                                                                \\\n        info.bpath = blockPath;                                                                 \\\n        info.chartPath = NULL;                                                                  \\\n        info.portIdx = portIndex;                                                               \\\n        info.max_points = maxPoints;                                                            \\\n        info.decimation_val = decimation;                                                       \\\n        info.ppValDesc = NULL;                                                                  \\\n        info.ppRet = ppElementDesc;                                                             \\\n        info.prop_name = propName;                                                              \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_ADD_ELEMENT_DESCRIPT, 0, &info)     \\\n            _ssSafelyCallGenericFcnEnd;                                                         \\\n    }\n\n\n#define ssLoggerAddGenericElementDescription(S, ppSetDesc, elementClassName, elementName,     \\\n                                             blockPath, maxPoints, decimation, ppElementDesc) \\\n    {                                                                                         \\\n        SFcnLoggerAddElementDescriptInfo info;                                                \\\n        info.ppDatasetDesc = ppSetDesc;                                                       \\\n        info.className = elementClassName;                                                    \\\n        info.name = elementName;                                                              \\\n        info.bpath = blockPath;                                                               \\\n        info.chartPath = NULL;                                                                \\\n        info.portIdx = -1;                                                                    \\\n        info.max_points = maxPoints;                                                          \\\n        info.decimation_val = decimation;                                                     \\\n        info.ppValDesc = NULL;                                                                \\\n        info.ppRet = ppElementDesc;                                                           \\\n        info.prop_name = NULL;                                                                \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_ADD_ELEMENT_DESCRIPT, 0, &info)   \\\n            _ssSafelyCallGenericFcnEnd;                                                       \\\n    }\n\n#define ssLoggerAddSignalDescriptionWithValuesDescription(S, ppSetDesc, elementName, propName,    \\\n                                                          blockPath, portIndex, maxPoints,        \\\n                                                          decimation, ppValueDesc, ppElementDesc) \\\n    {                                                                                             \\\n        SFcnLoggerAddElementDescriptInfo info;                                                    \\\n        info.ppDatasetDesc = ppSetDesc;                                                           \\\n        info.className = NULL;                                                                    \\\n        info.name = elementName;                                                                  \\\n        info.bpath = blockPath;                                                                   \\\n        info.chartPath = NULL;                                                                    \\\n        info.portIdx = portIndex;                                                                 \\\n        info.max_points = maxPoints;                                                              \\\n        info.decimation_val = decimation;                                                         \\\n        info.ppValDesc = ppValueDesc;                                                             \\\n        info.ppRet = ppElementDesc;                                                               \\\n        info.prop_name = propName;                                                                \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_ADD_ELEMENT_DESCRIPT, 0, &info)       \\\n            _ssSafelyCallGenericFcnEnd;                                                           \\\n    }\n\n#define ssLoggerAddGenericElementDescriptionWithValuesDescription(                              \\\n    S, ppSetDesc, elementClassName, elementName, blockPath, maxPoints, decimation, ppValueDesc, \\\n    ppElementDesc)                                                                              \\\n    {                                                                                           \\\n        SFcnLoggerAddElementDescriptInfo info;                                                  \\\n        info.ppDatasetDesc = ppSetDesc;                                                         \\\n        info.className = elementClassName;                                                      \\\n        info.name = elementName;                                                                \\\n        info.bpath = blockPath;                                                                 \\\n        info.chartPath = NULL;                                                                  \\\n        info.portIdx = -1;                                                                      \\\n        info.max_points = maxPoints;                                                            \\\n        info.decimation_val = decimation;                                                       \\\n        info.ppValDesc = ppValueDesc;                                                           \\\n        info.ppRet = ppElementDesc;                                                             \\\n        info.prop_name = NULL;                                                                  \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_ADD_ELEMENT_DESCRIPT, 0, &info)     \\\n            _ssSafelyCallGenericFcnEnd;                                                         \\\n    }\n\n#define ssLoggerAddStateflowElementDescription(S, ppSetDesc, elementClassName, elementName, \\\n                                               blockPath, chartElementPath, ppValueDesc,    \\\n                                               ppElementDesc)                               \\\n    {                                                                                       \\\n        SFcnLoggerAddElementDescriptInfo info;                                              \\\n        info.ppDatasetDesc = ppSetDesc;                                                     \\\n        info.className = elementClassName;                                                  \\\n        info.name = elementName;                                                            \\\n        info.bpath = blockPath;                                                             \\\n        info.chartPath = chartElementPath;                                                  \\\n        info.portIdx = -1;                                                                  \\\n        info.max_points = 0;                                                                \\\n        info.decimation_val = 0;                                                            \\\n        info.ppValDesc = ppValueDesc;                                                       \\\n        info.ppRet = ppElementDesc;                                                         \\\n        info.prop_name = NULL;                                                              \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_ADD_ELEMENT_DESCRIPT, 0, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                                     \\\n    }\n\n/** CREATION STEP 4:  Add timeseries description to a dataset element description **/\n#define ssLoggerAddTimeseriesDescriptionWithInterpolation(                                     \\\n    S, ppSetDesc, ppElementDescript, timeseriesName, signalNdims, signalDims, signalDataType,  \\\n    signalComplexity, interpMethod)                                                            \\\n    {                                                                                          \\\n        SFcnLoggerAddTimeseriesDescInfo info;                                                  \\\n        info.ppDatasetDesc = ppSetDesc;                                                        \\\n        info.ppElementDesc = ppElementDescript;                                                \\\n        info.name = timeseriesName;                                                            \\\n        info.nDims = signalNdims;                                                              \\\n        info.dims = signalDims;                                                                \\\n        info.dataType = signalDataType;                                                        \\\n        info.complexity = signalComplexity;                                                    \\\n        info.interp = interpMethod;                                                            \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_ADD_TIMESERIES_DESCRIPT, 0, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                                        \\\n    }\n\n#define ssLoggerAddTimeseriesDescription(S, ppSetDesc, ppElementDescript, timeseriesName,         \\\n                                         signalNdims, signalDims, signalDataType,                 \\\n                                         signalComplexity)                                        \\\n    ssLoggerAddTimeseriesDescriptionWithInterpolation(                                            \\\n        S, ppSetDesc, ppElementDescript, timeseriesName, signalNdims, signalDims, signalDataType, \\\n        signalComplexity, SS_LINEAR_INTERPOLATION);\n\n/* CREATION STEP 4:  Construct variable from description */\n#define ssLoggerCreateElementFromDescription(S, ppSetDesc, elementPtrArray)                  \\\n    {                                                                                        \\\n        SFcnLoggerCreateDatasetFromDescptInfo info;                                          \\\n        info.ppDatasetDesc = ppSetDesc;                                                      \\\n        info.ppRetElementArray = elementPtrArray;                                            \\\n        info.busName = NULL;                                                                 \\\n        info.sfOffsets = NULL;                                                               \\\n        info.sfOffsetsSize = 0;                                                              \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_CREATE_DATASET_FROM_DESCRIPT, 0, \\\n                                        &info) _ssSafelyCallGenericFcnEnd;                   \\\n    }\n\n#define ssLoggerCreateElementFromDescriptionForBus(S, ppSetDesc, busObjName, elementPtrArray, \\\n                                                   offsetArray, offsetArraySize)              \\\n    {                                                                                         \\\n        SFcnLoggerCreateDatasetFromDescptInfo info;                                           \\\n        info.ppDatasetDesc = ppSetDesc;                                                       \\\n        info.ppRetElementArray = elementPtrArray;                                             \\\n        info.busName = busObjName;                                                            \\\n        info.sfOffsets = offsetArray;                                                         \\\n        info.sfOffsetsSize = offsetArraySize;                                                 \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_CREATE_DATASET_FROM_DESCRIPT, 0,  \\\n                                        &info) _ssSafelyCallGenericFcnEnd;                    \\\n    }\n\n/** CREATION STEP 5 (optional):  Add additional properties to generic element **/\n#define ssLoggerAddElementProperty(S, elementPtr, propertyName, propertyVal)            \\\n    {                                                                                   \\\n        SFcnLoggerAddElementPropInfo info;                                              \\\n        info.propName = propertyName;                                                   \\\n        info.propVal = propertyVal;                                                     \\\n        info.pElement = elementPtr;                                                     \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_ADD_ELEMENT_PROP, 0, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                                 \\\n    }\n\n/** UPDATE **/\n#define ssLoggerUpdateTimeseries(S, elementPtr, timeseriesIdx, timeVal, dataPtr)                 \\\n    {                                                                                            \\\n        SFcnLoggerUpdateLogVarInfo info;                                                         \\\n        info.pwork = elementPtr;                                                                 \\\n        info.inputTime = timeVal;                                                                \\\n        info.inputData = dataPtr;                                                                \\\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_LOGGER_UPDATE_LOGVAR, timeseriesIdx, &info) \\\n            _ssSafelyCallGenericFcnEnd;                                                          \\\n    }\n\n/**\n *   Implementation of Simulink Pointer S-Function API\n */\n#define ssIsPointerDataType(S, dataTypeId)                                                       \\\n    ({                                                                                           \\\n        bool isPointer;                                                                          \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_IS_POINTER_DATA_TYPE, dataTypeId, &isPointer) \\\n            _ssSafelyCallGenericFcnEnd;                                                          \\\n        isPointer;                                                                               \\\n    })\n\n#define ssGetPointerContainedDataType(S, dataTypeId)                                            \\\n    ({                                                                                          \\\n        DTypeId retDtId;                                                                        \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_POINTER_CONTAINED_DATA_TYPE, dataTypeId, \\\n                                        &retDtId) _ssSafelyCallGenericFcnEnd;                   \\\n        retDtId;                                                                                \\\n    })\n\n#define ssGetPointerContainedDataComplexity(S, dataTypeId)                                \\\n    ({                                                                                    \\\n        \\ ssComplexity retCplx;                                                           \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_POINTER_CONTAINED_DATA_COMPLEXITY, \\\n                                        dataTypeId, &retCplx) _ssSafelyCallGenericFcnEnd; \\\n        retCplx;                                                                          \\\n    })\n\n#define ssGetPointerContainedData(S, dtId, dataArg)                                       \\\n    ({                                                                                    \\\n        PointerRec slPointerRec;                                                          \\\n        slPointerRec.dataTypeId = (dtId);                                                 \\\n        slPointerRec.data = (dataArg);                                                    \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_POINTER_CONTAINED_DATA, 0,         \\\n                                        (void*)&slPointerRec) _ssSafelyCallGenericFcnEnd; \\\n        slPointerRec.retData;                                                             \\\n    })\n\n#define ssGetPointerContainedDataWidth(S, dtId, dataArg)                                  \\\n    ({                                                                                    \\\n        PointerRec slPointerRec;                                                          \\\n        slPointerRec.dataTypeId = (dtId);                                                 \\\n        slPointerRec.data = (dataArg);                                                    \\\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_POINTER_CONTAINED_DATA_WIDTH, 0,   \\\n                                        (void*)&slPointerRec) _ssSafelyCallGenericFcnEnd; \\\n        slPointerRec.retWidth;                                                            \\\n    })\n\n#endif\n\n#define ssIsDimensionUnbounded(dim) ((dim) == (INT_MAX - 1))\n\n/*\n * API specific to Simulink solver that needs to be accessed in\n * Rapid accelerator and RSIM\n */\n\n#include \"simulink_solver_api.h\"\n\n/*\n * Include rtModel definitions if in RTW and using rtModel\n */\n#ifdef USE_RTMODEL\n#include \"sfcn_bridge.h\"\n#endif\n\n#endif /* __SIMSTRUC__INTERNAL */\n\n/* EOF: simstruc_internal.h */\n\n/* LocalWords:  SimStruct's NRT NSAMPLE NUMST sfunc sfunctions RSIM sfunction Fxp getters DAE meth\n * LocalWords:  elif ID's EXTLOGTASK ONESHOT ir Lcs dworks dstates fcncall DWork Vec Bds odesup\n * LocalWords:  SlvrJacobianFcn extmode DTypeId SIGSET sigmapdef th th'signal NOSYMBDIMS MExpr\n * LocalWords:  tid's zc intg conds nd resolveCBK vals sti iwork rwork pwork\n * LocalWords:  nzMax compat SG et AslErrMsg RWork IWork PWork SFunctions untest\n * LocalWords:  versioning NonsampledZCs SlvrJacobian FCSSCtrl fixedpoint CSignal\n * LocalWords:  OptimOpts reusability ny OR'd mxCalloc vxlib ASYNC cycan VxWorks\n * LocalWords:  Async ZOH TRIGSS dlg prms rtp datatype async APIS ints ABus dsm\n * LocalWords:  BPath mrBlk MODELREF submodel modelref UPtrs slvr nxc jc nxd ndx\n * LocalWords:  nx Prev Nonsampled ZCs nonsampled Dirs DState CStates Optim Asl\n * LocalWords:  SINGLETASKING XPC call's DType DerivPort Deriv slexec ssbridge\n * LocalWords:  upcasting rsim sil pil simbridge Symb Wreserved\n */\n"},{"name":"simstruc_internal_types.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/*\n *\n * File: simstruc_internal_types.h\n *\n * Abstract:\n *   Types used internally by SimStruct, but not published to external users.\n */\n\n#ifndef __SIMSTRUC_INTERNAL_TYPES_H__\n#define __SIMSTRUC_INTERNAL_TYPES_H__\n\n#include \"simstruc_types.h\"\n\n/* 32-bit and 64-bit exclusive typedefs */\ntypedef struct DimsInfo_tag DimsInfo_AsInt;\ntypedef struct DimsInfo_tag_SLSize DimsInfo_AsSLSize;\n\n/* Forward-declaration of type for which the full definition is not needed everywhere */\nstruct _ssMdlInfo;\n\n/* Model info types */\ntypedef enum {\n    MDL_INFO_ID_PARAM = 0,\n    MDL_INFO_ID_SIGNAL,\n    MDL_INFO_ID_STATE,\n    MDL_INFO_ID_DSM,\n    MDL_INFO_ID_GLOBAL_DSM,\n    MDL_INFO_ID_DATA_TYPE,\n    MDL_INFO_ID_CMPLX_DATA_TYPE,\n    MDL_INFO_ID_MODEL,\n    MDL_INFO_ID_FCNNAME,\n    MDL_INFO_ID_GRPFCNNAME,\n    MDL_INFO_ID_CSC,\n    MDL_INFO_ID_IMPORTED_CSC,\n    MDL_INFO_SUBSYS_FILENAME,\n    MDL_INFO_MODEL_FILENAME,\n    MDL_INFO_ID_MACHINE_EXPORTED,\n    MDL_INFO_NAME_GLOBAL_DSM,\n    MDL_INFO_NAME_MDLREF_DWORK,\n    MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT,\n    MDL_INFO_ID_ENUMTYPE_STRING,\n    MDL_INFO_ID_MODEL_FCN_ARGNAME,\n    MDL_INFO_ID_MODEL_FCN_NAME,\n    MDL_INFO_ID_MODEL_CLASS_NAME,\n    MDL_INFO_ID_MODEL_CLASS_NAMESPACE,\n    MDL_INFO_ID_AUTOSAR_RTE_FCN_NAME,\n    MDL_INFO_ID_SFCN_NAME,\n    MDL_INFO_ID_RESERVED,\n    MDL_INFO_ID_VARIANT,\n    MDL_INFO_ID_SLFCNCALL,\n    MDL_INFO_ID_OUTPORT_BLOCK_SIGNAL,\n    MDL_INFO_ID_MDL_WKS_PARAM,\n    MDL_INFO_ID_INPORT_SIGNAL,\n    NumMdlInfoType\n} MdlInfoType;\n\ntypedef enum { SIM_PAUSE, SIM_CONTINUE } ssSimStatusChangeType;\n\ntypedef struct PointerRec_t {\n    DTypeId dataTypeId;\n    const void* data;\n    void* retData;\n    size_t retWidth;\n} PointerRec;\n\ntypedef enum {\n    /*\n     * Called when the user request the trigger to be armed (i.e., after\n     * the 'arm trigger' button is pressed and the trigger arm message\n     * has successfully been handed off to ext_comm).\n     */\n    EXTLOGTASK_TRIG_ARM,\n\n    /*\n     * Called when the first point of a one-shot arrives.\n     */\n    EXTLOGTASK_INIT_EVENT,\n\n    /*\n     * Definitions:\n     *  one-shot:    one buffer of data collected when the trigger fires.\n     *  normal-mode: a series of one-shots\n     *\n     * When in normal mode, each buffer in the series, except for the last\n     * buffer is consider to be an 'intermediate' buffer.  When the final\n     * point of an intermediate buffer has arrived on the host, the\n     * EXTLOGTASK_TERM_INTERMEDIATE_ONESHOT method is called.  When the\n     * final point of the last buffer of the series arrives, the\n     * EXTLOGTASK_TERM_SESSION is called.\n     *\n     * Note that when not in normal mode, the\n     * EXTLOGTASK_TERM_INTERMEDIATE_ONESHOT method is never called.\n     *\n     * Also see EXTLOGTASK_TERM_SESSION.\n     */\n    EXTLOGTASK_TERM_INTERMEDIATE_ONESHOT,\n\n    /*\n     * Called when:\n     *  o In normal mode and the last point of the last buffer in a one-shot\n     *    series has arrived (i.e., this is the end of the current log session).\n     *\n     *  o When in one-shot mode and the final point arrives (again this is the\n     *    end of the logging session since the one and only buffer has been\n     *    acquired).\n     *\n     *  See comments for: EXTLOGTASK_TERM_INTERMEDIATE_ONESHOT\n     */\n    EXTLOGTASK_TERM_SESSION\n\n} ExtModeLogBlockMeth;\n\n\n#endif /* __SIMSTRUC_INTERNAL_TYPES_H__ */\n"},{"name":"simstruc_types.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2021 The MathWorks, Inc. */\n\n/*\n *\n * File: simstruc_types.h\n *\n * Abstract:\n *   The embedded code formats do not include simstruc.h, but\n *   need these common types.\n */\n\n#ifndef __SIMSTRUC_TYPES_H__\n#define __SIMSTRUC_TYPES_H__\n\n/** From R2017a onwards, by default, MEX-files build\n * using the 64-bit matrix API.\n * If you do not explicitly specify the -compatibleArrayDims flag with to build\n * using the 32-bit matrix API, or the -largeArrayDims flag to build\n * using 64-bit matrix API via the MEX command, then\n * override the default behavior by defining MX_COMPAT_32\n * explicitly. This applies only for code that\n * include simstruc.h\n *\n */\n#if defined(MATLAB_MEX_FILE)\n#if !defined(MX_COMPAT_32) && !defined(MX_COMPAT_64) && defined(USE_MEX_CMD)\n#if defined(tmwtypes_h)\nforceCompilationError tmwtypesbeforesimstrucdetected;\n#else\n#define MX_COMPAT_32\n#endif\n#endif\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n#include \"sl_types_def.h\"\n\n\n/* Additional types required for Simulink External Mode */\n#ifndef fcn_call_T\n#define fcn_call_T real_T\n#endif\n#ifndef action_T\n#define action_T real_T\n#endif\n\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x) /* do nothing */\n#else\n/*\n * This is the semi-ANSI standard way of indicating that a\n * unused function parameter is required.\n */\n#define UNUSED_PARAMETER(x) (void)(x)\n#endif\n#endif\n\n#define UNUSED_ARG(arg) UNUSED_PARAMETER(arg)\n\ntypedef enum {\n    SS_SIMMODE_NORMAL,          /* Running a \"normal\" Simulink simulation     */\n    SS_SIMMODE_SIZES_CALL_ONLY, /* Block edit eval to obtain number of ports  */\n    SS_SIMMODE_RTWGEN,          /* Generating code                            */\n    SS_SIMMODE_EXTERNAL         /* External mode simulation                   */\n} SS_SimMode;\n\ntypedef enum {\n    SS_SIMTYPE_UNKNOWN = -1,\n    SS_SIMTYPE_SIM,\n    SS_SIMTYPE_MODEL_API,\n    SS_SIMTYPE_LINEARIZATION,\n    SS_SIMTYPE_RTW,\n    SS_SIMTYPE_EXTERNAL\n} SS_SimType;\n\n/* Must be used when SS_SimMode is SS_SIMMODE_RTWGEN */\ntypedef enum {\n    SS_RTWGEN_UNKNOWN,\n    SS_RTWGEN_RTW_CODE,                  /* Code generation for RTW */\n    SS_RTWGEN_ACCELERATOR,               /* Code generation for accelerator */\n    SS_RTWGEN_MODELREFERENCE_SIM_TARGET, /*Code Generation for Model Reference Sim Target*/\n    SS_RTWGEN_MODELREFERENCE_RTW_TARGET  /*Code Generation for Model Reference RTW Target*/\n} RTWGenMode;\n\n/*=====================================*\n * Simulation Status                   *\n *=====================================*/\n\ntypedef enum {\n    SIMSTATUS_STOPPED,\n    SIMSTATUS_UPDATING,\n    SIMSTATUS_INITIALIZING,\n    SIMSTATUS_RESTARTING,\n    SIMSTATUS_RUNNING,\n    SIMSTATUS_PAUSED_IN_DEBUGGER,\n    SIMSTATUS_PAUSED,\n    SIMSTATUS_TERMINATING,\n    SIMSTATUS_COMPILED,\n\n\n    /* Must be last */\n    SIMSTATUS_EXTERNAL\n} SS_SimStatus;\n\n\n/* The following section is inlined from coder_model_reference_types.h */\n#ifndef MODEL_REFERENCE_TYPES\n#define MODEL_REFERENCE_TYPES\n\n/*\n * This structure is used by model reference to\n * communicate timing information through the hierarchy.\n */\ntypedef struct _rtTimingBridge_tag rtTimingBridge;\n\nstruct _rtTimingBridge_tag {\n\n    uint32_T nTasks;\n\n    uint32_T** clockTick;\n    uint32_T** clockTickH;\n\n    uint32_T* taskCounter;\n\n    real_T** taskTime;\n\n    boolean_T** rateTransition;\n\n    boolean_T* firstInitCond;\n};\n\ntypedef struct _rtCtrlRateMdlRefTiming_tag rtCtrlRateMdlRefTiming;\n\nstruct _rtCtrlRateMdlRefTiming_tag {\n\n    uint32_T firstCtrlRateTID;\n    uint32_T* numTicksToNextHitForCtrlRate;\n};\n\n#endif /* MODEL_REFERENCE_TYPES */\n\n\n#ifndef ZERO_CROSSING_TYPES_H\n#define ZERO_CROSSING_TYPES_H\n\n/* Trigger directions: falling, either, and rising */\ntypedef enum {\n    FALLING_ZERO_CROSSING = -1,\n    ANY_ZERO_CROSSING = 0,\n    RISING_ZERO_CROSSING = 1\n} ZCDirection;\n\n/* Previous state of a trigger signal */\ntypedef uint8_T ZCSigState;\n\n/* Initial value of a trigger zero crossing signal */\n#define UNINITIALIZED_ZCSIG 0x03U\n#define NEG_ZCSIG 0x02U\n#define POS_ZCSIG 0x01U\n#define ZERO_ZCSIG 0x00U\n\n/* Current state of a trigger signal */\ntypedef enum { FALLING_ZCEVENT = -1, NO_ZCEVENT = 0, RISING_ZCEVENT = 1 } ZCEventType;\n\n#endif /* ZERO_CROSSING_TYPES_H */\n\n/* Detail zerocrossing event for removing double detection */\n#ifndef ZERO_CROSSING_EVENT_TYPES\n#define ZERO_CROSSING_EVENT_TYPES\n\n#define ZC_EVENT_NUL 0x00\n#define ZC_EVENT_N2P 0x01\n#define ZC_EVENT_N2Z 0x02\n#define ZC_EVENT_Z2P 0x04\n#define ZC_EVENT_P2N 0x08\n#define ZC_EVENT_P2Z 0x10\n#define ZC_EVENT_Z2N 0x20\n#define ZC_EVENT_ALL_UP (ZC_EVENT_N2P | ZC_EVENT_N2Z | ZC_EVENT_Z2P)\n#define ZC_EVENT_ALL_DN (ZC_EVENT_P2N | ZC_EVENT_P2Z | ZC_EVENT_Z2N)\n#define ZC_EVENT_ALL (ZC_EVENT_ALL_UP | ZC_EVENT_ALL_DN)\n\n#endif /* ZERO_CROSSING_EVENT_TYPES */\n\n#define SS_START_MTH_PORT_ACCESS_UNSET 2\n#ifdef IS_SIM_TARGET\n#include \"rtw_matlogging_simtarget.h\"\n#else\n#include \"rtw_matlogging.h\"\n#endif\n#include \"rtw_extmode.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include \"sysran_types.h\"\n\ntypedef int_T CSignal_T;\n\n/* DimsInfo_T structure is for S-functions */\n#ifndef _DIMSINFO_T\n#define _DIMSINFO_T\n\nstruct DimsInfo_tag {\n    int width;                        /* number of elements    */\n    int numDims;                      /* number of dimensions  */\n    int* dims;                        /* dimensions            */\n    struct DimsInfo_tag* nextSigDims; /* for composite signals */\n};\n\n/* SLSize version of DimsInfo_tag struct */\nstruct DimsInfo_tag_SLSize {\n    int width;                               /* number of elements    */\n    int numDims;                             /* number of dimensions  */\n    int* dims;                               /* dimensions            */\n    struct DimsInfo_tag_SLSize* nextSigDims; /* for composite signals */\n};\n\n#if defined(SL_INTERNAL) || defined(SFCN64)\ntypedef struct DimsInfo_tag_SLSize DimsInfo_T;\n#else\ntypedef struct DimsInfo_tag DimsInfo_T;\n#endif\n\n\ntypedef int_T ssFcnCallErr_T;\n\n/*\n * DECL_AND_INIT_DIMSINFO(variableName):\n *    Macro for setting up a DimsInfo in an S-function to DYNAMIC_DIMENSION.\n *    This macro must be placed at the start of a declaration, for example:\n *\n *           static void mdlInitializeSizes(SimStruct *S)\n *           {\n *               DECL_AND_INIT_DIMSINFO(diminfo1);\n *\n *               ssSetNumSFcnParams(S, 0);\n *               <snip>\n *           }\n *\n *    The reason that this macro must be placed in the declaration section of a\n *    function or other scope is that this macro **creates** a local variable of\n *    the specified name with type DimsInfo_T. The variable is initialized\n *    to DYNAMIC_DIMENSION.\n */\n#define DECL_AND_INIT_DIMSINFO(variableName) DimsInfo_T variableName = {-1, -1, NULL, NULL}\n#endif /* _DIMSINFO_T */\n\n\n/*\n * Enumeration of work vector used as flag values.\n */\ntypedef enum {\n    SS_DWORK_USED_AS_DWORK = 0, /* default */\n    SS_DWORK_USED_AS_DSTATE,    /* will be logged, loaded, etc */\n    SS_DWORK_USED_AS_SCRATCH,   /* will be reused */\n    SS_DWORK_USED_AS_MODE       /* replace mode with dwork */\n} ssDWorkUsageType;\n\n#define SS_NUM_DWORK_USAGE_TYPES 3\n\n/*\n * DWork structure for S-Functions, one for each dwork.\n */\nstruct _ssDWorkRecord {\n    int_T width;\n    DTypeId dataTypeId;\n    CSignal_T complexSignal;\n    void* array;\n    const char_T* name;\n    ssDWorkUsageType usedAs;\n};\n\n#include \"sl_sample_time_defs.h\"\n\n\n/* ========================================================================== */\n\n/*\n * Lightweight structure for holding a real, sparse matrix\n * as used by the analytical Jacobian methods.\n */\ntypedef struct SparseHeader_Tag {\n    int_T mRows; /* number of rows   */\n    int_T nCols; /* number of cols   */\n    int_T nzMax; /* size of *pr, *ir */\n    int_T* Ir;   /* row indices      */\n    int_T* Jc;   /* column offsets   */\n#ifndef NO_FLOATS\n    real_T* Pr; /* nonzero entries  */\n#else\n    void* Pr;\n#endif\n} SparseHeader;\n\n/*========================*\n * Setup for multitasking *\n *========================*/\n\n/*\n * Let MT be synonym for MULTITASKING (to shorten command line for DOS)\n */\n#if defined(MT)\n#if MT == 0\n#undef MT\n#else\n#define MULTITASKING 1\n#endif\n#endif\n\n#if defined(MULTITASKING) && MULTITASKING == 0\n#undef MULTITASKING\n#endif\n\n#if defined(MULTITASKING) && !defined(TID01EQ)\n#define TID01EQ 0\n#endif\n\n/*\n * Undefine MULTITASKING if there is only one task or there are two\n * tasks and the sample times are equal (case of continuous and one discrete\n * with equal rates).\n */\n#if defined(NUMST) && defined(MULTITASKING)\n#if NUMST == 1 || (NUMST == 2 && TID01EQ == 1)\n#undef MULTITASKING\n#endif\n#endif\n\ntypedef enum {\n    SS_UNKNOWN_INTERPOLATION = -1,\n    SS_ZOH_INTERPOLATION = 1,\n    SS_LINEAR_INTERPOLATION = 2\n} SSLoggerInterpMethod;\n\ntypedef enum {\n    SS_MODEL_DATA_LOGS = 1,\n    SS_DATASET_FORMAT = 2,\n    SS_LOG_FORMAT_MIXED = 3,\n    SS_ARRAY_FORMAT = 4,\n    SS_STRUCTURE_FORMAT = 5,\n    SS_STRUCTUREWITHTIME_FORMAT = 6\n} SSLoggingSaveFormat;\n\n/*======================================================*\n * Types for Simulink Functions access from S-functions *\n *======================================================*/\n\n#ifndef SIMULINK_FUNCTION_TYPES\n#define SIMULINK_FUNCTION_TYPES\ntypedef struct _ssFcnCallExecArgInfo_tag {\n    void* dataPtr;\n    int_T dataSize;\n    void* reserved;\n} _ssFcnCallExecArgInfo;\n\ntypedef struct _ssFcnCallExecData_tag {\n    const char* fcnName;\n    void* reserved;\n} _ssFcnCallExecData;\n\ntypedef struct _ssFcnCallExecArgs_tag {\n    int_T numInArgs;\n    int_T numOutArgs;\n    _ssFcnCallExecArgInfo* inArgs;\n    _ssFcnCallExecArgInfo* outArgs;\n    _ssFcnCallExecData* execData;\n    void* reserved;\n} _ssFcnCallExecArgs;\n\ntypedef _ssFcnCallExecArgs ssFcnCallExecArgs;\n\n#endif /* SIMULINK_FUNCTION_TYPES */\n\n#endif /* __SIMSTRUC_TYPES_H__ */\n"},{"name":"simulink.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2002 The MathWorks, Inc. */\n\n#error Pre-Simulink 2.0 S-functions no are longer supported.  We suggest using one of the S-function templates and adding your algorithm code to it.\n\n"},{"name":"simulink2.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2002 The MathWorks, Inc. */\n\n#error Pre-Simulink 2.0 S-functions no are longer supported.  We suggest using one of the S-function templates and adding your algorithm code to it.\n\n"},{"name":"simulink_solver_api.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2010-2021 The MathWorks, Inc. */\n/*\n * simulink_solver_api.h\n * API specific to Simulink Solver that needs to be accessed in\n * Rapid accelerator and Rsim\n * ** This file needs to be compilable standalone with standard Raccel/Rsim\n *    compile flags. Any code that calls into Simulink Engine should NOT be\n *    added here.\n * ** Do NOT add additional macros in this file before consulting\n *    Simulink Execution/Solvers Group\n */\n\n#ifndef SIMULINK_SOLVER_API\n#define SIMULINK_SOLVER_API\n\n#include \"simstruc.h\"\n\n/*\n * Continuous state absolute tolerance handling\n */\n\n\n/*\n * To configure absolute tolerances for S-functions:\n * See documentation for ssSetStateAbsTol\n */\n\n\n\n/*\n * ssGetAbsTol (LEGACY MACRO) :  DO NOT USE IN NEW S-FUNCTIONS\n * This macros modifies internal control flags for absolute tolerances\n * and therefore, assumes that you intend to modify all elements\n * of the absolute tolerance vector.\n * Use the following alternatives:\n * 1. If you want to set the abstol, use : ssSetStateAbsTol\n * 2. If you want read-only-access to an abstol elemt, use : ssGetStateAbsTol\n */\n\n#define ssGetAbsTol(S) _ssGetAbsTol(S)\n\n#define ssGetAbsTolVector(S) (const real_T*)(((S)->states.statesInfo2)->absTol)\n\n#define ssGetAbsTolControlVector(S) \\\n    (const uint8_T*)(((S)->states.statesInfo2)->absTolControl) /*(*uint8_T) */\n\n\n#if (SS_SL_INTERNAL || SS_GENERATED_S_FUNCTION || SS_RTW_INTERNAL)\n\n#undef ssGetAbsTolVector\n#define ssGetAbsTolVector(S) ((S)->states.statesInfo2)->absTol /*   (*real_T)     */\n#define ssSetAbsTolVector(S, atol) ((S)->states.statesInfo2)->absTol = (atol)\n\n#undef ssGetAbsTolControlVector\n#define ssGetAbsTolControlVector(S) ((S)->states.statesInfo2)->absTolControl /*(*uint8_T) */\n#define ssSetAbsTolControlVector(S, atol) ((S)->states.statesInfo2)->absTolControl = (atol)\n\n#define ssGetStateAbsTolControl(S, idx) ((S)->states.statesInfo2)->(S)->absTolControl[idx]\n\n/* Only Set macros to allow Simulink Engine and generated code to set these\n * pointers on mdlInfo for use with legacy code.\n * No one should access/get these pointers for any reason whatsoever in new code.\n */\n#define ssSetAbsTolOffset_Obsolete(S, offset) (S)->blkInfo.absTolOffset_Obsolete = (offset)\n\n#define ssSetSolverAbsTol_Obsolete(S, atol) (S)->mdlInfo->solverAbsTol_Obsolete = (atol)\n#define ssSetSolverAbsTolControl_Obsolete(S, atol) \\\n    (S)->mdlInfo->solverAbsTolControl_Obsolete = (atol)\n\n#endif\n\n\n#endif\n"},{"name":"slImageTypes.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2020-2021 The MathWorks, Inc. */\n\n/**\n * @file: slImageTypes.h\n *\n * @brief SimStruct types for Simulink Image operations\n *\n */\n\n#ifndef __SIMSTRUC__IMAGETYPES\n#define __SIMSTRUC__IMAGETYPES\n\n#include \"images/datatypes/ImageDefs.hpp\"\n\n/* Data type properties for image types */\ntypedef struct {\n    size_t numChannels;\n    size_t numRows;\n    size_t numCols;\n    images::datatypes::ColorFormat colorFormat;\n    images::datatypes::Layout dataLayout;\n    images::datatypes::UnderlyingType baseType;\n} ImageDataTypeProperties;\n\n#endif\n"},{"name":"sl_common_types_def.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2010-2021 The MathWorks, Inc. */\n#ifndef __SL_COMMON_TYPES_DEF_H__\n#define __SL_COMMON_TYPES_DEF_H__\n\n#include \"sl_types_def.h\"\n#include \"sl_fixpt.h\"\n#include \"sl_datatype_access.h\"\n#include \"rtw_storage.h\"\n\n#define DYNAMICALLY_SIZED (-1)\n#define DYNAMICALLY_TYPED (-1)\n\n#define OVERWRITE_INPUT_ANY (-2)\n#define OVERWRITE_INPUT_NONE (-1)\n\n#define INVALID_PORT_IDX (-1)\n\ntypedef enum { COMPLEX_INHERITED = -1, COMPLEX_NO, COMPLEX_YES } ssComplexity;\n\n/*\n * Frame enum\n */\ntypedef enum { FRAME_INHERITED = -1, FRAME_NO, FRAME_YES } Frame_T;\n\n/*\n * ssSetNumSampleTimes(S,PORT_BASED_SAMPLE_TIMES) - Indicates that the sample\n * times are assigned on a per port basis.\n */\n#if !SS_SFCN_LEVEL_1\n#define PORT_BASED_SAMPLE_TIMES -1\n#endif\n\n#ifndef _DIMENSION_MODE_T\n#define _DIMENSION_MODE_T\n\n/*\n * Dimensions mode\n * S-function ports can have the following three dimensions modes:\n * 1) INHERIT_DIMS_MODE\n *    - Dimensions mode depends on settings of the connected ports;\n *    - Ports cannot have INHERIT_DIMS_MODE after model compile;\n * 2) FIXED_DIMS_MODE\n *    - Signal dimensions are fixed during simulation;\n * 3) VARIABLE_DIMS_MODE\n *    - Signal dimensions are allowed to change during simulation.\n */\ntypedef enum { INHERIT_DIMS_MODE = -1, FIXED_DIMS_MODE, VARIABLE_DIMS_MODE } DimensionsMode_T;\n\n#endif\n\ntypedef enum {\n    SS_VARIABLE_SIZE_FROM_INPUT_SIZE = 0,      /* Output sizes only depend on input sizes */\n    SS_VARIABLE_SIZE_FROM_INPUT_VALUE_AND_SIZE /* Output sizes depend on input values     */\n} SS_VariableSizeComputeType;\n\ntypedef enum {\n    SS_VARIABLE_SIZE_STATE_NO_NEED_RESET = 0,\n    SS_VARIABLE_SIZE_REQUIRE_STATE_RESET\n} SS_VariableSizeStateResetType;\n\ntypedef enum { SS_PRM_NOT_TUNABLE = 0, SS_PRM_TUNABLE, SS_PRM_SIM_ONLY_TUNABLE } ssParamTunability;\n\n#define SS_NOT_REUSABLE_AND_GLOBAL 0U /* default */\n#define SS_REUSABLE_AND_LOCAL 1U\n#define SS_REUSABLE_AND_GLOBAL 2U\n#define SS_NOT_REUSABLE_AND_LOCAL 3U\n\n\n/* For mdlRTW ssWriteRTWParamSettings macro */\n#define SSWRITE_VALUE_STR 0\n#define SSWRITE_VALUE_QSTR 1\n#define SSWRITE_VALUE_VECT_STR 2\n#define SSWRITE_VALUE_NUM 3\n#define SSWRITE_VALUE_VECT 4\n#define SSWRITE_VALUE_2DMAT 5\n#define SSWRITE_VALUE_DTYPE_NUM 6\n#define SSWRITE_VALUE_DTYPE_VECT 7\n#define SSWRITE_VALUE_DTYPE_2DMAT 8\n#define SSWRITE_VALUE_DTYPE_ML_VECT 9\n#define SSWRITE_VALUE_DTYPE_ML_2DMAT 10\n#define SSWRITE_VALUE_LIST_STR 11\n\n#define DTINFO(id, complexSignal) ((complexSignal) ? ((id) | 0x10000) : (id))\n\n/*\n *  Operating point used to be called SimState. For backward compatibility, the SimState flags are\n * preserved.\n */\ntypedef enum {\n    SIM_STATE_COMPLIANCE_INVALID = -1,\n    SIM_STATE_COMPLIANCE_UNKNOWN = 0,\n    USE_DEFAULT_SIM_STATE,\n    HAS_NO_SIM_STATE,\n    USE_CUSTOM_SIM_STATE,\n    DISALLOW_SIM_STATE\n\n} ssSimStateCompliance;\n\n/*\n * Enumerations to specify the S-function's compliance level with the\n * Operating Point save/restore feature\n */\ntypedef enum {\n    OPERATING_POINT_COMPLIANCE_INVALID = (int)SIM_STATE_COMPLIANCE_INVALID,\n    OPERATING_POINT_COMPLIANCE_UNKNOWN = (int)SIM_STATE_COMPLIANCE_UNKNOWN,\n    USE_DEFAULT_OPERATING_POINT = (int)USE_DEFAULT_SIM_STATE,\n    USE_EMPTY_OPERATING_POINT = (int)HAS_NO_SIM_STATE,\n    USE_CUSTOM_OPERATING_POINT = (int)USE_CUSTOM_SIM_STATE,\n    DISALLOW_OPERATING_POINT = (int)DISALLOW_SIM_STATE\n} ssOperatingPointCompliance;\n\ntypedef enum {\n    SIMULATION_ROLLBACK_UNINITIALIZED = 0U,\n    SIMULATION_ROLLBACK_COMPLIANT = 1U,\n    SIMULATION_ROLLBACK_NONCOMPLIANT_NEUTRAL = 2U,\n    SIMULATION_ROLLBACK_NONCOMPLIANT_FATAL = 3U\n} SimulationRollbackCompliance;\n\ntypedef enum {\n    SIMULATION_FASTRESTART_UNINITIALIZED = 0U,\n    SIMULATION_FASTRESTART_COMPLIANT = 1U,\n    SIMULATION_FASTRESTART_NONCOMPLIANT_NEUTRAL = 2U,\n    SIMULATION_FASTRESTART_NONCOMPLIANT_FATAL = 3U\n} SimulationFastRestartCompliance;\n\ntypedef enum {\n    VM_SIMULATIONS_COMPLIANT = 0U,\n    VM_SIMULATIONS_NONCOMPLIANT_NEUTRAL = 1U,\n    VM_SIMULATIONS_NONCOMPLIANT_FATAL = 2U\n} VmSimulationsCompliance;\n\n/*\n * Enumerations to specify the S-Function's compliance level of\n * runtime method thread safety.\n */\ntypedef enum {\n    RUNTIME_THREAD_SAFETY_COMPLIANCE_UNKNOWN = 0,\n    RUNTIME_THREAD_SAFETY_COMPLIANCE_FALSE,\n    RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE\n} RuntimeThreadSafetyCompliance;\n\ntypedef enum {\n    SAMPLE_TIME_SUPPORT_UNKNOWN = 0,\n    USE_DEFAULT_FOR_DISCRETE_INHERITANCE,\n    DISALLOW_SAMPLE_TIME_INHERITANCE\n} ModelRefTsInhRule;\n\n/*\n * ss(Set|Get)ModelReferenceNormalModeSupport\n *\n * If this s-function has a mdlProcessParameters and mdlStart function,\n * and is used in a model referenced in normal mode, Simulink will error\n * out by default.  If your mdlProcessParameters function is safe to call\n * before mdlStart, set it to  MDL_START_AND_MDL_PROCESS_PARAMS_OK\n */\ntypedef enum {\n    DEFAULT_SUPPORT_FOR_NORMAL_MODE = 0,\n    MDL_START_AND_MDL_PROCESS_PARAMS_OK = 1,\n    TUNABLE_PARAMS_NOT_USED_IN_MDL_START = 2\n} ssModelReferenceNormalModeSupport;\n\n/* Used by macro ssAddVariableSizeSignalsRuntimeChecker */\ntypedef enum { INPUTS_DIMS_MATCH = 0, INPUTS_DISALLOW_EMPTY_SIGNAL } RuntimeCheckerType_T;\n\n#ifndef _SS_PARAM_REC\n#define _SS_PARAM_REC\n/*\n * Typedef for the enumeration that keeps track of the \"transformed\"\n * status of run-time parameters.\n */\ntypedef enum {\n\n    /*\n     * Your run-time parameter is not transformed if nDialogParamIndices is\n     * one and there was no alteration of the dialog parameter\n     */\n    RTPARAM_NOT_TRANSFORMED = 0,\n\n    /*\n     * Your run-time parameter is transformed if nDialogParamIndices > 1 or\n     * there was an alteration of the dialog parameter value or data type.\n     */\n    RTPARAM_TRANSFORMED = 1,\n\n    /*\n     * Your run-time parameter can be marked as 'make transformed tunable'\n     * if nDialogParamIndices is one and you altered the dialog parameter\n     * value or data  type. If the parameter field contains a single\n     * tunable variable, say 'k', then the transformed data type, etc.\n     * version of k will be used in the generated code. All references to\n     * tunable parameters that have been transformed must be done so in\n     * the same fashion, otherwise an error will  be generated.\n     */\n    RTPARAM_MAKE_TRANSFORMED_TUNABLE = 2\n} TransformedFlag;\n\ntypedef struct ssParamRec_tag {\n\n    /*\n     * The parameter characteristics\n     */\n    const char* name; /* Name of the parameter. This must point\n                       * to persistent memory. Do not set to a local\n                       * variable (static char name[32] or strings\n                       * \"name\" are okay)\n                       */\n#ifdef SYSTEM_OBJECTS_DEF\n    char* mName;\n#endif\n    int_T nDimensions; /* Number of dimensions for this parameter     */\n\n#if defined(SFCN64)\n    void* unusedPtr;\n#else\n    int_T* dimensions; /* Array giving the dimension (sizes) of\n                        * the parameter                                */\n#endif\n\n#ifdef SYSTEM_OBJECTS_DEF\n    int_T numTotalElements;\n#endif\n    DTypeId dataTypeId;      /* For built-in data types, see BuiltInDTypeId\n                              * in simstruc_types.h                         */\n    boolean_T complexSignal; /* FALSE or TRUE                               */\n\n    /*\n     * The data pointer.  This is the data values for the run-time parameter.\n     * Simulink needs this when creating the model.rtw file. Complex Simulink\n     * signals are store interleaved. Likewise complex run-time parameters\n     * must be stored interleaved.\n     *\n     * Note that mxArrays store the real and complex parts of complex\n     * matrices as two separate contiguous pieces of data instead of\n     * interleaving the real and complex parts.  */\n\n    void* data;\n\n    /*\n     * The data attributes pointer is a persistent storage location where the\n     * user can store additional information describing the data and then\n     * recover this information later (potentially in a different function).\n     */\n    const void* dataAttributes;\n\n    /*\n     * Run-time parameters to dialog parameter map.\n     *\n     * For proper interaction with 'tunable parameter variables' that\n     * are set via the \"Tunable Parameters Dialog\", Simulink requires\n     * information about how the run-time parameters are derived.\n     *\n     * It is an implicit assumption that all run-time parameters are derived\n     * from the dialog parameters, i.e., ssGetSFcnParam(S,i).  Thus each\n     * run-time parameter is derived from a subset of the dialog parameters:\n     *    run-time_parameter = some_function(subset of dialog parameters).\n     * In the simplest case,\n     *    run-time_parameter = a specific dialog parameter\n     *\n     * The following information specifies which dialog parameters are\n     * used in deriving a specific run-time parameter. For the simplest case,\n     * we have\n     *     nDialogParamIndices = 1;\n     *     dialogParamIndices  = k;\n     *     transformed         = false;\n     * This case is important to identify because this will allow for\n     * efficient and correct code generation of run-time parameters when they\n     * map directly back to tunable parameter variables specified in\n     * the 'Tunable Parameters Dialog'.\n     */\n\n    int_T nDlgParamIndices;\n    int_T* dlgParamIndices;      /* Array of length nDialogParamIndices\n                                  * indicating the dialog parameters that\n                                  * are used in deriving the run-time\n                                  * parameter */\n    TransformedFlag transformed; /* Transformed status */\n    boolean_T outputAsMatrix;    /* Write out parameter as a vector (false)\n                                  * [default] or a matrix (true)\n                                  */\n#if defined(SFCN64)\n    int_T* dimensions;\n#elif defined(SL_INTERNAL)\n    int_T* dimensions64;\n#else\n    void* unusedPtr;\n#endif\n\n} ssParamRec;\n#endif\n\n#ifdef SYSTEM_OBJECTS_DEF\n\n#define DYNAMIC_DIMENSION getDefaultDimensionInfo()\n\n#else\n\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern const DimsInfo_T* DYNAMIC_DIMENSION;\n#ifdef __cplusplus\n}\n#endif\n#else\n#define DYNAMIC_DIMENSION NULL\n#endif\n\n#endif\n\n/*\n * Used to determine the indexing type of a port\n */\ntypedef enum { INDEX_BASE0, INDEX_BASE1, NONINDEX } slIdxPortType;\n\n/*\n * NUM_MAT_DIMS\n */\n#ifndef NUM_MAT_DIMS\n#define NUM_MAT_DIMS (2)\n#endif\n\n/*\n * Enumeration values used in dimension propagation algorithms\n */\ntypedef enum ssVectorMode_tag {\n    SS_UNKNOWN_MODE,\n    SS_1_D_OR_COL_VECT,\n    SS_1_D_OR_ROW_VECT,\n    SS_1_D_ROW_OR_COL_VECT,\n    SS_1_D_VECT,\n    SS_COL_VECT,\n    SS_ROW_VECT\n} ssVectorMode;\n\n/** Bus Mode (Currently not used)\n * S-function ports can have the following three bus modes:\n * 1) SL_INHERIT_BUS_MODE\n *    - Bus mode depends on the settings of the ports driving this port\n *    - Ports cannot have this setting after model compile\n * 2) SL_NON_BUS_MODE\n *    - This port cannot accept a bus signal\n * 3) SL_BUS_MODE\n *    - This port can accept a bus signal\n */\n#ifndef _BUS_MODE_T\n#define _BUS_MODE_T\ntypedef enum { SL_INHERIT_BUS_MODE = -1, SL_NON_BUS_MODE, SL_BUS_MODE } BusMode_T;\n#endif\n\n/*\n * Specify the capabilities to handle data types with\n * various word lengths. By default, it is assumed that\n * S-Function blocks are not implemented with necessary\n * RTW support for word lengths beyond 32 bits. If a block\n * has implemented necessary support for longer word\n * lengths, then two different levels of support can be\n * declared. One option is support up to the size of long\n * on the current code generation target. The second\n * option is no limitation which means the block is designed\n * to handle MultiWord situations.\n *\n * If limitations are declared and code generation is\n * attempted, then Simulink will automatically check\n * if any of the following items,  input ports, output\n * ports, run-time parameters or DWorks have data types\n * with word lengths beyond the limit. If the limit is\n * exceeded, Simulink will issue an error message.\n */\ntypedef enum {\n    RTW_SUPPORT_BEYOND_32_BITS_NO = 0U, /* S-Function default */\n    RTW_SUPPORT_BEYOND_32_BITS_FULLY = 1U,\n    RTW_SUPPORT_BEYOND_32_BITS_UP_TO_TARGET_LONG = 2U\n} SupportDataTypeBeyond32BitsInRTWFlag;\n\n/*\n * Enumeration of work vector origin flag values.\n */\ntypedef enum {\n    SS_DWORK_ORIGINATED_AS_DWORK = 0, /* default */\n    SS_DWORK_ORIGINATED_AS_MODE,\n    SS_DWORK_ORIGINATED_AS_RWORK,\n    SS_DWORK_ORIGINATED_AS_IWORK,\n    SS_DWORK_ORIGINATED_AS_PWORK,\n    SS_DWORK_ORIGINATED_AS_DSTATE,\n    SS_DWORK_ORIGINATED_AS_MASS_MATRIX_OFFSET,\n    SS_NUM_DWORK_ORIGIN_TYPES\n} ssDWorkOriginType;\n\n/*\n * Enumeration of data transfer signals for the exported function diagram\n * (a.k.a. scheduling diagram)\n *\n * For such a data transfer signal:\n * -- FORWARD_DATA_TRANSFER: sources of the signal are scheduled before its\n *    destinations.\n * -- REVERSE_DATA_TRANSFER: sources of the signal are scheduled after its\n *    destinations.\n * -- HYBRID_DATA_TRANSFER:  mixed case, some of sources of the signal are\n *    scheduled before, while others are scheduled after the destinations of\n *    the data transfer signal.\n */\ntypedef enum {\n    NOT_A_DATA_TRANSFER,\n    FORWARD_DATA_TRANSFER,\n    REVERSE_DATA_TRANSFER,\n    HYBRID_DATA_TRANSFER\n} DataTransferSignalType;\n\n#ifndef _UNIT_ID\n#define _UNIT_ID\n/*\n * Unit ID as registered in the model Unit Table - this is a unique ID assigned to\n * each unit expression.\n */\ntypedef int_T UnitId;\n#endif /* _UNIT_ID */\n\n#ifndef _PRE_DEFINED_UNIT_IDS\n#define _PRE_DEFINED_UNIT_IDS\n/*\n * Definition of Simulink builtin unit IDs\n */\nenum { INVALID_UNIT_ID = -10, SL_UNITS_MIXED = -2, SL_UNITS_INHERIT = -1, SL_UNSPECIFIED = 0 };\n#endif /* _PRE_DEFINED_UNIT_IDS */\n\n\n#endif\n\n/* LocalWords:  DType\n */\n"},{"name":"sl_datatype_access.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2009-2021 The MathWorks, Inc. */\n#ifndef __SL_DATATYPE_ACCESS__\n#define __SL_DATATYPE_ACCESS__\n\n#ifndef _DATA_TYPE_ACCESS\n#define _DATA_TYPE_ACCESS\n/*\n * Use incomplete type for function prototypes within DataTypeAccess itself\n */\ntypedef struct _slDataTypeAccess_tag slDataTypeAccess;\ntypedef struct _slDataTypeAccess64_tag slDataTypeAccess64;\n#endif\n\n#include \"sl_types_def.h\"    /* DTypeId */\n#include \"sl_report_types.h\" /*BDErrorValue*/\n\n#define INVALID_DTYPE_ID (-10)\n#define INVALID_DTYPE_SIZE (-1)\n#define INVALID_DTYPE_SIGNED (-1)\n#define INVALID_NUM_DTYPES (-1)\n\n\ntypedef enum {\n    GEN_DTA_INT_PROP_SIZE,\n    GEN_DTA_INT_PROP_STORAGE_ID,\n    GEN_DTA_INT_PROP_ID_ALIASED_THRU_TO,\n    GEN_DTA_INT_PROP_PROPERTIES_SIZE,\n    GEN_DTA_INT_PROP_ID_ALIASED_TO,\n    GEN_DTA_INT_PROP_NUM_ELEMENTS,\n    GEN_DTA_INT_PROP_IS_BUS,\n    GEN_DTA_INT_PROP_IS_ENUMTYPE,\n    GEN_DTA_INT_PROP_ENUMTYPE_NUMSTRINGS,\n    GEN_DTA_INT_PROP_ENUMTYPE_INDEX_OF_DEFAULT,\n    GEN_DTA_INT_PROP_ENUMTYPE_ADD_TYPENAME_AS_PREFIX,\n    GEN_DTA_INT_PROP_IS_BUS_WITH_VARDIMS_ELEMENT,\n    GEN_DTA_INT_PROP_VARDIMS_SIZE,\n    GEN_DTA_INT_PROP_CONTAINED_DATA_DATA_TYPE_ID,\n    GEN_DTA_INT_PROP_CONTAINED_DATA_NUM_DIMS\n} GenDTAIntPropType;\n\ntypedef enum {\n    GEN_DTA_INT_PROP_ELEMENT_DATA_TYPE,\n    GEN_DTA_INT_PROP_ELEMENT_SIGNAL_TYPE,\n    GEN_DTA_INT_PROP_ELEMENT_NUM_DIMENSIONS,\n    GEN_DTA_INT_PROP_ELEMENT_OFFSET,\n    GEN_DTA_INT_PROP_ENUMTYPE_INDEX_FROM_VALUE,\n    GEN_DTA_INT_PROP_ENUMTYPE_VALUE_FROM_INDEX,\n    GEN_DTA_INT_PROP_ELEMENT_DIMENSIONS_MODE,\n    GEN_DTA_INT_PROP_ELEMENT_VARDIMS_OFFSET,\n    GEN_DTA_INT_PROP_ELEMENT_UNIT_ID\n} GenDTAIntElemPropType;\n\ntypedef enum {\n    GEN_DTA_VOID_PROP_NAME,\n    GEN_DTA_VOID_PROP_ZERO,\n    GEN_DTA_VOID_PROP_PROPERTIES,\n    GEN_DTA_VOID_PROP_OBJECT,\n    GEN_DTA_VOID_PROP_CGTYPE\n} GenDTAVoidPropType;\n\ntypedef enum {\n    GEN_DTA_VOID_PROP_ELEMENT_NAME,\n    GEN_DTA_VOID_PROP_ELEMENT_DIMENSIONS,\n    GEN_DTA_VOID_PROP_ENUMTYPE_STRING_FROM_VALUE,\n    GEN_DTA_VOID_PROP_ENUMTYPE_STRING_FROM_INDEX,\n    GEN_DTA_VOID_PROP_ELEMENT_DIMENSIONS_64\n} GenDTAVoidElemPropType;\n\ntypedef enum {\n    GEN_DTA_REAL_PROP_ELEMENT_MIN,\n    GEN_DTA_REAL_PROP_ELEMENT_MAX\n} GenDTARealElemPropType;\n\ntypedef enum { GEN_DTA_UNARY_FCN_IS_POSITIVE, GEN_DTA_UNARY_FCN_IS_NEGATIVE } GenDTAUnaryFcnType;\n\ntypedef enum {\n    GEN_DTA_BINARY_FCN_GREATER_THAN,\n    GEN_DTA_BINARY_FCN_GREATER_EQUAL\n} GenDTABinaryFcnType;\n\ntypedef enum {\n    GEN_DTA_DATA_OVERFLOW,\n    GEN_DTA_INT32_TO_FLOAT,\n    GEN_DTA_PARAMETER_OVERFLOW,\n    GEN_DTA_PARAMETER_PRECISION_LOSS,\n    GEN_DTA_PARAMETER_DOWNCAST,\n    GEN_DTA_PARAMETER_UNDERFLOW,\n    GEN_DTA_DATA_SATURATION\n} GenDTADiagnosticType;\n\ntypedef void* (*RegisterDataTypeWithCheck)(void*, const char_T*, const char_T*, DTypeId*);\n\ntypedef DTypeId (*RegisterDataType)(void*, const char_T*, const char_T*);\n\ntypedef int_T (*GetNumDataTypes)(void*);\n\ntypedef DTypeId (*GetDataTypeId)(void*, const char_T*);\n\ntypedef int_T (*GetGenericDTAIntProp)(void*, const char_T*, DTypeId, GenDTAIntPropType);\ntypedef int_T (*SetGenericDTAIntProp)(void*, const char_T*, DTypeId, int_T, GenDTAIntPropType);\ntypedef int_T (\n    *GetGenericDTAIntElemProp)(void*, const char_T*, DTypeId, int_T, GenDTAIntElemPropType);\ntypedef int_T (\n    *SetGenericDTAIntElemProp)(void*, const char_T*, DTypeId, int_T, int_T, GenDTAIntElemPropType);\ntypedef real_T (\n    *GetGenericDTARealElemProp)(void*, const char_T*, DTypeId, int_T, GenDTARealElemPropType);\ntypedef int_T (*SetGenericDTARealElemProp)(void*,\n                                           const char_T*,\n                                           DTypeId,\n                                           int_T,\n                                           int_T,\n                                           GenDTARealElemPropType);\n\ntypedef const void* (*GetGenericDTAVoidProp)(void*, const char_T*, DTypeId, GenDTAVoidPropType);\ntypedef int_T (\n    *SetGenericDTAVoidProp)(void*, const char_T*, DTypeId, const void*, GenDTAVoidPropType);\ntypedef const void* (\n    *GetGenericDTAVoidElemProp)(void*, const char_T*, DTypeId, int_T, GenDTAVoidElemPropType);\ntypedef int_T (*SetGenericDTAVoidElemProp)(void*,\n                                           const char_T*,\n                                           DTypeId,\n                                           int_T,\n                                           const void*,\n                                           GenDTAVoidElemPropType);\n\ntypedef int_T (*ConvertBetweenFcn)(slDataTypeAccess*,\n                                   const char_T*,\n                                   DTypeId,\n                                   DTypeId,\n                                   int_T,\n                                   const void*,\n                                   const void*,\n                                   void*);\ntypedef ConvertBetweenFcn (*GetConvertBetweenFcn)(void*, const char_T*, DTypeId);\ntypedef int_T (*SetConvertBetweenFcn)(void*, const char_T*, DTypeId, ConvertBetweenFcn);\n\ntypedef int_T (*ConstructFcn)(void*, const void*);\ntypedef ConstructFcn (*GetConstructFcn)(void*, const char_T*, DTypeId);\ntypedef int_T (*SetConstructFcn)(void*, const char_T*, DTypeId, ConstructFcn);\n\ntypedef int_T (*DestructFcn)(void*);\ntypedef DestructFcn (*GetDestructFcn)(void*, const char_T*, DTypeId);\ntypedef int_T (*SetDestructFcn)(void*, const char_T*, DTypeId, DestructFcn);\n\ntypedef int_T (*DeepCopyFcn)(void*, const void*);\ntypedef DeepCopyFcn (*GetDeepCopyFcn)(void*, const char_T*, DTypeId);\ntypedef int_T (*SetDeepCopyFcn)(void*, const char_T*, DTypeId, DeepCopyFcn);\n\ntypedef size_t (*SizeOfFcn)(void);\ntypedef SizeOfFcn (*GetSizeOfFcn)(void*, DTypeId);\ntypedef int_T (*SetSizeOfFcn)(void*, DTypeId, SizeOfFcn);\n\ntypedef void* (*ContainedDataFcn)(void*);\ntypedef ContainedDataFcn (*GetContainedDataFcn)(void*, DTypeId);\ntypedef int_T (*SetContainedDataFcn)(void*, DTypeId, ContainedDataFcn);\n\ntypedef void (*ContainedDataDimsFcn)(const void*, size_t*);\ntypedef ContainedDataDimsFcn (*GetContainedDataDimsFcn)(void*, DTypeId);\ntypedef int_T (*SetContainedDataDimsFcn)(void*, DTypeId, ContainedDataDimsFcn);\n\ntypedef void (*UpdateContainedDataDimsFcn)(size_t, const size_t*, size_t, void*);\ntypedef UpdateContainedDataDimsFcn (*GetUpdateContainedDataDimsFcn)(void*, DTypeId);\ntypedef int_T (*SetUpdateContainedDataDimsFcn)(void*, DTypeId, UpdateContainedDataDimsFcn);\n\ntypedef void (*UpdateContainedDataDimFcn)(size_t, size_t, void*);\ntypedef UpdateContainedDataDimFcn (*GetUpdateContainedDataDimFcn)(void*, DTypeId);\ntypedef int_T (*SetUpdateContainedDataDimFcn)(void*, DTypeId, UpdateContainedDataDimFcn);\n\ntypedef const char* (*CoderPropertiesFcn)(const void*);\ntypedef CoderPropertiesFcn (*GetCoderPropertiesFcn)(void*, DTypeId);\ntypedef int_T (*SetCoderPropertiesFcn)(void*, DTypeId, CoderPropertiesFcn);\n\ntypedef int_T (*DataConstructFcn)(size_t, const size_t*, size_t, const void*, void*);\ntypedef DataConstructFcn (*GetDataConstructFcn)(void*, DTypeId);\ntypedef int_T (*SetDataConstructFcn)(void*, DTypeId, DataConstructFcn);\n\n\ntypedef int_T (*SerializeFcn)(void*, const void*, size_t, size_t);\ntypedef SerializeFcn (*GetSerializeFcn)(void*, DTypeId);\ntypedef int_T (*SetSerializeFcn)(void*, DTypeId, SerializeFcn);\n\ntypedef int_T (*DeserializeFcn)(void*, const void*, size_t, size_t);\ntypedef DeserializeFcn (*GetDeserializeFcn)(void*, DTypeId);\ntypedef int_T (*SetDeserializeFcn)(void*, DTypeId, DeserializeFcn);\n\ntypedef size_t (*SerializeSizeFcn)(const void*);\ntypedef SerializeSizeFcn (*GetSerializeSizeFcn)(void*, DTypeId);\ntypedef int_T (*SetSerializeSizeFcn)(void*, DTypeId, SerializeSizeFcn);\n\ntypedef int_T (*GenericDTAUnaryFcn)(slDataTypeAccess*,\n                                    const char_T*,\n                                    DTypeId,\n                                    int_T,\n                                    const void*,\n                                    const void*,\n                                    void*);\ntypedef GenericDTAUnaryFcn (*GetGenericDTAUnaryFcnGW)(void*,\n                                                      const char_T*,\n                                                      DTypeId,\n                                                      GenDTAUnaryFcnType);\ntypedef int_T (*SetGenericDTAUnaryFcnGW)(void*,\n                                         const char_T*,\n                                         DTypeId,\n                                         GenericDTAUnaryFcn,\n                                         GenDTAUnaryFcnType);\ntypedef int_T (*GenericDTAUnaryFcnGW)(slDataTypeAccess*,\n                                      DTypeId,\n                                      int_T,\n                                      const void*,\n                                      const void*,\n                                      void*,\n                                      GenDTAUnaryFcnType);\n\n\ntypedef int_T (*GenericDTABinaryFcn)(slDataTypeAccess*,\n                                     const char_T*,\n                                     DTypeId,\n                                     int_T,\n                                     const void*,\n                                     const void*,\n                                     const void*,\n                                     void*);\ntypedef GenericDTABinaryFcn (*GetGenericDTABinaryFcnGW)(void*,\n                                                        const char_T*,\n                                                        DTypeId,\n                                                        GenDTABinaryFcnType);\ntypedef int_T (*SetGenericDTABinaryFcnGW)(void*,\n                                          const char_T*,\n                                          DTypeId,\n                                          GenericDTABinaryFcn,\n                                          GenDTABinaryFcnType);\ntypedef int_T (*GenericDTABinaryFcnGW)(slDataTypeAccess*,\n                                       DTypeId,\n                                       int_T,\n                                       const void*,\n                                       const void*,\n                                       const void*,\n                                       void*,\n                                       GenDTABinaryFcnType);\n\ntypedef int_T (*GetGenericDTADiagnostic)(void*, const char_T*, GenDTADiagnosticType, BDErrorValue*);\n#ifdef INT64_T\ntypedef const void* (\n    *GetGenericDTAVoidElemProp64)(void*, const char_T*, DTypeId, int64_T, GenDTAVoidElemPropType);\ntypedef int_T (*SetGenericDTAVoidElemProp64)(void*,\n                                             const char_T*,\n                                             DTypeId,\n                                             int64_T,\n                                             const void*,\n                                             GenDTAVoidElemPropType);\n\ntypedef int_T (\n    *GetGenericDTAIntElemProp64)(void*, const char_T*, DTypeId, int64_T, GenDTAIntElemPropType);\ntypedef int_T (*SetGenericDTAIntElemProp64)(void*,\n                                            const char_T*,\n                                            DTypeId,\n                                            int64_T,\n                                            int_T,\n                                            GenDTAIntElemPropType);\ntypedef real_T (\n    *GetGenericDTARealElemProp64)(void*, const char_T*, DTypeId, int64_T, GenDTARealElemPropType);\ntypedef int_T (*SetGenericDTARealElemProp64)(void*,\n                                             const char_T*,\n                                             DTypeId,\n                                             int64_T,\n                                             int_T,\n                                             GenDTARealElemPropType);\n#else\ntypedef const void* (\n    *GetGenericDTAVoidElemProp64)(void*, const char_T*, DTypeId, int_T, GenDTAVoidElemPropType);\ntypedef int_T (*SetGenericDTAVoidElemProp64)(void*,\n                                             const char_T*,\n                                             DTypeId,\n                                             int_T,\n                                             const void*,\n                                             GenDTAVoidElemPropType);\n\ntypedef int_T (\n    *GetGenericDTAIntElemProp64)(void*, const char_T*, DTypeId, int_T, GenDTAIntElemPropType);\ntypedef int_T (*SetGenericDTAIntElemProp64)(void*,\n                                            const char_T*,\n                                            DTypeId,\n                                            int_T,\n                                            int_T,\n                                            GenDTAIntElemPropType);\ntypedef real_T (\n    *GetGenericDTARealElemProp64)(void*, const char_T*, DTypeId, int_T, GenDTARealElemPropType);\ntypedef int_T (*SetGenericDTARealElemProp64)(void*,\n                                             const char_T*,\n                                             DTypeId,\n                                             int_T,\n                                             int_T,\n                                             GenDTARealElemPropType);\n#endif\nstruct _slDataTypeAccess64_tag {\n\n    GetGenericDTAIntElemProp64 getGenericDTAIntElemProp;\n    SetGenericDTAIntElemProp64 setGenericDTAIntElemProp;\n\n    GetGenericDTAVoidElemProp64 getGenericDTAVoidElemProp;\n    SetGenericDTAVoidElemProp64 setGenericDTAVoidElemProp;\n\n    GetGenericDTARealElemProp64 getGenericDTARealElemProp;\n    SetGenericDTARealElemProp64 setGenericDTARealElemProp;\n};\n\nstruct _slDataTypeAccess_tag {\n    void* dataTypeTable;\n\n    const char_T* errorString;\n\n    RegisterDataType registerFcn;\n\n    GetNumDataTypes getNumDataTypesFcn;\n\n    GetDataTypeId getIdFcn;\n\n    GetGenericDTAIntProp getGenericDTAIntProp;\n    SetGenericDTAIntProp setGenericDTAIntProp;\n\n    GetGenericDTAVoidProp getGenericDTAVoidProp;\n    SetGenericDTAVoidProp setGenericDTAVoidProp;\n\n    GetGenericDTAUnaryFcnGW getGenericDTAUnaryFcnGW;\n    SetGenericDTAUnaryFcnGW setGenericDTAUnaryFcnGW;\n\n    GetGenericDTABinaryFcnGW getGenericDTABinaryFcnGW;\n    SetGenericDTABinaryFcnGW setGenericDTABinaryFcnGW;\n\n    GetConvertBetweenFcn getConvertBetweenFcn;\n    SetConvertBetweenFcn setConvertBetweenFcn;\n\n    GetGenericDTADiagnostic getGenericDTADiagnostic;\n\n    RegisterDataTypeWithCheck registerFcnWithCheck;\n\n    GetGenericDTAIntElemProp getGenericDTAIntElemProp;\n    SetGenericDTAIntElemProp setGenericDTAIntElemProp;\n\n    GetGenericDTAVoidElemProp getGenericDTAVoidElemProp;\n    SetGenericDTAVoidElemProp setGenericDTAVoidElemProp;\n\n    GetGenericDTARealElemProp getGenericDTARealElemProp;\n    SetGenericDTARealElemProp setGenericDTARealElemProp;\n\n    GetConstructFcn getConstructFcn;\n    SetConstructFcn setConstructFcn;\n\n    GetDestructFcn getDestructFcn;\n    SetDestructFcn setDestructFcn;\n\n    GetDeepCopyFcn getDeepCopyFcn;\n    SetDeepCopyFcn setDeepCopyFcn;\n\n    GetSizeOfFcn getSizeOfFcn;\n    SetSizeOfFcn setSizeOfFcn;\n\n    GetContainedDataFcn getContainedDataFcn;\n    SetContainedDataFcn setContainedDataFcn;\n\n    GetContainedDataDimsFcn getContainedDataDimsFcn;\n    SetContainedDataDimsFcn setContainedDataDimsFcn;\n\n    GetUpdateContainedDataDimsFcn getUpdateContainedDataDimsFcn;\n    SetUpdateContainedDataDimsFcn setUpdateContainedDataDimsFcn;\n\n    GetUpdateContainedDataDimFcn getUpdateContainedDataDimFcn;\n    SetUpdateContainedDataDimFcn setUpdateContainedDataDimFcn;\n\n    GetCoderPropertiesFcn getCoderPropertiesFcn;\n    SetCoderPropertiesFcn setCoderPropertiesFcn;\n\n    GetDataConstructFcn getDataConstructFcn;\n    SetDataConstructFcn setDataConstructFcn;\n\n    GetSerializeFcn getSerializeFcn;\n    SetSerializeFcn setSerializeFcn;\n\n    GetDeserializeFcn getDeserializeFcn;\n    SetDeserializeFcn setDeserializeFcn;\n\n    GetSerializeSizeFcn getSerializeSizeFcn;\n    SetSerializeSizeFcn setSerializeSizeFcn;\n\n    struct _slDataTypeAccess64_tag* access64;\n};\n\n#endif\n"},{"name":"sl_fileio_rtw.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifdef SUPPORTS_PRAGMA_ONCE\n# pragma once\n#endif\n#ifndef sl_fileio_rtw_h\n#define sl_fileio_rtw_h\n/*\n *\n * Copyright 2008-2016 The MathWorks, Inc.\n *\n * This header is the interface to the sl_fileio module. It is used by the\n * RTW-RSim and Rapid Accelerator targets.\n *\n * \n *\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern const char *rtwMATFileLoaderCreateInstance(\n    const char  *fileName,\n    int          errorXMLMode,\n    const int    extrapolationBeforeFirstDataPointInt,\n    const int    interpolationWithinTimeRangeInt,\n    const int    extrapolationAfterLastDataPointInt,\n    const unsigned char *ground,\n    const int    iZeroCrossingSwitch,\n    int          fxpDiagnosticOverflow,\n    int          fxpDiagnosticSaturation,\n    const char  *fxpBlockPath,\n    void        **outMATFileLoader\n    );\n\nextern const char *rtwMATFileLoaderDestroyInstance(\n    int  errorXMLMode,\n    void *pMATFileLoader\n    );\n\nextern const char *rtwMATFileLoaderGetOutput(\n    int            errorXMLMode,\n    void          *pMATFileLoader,\n    const double   t,\n    const int      iMajorTimeStep,\n    void         **outOutputValue\n    );\n\nextern const char *rtwMATFileLoaderGetZeroCrossingSignal(\n    void         *pMATFileLoader,\n    const double  t,\n    const int     iMajorTimeStep,\n    void         *outZeroCrossingSignal\n    );\n\n\nextern const char *rtwMATFileLoaderCheckMATFileConsistency(\n    void           *pMATFileLoader,\n    const char     *MATFileName,\n    int             errorXMLMode,\n    const char     *expDTypeName,\n    const int       expNDims,\n    const int      *expDims,\n    const int       expComplexity,\n    const int       isFixedPoint,\n    const int       dataTypeMode,\n    const int       isSigned,\n    const int       wordLength,\n    const double    slopeAdjustmentFactor,\n    const int       fixedExponent,\n    const double    bias,\n    const int       expEnumNStrings,\n    const char    **expEnumStrings,\n    const int      *expEnumValues);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* sl_fileio_rtw_h */\n\n/* LocalWords:  RSim\n */\n"},{"name":"sl_fixpt.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef __SL_FIXPT__\n#define __SL_FIXPT__\n\n/* Copyright 1990-2013 The MathWorks, Inc. */\n\n/*\n * FixPt: Data type override options\n */\ntypedef enum {\n    FIXPT_DATATYPE_LOCAL,\n    FIXPT_DATATYPE_SCALED_DOUBLES,\n    FIXPT_DATATYPE_TRUE_DOUBLES,\n    FIXPT_DATATYPE_TRUE_SINGLES,\n    FIXPT_DATATYPE_OFF,\n    FIXPT_DATATYPE_OVERRIDE_IGNORE,\n    FIXPT_DATATYPE_OVERRIDE_UNKNOWN\n} FixPtDataTypeOverride;\n\n/*\n * FixPt: Data type override applies to options\n */\ntypedef enum {\n    FIXPT_DATATYPEOVERRIDE_NUMERIC_TYPES,\n    FIXPT_DATATYPEOVERRIDE_FLOATING_POINT,\n    FIXPT_DATATYPEOVERRIDE_FIXED_POINT\n} FixPtDataTypeOverrideAppliesTo;\n\n/*\n * FixPt: Min/Max logging options\n */\ntypedef enum {\n    FIXPT_LOGGING_LOCAL,\n    FIXPT_LOGGING_MIN_MAX_OVERFLOW,\n    FIXPT_LOGGING_OVERFLOW_ONLY,\n    FIXPT_LOGGING_OFF\n} FixPtMinMaxOverflowLogging;\n\n/*\n * FixPt: Min/Max logging mode options\n */\ntypedef enum {\n    FIXPT_ARCHIVEMODE_OVERWRITE,\n    FIXPT_ARCHIVEMODE_MERGE\n} FixPtMinMaxOverflowArchiveMode;\n\n#endif\n"},{"name":"sl_prodhwdevicetype.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef __SL_PRODHWDEVICETYPE__\n#define __SL_PRODHWDEVICETYPE__\n\n/* Copyright 1990-2013 The MathWorks, Inc. */\n\n/*\n * Production hardware characteristics settings\n */\ntypedef enum {\n    FIXPT_PRODHWDEVICE_MICRO,\n    FIXPT_PRODHWDEVICE_ASIC,\n    FIXPT_PRODHWDEVICE_UNKNOWN\n} ProdHWDeviceType;\n\n#endif\n"},{"name":"sl_report_types.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2016-2021 The MathWorks, Inc. */\n#ifndef SL_REPORT_TYPES_H\n#define SL_REPORT_TYPES_H\n\ntypedef enum { BD_ERR_VALUE_NONE, BD_ERR_VALUE_WARNING, BD_ERR_VALUE_ERROR } BDErrorValue;\n\n#endif\n"},{"name":"sl_sample_time_defs.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2010-2021 The MathWorks, Inc. */\n\n/*\n * File: sl_sample_time_defs.h\n *\n * Abstract:\n *   This file contains sample time related definitions (typedefs, macros, etc.)\n *   prototypes that are used both by User S-Functions and inside Simulink.\n */\n\n#ifndef __SL_SAMPLE_TIME_DEFS_H__\n#define __SL_SAMPLE_TIME_DEFS_H__\n\n/*\n * INHERITED_SAMPLE_TIME      - Specify for blocks that inherit their sample\n *                              time from the block that feeds their input.\n *\n * CONTINUOUS_SAMPLE_TIME     - A continuous sample time indicates that the\n *                              block executes every simulation step.\n *\n * VARIABLE_SAMPLE_TIME       - Specifies that this sample time is discrete\n *                              with a varying period.\n *\n * FIXED_IN_MINOR_STEP_OFFSET - This can be specified for the offset of either\n *                              the inherited or continuous sample time\n *                              indicating that the output does not change\n *                              in minor steps.\n */\n#define INHERITED_SAMPLE_TIME ((real_T)-1.0)\n#define CONTINUOUS_SAMPLE_TIME ((real_T)0.0)\n#define VARIABLE_SAMPLE_TIME ((real_T)-2.0)\n#define FIXED_IN_MINOR_STEP_OFFSET ((real_T)1.0)\n\n\ntypedef enum {\n    SS_TIMESOURCE_BASERATE,      /* async task does not manage time,\n                       reads absolute time from base rate */\n    SS_TIMESOURCE_SELF,          /* async task manage it own independent\n                      timer */\n    SS_TIMESOURCE_CALLER,        /* async task read time from its upstream\n                     task */\n    SS_TIMESOURCE_SELF_INTERNAL, /* If an async task periodically executes,\n                                  * the task may choose to maintain internal timer\n                                  * by incrementing at each execution */\n    SS_INVALID_TIMESOURCE\n} slTimeSource;\n\n/* Value/representation of an unknown tid */\n#define UNKNOWN_TID (-5)\n\n#endif\n"},{"name":"sl_sfcn_st_api.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2016-2021 The MathWorks, Inc. */\n\n/*\n * File:\n *\n * Abstract:\n */\n\n#ifndef SL_SFCN_ST_API_H\n#define SL_SFCN_ST_API_H\n\n/* Guard against early inclusions */\n#ifndef _SIMSTRUCT\n#error \"This file should be included from simstruc.h\"\n#endif\n\ntypedef int_T slstRateID;\n\n#ifdef BUILDING_LIBMWSIMULINK\n#include \"package.h\"\n#define SLST_SFCN_API_EXPORT_EXTERN_C extern \"C\" DLL_EXPORT_SYM\n#else\n#if defined(__cplusplus)\n#define SLST_SFCN_API_EXPORT_EXTERN_C extern \"C\"\n#else\n#define SLST_SFCN_API_EXPORT_EXTERN_C extern\n#endif\n#endif\n\nSLST_SFCN_API_EXPORT_EXTERN_C void slstEnableSTAPI(SimStruct* S);\n\nSLST_SFCN_API_EXPORT_EXTERN_C boolean_T slstIsPeriodicDiscreteRate(SimStruct* S,\n                                                                   real_T period,\n                                                                   real_T offset);\n\nSLST_SFCN_API_EXPORT_EXTERN_C boolean_T slstIsControllableRate(SimStruct* S,\n                                                               real_T period,\n                                                               real_T offset);\n\nSLST_SFCN_API_EXPORT_EXTERN_C slstRateID slstRegisterControllableRate(SimStruct* S,\n                                                                      real_T period,\n                                                                      const char* id);\n\nSLST_SFCN_API_EXPORT_EXTERN_C slstRateID slstRegisterPeriodicDiscreteRate(SimStruct* S,\n                                                                          real_T period);\n\nSLST_SFCN_API_EXPORT_EXTERN_C void slstSetBlockRateID(SimStruct* S, slstRateID rateID);\n\nSLST_SFCN_API_EXPORT_EXTERN_C slstRateID slstGetBlockRateID(SimStruct* S);\n\nSLST_SFCN_API_EXPORT_EXTERN_C void slstSetInputPortRateID(SimStruct* S,\n                                                          int_T ip,\n                                                          slstRateID rateID);\n\nSLST_SFCN_API_EXPORT_EXTERN_C slstRateID slstGetInputPortRateID(SimStruct* S, int_T ip);\n\nSLST_SFCN_API_EXPORT_EXTERN_C void slstAcceptPropagatedInputPortRate(SimStruct* S, int_T ip);\n\nSLST_SFCN_API_EXPORT_EXTERN_C void slstSetOutputPortRateID(SimStruct* S,\n                                                           int_T op,\n                                                           slstRateID rateID);\n\nSLST_SFCN_API_EXPORT_EXTERN_C slstRateID slstGetOutputPortRateID(SimStruct* S, int_T op);\n\nSLST_SFCN_API_EXPORT_EXTERN_C void slstAcceptPropagatedOutputPortRate(SimStruct* S, int_T op);\n\n#define slstIsRateControlledByThisBlock(S, sti) \\\n    (_ssGetBlkInfo2STInfo2Ptr(S)->isControlledByThisBlock[sti])\n\n#define slstSetNumTicksToNextSampleHitForControllableRate(S, sti, nTicks) \\\n    slexecSetNumTicksToNextSampleHitForControllableSampleTime(            \\\n        ssGetRootSS(S), _ssGetBlkInfo2STInfo2Ptr(S)->ctrlRateInstanceIndex[sti], nTicks)\n\n\n#define slstGetNumTicksToNextSampleHitForControllableRate(S, sti) \\\n    slexecGetNumTicksToNextSampleHitForControllableSampleTime(    \\\n        ssGetRootSS(S), _ssGetBlkInfo2STInfo2Ptr(S)->ctrlRateInstanceIndex[sti])\n\n\n#define slstHasSampleHit(S, rateID, tid) ssIsSampleHit(S, ((int_T)rateID), tid)\n\n\n#endif /* SL_SFCN_ST_API_H */\n"},{"name":"sl_solver_rtw.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef sl_solver_rtw_h\n#define sl_solver_rtw_h\n#ifdef SUPPORTS_PRAGMA_ONCE\n# pragma once\n#endif\n/*\n *\n * Copyright 2008-2013 The MathWorks, Inc.\n *\n * This header is the entrance to the sl_solver_rtw module. It is used by the\n * RTW-RSim and Rapid Accelerator targets.\n *\n */\n\n#if defined(RSIM_WITH_SL_SOLVER)\n /*\n  * This header is being included by either the RSim or RapidAccelerator runtime\n  * interface (both require C linkage)\n  */\n# define SL_SOLVER_RTW_EXPORT_EXTERN_C  extern\n# include \"simstruc.h\"\n\n#else\n# include \"package.h\"\n# if defined(SL_SOLVER_RTW_INTERNAL)\n  /*\n   * This header is being included by files inside src/sl_solver_rtw\n   */\n#  define SL_SOLVER_RTW_EXPORT_EXTERN_C  extern \"C\" DLL_EXPORT_SYM\n# else\n  /*\n   * This file is being include by other internal modules.\n   */\n#  define SL_SOLVER_RTW_EXPORT_EXTERN_C  extern \"C\" DLL_IMPORT_SYM\n# endif\n# include \"simstruct/simstruc.h\"\n#endif\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimEnableDebugOutput(size_t simStructSize,\n                                    size_t ssMdlInfoSize);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C int  getStiffnessFromJacobian( SimStruct* S, \n                   int nx, \n\t\t\t\t\t\t\t     double stiffnessThreshold, \n\t\t\t\t\t\t\t     double *solverJac, \n\t\t\t\t\t\t\t     bool* isStiff, \n\t\t\t\t\t\t\t     double* stiffness); \n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimFinalizeAutoSolverForStiffModelsIfNeeded( SimStruct* S, \n                                            const char* slvrJpatternFileName,\n                                            int numStatesForStiffnessChecking,\n                                            double stiffnessThreshold,\n                                            double configsetInitialStepSize ); \n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimCreateSolverData(SimStruct* S, const char* slvrJpatternFileName);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimSetDecoupledContinuousIntegration(SimStruct* S, const bool decoupledContinuousIntegration);\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimSetOptimalSolverResetCausedByZc(SimStruct* S, const bool optimalSolverResetCausedByZc);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimDestroySolverData( SimStruct* S );\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimInitializeEngine(SimStruct* S);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimAdvanceSolver(SimStruct* S);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimUpdateDiscreteTaskTimesAndSampleHits(SimStruct* S);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimUpdateSolverStopTimeForFixedStepMultiTaskingSim(SimStruct* S);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimUpdateTimingEngineAndSolverStopTime(SimStruct* S);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimTerminateEngine(SimStruct* S, int verbose);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimDisplayTimingData(SimStruct* S,\n                                    size_t simStructSize,\n                                    size_t ssMdlInfoSize);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimInstallAllHandlers(\n    SimStruct* S,\n    void (*logDataFcn)(SimStruct* s),\n    int        timeLimit );\n    \nSL_SOLVER_RTW_EXPORT_EXTERN_C void rsimUninstallNonfatalHandlers(void);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C int isVariableStepSolver(const char* slvrName);\n\nSL_SOLVER_RTW_EXPORT_EXTERN_C int isFixedStepSolver(const char* slvrName);\n\n#endif /* sl_solver_rtw_h */\n\n/* LocalWords:  RSim\n */\n"},{"name":"sl_types_def.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2009-2021 The MathWorks, Inc. */\n\n/*\n * File: sl_types_def.h\n *\n * Abstract:\n *   The embedded RTW code formats do not include simstruc.h, but\n *   needs these common types.\n *   Generated from sl_types_def.tpl.\n */\n\n#ifndef __SL_TYPES_DEF_H__\n#define __SL_TYPES_DEF_H__\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n/* SLSize is first defined in tmwtypes.h, however,\n   some codegen targets' rtwtypes.h do not include\n   tmwtypes.h, so SLSize is defined here. */\n#ifndef SLSIZE_SLINDEX\n#define SLSIZE_SLINDEX\n#ifdef INT_TYPE_64_IS_SUPPORTED\ntypedef int64_T SLIndex;\ntypedef int64_T SLSize;\n#else\ntypedef int SLIndex;\ntypedef int SLSize;\n#endif\n#endif\n#endif\n\n/* The following section is inlined from builtin_typeid_types.h */\n#ifndef BUILTIN_TYPEID_TYPES\n#define BUILTIN_TYPEID_TYPES\n\n/* Enumeration of built-in data types */\ntypedef enum {\n    SS_DOUBLE = 0, /* real_T    */\n    SS_SINGLE = 1, /* real32_T  */\n    SS_INT8 = 2,   /* int8_T    */\n    SS_UINT8 = 3,  /* uint8_T   */\n    SS_INT16 = 4,  /* int16_T   */\n    SS_UINT16 = 5, /* uint16_T  */\n    SS_INT32 = 6,  /* int32_T   */\n    SS_UINT32 = 7, /* uint32_T  */\n    SS_BOOLEAN = 8 /* boolean_T */\n} BuiltInDTypeId;\n\n#define SS_NUM_BUILT_IN_DTYPE ((int_T)SS_BOOLEAN + 1)\n\n#ifndef _DTYPEID\n#define _DTYPEID\n/* Enumeration for MAT-file logging code */\ntypedef int_T DTypeId;\n#endif\n\ntypedef enum {\n    SS_FCN_CALL = 9,\n    SS_INTEGER = 10,\n    SS_POINTER = 11,\n    SS_INTERNAL_DTYPE2 = 12,\n    SS_TIMER_UINT32_PAIR = 13,\n    SS_CONNECTION_TYPE = 14\n\n    /* if last in list changes also update define below */\n\n} PreDefinedDTypeId;\n\n#endif /* BUILTIN_TYPEID_TYPES */\n\n#define SS_DOUBLE_UINT32 SS_TIMER_UINT32_PAIR\n\n#define SS_NUM_PREDEFINED_DTYPES 6\n\n#ifndef SYMBOLIC_DIMS_ID\n#define SYMBOLIC_DIMS_ID\ntypedef int_T SymbDimsId;\n#endif /* SYMBOLIC_DIMS_ID */\n\n#ifndef PRE_DEFINED_SYMBOLIC_DIMS_IDS\n#define PRE_DEFINED_SYMBOLIC_DIMS_IDS\n/*\n * Definition of Simulink builtin symbolic dimensions IDs\n */\nenum {\n    SL_INVALID_SYMBDIMS_ID = -2,\n    SL_INHERIT = -1, /* must be the same as DYNAMICALLY_TYPED = -1 */\n    SL_NOSYMBDIMS = 0\n};\n#endif /* PRE_DEFINED_SYMBOLIC_DIMS_IDS */\n\n/*\n * DYNAMICALLY_TYPED - Specify for input/output port data types that can\n * accept a variety of data types.\n */\n#define DYNAMICALLY_TYPED (-1)\n\n#endif /* __SL_TYPES_DEF_H__ */\n"},{"name":"slccrt.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/*\n * PUBLISHED header for C slccrt, the runtime library for SLCC C file\n *\n * Copyright 2019 The MathWorks, Inc.\n *\n */\n\n#ifndef slccrt_h\n#define slccrt_h\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n/*\n * Only define EXTERN_C if it hasn't been defined already. This allows\n * individual modules to have more control over managing their exports.\n */\n#ifndef EXTERN_C\n\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#else\n#define EXTERN_C extern\n#endif\n\n#endif /*EXTERN_C*/\n\n#ifndef LIBSLCCRT_API\n#define LIBSLCCRT_API\n#endif\n\nEXTERN_C LIBSLCCRT_API void slccrtCallOutOfProcessFcn(const char* ccChecksum, \n                                                      const char* fcnName, \n                                                      int32_T argNum, \n                                                      int32_T* scopeIds,\n                                                      int32_T* dims,\n                                                      int32_T* elemSizes,\n                                                      void** dataPtrs);\n\nEXTERN_C LIBSLCCRT_API bool slccrtIsLibAllowToDebug(const char* ccChecksum);\n\n#endif /* slccrt_h */\n"},{"name":"slexec_block_runtime_service.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SIMSTRUCT_SLEXEC_BLOCK_RUNTIME_SERVICE_H\n#define SIMSTRUCT_SLEXEC_BLOCK_RUNTIME_SERVICE_H\n\n/**\n * @file slexec_block_runtime_service.h\n *\n * This header is the exported C interface to the simulink execution engine\n * (slexec_simbridge) that provides block runtime services. This file should be\n * included from simstruct (and no earlier) so that we have access to\n * preprocessor variables.\n *\n * Note that this header file should be placed in the simstruct folder, and its\n * implementations are in the simbridge module.\n *\n */\n\n/* Copyright 2017-2021 The MathWorks, Inc. */\n\n/* Guard against early inclusions */\n#ifndef _SIMSTRUCT\n#error \"This file should be included from simstruc.h\"\n#endif\n\n#ifdef BUILDING_SLEXEC_SIMBRIDGE\n/* being included from inside slexec_simbridge module */\n#include \"package.h\"\n#define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\" DLL_EXPORT_SYM\n#else\n/* being included from outside, such as raccel code */\n#if defined(__cplusplus)\n/* Needed for non-inlined C++ S-functions */\n#define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\"\n#else\n#define SLEXEC_SIMBRIDGE_PUBLISHED_C extern\n#endif\n#endif\n\n/* Block runtime service keys */\ntypedef enum {\n    SLEXEC_BLK_RTS_SET_NUM_TICKS_TO_NEXT_SAMPLE_HIT_FOR_CTRLRATE,\n    SLEXEC_BLK_RTS_GET_NUM_TICKS_TO_NEXT_SAMPLE_HIT_FOR_CTRLRATE\n} _slexecBlkRTSType;\n\n/* Type declarations */\ntypedef int_T (*_slexecBlkRTSGateway)(SimStruct* S, _slexecBlkRTSType type, int_T arg1, void* arg2);\n\n/* Macro utilities */\n#define _slexecSafelyCallBlkRTSGatewayStart(S) \\\n    (((S)->mdlInfo->blkRTSGateway==NULL) ? 0 : ((*(S)->mdlInfo->blkRTSGateway)\n#define _slexecSafelyCallBlkRTSGatewayEnd ))\n\n#define _slexecSetBlkRTSGateway(S, fcn) (S)->mdlInfo->blkRTSGateway = (fcn)\n\n/* Block runtime service function */\nSLEXEC_SIMBRIDGE_PUBLISHED_C int _slexecBlockRuntimeServiceGateway(SimStruct* S,\n                                                                   _slexecBlkRTSType blkRTSType,\n                                                                   int arg1,\n                                                                   void* arg2);\n\n/* Published block runtime service macros */\n\n/*\n * This macro is used to set the number of ticks to the next sample hit for controllable rate in the\n * block.\n *\n * sti is the sample time index of the controllable rate in the block, and numTicks is the the next\n * ticks to the next sample hit.\n *\n */\n#define ssSetNumTicksToNextHitForControllableSampleTime(S, st_index, numTicks)              \\\n    {                                                                                       \\\n        double numTicks_tmp = (double)numTicks;                                             \\\n        _slexecSafelyCallBlkRTSGatewayStart(S)(                                             \\\n            S, SLEXEC_BLK_RTS_SET_NUM_TICKS_TO_NEXT_SAMPLE_HIT_FOR_CTRLRATE, (int)st_index, \\\n            &numTicks_tmp) _slexecSafelyCallBlkRTSGatewayEnd;                               \\\n    }\n\n/*\n * This macro is used to get the number of ticks to the next sample hit for controllable rate in the\n * block.\n *\n * sti is the sample time index of the controllable rate in the block.\n *\n */\n#define ssGetNumTicksToNextHitForControllableSampleTime(S, st_index)                    \\\n    _slexecSafelyCallBlkRTSGatewayStart(S)(                                             \\\n        S, SLEXEC_BLK_RTS_GET_NUM_TICKS_TO_NEXT_SAMPLE_HIT_FOR_CTRLRATE, (int)st_index, \\\n        (void*)NULL) _slexecSafelyCallBlkRTSGatewayEnd\n\n#endif\n"},{"name":"slexec_parallel.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLEXEC_PARALLEL_H\n#define SLEXEC_PARALLEL_H\n\n/* Copyright 2008-2020 The MathWorks, Inc. */\n\n/**\n * @file slexec_parallel.h\n *\n * This header is the exported interface to the simulink/execution/parallel. \n * It is used by the Rapid Accelerator targets.\n *\n *\n */\n\n\n#include \"tmwtypes.h\"\n\n#ifdef BUILDING_LIBMWSLEXEC_PARALLEL\n  /* being included from inside slexec_parallel module */\n  #include \"package.h\"\n  #define SLEXEC_PARALLEL_PUBLISHED_C extern \"C\" DLL_EXPORT_SYM\n#else\n  /* being included from outside, such as raccel code */\n  #if defined(__cplusplus)\n    /* Needed for non-inlined C++ S-functions */\n    #define SLEXEC_PARALLEL_PUBLISHED_C extern \"C\"\n  #else \n    #define SLEXEC_PARALLEL_PUBLISHED_C extern\n  #endif\n#endif\n\ntypedef void (*ParallelForTaskFunction)(int);\n\ntypedef enum {\n    PARALLEL_EXECUTION_AUTO = -1,\n    PARALLEL_EXECUTION_OFF = 0,\n    PARALLEL_EXECUTION_ON = 1\n} ParallelExecutionMode;\n\ntypedef struct ParallelExecutionOptions_tag {\n    int numberOfNodes;\n    ParallelExecutionMode parallelExecutionMode;\n    int numberOfThreads;\n    int numberOfStepsToAnalyze;\n    boolean_T enableTiming;\n    boolean_T dumpProfilingInfo;\n    const char* timingOutputFilename;\n    const char* nodeExecutionModesFilename;\n} ParallelExecutionOptions;\n\n\nSLEXEC_PARALLEL_PUBLISHED_C void initialize_parallel_execution(\n    ParallelExecutionOptions options);\n\nSLEXEC_PARALLEL_PUBLISHED_C void analyze_parallel_execution(void);\n\nSLEXEC_PARALLEL_PUBLISHED_C void parallel_for(\n    int loopSize, \n    ParallelForTaskFunction taskFunction, \n    int execMode,\n    const char_T* taskFuncName);\n\n#endif\n\n/* LocalWords:  raccel\n */\n"},{"name":"slexec_simbridge.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLEXEC_SIMBRIDGE_H\n#define SLEXEC_SIMBRIDGE_H\n/**\n * @file slexec_simbridge.h\n *\n * This header is the exported C interface to the simulink execution engine\n * (slexec_simbridge) for API that does not involved simstruct. It is used by\n * the Rapid Accelerator targets. This header can be included from any header\n * (see slexec_simstruct_bridge.h for simstruct related API)\n *\n * \n */\n\n/* Copyright 2014 The MathWorks, Inc. */\n\n#include \"tmwtypes.h\"\n\n/*******************************************************************************\n * Section A.1. Symbol visibility\n *******************************************************************************/\n\n#ifdef BUILDING_SLEXEC_SIMBRIDGE\n /* being included from inside slexec_simbridge module */\n  #include \"package.h\"\n  #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\" DLL_EXPORT_SYM\n#else\n /* being included from outside, such as raccel code */\n  #if defined(__cplusplus)\n /* Needed for non-inlined C++ S-functions */\n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\"\n  #else \n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern\n  #endif\n#endif\n\n/********************************************************************************\n * Section A.2. External mode hooks\n *******************************************************************************/\n\n#ifndef _RTWEXTMODEINFO\n  #define _RTWEXTMODEINFO\n    typedef struct _RTWExtModeInfo_tag RTWExtModeInfo;\n#endif\n\ntypedef struct ssBridgeExtModeCallbacks_tag {\n    void (*checkInit)(int_T);\n    void (*waitForStartPkt)(RTWExtModeInfo *,int_T,boolean_T*);\n    void (*oneStepFcn)(RTWExtModeInfo*, int, boolean_T*);\n    void (*uploadCheckTriggerFcn)(int_T);\n    void (*uploadFcn)(int_T, time_T);\n    void (*checkEndTriggerFcn)(void);\n    void (*pauseIfNeeded)(RTWExtModeInfo*, int, boolean_T*);\n    void (*shutDown)(int);\n\n    struct ssBridgeTargetConnectivityCallbacks_tag {\n        void (*TgtConnPreStep)(int_T);\n        void (*TgtConnPostStep)(int_T);\n    } targetConnectivityCallbacks_;\n\n} ssBridgeExtModeCallbacks_T;\n\n/* Time Accessor for simulink execution based simulation (raccel/rsim) */\nSLEXEC_SIMBRIDGE_PUBLISHED_C time_T rteiGetT(RTWExtModeInfo* ei);\n\n#define rteiSetTPtr(E,p) /* no-op */\n\n#endif /* ifdef SLEXEC_SSBRIDGE_H */\n"},{"name":"slexec_simstruct_bridge.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLEXEC_SIMSTRUCT_BRIDGE_H\n#define SLEXEC_SIMSTRUCT_BRIDGE_H\n/**\n * @file slexec_simstruct_bridge.h\n *\n * This header is the exported C interface to the simulink execution engine\n * (slexec_simbridge) that involves simstruct. It is used by the Rapid\n * Accelerator target. This file should be included from simstruct (and no\n * earlier) so that we have access to preprocessor variables. \n *\n * \n */\n\n/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#include \"slexec_simbridge.h\"\n#include \"slexec_ssExecutionInfo.h\"\n#include \"slexec_parallel.h\"\n#include <setjmp.h>\n\n/* Guard against early inclusions */\n#ifndef _SIMSTRUCT\n#error \"This file should be included from simstruc.h\"\n#endif\n\n\n/* runtimeEventIndex is the index of the runtime event on which you want to call raise */\n/* runMultiplicity is the number of times the tasks in the event clock are run when raised */\nSLEXEC_SIMBRIDGE_PUBLISHED_C void ssRaiseEventWithRunMultiplicity(\n    SimStruct* S,\n    uint_T runtimeEventIndex,\n    uint_T runMultiplicity);\n\n/* runtimeEventIndex is the index of the runtime event on which you want to raise the event */\nSLEXEC_SIMBRIDGE_PUBLISHED_C void ssRaiseEvent(\n    SimStruct* S,\n    uint_T runtimeEventIndex);\n\n/* taskRuntimeIndex is the runtime index of the task thay you want to raise by enqueuing */\nSLEXEC_SIMBRIDGE_PUBLISHED_C void ssRaiseEventWithEnqueue(\n    SimStruct* S,\n    uint_T taskRuntimeIndex);\n\n/* sti is the (also runtime) index of the *sole* rate in the task thay you want to disable */\nSLEXEC_SIMBRIDGE_PUBLISHED_C void ssDisableTaskUsingRateIndex(\n    SimStruct* S,\n    int_T sti);\n\n/* taskRuntimeIndex is the runtime index of the task thay you want to disable */\nSLEXEC_SIMBRIDGE_PUBLISHED_C void ssDisableTask(\n    SimStruct* S,\n    uint_T taskRuntimeIndex);\n\n/* sti is the (also runtime) index of the *sole* rate in the task thay you want to enable */\nSLEXEC_SIMBRIDGE_PUBLISHED_C void ssEnableTaskUsingRateIndex(\n    SimStruct* S,\n    int_T sti);\n\n/* taskRuntimeIndex is the runtime index of the task thay you want to enable */\nSLEXEC_SIMBRIDGE_PUBLISHED_C void ssEnableTask(\n    SimStruct* S,\n    uint_T taskRuntimeIndex);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void slexecSetNumTicksToNextSampleHitForControllableSampleTime(\n    SimStruct* rootS,\n    size_t ctrlRateIdx,\n    size_t nTicks);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C size_t slexecGetNumTicksToNextSampleHitForControllableSampleTime(\n    SimStruct* rootS,\n    size_t ctrlRateIdx);\n\n/* */\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint32_T slexecGetLiveOutputIndex(\n    SimStruct* S,\n    const char* identifier,\n    const char* path);\n\n\n/* */\nSLEXEC_SIMBRIDGE_PUBLISHED_C void slexecRecordLiveOutputData(\n        SimStruct* S,\n        uint32_T index,\n        double time,\n        void const* data);\n\n#endif \n"},{"name":"slexec_ssExecutionInfo.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLEXEC_EXECUTIONINFO_H\n#define SLEXEC_EXECUTIONINFO_H\n/**\n * @file slexec_executioninfo.h\n *\n * This header contains execution related parameters\n * which are used in rapid accelerator target.\n *\n */\n\n/* Copyright 2019-2021 The MathWorks, Inc. */\n\n#include \"slexec_parallel.h\"\n#include <setjmp.h>\n\n/* Guard against early inclusions */\n#ifndef _SIMSTRUCT\n#error \"This file should be included from simstruc.h\"\n#endif\n\n/* Information required to initialize/run Execution Engine */\ntypedef struct ssExecutionInfo_tag {\n    /* Root Simstruct */\n    SimStruct* simstruct_;\n\n    struct Comm {\n        int simServicePID_;\n        const char* channelNameColonBufferSize_;\n        void* controller_;\n    } comm_; \n\n    struct SimulationOptions {\n        const char* programActiveToken_;\n        const char* errorFile_;\n        const char* parameterFileName_; /* simulation option parameter file name */\n        const char* simMetadataFilePath_;\n        const char* inportFileName_;\n        const char* errorStatus_;\n        const char* matLoggingFilename_;\n        const char* matSigstreamLoggingFilename_;\n        const char* matSigLogSelectorFilename_;\n        const char* simDataRepoFilename_;\n        const char* toFileSuffix_;\n        const char* paramFilename_;\n        int parameterArrayIndex_; /* simulation options array index */\n        int timeLimit_;           /* time out for executable (is an int as of now) */\n        int enableSLExecSSBridgeFeatureValue_;\n        int* matFileFormat_;\n        int_T numRootInportBlks_;\n        boolean_T liveStreaming_;\n        boolean_T runningInParallel_;\n    } simulationOptions_;\n\n    struct ModelMethods {\n        /* model start */\n        void (*start)(void);\n        /* parameter update function */\n        void (*outputsParameterSampleTime)(int);\n        /* model terminate */\n        void (*terminate)(void);\n    } modelMethods_;\n\n    struct RuntimeCallbacks {\n        /* external mode call backs */\n        ssBridgeExtModeCallbacks_T* externalModeCallbacks_;\n        /* logging function */\n        void (*loggingFunction)(SimStruct*);\n        void (*partialSimOutputFunction)(const char_T*, RTWLogInfo*, boolean_T, boolean_T);\n        void (*setupMMIStateLog)(SimStruct*);\n        const char* (*startDataLoggingWithStartTime)(\n            RTWLogInfo*, const real_T, const real_T, const real_T, const char_T**);\n        const char* (*rapidReadInportsAndAperiodicHitTimes)(SimStruct*, const char*, int*);\n        const char* (*rapidCheckRemappings)(void);\n        void (*sdiBindObserversAndStartStreamingEngine)(const char*);\n        double (*nextAperiodicPartitionHitTime)(SimStruct*, double);\n        void (*updateParamsFcn)(const SimStruct*);\n\n    } runtimeCallbacks_;\n\n    struct RootIODataMethods {\n        void* (*getRootInput)(int /*idx*/);  /* idxth root input buffer */\n        void* (*getRootOutput)(int /*idx*/); /* idxth root output buffer */\n        int (*getNumRootInputs)(void);\n        int (*getNumRootOutputs)(void);\n        int (*getRootInputSize)(int);\n        int (*getRootOutputSize)(int);\n        int (*getRootInputDatatypeSSId)(int idx);\n        uint_T const* (*getRootInputDimArray)(int idx);\n        int (*getRootInputNumDims)(int idx);\n        int (*getRootOutputDatatypeSSId)(int idx);\n        uint_T const* (*getRootOutputDimArray)(int idx);\n        int (*getRootOutputNumDims)(int idx);\n\t\tint (*getRootOutputDataIsComplex)(int idx);\n\t\tint (*getRootInputDataIsComplex)(int idx);\n        int (*getRootInputPortNumber)(int idx);\n        int (*getRootOutputPortNumber)(int idx);\n    } rootIODataMethods_;\n\n    struct RuntimeFlags {\n        boolean_T* parameterPacketReceived_;\n        boolean_T startPacketReceived_;\n        const char* sFcnInfoFileName;\n    } runtimeFlags_;\n\n    struct RuntimeObjects {\n        jmp_buf* longJumpBuffer_;\n        void* iSigstreamManager_;\n    } runtimeObjects_;\n\n    struct ParallelExecution {\n        boolean_T enabled_;\n        int_T simulatorType_;\n        ParallelExecutionOptions options_;\n    } parallelExecution_;\n    \n    struct DeployedExecution {\n        boolean_T runningDeployed_;\n    } deployedExecution_;\n\n    struct ExecutionOptions {\n        boolean_T loadInitialState_;\n        void* aperiodicPartitionHitTimes_;\n    } executionOptions_;\n\n    struct Reval {\n        int servicePort_;\n        uint_T host2target_;\n        uint_T target2host_;\n    } reval_;\n\n    struct Services {\n        void* executionServices_;\n    } services_;\n    \n} ssExecutionInfo;\n\n/* Get ExecutionInfo from simstruct */\n#define ssGetExecutionInfo(S) ((ssExecutionInfo*)((S)->mdlInfo->executionInfo))\n\n/* Set ExecutionInfo on simstruct */\n#define ssSetExecutionInfo(S, exInfo) (S)->mdlInfo->executionInfo = (void*)(exInfo); \\\n(exInfo)->simstruct_ = (S)\n\n/* This macro is used to get the status whether InitialState is set from outside */\n#define ssGetGlobalInitialStatesAvailable(S) ssGetExecutionInfo(S)->executionOptions_.loadInitialState_\n\n/* This macro is used to get the aperiodic partition hit times */\n#define ssGetExecOptionAperiodicPartitionHitTimes(S) ssGetExecutionInfo(S)->executionOptions_.aperiodicPartitionHitTimes_\n\n#endif\n\n/* LocalWords:  executioninfo idxth\n */\n"},{"name":"slexec_vm_lookup_functions.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLEXEC_VM_LOOKUP_FUNCTIONS_H\n#define SLEXEC_VM_LOOKUP_FUNCTIONS_H\n/**\n * @file slexec_vm_lookup_functions.h\n *\n * This header is the exported C interface of the Simulink lookup functions\n * for use in VM applications.\n * \n */\n\n/* Copyright 2015 The MathWorks, Inc. */\n\n#include \"tmwtypes.h\"\n\n#ifndef INTERP\n# define INTERP(x,x1,x2,y1,y2)         ( (y1)+(((y2) - (y1))/((x2) - (x1)))*((x)-(x1)) )\n#endif\n\n#ifndef ZEROTECHNIQUE\n#define ZEROTECHNIQUE\n\ntypedef enum {\n  NORMAL_INTERP,\n  AVERAGE_VALUE,\n  MIDDLE_VALUE\n} ZeroTechnique;\n\n#endif\n\n#ifdef BUILDING_SLEXEC_SIMBRIDGE\n /* being included from inside slexec_simbridge module */\n  #include \"package.h\"\n  #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\" DLL_EXPORT_SYM\n#else\n /* being included from outside, such as raccel code */\n  #if defined(__cplusplus)\n /* Needed for non-inlined C++ S-functions */\n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\"\n  #else \n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern\n  #endif\n#endif\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C real_T rt_Lookup(\n    const real_T *x, int_T xlen, real_T u, const real_T *y);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C real32_T rt_Lookup32(\n    const real32_T *x, int_T xlen, real32_T u, const real32_T *y);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C real_T rt_Lookup2D_Normal(\n    const real_T *xVals, const int_T numX,\n    const real_T *yVals, const int_T numY,\n    const real_T *zVals,\n    const real_T x, const real_T y);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C real32_T rt_Lookup2D32_Normal(\n    const real32_T *xVals, const int_T numX,\n    const real32_T *yVals, const int_T numY,\n    const real32_T *zVals,\n    const real32_T x, const real32_T y);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C real_T rt_Lookup2D_General(\n    const real_T *rowVals, const int_T numRowVals,\n    const real_T *colVals, const int_T numColVals,\n    const real_T *outputValues,\n    const real_T uX, const real_T uY,\n    const int_T colZeroIdx,\n    const ZeroTechnique colZeroTechnique,\n    const real_T *outputAtRowZero);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C real32_T rt_Lookup2D32_General(\n    const real32_T *rowVals, const int_T numRowVals,\n    const real32_T *colVals, const int_T numColVals,\n    const real32_T *outputValues,\n    const real32_T uX, const real32_T uY,\n    const int_T colZeroIdx,\n    const ZeroTechnique colZeroTechnique,\n    const real32_T *outputAtRowZero);\n\n#endif\n"},{"name":"slexec_vm_rt_functions.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLEXEC_VM_RT_FUNCTIONS_H\n#define SLEXEC_VM_RT_FUNCTIONS_H\n/**\n * @file slexec_vm_rt_functions.h\n *\n * This header is the exported C interface of the Simulink RT functions\n * for use in VM applications.\n * \n */\n\n/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#include \"tmwtypes.h\"\n\n#ifdef BUILDING_SLEXEC_SIMBRIDGE\n /* being included from inside slexec_simbridge module */\n  #include \"package.h\"\n  #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\" DLL_EXPORT_SYM\n#else\n /* being included from outside, such as raccel code */\n  #if defined(__cplusplus)\n /* Needed for non-inlined C++ S-functions */\n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\"\n  #else \n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern\n  #endif\n#endif\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void rtErrorMsgID(\n    void*  S, const char* msgID);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void rtSizeEqCheck1D(\n    void*  S, int  dims1, int dims2);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void rtSizeEqCheckND(\n    void*  S, int* dims1, int* dims2, int  nDims);\n\n// g2104313 : Matlab crash during accelerator mode simulation of attached model\n// Adding the definition of these functions which will be required for llvm \n// based accelerated mode simulation.\nSLEXEC_SIMBRIDGE_PUBLISHED_C real_T rtGetInf();\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C real_T rtGetNaN();\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C real_T rtGetMinusInf();\n//end of changes for g2104313\n\n#endif\n"},{"name":"slexec_vm_simstruct_bridge.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLEXEC_VM_SIMSTRUCT_BRIDGE_H\n#define SLEXEC_VM_SIMSTRUCT_BRIDGE_H\n/**\n * @file slexec_vm_simstruct_bridge.h\n *\n * This header is the exported C interface of the SimStruct and related\n * data structures, for use in VM applications.\n * \n */\n\n/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#include \"tmwtypes.h\"\n\n#ifdef BUILDING_SLEXEC_SIMBRIDGE\n /* being included from inside slexec_simbridge module */\n  #include \"package.h\"\n  #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\" DLL_EXPORT_SYM\n#else\n /* being included from outside, such as raccel code */\n  #if defined(__cplusplus)\n /* Needed for non-inlined C++ S-functions */\n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\"\n  #else \n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern\n  #endif\n#endif\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssCallAccelRunBlock(\n    void* S, int_T sysIdx, int_T blkIdx, int_T blkFcn);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssCallAccelPreBlock(\n    void* S, int_T sysIdx, int_T blkIdx, int_T blkFcn);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssCallAccelPostBlock(\n    void* S, int_T sysIdx, int_T blkIdx, int_T blkFcn);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_slmrAccelRunBlockSystemInitialize(\n    void* S, int_T sysIdx, int_T blkIdx);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_slmrAccelRunBlockSystemReset(\n    void* S, int_T sysIdx, int_T blkIdx);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssCallAccelModelBlockFcnCallInput(\n    void* S, int_T sysIdx, int_T blkIdx, int_T portIdx, int_T tid, int_T blkFcn);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssCallAccelCopyCacheForIISBasedOnDescSysList(\n    void* S, int_T sysIdx, int_T fromCache);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssCallAccelCopyCacheForIISBasedOnCGSysList(\n    void* S, int_T sysIdx, int_T fromCache);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssCallAccelSetDims(\n    void* S, int_T sysIdx, int_T blkIdx, int_T outIdx, int_T ruleIdx);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssSetReinitializeEventBeingProcessed(void* S,\n                                                                          char_T* reinitId);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssSetChecksumVal(\n    void *S, int_T sysIdx, int_T blkIdx);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm__ssGetBlockPath(\n    void* S, int_T sysIdx, int_T blkIdx, char_T** path);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetRootDWork(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm__ssGetModelBlockIO(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C const void* vm_ssGetConstBlockIO(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C double* vm_ssGetModelRtp(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetU(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetUByIndex(void* S, int_T index);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetX(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetdX(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetAbsTolVector(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetJacobianPerturbationBoundsMinVec(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetJacobianPerturbationBoundsMaxVec(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetY(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void* vm_ssGetYByIndex(void* S, int_T index);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_dworkSizeCheck(void* S, uint_T sizeofStruct);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_blockIOSizeCheck(void* S, uint_T sizeofStruct);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_USizeCheck(void* S, uint_T sizeofStruct);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_YSizeCheck(void* S, uint_T sizeofStruct);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_paramSizeCheck(void* S, uint_T sizeofStruct);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C int_T\n    vm_ssIsSampleHit(void* S, int_T sti, int_T tid);\nSLEXEC_SIMBRIDGE_PUBLISHED_C int_T vm_ssIsContinuousTask(void* S, int_T tid);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm__ssSetSampleHit(void* S, int_T sti,\n                                                     int_T v);\nSLEXEC_SIMBRIDGE_PUBLISHED_C int vm_ssIsSpecialSampleHit(void* S, int_T my_sti,\n                                                         int_T promoted_sti,\n                                                         int_T tid);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint32_T vm_ssGetClockTick(void* S, int_T sti);\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint32_T vm_ssGetClockTickH(void* S, int_T sti);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C double* vm_ssGetSolverZcSignalVector(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint8_T* vm_ssGetPrevZCSigState(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C int_T vm_ssIsMajorTimeStep(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C bool vm_ssIsModeUpdateTimeStep(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssSetStopRequested(void* S, int_T val);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_srClearBC(int8_T* state);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void  vm_srUpdateBC(int8_T* state);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C double vm_ssGetT(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C double vm_ssGetTaskTime(void* S, int_T sti);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm__ssSetTaskTime(void* S, int_T sti,\n                                                    double time);\nSLEXEC_SIMBRIDGE_PUBLISHED_C double vm_ssGetTStart(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C double vm_ssGetTFinal(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C double vm_ssGetStepSize(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C double vm_ssGetTimeOfLastOutput(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C double vm__ssGetVarNextHitTime(void* S,\n                                                            int_T varId);\nSLEXEC_SIMBRIDGE_PUBLISHED_C double vm_ssGetTimeOfNextVarHit(void* S, int_T sti);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm__ssSetVarNextHitTime(void* S, int_T varId,\n                                                          double tNextMin);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssSetTimeOfNextVarHit(void* S, int_T sti,\n                                                           double tNextMin);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint8_T\n    vm_ssGetTNextWasAdjusted(void* S, int_T varTsId);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint8_T* vm_ssGetContStateDisabled(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint8_T vm_ssIsFirstInitCond(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C const char_T* vm_ssGetErrorStatus(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint8_T vm_getHasError(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssSetErrorStatus(void* S,\n                                                      const char_T* str);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm__ssSet_slErrMsg(void* S, void* diag);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm__ssReportDiagnosticAsWarning(void* S,\n                                                                  void* diag);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm__ssReportDiagnosticAsInfo(void* S,\n                                                               void* diag);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssSetContTimeOutputInconsistentWithStateAtMajorStep(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssSetBlockStateForSolverChangedAtMajorStep(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ReadLocalDSMNoIdx(void* S, int_T dsmIdx,\n                                                       const char_T* blockPath,\n                                                       int_T idxWidth);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ReadLocalDSMIntIdx(void* S, int_T dsmIdx,\n                                                        const char_T* blockPath,\n                                                        int_T idx,\n                                                        int_T idxWidth);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_WriteLocalDSMNoIdx(void* S, int_T dsmIdx,\n                                                        const char_T* blockPath,\n                                                        int_T idxWidth);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_WriteLocalDSMIntIdx(\n    void* S, int_T dsmIdx, const char_T* blockPath, int_T idx, int_T idxWidth);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ReadGlobalDSMNoIdx(void* S, int_T dsmIdx,\n                                                        const char_T* blockPath,\n                                                        int_T idxWidth);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ReadGlobalDSMIntIdx(\n    void* S, int_T dsmIdx, const char_T* blockPath, int_T idx, int_T idxWidth);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_WriteGlobalDSMNoIdx(\n    void* S, int_T dsmIdx, const char_T* blockPath, int_T idxWidth);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_WriteGlobalDSMIntIdx(\n    void* S, int_T dsmIdx, const char_T* blockPath, int_T idx, int_T idxWidth);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm__ssIsPositiveDataValue(void* S, void* data,\n                                                            int_T dtId,\n                                                            int8_T* result);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm__ssSignDataValue(void* S, void* data,\n                                                      int_T dtId,\n                                                      int8_T* result);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint8_T vm_ssIsSolverComputingJacobian(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint8_T vm_ssIsSolverRequestingReset(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint8_T vm_ssIsSolverCheckingCIC(void* S);\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssRaiseEvent(void* S, uint_T runtimeEventIndex);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssDummy();\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C uint8_T vm_ssGetEvaluatingF0ForJacobian(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C bool vm_ssGetIsZCEvaluationForRefine(void* S);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssSetNumTicksToNextHitForControllableSampleTime(void* S,\n                                                                               int_T stIdx,\n                                                                               double numTicks);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C void vm_ssSetDenormalBehavior(int_T flag);\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C bool vm_ssGetGlobalInitialStatesAvailable(void* S);\n\n#endif\n"},{"name":"slexec_vm_zc_functions.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLEXEC_VM_ZC_FUNCTIONS_H\n#define SLEXEC_VM_ZC_FUNCTIONS_H\n/**\n * @file slexec_vm_zc_functions.h\n *\n * This header is the exported C interface of the Simulink ZC functions\n * for use in VM applications.\n * \n */\n\n/* Copyright 2015 The MathWorks, Inc. */\n#include \"simstruc_types.h\"\n\n#ifdef BUILDING_SLEXEC_SIMBRIDGE\n /* being included from inside slexec_simbridge module */\n  #include \"package.h\"\n  #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\" DLL_EXPORT_SYM\n#else\n /* being included from outside, such as raccel code */\n  #if defined(__cplusplus)\n /* Needed for non-inlined C++ S-functions */\n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern \"C\"\n  #else \n    #define SLEXEC_SIMBRIDGE_PUBLISHED_C extern\n  #endif\n#endif\n\nSLEXEC_SIMBRIDGE_PUBLISHED_C ZCEventType rt_ZCFcn(\n    ZCDirection zcDir, uint8_T* prevZc, double currValue);\nSLEXEC_SIMBRIDGE_PUBLISHED_C ZCEventType rt_I32ZCFcn(\n    ZCDirection zcDir, uint8_T* prevZc, int32_T currValue);\n\n#endif\n"},{"name":"slsa_sim_engine.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"#ifndef SLSA_SIM_ENGINE_H\n#define SLSA_SIM_ENGINE_H\n\n/**\n * @file slsa_sim_engine.h\n *\n * This file declares functions which provide\n * access to new execution engine.\n**/ \n\n/* Copyright 2011-2021 The MathWorks, Inc. */\n\n#include \"libmwslsa_sim.h\"\n#include \"matrix.h\"\n\n/* Custom save function signature for saving the block specific execution data.\n * Saved data is returned as 'void*' which has to be deallocated by the caller.\n * Size of the data saved is returned in argument 'sizeInBytes'.\n *\n * NOTE : It is assumed that the memory is allocated by 'malloc' or it's sister functions and\n * on the rapid accelerator side 'free' is used cleanup the memory */\ntypedef void* (*SlsaCustomOPSaveFcn)(void* dworkPtr, unsigned int* sizeInBytes);\n\n/* Custom restore function signature for saving the block specific execution data.*/\ntypedef void  (*SlsaCustomOPRestoreFcn)(void* dworkPtr, const void* data, unsigned int sizeInBytes);\n\n/* Returns the set of blocks which do not support save/restore OperatingPoint\n * in rapid accelerator mode.*/\ntypedef mxArray*  (*SlsaDisallowedBlocksFcn)();\n\n/* Pointer to GetWork function */\ntypedef mxArray*  (*SlsaGetWorkFcn)();\n\n/* Pointer to SetWork function */\ntypedef void  (*SlsaSetWorkFcn)(const mxArray* workData);\n\n/* Debug Timing Log */\n\n/* The global variable slsaDebugTimingLogFH used in the macro below is defined in this module (in\n * util/debug.cpp) and in raccel_main.c. We need to define this seperate in the two modules as it is\n * not possible to export a varable out of module with C linkage in C++ on MSVC\n */\n#define SLSA_DEBUG_TIMING_LOG(msg)                              \\\n    if (slsaDebugTimingLogFH) slsaRecordDebugTimingLog(msg)\n\nSLSA_SIM_PUBLISHED_C FILE* slsaOpenDebugTimingLog(FILE* FH);\nSLSA_SIM_PUBLISHED_C void slsaRecordDebugTimingLog(const char* msg);\n\n\n/* setup comm controller */\nSLSA_SIM_PUBLISHED_C const char* slsaSetupCommController(void* exInfo);\n\n/* hook to perform cleanup tasks at program exit */\nSLSA_SIM_PUBLISHED_C void slsaAtProgramExit(void* ei);\n\n/* run simulation */\nSLSA_SIM_PUBLISHED_C void ssRunSimulation(void* ss);\n\n/* Parse arguments to rapid accelerator main */\nSLSA_SIM_PUBLISHED_C void slsaParseArguments(int_T argc, char_T *argv[], void* executionInfo);\n\nSLSA_SIM_PUBLISHED_C void ssWriteSimMetadata(\n    void* ss,\n    const char* metadataFilePath);\n\n/* Create OperatingPoint ModelData */\nSLSA_SIM_PUBLISHED_C void slsaAllocOPModelData(void* pSimStruct);\n\n/* Delete OperatingPoint ModelData */\nSLSA_SIM_PUBLISHED_C void slsaFreeOPModelData(void* pSimStruct);\n\n/* Cache the pointers */\nSLSA_SIM_PUBLISHED_C void slsaCacheDWorkPointerForSimTargetOP(void* ss, void** ptr);\n\n/* Cache the data */\nSLSA_SIM_PUBLISHED_C void slsaCacheDWorkDataForSimTargetOP(\n    void* ss,\n    void* dataPtr,\n    unsigned int sizeInBytes);\n\n/* Cache the raw memory */\nSLSA_SIM_PUBLISHED_C void slsaSaveRawMemoryForSimTargetOP(\n        void* ss,\n        const char* key,\n        void** ptr,\n        unsigned int sizeInBytes,\n        SlsaCustomOPSaveFcn customOPSaveFcn,\n        SlsaCustomOPRestoreFcn customOPRestoreFcn\n        );\n\n/* Set the different WORK sizes in bytes */\nSLSA_SIM_PUBLISHED_C void ssSetWorkSizeInBytes(\n        void*  ss,\n        unsigned int sizeInBytes,\n        const char*  type\n        );\n\n/* Unsupported blocks for save/restore OperatingPoint */\nSLSA_SIM_PUBLISHED_C void slsaDisallowedBlocksForSimTargetOP(\n        void* ss,\n        SlsaDisallowedBlocksFcn disallowedBlocksFcn\n        );\n\n/* Set the <model>_GetDWork function pointer on SimStruct 'ss' */\nSLSA_SIM_PUBLISHED_C void slsaGetWorkFcnForSimTargetOP(\n        void*  ss,\n        SlsaGetWorkFcn getWorkFcn\n        );\n\n/* Set the <model>_SetDWork function pointer on SimStruct 'ss' */\nSLSA_SIM_PUBLISHED_C void slsaSetWorkFcnForSimTargetOP(\n        void*  ss,\n        SlsaSetWorkFcn setWorkFcn\n        );\n\n/* Call back to MATLAB interpreter for string-to-string functions. */\nSLSA_SIM_PUBLISHED_C\nchar *rtCallMATLABInterpStr2Str(const char *cmd, const char *input);\n\n/* Release memory used for the result of rtCallMATLABInterpStr2Str. */\nSLSA_SIM_PUBLISHED_C void rtCallMATLABInterpStr2StrFree(char *str);\n\n\n/* Verifying results of rtCallMATLABInterpStr2Str call. */\nSLSA_SIM_PUBLISHED_C\nbool rtCallMATLABInterpStr2StrVerify(const char *str1, const char *str2);\n\n/* Call back to MATLAB interpreter for string-to-string functions with the \n   result string replacing the input string. \n*/\nSLSA_SIM_PUBLISHED_C\nvoid rtCallMATLABInterpStrReplace(\n    const char *cmd,\n    char *inputOutput,\n    const size_t size\n    );\n\n/* Call back to MATLAB interpreter for double-to-double functions.*/\nSLSA_SIM_PUBLISHED_C\ndouble rtCallMATLABInterpDouble2double(const char *cmd, const double u);\n\n/* System Object setup function. It is invoked from MATLAB System Block start. */\nSLSA_SIM_PUBLISHED_C void ssRevalSysObjSetup(const char *sysObjName);\n\n/* System Object step function. It is invoked from MATLAB System Block output. */\nSLSA_SIM_PUBLISHED_C double ssRevalSysObjStep(const double u);\n\n/* System Object terminate function. It is invoked from MATLAB System Block \nterminate. */\nSLSA_SIM_PUBLISHED_C void ssRevalSysObjTerminate();\n\n/* System Object reset function. It is invoked from MATLAB System Block \ninitialize. */\nSLSA_SIM_PUBLISHED_C void ssRevalSysObjReset();\n\n/* System Object update function. It is invoked from MATLAB System Block \nupdate. */\nSLSA_SIM_PUBLISHED_C void ssRevalSysObjUpdate();\n\n/* Add a network outbound rule to allow the rapid accelerator to communicate\n * with MATLAB over a TCP port */\nSLSA_SIM_PUBLISHED_C int addOutBoundRule(size_t port, const char* program);\n\n#endif /* SLSA_SIM_ENGINE_H */\n"},{"name":"slsv_diagnostic_codegen_c_api.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2010-2012 The MathWorks, Inc. */\n\n#ifndef slsv_diagnostic_codegen_c_api_h\n#define slsv_diagnostic_codegen_c_api_h\n\n#include \"tmwtypes.h\"\n\n#ifdef BUILDING_LIBMWSL_SERVICES\n /* being included from inside sl_services module */\n  #include \"package.h\"\n  #define SL_SERVICES_PUBLISHED_C extern \"C\" DLL_EXPORT_SYM\n#else\n /* being included from outside, such as raccel code */\n  #if defined(__cplusplus)\n /* Needed for non-inlined C++ S-functions */\n    #define SL_SERVICES_PUBLISHED_C extern \"C\"\n  #else \n    #define SL_SERVICES_PUBLISHED_C extern\n  #endif\n#endif\n\n/* for valist_CreateDiagnosticAsVoidPtr */\n#if defined(__cplusplus)\n  #include <cstdarg> \n#else\n  #include <stdarg.h>\n#endif\n\n#include \"slsv_diagnostic_logger_type.h\"\n\n#define CODEGEN_SUPPORT_ARG_END_LIST             (int)0\n#define CODEGEN_SUPPORT_ARG_INTEGER_TYPE (int)1\n#define CODEGEN_SUPPORT_ARG_REAL_TYPE (int)2\n#define CODEGEN_SUPPORT_ARG_STRING_TYPE (int)3\n#define CODEGEN_SUPPORT_ARG_ENCODED_STRING_TYPE (int)4\n#define CODEGEN_SUPPORT_ARG_ESCAPED_STRING_TYPE (int)5\n\n#define CODEGEN_SUPPORT_DIAGNOSTIC_INFO (int)0\n#define CODEGEN_SUPPORT_DIAGNOSTIC_WARNING (int)1\n#define CODEGEN_SUPPORT_DIAGNOSTIC_ERROR (int)2\n\nSL_SERVICES_PUBLISHED_C char* CreateDiagnosticXMLSnippet(const char* id,\n                                                         int nargs, ...);\n\nSL_SERVICES_PUBLISHED_C void* CreateDiagnosticAsVoidPtr(const char* id,\n                                                        int nargs, ...);\n\nSL_SERVICES_PUBLISHED_C void* valist_CreateDiagnosticAsVoidPtr(const char* id,\n                                                               int nargs,\n                                                               va_list args);\n\n/* UTF8 path */\nSL_SERVICES_PUBLISHED_C void dl_set_home(const char *path);\n\nSL_SERVICES_PUBLISHED_C dl_logger_sid_t dl_init(size_t);\nSL_SERVICES_PUBLISHED_C dl_logger_sid_t dl_init_objpath(size_t);\nSL_SERVICES_PUBLISHED_C void dl_clear(dl_logger_sid_t);\nSL_SERVICES_PUBLISHED_C void dl_destroy(dl_logger_sid_t);\nSL_SERVICES_PUBLISHED_C void dl_reset(dl_logger_sid_t);\n\nSL_SERVICES_PUBLISHED_C void dl_report(dl_logger_sid_t, int type, const char* id, ...);\n\n/* void * from CreateDiagnosticAsVoidPtr */\nSL_SERVICES_PUBLISHED_C void dl_report_from_diagnostic(dl_logger_sid_t, int type, void* diagnostic);\n\nSL_SERVICES_PUBLISHED_C char* dl_get_object_path(dl_logger_sid_t, int sysId, int objId);\n\nSL_SERVICES_PUBLISHED_C void slsvRegisterDiagnosticListenerCG(const char *id, bool enable);\nSL_SERVICES_PUBLISHED_C void slsvUnRegisterDiagnosticListenerCG();\n\nSL_SERVICES_PUBLISHED_C void slsvEnableDiagnosticListenerCG();\nSL_SERVICES_PUBLISHED_C void slsvDisableDiagnosticListenerCG();\n\nSL_SERVICES_PUBLISHED_C void slsvClearListenerCG(const char *id);\nSL_SERVICES_PUBLISHED_C void slsvClearAllListenersCG();\n\nSL_SERVICES_PUBLISHED_C void slsvSetUserDataDiagnosticListenerCG(const void *data);\n\nSL_SERVICES_PUBLISHED_C void    slsvTic();\nSL_SERVICES_PUBLISHED_C double  slsvToc();\n#endif /* slsv_diagnostic_codegen_c_api_h */\n"},{"name":"slsv_diagnostic_deployment_c_api.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2019 The MathWorks, Inc. */\n\n#ifndef slsv_diagnostic_deployment_c_api_h\n#define slsv_diagnostic_deployment_c_api_h\n\n#include \"tmwtypes.h\"\n\n#ifdef BUILDING_LIBMWSL_SERVICES\n/* being included from inside sl_services module */\n#include \"package.h\"\n#define SL_SERVICES_PUBLISHED_C extern \"C\" DLL_EXPORT_SYM\n#else\n/* being included from outside, such as raccel code */\n#if defined(__cplusplus)\n/* Needed for non-inlined C++ S-functions */\n#define SL_SERVICES_PUBLISHED_C extern \"C\"\n#else\n#define SL_SERVICES_PUBLISHED_C extern\n#endif\n#endif\n\n#include <limits.h>\n\n#define UNDEFINED_VALUE INT_MIN\n\nSL_SERVICES_PUBLISHED_C int feature_get(const char *);\nSL_SERVICES_PUBLISHED_C int feature_set(const char *, int);\n\nSL_SERVICES_PUBLISHED_C int hook_get(const char *);\nSL_SERVICES_PUBLISHED_C int hook_set(const char *, int);\n\n\n#endif /* slsv_diagnostic_deployment_c_api_h */\n"},{"name":"slsv_diagnostic_logger_type.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2016 The MathWorks, Inc. */\n/*\n  dl_logger_type.h\n  libmwsl_services\n\n  Created by dima on 7/16/16.\n*/\n\n#ifndef dl_logger_type_hpp\n#define dl_logger_type_hpp\n\ntypedef void* dl_logger_sid_t;\n\n#endif /* dl_logger_type_hpp */\n"},{"name":"slsv_mexhelper.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2014 The MathWorks, Inc. */\n\n#ifdef SUPPORTS_PRAGMA_ONCE\n#pragma once\n#endif\n\n#ifndef SLSV_MEXHELPER\n#define SLSV_MEXHELPER\n\n#ifndef DLL_EXPORT_SYM\n#ifdef SL_INTERNAL\n#include \"package.h\"\n#else\n#define DLL_EXPORT_SYM\n#endif\n#endif\n\n#ifdef __cplusplus\n#define SL_SERVICES_EXPORT_EXTERN_C extern \"C\" DLL_EXPORT_SYM\n#else\n#define SL_SERVICES_EXPORT_EXTERN_C extern DLL_EXPORT_SYM\n#endif\n\n#include \"matrix.h\"\n\n/* ////////////////////////////////////////////////////////////////////////\n * This code is used to override calls to the mex api made from dynamically\n * loaded s-functions in rapid-accelerator (see g1472731). */\n\ntypedef bool (*RAccelMexIsLocked)(void);\n\ntypedef int (*RAccelMexPutVar)(\n    const char*,\n    const char*,\n    const mxArray* );\n\ntypedef const mxArray * (*RAccelMexGetVarPtr)(\n    const char*,\n    const char* );\n\ntypedef mxArray * (*RAccelMexGetVar)(\n    const char*,\n    const char * );\n\ntypedef void (*RAccelMexLock)( void );\n\ntypedef void (*RAccelMexUnlock)( void );\n\ntypedef const char * (*RAccelMexFunctionName)( void );\n\ntypedef int (*RAccelMexEvalString)( const char * );\n\ntypedef mxArray * (*RAccelMexEvalStringWithTrap)( const char * );\n\ntypedef int (*RAccelMexSet)(\n    double,\n    const char *,\n    mxArray * );\n\ntypedef const mxArray* (*RAccelMexGet)(\n    double,\n    const char * );\n\ntypedef int (*RAccelMexCallMatlab)(\n    int,\n    mxArray *plhs[],\n    int,\n    mxArray *prhs[],\n    const char *,\n    bool );\n\ntypedef mxArray * (*RAccelMexCallMatlabWithTrap)(\n    int,\n    mxArray *plhs[],\n    int,\n    mxArray *prhs[],\n    const char * );\n\ntypedef mxArray * (*RAccelMexCreateSimpleFunctionHandle)( mxFunctionPtr f);\n\ntypedef int (*RAccelMexAtExit)(void (*exitFcn)(void));\n\ntypedef bool (*RAccelMexSetMexTrapFlag)();\n\ntypedef struct RAccelMexCallbacks_T\n{\n    RAccelMexIsLocked isLocked_;\n    RAccelMexPutVar putVar_;\n    RAccelMexGetVarPtr getVarPtr_;\n    RAccelMexGetVar getVar_;\n    RAccelMexLock lock_;\n    RAccelMexUnlock unlock_;\n    RAccelMexFunctionName functionName_;\n    RAccelMexEvalString evalString_;\n    RAccelMexEvalStringWithTrap evalStringWithTrap_;\n    RAccelMexSet set_;\n    RAccelMexGet get_;\n    RAccelMexCallMatlab mexCallMatlab_;\n    RAccelMexCallMatlabWithTrap mexCallMatlabWithTrap_;\n    RAccelMexCreateSimpleFunctionHandle createSimpleFunctionHandle_;\n    RAccelMexAtExit atExit_;\n    RAccelMexSetMexTrapFlag setMexTrapFlag_;\n} RAccelMexCallbacks;\n\nSL_SERVICES_EXPORT_EXTERN_C void rapidAccelSetMexCallbacks(RAccelMexCallbacks cb);\n\n#endif /* SLSV_MEXHELPER */\n"},{"name":"solver_zc.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2002-2021 The MathWorks, Inc. */\n/**\n *\n * Types and define related to zero crossing signals and events\n *\n */\n\n/* Leading _ in header guards violates MISRA standard rule 21.1 */\n#ifndef solver_zc_hpp_\n#define solver_zc_hpp_\n\n/* slZcSignalType ==============================================================\n *\n */\ntypedef enum {\n\n    SL_ZCS_TYPE_CONT = 0,\n    SL_ZCS_TYPE_DISC = 1,\n    SL_ZCS_TYPE_HYBRID = 2\n\n} slZcSignalType;\n\n\n/* slZcEventType ===============================================================\n *\n *  zcEvents are bit packed as follows:\n *\n *   .-----.-----.-----.-----.-----.-----.-----.-----.\n *   |     |     | z2n | p2z | p2n | z2p | n2z | n2p |\n *   '-----'-----'-----'-----'-----'-----'-----'-----'\n *            ^  |<----------- eventTypes ---------->|\n *            |\n *            `--- needsSolverReset\n *\n */\ntypedef uint8_T slZcEventType;\n#define SL_ZCS_EVENT_NUL 0x00U\n#define SL_ZCS_EVENT_N2P 0x01U\n#define SL_ZCS_EVENT_N2Z 0x02U\n#define SL_ZCS_EVENT_Z2P 0x04U\n#define SL_ZCS_EVENT_P2N 0x08U\n#define SL_ZCS_EVENT_P2Z 0x10U\n#define SL_ZCS_EVENT_Z2N 0x20U\n\n#define SL_ZCS_EVENT_ALL_UP (SL_ZCS_EVENT_N2P | SL_ZCS_EVENT_N2Z | SL_ZCS_EVENT_Z2P)\n\n#define SL_ZCS_EVENT_ALL_DN (SL_ZCS_EVENT_P2N | SL_ZCS_EVENT_P2Z | SL_ZCS_EVENT_Z2N)\n\n#define SL_ZCS_EVENT_ALL (SL_ZCS_EVENT_ALL_UP | SL_ZCS_EVENT_ALL_DN)\n\n#define slZcSignalGetNeedsSolverReset(a) (((a)&0x40) != 0x00)\n\n#define slZcSignalSetNeedsSolverReset(a, v) (a) = (v) ? ((a) | 0x40) : ((a)&0xBF)\n\n\n/* slZcSignalAttribType ========================================================\n *\n *  ZcSignal attributes are bit packed as follows:\n *\n *   .-----.-----.-----.-----.-----.-----.-----.-----.\n *   |     |     | z2n | p2z | p2n | z2p | n2z | n2p |\n *   '-----'-----'-----'-----'-----'-----'-----'-----'\n *      ^     ^  |<---- which events to look for --->|\n *      |     |\n *      |     `--- isDiscrete\n *      |\n *      `--------- needsEventNotification\n */\ntypedef uint8_T slZcSignalAttribType;\n\n#define slZcSignalGetEventDirections(a) ((a)&0x3F)\n\n#define slZcSignalSetEventDirections(a, d) (a) = (((a)&0xC0) | (d))\n\n#define slZcSignalGetIsDiscrete(a) (((a)&0x40) != 0x00)\n\n#define slZcSignalSetIsDiscrete(a, v) (a) = (v) ? ((a) | 0x40) : ((a)&0xBF)\n\n#define slZcSignalGetNeedsEventNotification(a) (((a)&0x80) != 0x00)\n\n#define slZcSignalSetNeedsEventNotification(a, v) (a) = (v) ? ((a) | 0x80) : ((a)&0x7F)\n\n\n/* slZcSignalSignType ==========================================================\n *\n */\ntypedef uint8_T slZcSignalSignType;\n#define SL_ZCS_SIGN_ZERO 0x00U\n#define SL_ZCS_SIGN_POS 0x01U\n#define SL_ZCS_SIGN_NEG 0x02U\n#define SL_ZCS_SIGN_UNKNOWN 0x03U\n\n#endif /* _solver_zc_hpp_ */\n\n/* eof */\n"},{"name":"sysran_types.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\include","tag":"","groupDisplay":"Other files","code":"/* Copyright 2004-2021 The MathWorks, Inc. */\n\n/*\n * File: sysran_types.h\n *\n * Abstract:\n *   This files defines the enum and the macros to do with the system ran\n *   breadcrumbs\n *\n *   This file is used both by Simulink and some of the generated code\n */\n\n#ifndef SIMSTRUCT_SYSRAN_TYPES_H\n#define SIMSTRUCT_SYSRAN_TYPES_H\n\n/* Subsystem run state -- used by Model Reference simulation target */\ntypedef enum {\n    SUBSYS_RAN_BC_DISABLE,\n    SUBSYS_RAN_BC_ENABLE,\n    SUBSYS_RAN_BC_DISABLE_TO_ENABLE,\n    SUBSYS_RAN_BC_ENABLE_TO_DISABLE,\n    SUBSYS_RAN_BC_ONE_SHOT\n} SubSystemRanBCTransition;\n\n/* This is the data type of the dwork entry for the system ran breadcrumb */\ntypedef int8_T sysRanDType;\n\n/*\n * System ran breadcrumb macros\n *\n * Clearing macro.  2 callers\n *    i) top of the sim-loop\n *   ii) top of each Outputs function for External mode\n *\n *\n * Here is the basic idea:\n *   If a system is DISABLED, it stays DISABLED.\n *   For any other state, assume ENABLE_TO_DISABLE,\n *     If it runs then the OutputFcn will move it to ENABLE\n *     otherwise it will come back as  ENABLE_TO_DISABLE(hence it never ran)\n *\n * DISABLE            -> DISABLE  (latched)\n * ENABLE             -> ENABLE_TO_DISABLE (assume)\n * ENABLE_TO_DISABLE  -> DISABLE (new latch)\n * DISABLE_TO_ENABLE  -> ENABLE  (new enable)\n * ONE_SHOT           -> DISABLE (by definition)\n *\n * Note: These macros are called both by Simulink and the generated code\n */\n\n/* sr stands for SystemRan, BC stands for BreadCrumb */\n#define srClearBC(state)                                                      \\\n    {                                                                         \\\n        SubSystemRanBCTransition prevState = (SubSystemRanBCTransition)state; \\\n        SubSystemRanBCTransition newState = SUBSYS_RAN_BC_DISABLE;            \\\n                                                                              \\\n        switch (prevState) {                                                  \\\n        case SUBSYS_RAN_BC_DISABLE:                                           \\\n            newState = SUBSYS_RAN_BC_DISABLE;                                 \\\n            break;                                                            \\\n        case SUBSYS_RAN_BC_ENABLE:                                            \\\n            newState = SUBSYS_RAN_BC_ENABLE_TO_DISABLE;                       \\\n            break;                                                            \\\n        case SUBSYS_RAN_BC_DISABLE_TO_ENABLE:                                 \\\n            newState = SUBSYS_RAN_BC_ENABLE_TO_DISABLE;                       \\\n            break;                                                            \\\n        case SUBSYS_RAN_BC_ENABLE_TO_DISABLE:                                 \\\n            newState = SUBSYS_RAN_BC_DISABLE;                                 \\\n            break;                                                            \\\n        case SUBSYS_RAN_BC_ONE_SHOT:                                          \\\n            newState = SUBSYS_RAN_BC_DISABLE;                                 \\\n            break;                                                            \\\n        }                                                                     \\\n        state = newState;                                                     \\\n    }\n\n/*\n * Update macro\n *\n * Called by the OutputFcn of all conditionally exec'd subsystems\n * from subsystm.cpp and commonbodlib.tlc\n *\n * DISABLE           -> DISABLE_ENABLE (new enable)\n * ENABLE_TO_DISABLE -> ENABLE (must have run last time step)\n * All other state   -> should really be an assert\n *\n */\n/* sr stands for SystemRan, BC stands for BreadCrumb */\n#define srUpdateBC(state)                                                     \\\n    {                                                                         \\\n        SubSystemRanBCTransition prevState = (SubSystemRanBCTransition)state; \\\n        SubSystemRanBCTransition newState = prevState;                        \\\n                                                                              \\\n        switch (prevState) {                                                  \\\n        case SUBSYS_RAN_BC_DISABLE:                                           \\\n            newState = SUBSYS_RAN_BC_DISABLE_TO_ENABLE;                       \\\n            break;                                                            \\\n        case SUBSYS_RAN_BC_ENABLE_TO_DISABLE:                                 \\\n            newState = SUBSYS_RAN_BC_ENABLE;                                  \\\n            break;                                                            \\\n        case SUBSYS_RAN_BC_ENABLE:                                            \\\n        case SUBSYS_RAN_BC_DISABLE_TO_ENABLE:                                 \\\n        case SUBSYS_RAN_BC_ONE_SHOT:                                          \\\n            break;                                                            \\\n        }                                                                     \\\n        state = newState;                                                     \\\n    }\n\n#endif /* SIMSTRUCT_SYSRAN_TYPES_H */\n\n/* EOF sysran_types.h */\n\n/* LocalWords:  sr exec'd subsystm commonbodlib\n */\n"},{"name":"tmwtypes.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\extern\\include","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1984-2018 The MathWorks, Inc.\n */\n\n#if defined(_MSC_VER)\n# pragma once\n#endif\n#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))\n# pragma once\n#endif\n\n#ifndef tmwtypes_h\n#define tmwtypes_h\n\n#ifndef __TMWTYPES__\n#define __TMWTYPES__\n/*\n * File    : tmwtypes.h\n * Abstract:\n *      Data types for use with MATLAB/SIMULINK and the Real-Time Workshop.\n *\n *      When compiling stand-alone model code, data types can be overridden\n *      via compiler switches.\n *\n *      Define NO_FLOATS to eliminate reference to real_T, etc.\n */\n\n#ifdef MW_LIBTOOLING\n#include \"mwstdint.h\"\n#endif\n\n#include <limits.h>\n\n/* __STDC_VERSION__ version check below means \"check for a C99 compiler\".\n\n   Visual Studio (checked on versions 2015 and 2017) does\n   not define __STDC_VERSION__, however  it has stdbool.h available,\n   thus a separate check for _MSC_VER below.\n */\n#if defined(__APPLE_CC__) \\\n    || (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) \\\n    || (defined(_MSC_VER) && (_MSC_VER >= 1900))\n#ifndef tmwtypes_do_not_include_stdbool\n#include <stdbool.h>\n#endif\n#endif\n\n#define LOGICAL_IS_A_TYPE\n#define SPARSE_GENERALIZATION\n\n#ifdef NO_FLOATS\n# define double double_not_allowed\n# define float  float_not_allowed\n#endif /*NO_FLOATS*/\n\n#ifndef NO_FLOATS\n\n#ifndef __MWERKS__\n# ifdef __STDC__\n#  include <float.h>\n# else\n#  ifndef FLT_MANT_DIG\n#   define FLT_MANT_DIG 24\n#  endif\n#  ifndef DBL_MANT_DIG\n#   define DBL_MANT_DIG 53\n#  endif\n# endif\n#endif\n\n#endif /*NO_FLOATS*/\n\n/*\n *      The following data types cannot be overridden when building MEX files.\n */\n#ifdef MATLAB_MEX_FILE\n# undef CHARACTER_T\n# undef INTEGER_T\n# undef BOOLEAN_T\n# undef REAL_T\n# undef TIME_T\n#endif\n\n/*\n * The uchar_T, ushort_T and ulong_T types are needed for compilers which do \n * not allow defines to be specified, at the command line, with spaces in them.\n */\n\ntypedef unsigned char       uchar_T;\ntypedef unsigned short      ushort_T;\ntypedef unsigned long       ulong_T;\n\n#if (defined(_MSC_VER) && _MSC_VER >= 1500)      \\\n    || defined(__x86_64__) || defined(__LP64__)  \\\n    || defined(__LCC64__)\n    \ntypedef unsigned long long  ulonglong_T;\n#endif\n\n\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\n\n/* When used with Real Time Workshop generated code, this\n * header file can be used with a variety of compilers.\n *\n * The compiler could be for an 8 bit embedded processor that\n * only had 8 bits per integer and 16 bits per long.\n * In that example, a 32 bit integer size is not even available.\n * This header file should be robust to that.   \n *\n * For the case of an 8 bit processor, the preprocessor\n * may be limited to 16 bit math like its target.  That limitation \n * would mean that 32 bit comparisons can't be done accurately.  \n * To increase robustness to this, comparisons are done against\n * smaller values first.  An inaccurate 32 bit comparison isn't\n * attempted if the 16 bit comparison has already succeeded.\n *\n * Limitations on preprocessor math can also be stricter than\n * for the target.  There are known cases where a compiler\n * targeting processors with 64 bit longs can't do accurate\n * preprocessor comparisons on more than 32 bits.  \n */\n\n/* Determine the number of bits for int, long, short, and char.\n * If one fails to be determined, set the number of bits to -1\n */\n\n#ifndef TMW_BITS_PER_INT\n# if   INT_MAX  == 0x7FL\n#  define TMW_BITS_PER_INT 8\n# elif INT_MAX  == 0x7FFFL\n#  define TMW_BITS_PER_INT 16\n# elif INT_MAX  == 0x7FFFFFFFL\n#  define TMW_BITS_PER_INT 32\n# else\n#  define TMW_BITS_PER_INT -1\n# endif\n#endif\n\n#ifndef TMW_BITS_PER_LONG\n# if   LONG_MAX  == 0x7FL\n#  define TMW_BITS_PER_LONG 8\n# elif LONG_MAX  == 0x7FFFL\n#  define TMW_BITS_PER_LONG 16\n# elif LONG_MAX  == 0x7FFFFFFFL\n#  define TMW_BITS_PER_LONG 32\n# else\n#  define TMW_BITS_PER_LONG -1\n# endif\n#endif\n\n#ifndef TMW_BITS_PER_SHRT\n# if   SHRT_MAX  == 0x7FL\n#  define TMW_BITS_PER_SHRT 8\n# elif SHRT_MAX  == 0x7FFFL\n#  define TMW_BITS_PER_SHRT 16\n# elif SHRT_MAX  == 0x7FFFFFFFL\n#  define TMW_BITS_PER_SHRT 32\n# else\n#  define TMW_BITS_PER_SHRT -1\n# endif\n#endif\n\n#ifndef TMW_BITS_PER_SCHAR\n# if   SCHAR_MAX  == 0x7FL\n#  define TMW_BITS_PER_SCHAR 8\n# elif SCHAR_MAX  == 0x7FFFL\n#  define TMW_BITS_PER_SCHAR 16\n# elif SCHAR_MAX  == 0x7FFFFFFFL\n#  define TMW_BITS_PER_SCHAR 32\n# else\n#  define TMW_BITS_PER_SCHAR -1\n# endif\n#endif\n\n#ifndef TMW_CHAR_SIGNED\n# if SCHAR_MAX == CHAR_MAX\n#  define TMW_CHAR_SIGNED 1\n# else\n#  define TMW_CHAR_SIGNED 0\n# endif\n#endif\n\n/* It is common for one or more of the integer types\n * to be the same size.  For example, on many embedded\n * processors, both shorts and ints are 16 bits.  On\n * processors used for workstations, it is quite common\n * for both int and long to be 32 bits.  \n *   When there is more than one choice for typdef'ing\n * a portable type like int16_T or uint32_T, in\n * concept, it should not matter which choice is made.\n * However, some style guides and some code checking\n * tools do identify and complain about seemingly\n * irrelevant differences.  For example, a code\n * checking tool may complain about an implicit\n * conversion from int to short even though both\n * are 16 bits.  To reduce these types of\n * complaints, it is best to make int the\n * preferred choice when more than one is available.\n */\n\n#ifndef INT8_T\n# if   defined(MW_LIBTOOLING)\n#  define INT8_T  int8_t\n# elif TMW_BITS_PER_INT   == 8\n#  define  INT8_T int\n# elif TMW_BITS_PER_LONG  == 8\n#  define  INT8_T long\n# elif TMW_BITS_PER_SCHAR == 8\n#  define  INT8_T signed char\n# elif TMW_BITS_PER_SHRT  == 8\n#  define  INT8_T short\n# endif\n#endif\n#ifdef INT8_T\n typedef INT8_T int8_T;\n#endif\n\n#ifndef UINT8_T\n# if   defined(MW_LIBTOOLING)\n#  define  UINT8_T uint8_t\n# elif   TMW_BITS_PER_INT   == 8\n#  define  UINT8_T unsigned int\n# elif TMW_BITS_PER_LONG  == 8\n#  define  UINT8_T unsigned long\n# elif TMW_BITS_PER_SCHAR == 8\n#  define  UINT8_T unsigned char\n# elif TMW_BITS_PER_SHRT  == 8\n#  define  UINT8_T unsigned short\n# endif\n#endif\n#ifdef UINT8_T\n typedef UINT8_T uint8_T;\n#endif\n\n\n#ifndef INT16_T\n# if   defined(MW_LIBTOOLING)\n#  define  INT16_T int16_t\n# elif   TMW_BITS_PER_INT   == 16\n#  define  INT16_T int\n# elif TMW_BITS_PER_LONG  == 16\n#  define  INT16_T long\n# elif TMW_BITS_PER_SCHAR == 16\n#  define  INT16_T signed char\n# elif TMW_BITS_PER_SHRT  == 16\n#  define  INT16_T short\n# endif\n#endif\n#ifdef INT16_T\n typedef INT16_T int16_T;\n#endif\n\n\n#ifndef UINT16_T\n# if   defined(MW_LIBTOOLING)\n#  define  UINT16_T uint16_t\n# elif TMW_BITS_PER_INT   == 16\n#  define  UINT16_T unsigned int\n# elif TMW_BITS_PER_LONG  == 16\n#  define  UINT16_T unsigned long\n# elif TMW_BITS_PER_SCHAR == 16\n#  define  UINT16_T unsigned char\n# elif TMW_BITS_PER_SHRT  == 16\n#  define  UINT16_T unsigned short\n# endif\n#endif\n#ifdef UINT16_T\n typedef UINT16_T uint16_T;\n#endif\n\n\n#ifndef INT32_T\n# if   defined(MW_LIBTOOLING)\n#  define  INT32_T int32_t\n# elif TMW_BITS_PER_INT   == 32\n#  define  INT32_T int\n# elif TMW_BITS_PER_LONG  == 32\n#  define  INT32_T long\n# elif TMW_BITS_PER_SCHAR == 32\n#  define  INT32_T signed char\n# elif TMW_BITS_PER_SHRT  == 32\n#  define  INT32_T short\n# endif\n#endif\n#ifdef INT32_T\n typedef INT32_T int32_T;\n#endif\n\n\n#ifndef UINT32_T\n# if   defined(MW_LIBTOOLING)\n#  define  UINT32_T uint32_t\n# elif TMW_BITS_PER_INT   == 32\n#  define  UINT32_T unsigned int\n# elif TMW_BITS_PER_LONG  == 32\n#  define  UINT32_T unsigned long\n# elif TMW_BITS_PER_SCHAR == 32\n#   define UINT32_T unsigned char\n# elif TMW_BITS_PER_SHRT  == 32\n#  define  UINT32_T unsigned short\n# endif\n#endif\n#ifdef UINT32_T\n typedef UINT32_T uint32_T;\n#endif\n\n/* The following is used to emulate smaller integer types when only\n * larger types are available.  For example, compilers for TI C3x/C4x DSPs \n * define char and short to be 32 bits, so 8 and 16 bits are not directly\n * available.  This target is commonly used with RTW rapid prototyping.\n * Other DSPs define char to be 16 bits, so 8 bits is not directly \n * available.\n */\n#ifndef INT8_T\n# ifdef INT16_T\n#  define INT8_T INT16_T\n   typedef INT8_T int8_T;\n# else\n#  ifdef INT32_T\n#   define INT8_T INT32_T\n    typedef INT8_T int8_T;\n#  endif\n# endif\n#endif\n\n#ifndef UINT8_T\n# ifdef UINT16_T\n#   define UINT8_T UINT16_T\n    typedef UINT8_T uint8_T;\n# else\n#  ifdef UINT32_T\n#   define UINT8_T UINT32_T\n    typedef UINT8_T uint8_T;\n#  endif\n# endif\n#endif\n\n#ifndef INT16_T\n# ifdef INT32_T\n#   define INT16_T INT32_T\n    typedef INT16_T int16_T;\n# endif\n#endif\n\n#ifndef UINT16_T\n# ifdef UINT32_T\n#   define UINT16_T UINT32_T\n    typedef UINT16_T uint16_T;\n# endif\n#endif\n\n\n#ifndef NO_FLOATS\n\n#ifndef REAL32_T\n# ifndef __MWERKS__\n#  if FLT_MANT_DIG >= 23\n#   define REAL32_T float\n#  endif\n# else\n#  define REAL32_T float\n# endif\n#endif\n#ifdef REAL32_T\n typedef REAL32_T real32_T;\n#endif\n\n\n#ifndef REAL64_T\n# ifndef __MWERKS__\n#  if DBL_MANT_DIG >= 52\n#   define REAL64_T double\n#  endif\n# else\n#  define REAL64_T double\n# endif\n#endif\n#ifdef REAL64_T\n typedef REAL64_T real64_T;\n#endif\n\n#endif /* NO_FLOATS*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int64_T                      - signed 64 bit integers               *\n *   uint64_T                     - unsigned 64 bit integers             *\n *=======================================================================*/\n\n# if   defined(MW_LIBTOOLING)\n#  ifdef INT64_T\n#    undef  INT64_T\n#  endif\n#  define  INT64_T int64_t\n#  ifdef UINT64_T\n#    undef  UINT64_T\n#  endif\n#  define  UINT64_T uint64_t\n# endif\n#if !defined(INT64_T) || !defined(UINT64_T) || !defined(FMT64)\n# if defined(__APPLE__) || defined(__clang__)\n#  ifndef INT64_T\n#   define INT64_T long long\n#  endif\n#  ifndef UINT64_T\n#   define UINT64_T unsigned long long\n#  endif\n#  ifndef FMT64\n#   define FMT64 \"ll\"\n#  endif\n#  if defined(__LP64__) && !defined(INT_TYPE_64_IS_LONG)\n#    define INT_TYPE_64_IS_LONG\n#  endif\n# elif (defined(__x86_64__) || defined(__LP64__))&& !defined(__MINGW64__) \n#  ifndef INT64_T\n#   define INT64_T long\n#  endif\n#  ifndef UINT64_T\n#   define UINT64_T unsigned long\n#  endif\n#  ifndef FMT64\n#   define FMT64 \"l\"\n#  endif\n#  if !defined(INT_TYPE_64_IS_LONG)\n#    define INT_TYPE_64_IS_LONG\n#  endif\n# elif defined(_MSC_VER) || (defined(__BORLANDC__) && __BORLANDC__ >= 0x530) \\\n                         || (defined(__WATCOMC__)  && __WATCOMC__  >= 1100)\n#  ifndef INT64_T\n#   define INT64_T __int64\n#  endif\n#  ifndef UINT64_T\n#   define UINT64_T unsigned __int64\n#  endif\n#  ifndef FMT64\n#   define FMT64 \"I64\"\n#  endif\n# elif defined(__GNUC__) || defined(TMW_ENABLE_INT64) \\\n                         || defined(__LCC64__)\n#  ifndef INT64_T\n#   define INT64_T long long\n#  endif\n#  ifndef UINT64_T\n#   define UINT64_T unsigned long long\n#  endif\n#  ifndef FMT64\n#   define FMT64 \"ll\"\n#  endif\n# endif\n\n#endif\n\n#if defined(INT64_T)\n# if defined(__GNUC__) && \\\n    ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ >=9)))\n  __extension__\n# endif\n typedef INT64_T int64_T;\n#endif\n\n#if defined(_WIN64) || (defined(__APPLE__) && defined(__LP64__)) \\\n                    || defined(__x86_64__) \\\n                    || defined(__LP64__)\n#  define INT_TYPE_64_IS_SUPPORTED\n#endif\n\n#if defined(UINT64_T)\n# if defined(__GNUC__) && \\\n    ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ >=9)))\n  __extension__\n# endif\n typedef UINT64_T uint64_T;\n#endif\n\n/*===========================================================================*\n * Format string modifiers for using size_t variables in printf statements.  *\n *===========================================================================*/\n\n#ifndef FMT_SIZE_T\n#  if (defined( __GNUC__ ) || defined(_STDC_C99))&& !defined(__MINGW64__)\n#    define FMT_SIZE_T \"z\"\n#  elif defined (__WATCOMC__)\n#    define FMT_SIZE_T \"l\"\n#  elif defined (_WIN32 )\n#    define FMT_SIZE_T \"I\"\n#  else\n#    define FMT_SIZE_T \"l\"\n#  endif\n#endif\n\n#ifndef FMT_PTRDIFF_T\n#  if defined(__APPLE__)\n#    define FMT_PTRDIFF_T \"l\"\n#  elif defined( __GNUC__ ) || defined(_STDC_C99)\n#    define FMT_PTRDIFF_T \"t\"\n#  elif defined (__WATCOMC__)\n#    define FMT_PTRDIFF_T \"l\"\n#  elif defined (_WIN32 )\n#    define FMT_PTRDIFF_T \"I\"\n#  else\n#    define FMT_PTRDIFF_T \"l\"\n#  endif\n#endif\n\n/*===========================================================================*\n * General or logical data types where the word size is not guaranteed.      *\n *  real_T     - possible settings include real32_T or real64_T              *\n *  time_T     - possible settings include real32_T or real64_T              *\n *  boolean_T                                                                *\n *  char_T                                                                   *\n *  int_T                                                                    *\n *  uint_T                                                                   *\n *  byte_T                                                                   *\n *===========================================================================*/\n\n#ifndef NO_FLOATS\n\n#ifndef REAL_T\n# ifdef REAL64_T\n#  define REAL_T real64_T\n# else\n#  ifdef REAL32_T\n#   define REAL_T real32_T\n#  endif\n# endif\n#endif\n#ifdef REAL_T\n typedef REAL_T real_T;\n#endif\n\n#ifndef TIME_T\n# ifdef REAL_T\n#  define TIME_T real_T\n# endif\n#endif\n#ifdef TIME_T\n typedef TIME_T time_T;\n#endif\n\n#endif /* NO_FLOATS */\n\n#ifndef BOOLEAN_T\n# if defined(UINT8_T)\n#  define BOOLEAN_T UINT8_T\n# else\n#  define BOOLEAN_T unsigned int\n# endif\n#endif\ntypedef BOOLEAN_T boolean_T;\n\n\n#ifndef CHARACTER_T\n# define CHARACTER_T char\n#endif\ntypedef CHARACTER_T char_T;\n\n\n#ifndef INTEGER_T\n# define INTEGER_T int\n#endif\ntypedef INTEGER_T int_T;\n\n\n#ifndef UINTEGER_T\n# define UINTEGER_T unsigned\n#endif\ntypedef UINTEGER_T uint_T;\n\n\n#ifndef BYTE_T\n# define BYTE_T unsigned char\n#endif\ntypedef BYTE_T byte_T;\n\n\n/*===========================================================================*\n * Define Complex Structures                                                 *\n *===========================================================================*/\n#ifndef NO_FLOATS\n\n#ifndef CREAL32_T\n#  ifdef REAL32_T\n    typedef struct {\n      real32_T re, im;\n    } creal32_T;\n#    define CREAL32_T creal32_T\n#  endif\n#endif\n\n#ifndef CREAL64_T\n#  ifdef REAL64_T\n    typedef struct {\n      real64_T re, im;\n    } creal64_T;\n#    define CREAL64_T creal64_T\n#  endif\n#endif\n\n#ifndef CREAL_T\n#  ifdef REAL_T\n    typedef struct {\n      real_T re, im;\n    } creal_T;\n#    define CREAL_T creal_T\n#  endif\n#endif\n\n#endif /* NO_FLOATS */\n\n#ifndef CINT8_T\n#  ifdef INT8_T\n    typedef struct {\n      int8_T re, im;\n    } cint8_T;\n#    define CINT8_T cint8_T\n#  endif\n#endif\n\n#ifndef CUINT8_T\n#  ifdef UINT8_T\n    typedef struct {\n      uint8_T re, im;\n    } cuint8_T;\n#    define CUINT8_T cuint8_T\n#  endif\n#endif\n\n#ifndef CINT16_T\n#  ifdef INT16_T\n    typedef struct {\n      int16_T re, im;\n    } cint16_T;\n#    define CINT16_T cint16_T\n#  endif\n#endif\n\n#ifndef CUINT16_T\n#  ifdef UINT16_T\n    typedef struct {\n      uint16_T re, im;\n    } cuint16_T;\n#    define CUINT16_T cuint16_T\n#  endif\n#endif\n\n#ifndef CINT32_T\n#  ifdef INT32_T\n    typedef struct {\n      int32_T re, im;\n    } cint32_T;\n#    define CINT32_T cint32_T\n#  endif\n#endif\n\n#ifndef CUINT32_T\n#  ifdef UINT32_T\n    typedef struct {\n      uint32_T re, im;\n    } cuint32_T;\n#    define CUINT32_T cuint32_T\n#  endif\n#endif\n\n#ifndef CINT64_T\n#  ifdef INT64_T\n    typedef struct {\n      int64_T re, im;\n    } cint64_T;\n#    define CINT64_T cint64_T\n#  endif\n#endif\n\n#ifndef CUINT64_T\n#  ifdef UINT64_T\n    typedef struct {\n      uint64_T re, im;\n    } cuint64_T;\n#    define CUINT64_T cuint64_T\n#  endif\n#endif\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n\n#define  MAX_int8_T      ((int8_T)(127))            /* 127  */\n#define  MIN_int8_T      ((int8_T)(-128))           /* -128 */\n#define  MAX_uint8_T     ((uint8_T)(255))           /* 255  */\n#define  MIN_uint8_T     ((uint8_T)(0))\n                           \n#define  MAX_int16_T     ((int16_T)(32767))         /* 32767 */\n#define  MIN_int16_T     ((int16_T)(-32768))        /* -32768 */\n#define  MAX_uint16_T    ((uint16_T)(65535))        /* 65535 */\n#define  MIN_uint16_T    ((uint16_T)(0))\n                           \n#define  MAX_int32_T     ((int32_T)(2147483647))    /* 2147483647  */\n#define  MIN_int32_T     ((int32_T)(-2147483647-1)) /* -2147483648 */\n#define  MAX_uint32_T    ((uint32_T)(0xFFFFFFFFU))  /* 4294967295  */\n#define  MIN_uint32_T    ((uint32_T)(0))\n\n#if defined(_MSC_VER) || (defined(__BORLANDC__) && __BORLANDC__ >= 0x530) \\\n                      || (defined(__WATCOMC__)  && __WATCOMC__  >= 1100) \\\n                      || defined(__LCC64__)\n#  ifdef INT64_T\n#    define  MAX_int64_T     ((int64_T)(9223372036854775807LL))\n#    define  MIN_int64_T     ((int64_T)(-9223372036854775807LL-1LL))\n#  endif\n#  ifdef UINT64_T\n#    define  MAX_uint64_T    ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\n#    define  MIN_uint64_T    ((uint64_T)(0))\n#  endif\n#else\n#  ifdef INT64_T\n#    ifdef INT_TYPE_64_IS_LONG\n#      define  MAX_int64_T     ((int64_T)(9223372036854775807L))\n#      define  MIN_int64_T     ((int64_T)(-9223372036854775807L-1L))\n#    else\n#      define  MAX_int64_T     ((int64_T)(9223372036854775807LL))\n#      define  MIN_int64_T     ((int64_T)(-9223372036854775807LL-1LL))\n#    endif\n#  endif\n#  ifdef UINT64_T\n#    ifdef INT_TYPE_64_IS_LONG\n#      define  MAX_uint64_T    ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n#      define  MIN_uint64_T    ((uint64_T)(0))\n#    else\n#      define  MAX_uint64_T    ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\n#      define  MIN_uint64_T    ((uint64_T)(0))\n#    endif\n#  endif\n#endif\n\n#if (defined(_MSC_VER) && !defined(__clang__))\n\n/* Conversion from unsigned __int64 to double is not implemented in Visual Studio\n * and results in a compile error, thus the value must first be cast to\n * signed __int64, and then to double.\n *\n * If the 64 bit int value is greater than 2^63-1, which is the signed int64 max,\n * the macro below provides a workaround for casting a uint64 value to a double\n * in windows.\n */\n#  define uint64_to_double(u) ( ((u) > _I64_MAX) ? \\\n            (double)(__int64)((u) - _I64_MAX - 1) + (double)_I64_MAX + 1: \\\n            (double)(__int64)(u) )\n\n/* The following inline function should only be used in the macro double_to_uint64,\n * as it only handles the specfic range of double between 2^63 and 2^64-1 */\n__forceinline\nuint64_T double_to_uint64_helper(double d) {\n  union double_to_uint64_union_type {\n    double dd;\n    uint64_T i64;\n  } di;\n  di.dd = d;\n  return (((di.i64 & 0x000fffffffffffff) | 0x0010000000000000) << 11);\n}\n\n/* The largest double value that can be cast to uint64 in windows is the\n * signed int64 max, which is 2^63-1. The macro below provides\n * a workaround for casting large double values to uint64 in windows.\n */\n/* The magic number 18446744073709551616.0 is 2^64 */\n/* The magic number 9223372036854775808.0 is 2^63 */\n#  define double_to_uint64(d) ( ((d) >= 18446744073709551616.0) ? \\\n            0xffffffffffffffffULL : \\\n            ((d) >= 0.0) ? \\\n            ((d) >= 9223372036854775808.0) ? \\\n            double_to_uint64_helper(d) : \\\n            (unsigned __int64)(d) : \\\n            0ULL )\n#else\n#  define uint64_to_double(u) ((double)(u))\n#  if defined(__BORLANDC__) || defined(__WATCOMC__) || defined(__TICCSC__)\n/* double_to_uint64 defined only for MSVC and UNIX */\n#  else\n#  define double_to_uint64(d) ( ((d) >= 18446744073709551616.0) ? \\\n            (unsigned long long) 0xffffffffffffffffULL : \\\n            ((d) >= 0) ? (unsigned long long)(d) : (unsigned long long) 0 )\n#  endif\n#endif\n\n#if !defined(__cplusplus) && !defined(__bool_true_false_are_defined)\n\n#ifndef _bool_T\n#define _bool_T\n\ntypedef boolean_T bool;\n\n#ifndef false\n#define false (0)\n#endif\n#ifndef true \n#define true (1)\n#endif\n\n#endif /* _bool_T */\n\n#endif /* !__cplusplus */\n\n/* \n * This software assumes that the code is being compiled on a target using a \n * 2's complement representation for signed integer values.\n */\n#if ((SCHAR_MIN + 1) != -SCHAR_MAX)\n#error \"This code must be compiled using a 2's complement representation for signed integer values\"\n#endif\n\n/*\n * Maximum length of a MATLAB identifier (function/variable/model)\n * including the null-termination character.\n */\n#define TMW_NAME_LENGTH_MAX 64\n\n/*\n * Maximum values for indices and dimensions\n */\n#include <stddef.h>\n\n#ifdef MX_COMPAT_32\ntypedef int mwSize;\ntypedef int mwIndex;\ntypedef int mwSignedIndex;\n#else\ntypedef size_t    mwSize;         /* unsigned pointer-width integer */\ntypedef size_t    mwIndex;        /* unsigned pointer-width integer */\ntypedef ptrdiff_t mwSignedIndex;  /* a signed pointer-width integer */\n#endif\n\n                                  /* for the individual dim */\n/* If updating SLSize or SLIndex, update defintions in sl_types_def.h\n   as well. */\n#ifndef SLSIZE_SLINDEX\n  #define SLSIZE_SLINDEX\n  #ifdef INT_TYPE_64_IS_SUPPORTED\n    typedef int64_T SLIndex;\n    typedef int64_T SLSize;\n  #else\n    typedef int SLIndex;\n    typedef int SLSize;\n  #endif\n#endif\n\n/* for the total size */\n#define SLIndexType size_t\n#define INVALID_SIZET_VALUE   (std::numeric_limits<SLIndexType>::max())\n#define MAX_VALID_SIZET_VALUE   (std::numeric_limits<SLIndexType>::max() -1)\n\n\n#if (defined(_LP64) || defined(_WIN64)) && !defined(MX_COMPAT_32)\n/* Currently 2^48 based on hardware limitations */\n# define MWSIZE_MAX    281474976710655UL\n# define MWINDEX_MAX   281474976710655UL\n# define MWSINDEX_MAX  281474976710655L\n# define MWSINDEX_MIN -281474976710655L\n#else\n# define MWSIZE_MAX    2147483647UL\n# define MWINDEX_MAX   2147483647UL\n# define MWSINDEX_MAX  2147483647L\n# define MWSINDEX_MIN -2147483647L\n#endif\n#define MWSIZE_MIN    0UL\n#define MWINDEX_MIN   0UL\n\n/** UTF-16 character type */\n\n#if (defined(__cplusplus) && (__cplusplus >= 201103L)) || (defined(_HAS_CHAR16_T_LANGUAGE_SUPPORT) && _HAS_CHAR16_T_LANGUAGE_SUPPORT)\ntypedef char16_t CHAR16_T;\n#define U16_STRING_LITERAL_PREFIX u\n#elif defined(_MSC_VER)\ntypedef wchar_t CHAR16_T;\n#define U16_STRING_LITERAL_PREFIX L\n#else\ntypedef UINT16_T CHAR16_T;\n#endif\n\n#endif  /* __TMWTYPES__ */\n\n#endif /* tmwtypes_h */\n"},{"name":"updown.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/* \n * Copyright 1994-2008 The MathWorks, Inc.\n */\n#ifndef updown_h\n#define updown_h\n\n#include \"upsup_public.h\"\n\n#define NUM_UPINFOS   2 /* Number of UploadLogInfos in use */\n\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\nextern void      SetParam(RTWExtModeInfo  *ei,\n                          const char      *pbuf);\n\nextern void      UploadLogInfoReset(int32_T upInfoIdx);\n\nextern void      UploadPrepareForFinalFlush(int32_T upInfoIdx);\n\nextern void      UploadLogInfoTerm(int32_T upInfoIdx,\n                                   int_T   numSampTimes);\n\nextern boolean_T UploadLogInfoInit(RTWExtModeInfo *ei,\n                                   int_T          numSampTimes,\n                                   const char     *pkt,\n                                   int32_T        upInfoIdx);\n\nextern boolean_T UploadInitTrigger(RTWExtModeInfo *ei, \n                                   const char     *pkt,\n                                   int32_T        upInfoIdx);\n\nextern void      UploadArmTrigger(int32_T upInfoIdx,\n                                  int_T   numSampTimes);\n\nextern void      UploadEndLoggingSession(int32_T upInfoIdx,\n                                         int_T   numSampTimes);\n\nextern void      UploadCancelLogging(int32_T upInfoIdx);\n\nextern void      UploadBufDataSent(const int_T tid,\n                                   int32_T     upInfoIdx);\n\nextern void      UploadBufAddTimePoint(int_T   tid,\n                                       real_T  taskTime,\n                                       int32_T upInfoIdx);\n\nextern void      UploadCheckTrigger(int32_T upInfoIdx,\n                                    int_T   numSampTimes);\n\nextern void      UploadCheckEndTrigger(int32_T upInfoIdx);\n\nextern void      UploadBufGetData(ExtBufMemList *extBufList,\n                                  int32_T       upInfoIdx,\n                                  int_T         numSampTimes);\n\nextern boolean_T IsAnyDataReadyForUpload(int32_T upInfoIdx);\n\n#ifdef __cplusplus\n\n}\n#endif\n\n#endif /* updown_h */\n"},{"name":"updown_util.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"#ifndef __UPDOWN_UTIL__\n#define __UPDOWN_UTIL__\n\n/*\n * Copyright 1994-2002 The MathWorks, Inc.\n *\n * File    : updown_util.h\n * Abstract:\n *  'assert' support for external MATLAB files.\n */\n\n/*\n * Set ASSERTS_ON to 1 turn asserts on, 0 otherwise.\n */\n#define ASSERTS_ON (0)\n\n/*------------------------------------------------------------------------------\n * Do not modify below this line.\n *----------------------------------------------------------------------------*/\n#if ASSERTS_ON\n#include <assert.h>\n#else\n#define assert(dum) /* do nothing */\n#endif\n\n#ifdef VERBOSE\n# define PRINT_VERBOSE(args) (void)printf args\n#else\n#define PRINT_VERBOSE(args) /* do nothing */\n#endif\n\n#endif /* __UPDOWN_UTIL__ */\n"},{"name":"upsup_public.h","type":"header","group":"other","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/* \n * Copyright 1994-2002 The MathWorks, Inc.\n */\n#ifndef upsup_public_h\n#define upsup_public_h\n\n/*\n * Maps out a section of a circular buffer.  When the buffer is not\n * wrapped, only section 1 is required.  When the buffer is wrapped\n * both sections are required.\n */\ntypedef struct BufMem_tag {\n    int_T   nBytes1;    /* nbytes in sections 1          */\n    char_T  *section1;  /* ptr to start of section 1     */\n\n    int_T   nBytes2;    /* nbytes in section 2 (0 if not wrapped)          */\n    char_T  *section2;  /* ptr to start of section 2 (NULL if not wrapped) */\n} BufMem;\n\n\n\n/*\n * For each of nActiveBufs (buffers with data in them) we have a list of\n * the buffer memory (bufs) and a list of the tid's with which this buffer\n * is associated.\n */\ntypedef struct ExtBufMemList_tag {\n    int_T        nActiveBufs; /* num bufs with data to upload */\n\n    const BufMem *bufs; /* sections of each buffer for uploading */\n    const int_T  *tids; /* tid associated with each section      */\n} ExtBufMemList; \n\ntypedef struct BdUploadInfo_tag BdUploadInfo;\n\n#endif /* upsup_public_h */\n"},{"name":"waijung2_hwdrvlib.c","type":"source","group":"","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: waijung2_hwdrvlib.c\r\n *\r\n * Code generated with Waijung 2 ESP32 Target Blockset,\r\n * for Simulink model 'esp32_adc_demo'.\r\n *\r\n * Model version                  : 8.0\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Mon Aug 29 16:38:05 2022\r\n *\r\n * Target selection: esp32.tlc\r\n * Embedded hardware selection: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"esp32_adc_demo.h\"            /* Model's header file */\r\n\r\n/************* GPIO Output Initialize Function: DigitalOut *************/\r\nvoid GPIO_initialize_DigitalOut()\r\n{\r\n  /*gpio_config_t io_conf;\r\n     io_conf.pin_bit_mask = ((1ULL<<2));            // Select pins\r\n     io_conf.mode = GPIO_MODE_OUTPUT;                     // Pins mode\r\n     io_conf.intr_type = GPIO_INTR_DISABLE;          // Disable interrupt\r\n     io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE; \t// Disable pull-down mode\r\n     io_conf.pull_up_en = GPIO_PULLUP_DISABLE;\t\t// Disable pull-up mode\r\n     gpio_config(&io_conf);*/\r\n  gpio_pad_select_gpio(2);\r\n  gpio_set_direction(2, GPIO_MODE_OUTPUT);\r\n  gpio_set_drive_capability(GPIO_NUM_2, GPIO_DRIVE_CAP_2);\r\n}\r\n\r\n/************* GPIO Output Initialize Function: DigitalOut1 *************/\r\nvoid GPIO_initialize_DigitalOut1()\r\n{\r\n  /*gpio_config_t io_conf;\r\n     io_conf.pin_bit_mask = ((1ULL<<12));            // Select pins\r\n     io_conf.mode = GPIO_MODE_OUTPUT_OD;                     // Pins mode\r\n     io_conf.intr_type = GPIO_INTR_DISABLE;          // Disable interrupt\r\n     io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE; \t// Disable pull-down mode\r\n     io_conf.pull_up_en = GPIO_PULLUP_DISABLE;\t\t// Disable pull-up mode\r\n     gpio_config(&io_conf);*/\r\n  gpio_pad_select_gpio(12);\r\n  gpio_set_direction(12, GPIO_MODE_OUTPUT_OD);\r\n  gpio_set_drive_capability(GPIO_NUM_12, GPIO_DRIVE_CAP_2);\r\n}\r\n\r\n/* [EOF] */\r\n"},{"name":"waijung2_hwdrvlib.h","type":"header","group":"","path":"C:\\Users\\oak07\\Documents\\Vichatirawruk\\adc_demo\\esp32_adc_demo_esp32","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: waijung2_hwdrvlib.h\r\n *\r\n * Code generated with Waijung 2 ESP32 Target Blockset,\r\n * for Simulink model 'esp32_adc_demo'.\r\n *\r\n * Model version                  : 8.0\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Mon Aug 29 16:38:05 2022\r\n *\r\n * Target selection: esp32.tlc\r\n * Embedded hardware selection: Cadence Design Systems (Tensilica)->Xtensa® single-/dual-core 32-bit LX6 microprocessor\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_waijung2_hwdrvlib_h_\r\n#define RTW_HEADER_waijung2_hwdrvlib_h_\r\n\r\n/* ESP32 headers */\r\n#include \"freertos/FreeRTOS.h\"\r\n#include \"freertos/task.h\"\r\n#include \"esp_system.h\"\r\n#include \"esp_spi_flash.h\"\r\n#include \"soc/timer_group_struct.h\"\r\n#include \"soc/timer_group_reg.h\"\r\n#include \"freertos/semphr.h\"\r\n#include \"esp_err.h\"\r\n#include \"esp_log.h\"\r\n#include <stdio.h>\r\n#include <stdint.h>\r\n#include <stddef.h>\r\n#include \"driver/adc.h\"\r\n#include \"driver/gpio.h\"\r\n#define BASE_SAMPLE_TIME               0.2                       /* Base sample time in second */\r\n\r\nvoid GPIO_initialize_DigitalOut();\r\nvoid GPIO_initialize_DigitalOut1();\r\n\r\n#endif                                 /* RTW_HEADER_waijung2_hwdrvlib_h_ */\r\n\r\n/* [EOF] */\r\n"}],"trace":"{\"model\":\"esp32_adc_demo\",\"sources\":[\"esp32_adc_demo.c\",\"esp32_adc_demo.h\"],\"categoricalProps\":[\"ModelElemCategory\",\"StorageClass\"],\"categoricalValues\":[\"InternalData\",\"Default\"],\"sidPrefixes\":[\"esp32_adc_demo\"],\"fileRecords\":{\"1\":{\"records\":[{\"tk\":[44,3,44,10],\"els\":[\"1:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[44,11,44,14],\"els\":[\"1:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[44,14,44,15],\"els\":[\"1:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[45,3,45,12],\"els\":[\"1:4:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[45,13,45,20],\"els\":[\"1:4:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[45,20,45,21],\"els\":[\"1:4:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[46,3,46,12],\"els\":[\"1:13\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[46,13,46,14],\"els\":[\"1:13\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[46,14,46,15],\"els\":[\"1:13\"],\"ct\":{\"1\":1,\"0\":0}}]},\"0\":{\"records\":[{\"tk\":[36,3,36,20],\"els\":[\"0:2\"]},{\"tk\":[36,20,36,21],\"els\":[\"0:2\"]},{\"tk\":[36,21,36,37],\"els\":[\"0:2\"]},{\"tk\":[36,37,36,38],\"els\":[\"0:2\"]},{\"tk\":[36,38,36,39],\"els\":[\"0:2\"]},{\"tk\":[37,3,37,28],\"els\":[\"0:2\"]},{\"tk\":[37,28,37,29],\"els\":[\"0:2\"]},{\"tk\":[37,29,37,43],\"els\":[\"0:2\"]},{\"tk\":[37,43,37,44],\"els\":[\"0:2\"]},{\"tk\":[37,45,37,60],\"els\":[\"0:2\"]},{\"tk\":[37,60,37,61],\"els\":[\"0:2\"]},{\"tk\":[37,61,37,62],\"els\":[\"0:2\"]},{\"tk\":[38,3,38,19],\"els\":[\"0:2\"]},{\"tk\":[38,19,38,20],\"els\":[\"0:2\"]},{\"tk\":[38,20,38,23],\"els\":[\"0:2\"]},{\"tk\":[38,24,38,25],\"els\":[\"0:2\"]},{\"tk\":[38,26,38,38],\"els\":[\"0:2\"]},{\"tk\":[38,38,38,39],\"els\":[\"0:2\"]},{\"tk\":[38,39,38,53],\"els\":[\"0:2\"]},{\"tk\":[38,53,38,54],\"els\":[\"0:2\"]},{\"tk\":[38,54,38,55],\"els\":[\"0:2\"]},{\"tk\":[43,3,43,19],\"els\":[\"0:4:2#out:1\"]},{\"tk\":[43,20,43,27],\"els\":[\"0:4:2#out:1\"]},{\"tk\":[43,28,43,29],\"els\":[\"0:4:2#out:1\",\"0:4:2\"]},{\"tk\":[43,31,43,47],\"els\":[\"0:4:2\"]},{\"tk\":[43,48,43,51],\"els\":[\"0:4:2\"]},{\"tk\":[43,52,43,54],\"els\":[\"0:4:2\"]},{\"tk\":[43,55,43,58],\"els\":[\"0:4:2\",\"0:4:3\"]},{\"tk\":[48,3,48,17],\"els\":[\"0:8\"]},{\"tk\":[48,17,48,18],\"els\":[\"0:8\"]},{\"tk\":[48,18,48,19],\"els\":[\"0:8\"]},{\"tk\":[48,19,48,20],\"els\":[\"0:8\"]},{\"tk\":[48,20,48,21],\"els\":[\"0:8\"]},{\"tk\":[48,21,48,29],\"els\":[\"0:8\"]},{\"tk\":[48,29,48,30],\"els\":[\"0:8\"]},{\"tk\":[48,31,48,47],\"els\":[\"0:8\"]},{\"tk\":[48,47,48,48],\"els\":[\"0:8\"]},{\"tk\":[48,48,48,55],\"els\":[\"0:8\"]},{\"tk\":[48,55,48,56],\"els\":[\"0:8\"]},{\"tk\":[48,56,48,57],\"els\":[\"0:8\"]},{\"tk\":[51,3,51,19],\"els\":[\"0:13::22#out:2\"]},{\"tk\":[51,20,51,21],\"els\":[\"0:13::22#out:2\"]},{\"tk\":[51,22,51,23],\"els\":[\"0:13::22#out:2\",\"0:13:37-45\",\"0:13\",\"0:13::22\",\"0:13:56-65\"]},{\"tk\":[51,25,51,41],\"els\":[\"0:13\",\"0:13::22\"]},{\"tk\":[51,42,51,45],\"els\":[\"0:13\",\"0:13::22\"]},{\"tk\":[51,46,51,48],\"els\":[\"0:13:24-32\",\"0:13\",\"0:13::22\"]},{\"tk\":[51,49,51,52],\"els\":[\"0:13:24-32\",\"0:13\",\"0:13::22\"]},{\"tk\":[56,3,56,17],\"els\":[\"0:14\"]},{\"tk\":[56,17,56,18],\"els\":[\"0:14\"]},{\"tk\":[56,18,56,20],\"els\":[\"0:14\"]},{\"tk\":[56,20,56,21],\"els\":[\"0:14\"]},{\"tk\":[56,21,56,22],\"els\":[\"0:14\"]},{\"tk\":[56,22,56,30],\"els\":[\"0:14\"]},{\"tk\":[56,30,56,31],\"els\":[\"0:14\"]},{\"tk\":[56,32,56,48],\"els\":[\"0:14\"]},{\"tk\":[56,48,56,49],\"els\":[\"0:14\"]},{\"tk\":[56,49,56,50],\"els\":[\"0:14\"]},{\"tk\":[56,50,56,51],\"els\":[\"0:14\"]},{\"tk\":[56,51,56,52],\"els\":[\"0:14\"]},{\"tk\":[87,3,87,29],\"els\":[\"0:8\"]},{\"tk\":[87,29,87,30],\"els\":[\"0:8\"]},{\"tk\":[87,30,87,31],\"els\":[\"0:8\"]},{\"tk\":[87,31,87,32],\"els\":[\"0:8\"]},{\"tk\":[91,3,91,30],\"els\":[\"0:14\"]},{\"tk\":[91,30,91,31],\"els\":[\"0:14\"]},{\"tk\":[91,31,91,32],\"els\":[\"0:14\"]},{\"tk\":[91,32,91,33],\"els\":[\"0:14\"]}]}}}","blocks":[{"RTWName":"<Root>/ADC","SIDString":"esp32_adc_demo:2"},{"RTWName":"<S1>/u","SIDString":"esp32_adc_demo:4:1"},{"RTWName":"<S1>/Compare","SIDString":"esp32_adc_demo:4:2"},{"RTWName":"<S1>/Constant","SIDString":"esp32_adc_demo:4:3"},{"RTWName":"<S1>/y","SIDString":"esp32_adc_demo:4:4"},{"RTWName":"<Root>/Digital Out","SIDString":"esp32_adc_demo:8"},{"RTWName":"<Root>/Digital Out1","SIDString":"esp32_adc_demo:14"},{"RTWName":"<S2>:1","SIDString":"esp32_adc_demo:13:1"},{"RTWName":"<Root>/Waijung 2 Target Setup","SIDString":"esp32_adc_demo:1"},{"RTWName":"<Root>/Compare\nTo Constant","SIDString":"esp32_adc_demo:4"},{"RTWName":"<Root>/MATLAB Function","SIDString":"esp32_adc_demo:13"}]};